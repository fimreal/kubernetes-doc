<!doctype html>
<html lang="zh" class="no-js">
  <head>
    

<script async src="https://www.googletagmanager.com/gtag/js?id=UA-36037335-10"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-36037335-10');
</script>


<link rel="alternate" hreflang="en" href="https://kubernetes.io/docs/tasks/tls/">
<link rel="alternate" hreflang="ko" href="https://kubernetes.io/ko/docs/tasks/tls/">
<link rel="alternate" hreflang="ja" href="https://kubernetes.io/ja/docs/tasks/tls/">
<link rel="alternate" hreflang="fr" href="https://kubernetes.io/fr/docs/tasks/tls/">
<link rel="alternate" hreflang="de" href="https://kubernetes.io/de/docs/tasks/tls/">
<link rel="alternate" hreflang="es" href="https://kubernetes.io/es/docs/tasks/tls/">
<link rel="alternate" hreflang="id" href="https://kubernetes.io/id/docs/tasks/tls/">

<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="generator" content="Hugo 0.88.1" />

<META NAME="ROBOTS" CONTENT="NOINDEX, NOFOLLOW">

<link rel="canonical" type="text/html" href="https://kubernetes.io/zh/docs/tasks/tls/">
<link rel="shortcut icon" type="image/png" href="/images/favicon.png">
<link rel="apple-touch-icon" href="/favicons/apple-touch-icon-180x180.png" sizes="180x180">
<link rel="manifest" href="/manifest.webmanifest">
<link rel="apple-touch-icon" href="/images/kubernetes-192x192.png">
<title>TLS | Kubernetes</title><meta property="og:title" content="TLS" />
<meta property="og:description" content="了解如何使用传输层安全性（ TLS ）保护集群中的流量。" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://kubernetes.io/zh/docs/tasks/tls/" /><meta property="og:site_name" content="Kubernetes" />

<meta itemprop="name" content="TLS">
<meta itemprop="description" content="了解如何使用传输层安全性（ TLS ）保护集群中的流量。"><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="TLS"/>
<meta name="twitter:description" content="了解如何使用传输层安全性（ TLS ）保护集群中的流量。"/>





<link rel="preload" href="/scss/main.min.0bda2f3af46d1514ab4d3cad78295716cfd9557a35a41868b7db38040502bb54.css" as="style">
<link href="/scss/main.min.0bda2f3af46d1514ab4d3cad78295716cfd9557a35a41868b7db38040502bb54.css" rel="stylesheet" integrity="">


<script
  src="/js/jquery-3.3.1.min.js"
  integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8="
  crossorigin="anonymous"></script>





<script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@type": "Organization",
    "url": "https://kubernetes.io",
    "logo": "https://kubernetes.io/images/favicon.png",
    "potentialAction": {
      "@type": "SearchAction",
      "target": "https://kubernetes.io/search/?q={search_term_string}",
      "query-input": "required name=search_term_string"
    }

  }
</script>
<meta name="theme-color" content="#326ce5">




<link rel="stylesheet" href="/css/feature-states.css">



<meta name="description" content="了解如何使用传输层安全性（ TLS ）保护集群中的流量。">
<meta property="og:description" content="了解如何使用传输层安全性（ TLS ）保护集群中的流量。">
<meta name="twitter:description" content="了解如何使用传输层安全性（ TLS ）保护集群中的流量。">
<meta property="og:url" content="https://kubernetes.io/zh/docs/tasks/tls/">
<meta property="og:title" content="TLS">
<meta name="twitter:title" content="TLS">
<meta name="twitter:image" content="https://kubernetes.io/images/favicon.png" />

<meta name="twitter:image:alt" content="Kubernetes">

<meta property="og:image" content="/images/kubernetes-horizontal-color.png">

<meta property="og:type" content="article">



<script src="/js/script.js"></script>


  </head>
  <body class="td-section">
    <header>
      
<nav class="js-navbar-scroll navbar navbar-expand navbar-dark  flex-row td-navbar" data-auto-burger="primary">
        <a class="navbar-brand" href="/zh/"></a>
	<div class="td-navbar-nav-scroll ml-md-auto" id="main_navbar">
		
		<ul class="navbar-nav mt-2 mt-lg-0">
			
			
			
			
			<li class="nav-item mr-2 mb-lg-0">
				
				<a class="nav-link active" href="/zh/docs/" >文档</span></a>
			</li>
			
			
			
			<li class="nav-item mr-2 mb-lg-0">
				
				<a class="nav-link" href="/zh/blog/" >Kubernetes 博客</span></a>
			</li>
			
			
			
			<li class="nav-item mr-2 mb-lg-0">
				
				<a class="nav-link" href="/zh/training/" >培训</span></a>
			</li>
			
			
			
			<li class="nav-item mr-2 mb-lg-0">
				
				<a class="nav-link" href="/zh/partners/" >合作伙伴</span></a>
			</li>
			
			
			
			<li class="nav-item mr-2 mb-lg-0">
				
				<a class="nav-link" href="/zh/community/" >社区</span></a>
			</li>
			
			
			
			<li class="nav-item mr-2 mb-lg-0">
				
				<a class="nav-link" href="/zh/case-studies/" >案例分析</span></a>
			</li>
			
			
			
			<li class="nav-item dropdown">
				<a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
	版本列表
</a>
<div class="dropdown-menu dropdown-menu-right" aria-labelledby="navbarDropdownMenuLink">
	
	<a class="dropdown-item" href="/releases">Release Information</a>
	
	<a class="dropdown-item" href="https://kubernetes.io/zh/docs/tasks/tls/">v1.22</a>
	
	<a class="dropdown-item" href="https://v1-21.docs.kubernetes.io/zh/docs/tasks/tls/">v1.21</a>
	
	<a class="dropdown-item" href="https://v1-20.docs.kubernetes.io/zh/docs/tasks/tls/">v1.20</a>
	
	<a class="dropdown-item" href="https://v1-19.docs.kubernetes.io/zh/docs/tasks/tls/">v1.19</a>
	
	<a class="dropdown-item" href="https://v1-18.docs.kubernetes.io/zh/docs/tasks/tls/">v1.18</a>
	
</div>
			</li>
			
			
			<li class="nav-item dropdown">
				

<a class="nav-link dropdown-toggle" href="#" id="navbarDropdownMenuLink" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
	中文 Chinese
</a>
<div class="dropdown-menu dropdown-menu-right" aria-labelledby="navbarDropdownMenuLink">
	
	<a class="dropdown-item" href="/docs/tasks/tls/">English</a>
	
	<a class="dropdown-item" href="/ko/docs/tasks/tls/">한국어 Korean</a>
	
	<a class="dropdown-item" href="/ja/docs/tasks/tls/">日本語 Japanese</a>
	
	<a class="dropdown-item" href="/fr/docs/tasks/tls/">Français</a>
	
	<a class="dropdown-item" href="/de/docs/tasks/tls/">Deutsch</a>
	
	<a class="dropdown-item" href="/es/docs/tasks/tls/">Español</a>
	
	<a class="dropdown-item" href="/id/docs/tasks/tls/">Bahasa Indonesia</a>
	
</div>

			</li>
			
		</ul>
	</div>
	<button id="hamburger" onclick="kub.toggleMenu()" data-auto-burger-exclude><div></div></button>
</nav>
    </header>
    <div class="container-fluid td-outer">
      <div class="td-main">
        <div class="row flex-xl-nowrap">
          <div class="col-12 col-md-3 col-xl-2 td-sidebar d-print-none">
          </div>
          <div class="d-none d-xl-block col-xl-2 td-toc d-print-none">
          </div>
          <main class="col-12 col-md-9 col-xl-8 pl-md-5" role="main">
            




<div class="td-content">
<div class="pageinfo pageinfo-primary d-print-none">
<p>
这是本节的多页打印视图。
<a href="#" onclick="print();return false;">点击此处打印</a>.
</p><p>
<a href="/zh/docs/tasks/tls/">返回本页常规视图</a>.
</p>
</div>



<h1 class="title">TLS</h1>
<div class="lead">了解如何使用传输层安全性（ TLS ）保护集群中的流量。</div>




    <ul>
    
  
  
  
  

  
    
    
	
<li>1: <a href="#pg-1272b18ac0c008f6ffc2c62a29fa929f">为 kubelet 配置证书轮换</a></li>


    
  
    
    
	
<li>2: <a href="#pg-43d5e2b1fc2a7e104e66d481d08578dc">手动轮换 CA 证书</a></li>


    
  
    
    
	
<li>3: <a href="#pg-9a87de8ee8332cb487f34a05debb1125">管理集群中的 TLS 认证</a></li>


    
  

    </ul>


<div class="content">
      
</div>
</div>


  
  
  
  

  
  

  
    
    
	
    

<div class="td-content" style="">
    
	<h1 id="pg-1272b18ac0c008f6ffc2c62a29fa929f">1 - 为 kubelet 配置证书轮换</h1>
    
	<!--
reviewers:
- jcbsmpsn
- mikedanese
title: Configure Certificate Rotation for the Kubelet
content_type: task
-->
<!-- overview -->
<!--
This page shows how to enable and configure certificate rotation for the kubelet.
-->
<p>本文展示如何在 kubelet 中启用并配置证书轮换。</p>





<div style="margin-top: 10px; margin-bottom: 10px;">
<b>FEATURE STATE:</b> <code>Kubernetes v1.19 [stable]</code>
</div>

<h2 id="准备开始">准备开始</h2>
<!--
* Kubernetes version 1.8.0 or later is required
-->
<ul>
<li>要求 Kubernetes 1.8.0 或更高的版本</li>
</ul>
<!-- steps -->
<!--
## Overview

The kubelet uses certificates for authenticating to the Kubernetes API.  By
default, these certificates are issued with one year expiration so that they do
not need to be renewed too frequently.
-->
<h2 id="概述">概述</h2>
<p>Kubelet 使用证书进行 Kubernetes API 的认证。
默认情况下，这些证书的签发期限为一年，所以不需要太频繁地进行更新。</p>
<!--
Kubernetes contains [kubelet certificate
rotation](/docs/reference/command-line-tools-reference/kubelet-tls-bootstrapping/),
that will automatically generate a new key and request a new certificate from
the Kubernetes API as the current certificate approaches expiration. Once the
new certificate is available, it will be used for authenticating connections to
the Kubernetes API.
-->
<p>Kubernetes 包含特性
<a href="/zh/docs/reference/command-line-tools-reference/kubelet-tls-bootstrapping/">kubelet 证书轮换</a>，
在当前证书即将过期时，
将自动生成新的秘钥，并从 Kubernetes API 申请新的证书。 一旦新的证书可用，它将被用于与
Kubernetes API 间的连接认证。</p>
<!--
## Enabling client certificate rotation

The `kubelet` process accepts an argument `--rotate-certificates` that controls
if the kubelet will automatically request a new certificate as the expiration of
the certificate currently in use approaches.
-->
<h2 id="启用客户端证书轮换">启用客户端证书轮换</h2>
<p><code>kubelet</code> 进程接收 <code>--rotate-certificates</code> 参数，该参数决定 kubelet 在当前使用的
证书即将到期时，是否会自动申请新的证书。</p>
<!--
The `kube-controller-manager` process accepts an argument
`--cluster-signing-duration`  (`--experimental-cluster-signing-duration` prior to 1.19)
that controls how long certificates will be issued for.
-->
<p><code>kube-controller-manager</code> 进程接收 <code>--cluster-signing-duration</code> 参数
（在 1.19 版本之前为 <code>--experimental-cluster-signing-duration</code>），用来
控制签发证书的有效期限。</p>
<!--
## Understanding the certificate rotation configuration

When a kubelet starts up, if it is configured to bootstrap (using the
`--bootstrap-kubeconfig` flag), it will use its initial certificate to connect
to the Kubernetes API and issue a certificate signing request. You can view the
status of certificate signing requests using:
-->
<h2 id="理解证书轮换配置">理解证书轮换配置</h2>
<p>当 kubelet 启动时，如被配置为自举（使用<code>--bootstrap-kubeconfig</code> 参数），kubelet
会使用其初始证书连接到 Kubernetes API ，并发送证书签名的请求。
可以通过以下方式查看证书签名请求的状态：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl get csr
</code></pre></div><!--
Initially a certificate signing request from the kubelet on a node will have a
status of `Pending`. If the certificate signing requests meets specific
criteria, it will be auto approved by the controller manager, then it will have
a status of `Approved`. Next, the controller manager will sign a certificate,
issued for the duration specified by the
`--cluster-signing-duration` parameter, and the signed certificate
will be attached to the certificate signing request.
-->
<p>最初，来自节点上 kubelet 的证书签名请求处于 <code>Pending</code> 状态。 如果证书签名请求满足特定条件，
控制器管理器会自动批准，此时请求会处于 <code>Approved</code> 状态。 接下来，控制器管理器会签署证书，
证书的有效期限由 <code>--cluster-signing-duration</code> 参数指定，签署的证书会被附加到证书签名请求中。</p>
<!--
The kubelet will retrieve the signed certificate from the Kubernetes API and
write that to disk, in the location specified by `--cert-dir`. Then the kubelet
will use the new certificate to connect to the Kubernetes API.
-->
<p>Kubelet 会从 Kubernetes API 取回签署的证书，并将其写入磁盘，存储位置通过 <code>--cert-dir</code>
参数指定。
然后 kubelet 会使用新的证书连接到 Kubernetes API。</p>
<!--
As the expiration of the signed certificate approaches, the kubelet will
automatically issue a new certificate signing request, using the Kubernetes API. 
This can happen at any point between 30% and 10% of the time remaining on the 
certificate. Again, the controller manager will automatically approve the certificate
request and attach a signed certificate to the certificate signing request. The
kubelet will retrieve the new signed certificate from the Kubernetes API and
write that to disk. Then it will update the connections it has to the
Kubernetes API to reconnect using the new certificate.
-->
<p>当签署的证书即将到期时，kubelet 会使用 Kubernetes API，自动发起新的证书签名请求。
该请求会发生在证书的有效时间剩下 30% 到 10% 之间的任意时间点。
同样地，控制器管理器会自动批准证书请求，并将签署的证书附加到证书签名请求中。 Kubelet
会从 Kubernetes API 取回签署的证书，并将其写入磁盘。 然后它会更新与 Kubernetes API
的连接，使用新的证书重新连接到 Kubernetes API。</p>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-43d5e2b1fc2a7e104e66d481d08578dc">2 - 手动轮换 CA 证书</h1>
    
	<!--
title: Manual Rotation of CA Certificates
min-kubernetes-server-version: v1.13
content_type: task
-->
<!-- overview -->
<!--
This page shows how to manually rotate the certificate authority (CA) certificates.
-->
<p>本页展示如何手动轮换证书机构（CA）证书。</p>
<h2 id="准备开始">准备开始</h2>
<p><p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
如果你还没有集群，你可以通过 <a href="/zh/docs/tasks/tools/#minikube">Minikube</a> 构建一
个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p>
<!--
You need to have a Kubernetes cluster, and the kubectl command-line tool must
be configured to communicate with your cluster. If you do not already have a
cluster, you can create one by using
[minikube](/docs/tasks/tools/#minikube)
or you can use one of these Kubernetes playgrounds:
-->
<ul>
<li><a href="https://www.katacoda.com/courses/kubernetes/playground">Katacoda</a></li>
<li><a href="http://labs.play-with-k8s.com/">玩转 Kubernetes</a></li>
</ul>
 

您的 Kubernetes 服务器版本必须不低于版本 v1.13.
 要获知版本信息，请输入 <code>kubectl version</code>.
</p>
<!--
- For more information about authentication in Kubernetes, see [Authenticating](/docs/reference/access-authn-authz/authentication).
- For more information about best practices for CA certificates, see [Single root CA](/docs/setup/best-practices/certificates/#single-root-ca).
-->
<ul>
<li>要了解 Kubernetes 中用户认证的更多信息，参阅
<a href="/zh/docs/reference/access-authn-authz/authentication">认证</a>；</li>
<li>要了解与 CA 证书最佳实践有关的更多信息，参阅<a href="/zh/docs/setup/best-practices/certificates/#single-root-ca">单根 CA</a>。</li>
</ul>
<!-- steps -->
<!--
## Rotate the CA certificates manually
-->
<h2 id="rotate-the-ca-certificates-manually">手动轮换 CA 证书 </h2>
<!--
Make sure to back up your certificate directory along with configuration files and any other necessary files.

This approach assumes operation of the Kubernetes control plane in a HA configuration with multiple API servers.
Graceful termination of the API server is also assumed so clients can cleanly disconnect from one API server and reconnect to another.

Configurations with a single API server will experience unavailability while the API server is being restarted.
-->
<blockquote class="caution callout">
  <div><strong>注意：</strong> <p>确保备份你的证书目录、配置文件以及其他必要文件。</p>
<p>这里的方法假定 Kubernetes 的控制面通过运行多个 API 服务器以高可用配置模式运行。
另一假定是 API 服务器可体面地终止，因而客户端可以彻底地与一个 API 服务器断开
连接并连接到另一个 API 服务器。</p>
<p>如果集群中只有一个 API 服务器，则在 API 服务器重启期间会经历服务中断期。</p>
</div>
</blockquote>

<!--
1. Distribute the new CA certificates and private keys
   (ex: `ca.crt`, `ca.key`, `front-proxy-ca.crt`, and `front-proxy-ca.key`)
   to all your control plane nodes in the Kubernetes certificates directory.
-->
<ol>
<li>将新的 CA 证书和私钥（例如：<code>ca.crt</code>、<code>ca.key</code>、<code>front-proxy-ca.crt</code> 和
<code>front-proxy-client.key</code>）分发到所有控制面节点，放在其 Kubernetes 证书目录下。</li>
</ol>
<!--
1. Update <a class='glossary-tooltip' title='主节点上运行控制器的组件。' data-toggle='tooltip' data-placement='top' href='/docs/reference/generated/kube-controller-manager/' target='_blank' aria-label='kube-controller-manager'>kube-controller-manager</a>'s `--root-ca-file` to
   include both old and new CA. Then restart the component.

   Any service account created after this point will get secrets that include both old and new CAs.
   
   <blockquote class="note callout">
  <div><strong>说明：</strong> The files specified by the kube-controller-manager flags <code>--client-ca-file</code> and <code>--cluster-signing-cert-file</code>
cannot be CA bundles. If these flags and <code>--root-ca-file</code> point to the same <code>ca.crt</code> file which is now a
bundle (includes both old and new CA) you will face an error. To workaround this problem you can copy the new CA to a separate
file and make the flags <code>--client-ca-file</code> and <code>--cluster-signing-cert-file</code> point to the copy. Once <code>ca.crt</code> is no longer
a bundle you can restore the problem flags to point to <code>ca.crt</code> and delete the copy.</div>
</blockquote>
-->
<ol start="2">
<li>
<p>更新 <a class='glossary-tooltip' title='主节点上运行控制器的组件。' data-toggle='tooltip' data-placement='top' href='/docs/reference/generated/kube-controller-manager/' target='_blank' aria-label='kube-controller-manager'>kube-controller-manager</a> 的
<code>--root-ca-file</code> 标志，使之同时包含老的和新的 CA，之后重启组件。</p>
<p>自此刻起，所创建的所有服务账号都会获得同时包含老的 CA 和新的 CA 的 Secret。</p>
<blockquote class="note callout">
  <div><strong>说明：</strong> kube-controller-manager 标志 <code>--client-ca-file</code> 和 <code>--cluster-signing-cert-file</code> 所引用的文件
不能是 CA 证书包。如果这些标志和 <code>--root-ca-file</code> 指向同一个 <code>ca.crt</code> 包文件（包含老的和新的 CA 证书），
你将会收到出错信息。
要解决这个问题，可以将新的 CA 证书复制到单独的文件中，并将 <code>--client-ca-file</code> 和 <code>--cluster-signing-cert-file</code>
标志指向该副本。一旦 <code>ca.crt</code> 不再是证书包文件，就可以恢复有问题的标志指向  <code>ca.crt</code> 并删除该副本。</div>
</blockquote>
</li>
</ol>
<!--
   1. Update all service account tokens to include both old and new CA certificates.

   If any pods are started before new CA is used by API servers, they will get this update and trust both old and new CAs.
-->
<ol start="3">
<li>
<p>更新所有服务账号令牌，使之同时包含老的和新的 CA 证书。</p>
<p>如果在 API 服务器使用新的 CA 之前启动了新的 Pod，这些 Pod
也会获得此更新并且同时信任老的和新的 CA 证书。</p>
<!--
```shell
base64_encoded_ca="$(base64 -w0 <path to file containing both old and new CAs>)"

for namespace in $(kubectl get ns --no-headers | awk '{print $1}'); do
    for token in $(kubectl get secrets --namespace "$namespace" --field-selector type=kubernetes.io/service-account-token -o name); do
        kubectl get $token --namespace "$namespace" -o yaml | \
          /bin/sed "s/\(ca.crt:\).*/\1 ${base64_encoded_ca}/" | \
          kubectl apply -f -
    done
done
```
-->
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="color:#b8860b">base64_encoded_ca</span><span style="color:#666">=</span><span style="color:#b44">&#34;</span><span style="color:#a2f;font-weight:bold">$(</span>base64 -w0 &lt;path to file containing both old and new CAs&gt;<span style="color:#a2f;font-weight:bold">)</span><span style="color:#b44">&#34;</span>

<span style="color:#a2f;font-weight:bold">for</span> namespace in <span style="color:#a2f;font-weight:bold">$(</span>kubectl get ns --no-headers | awk <span style="color:#b44">&#39;{print $1}&#39;</span><span style="color:#a2f;font-weight:bold">)</span>; <span style="color:#a2f;font-weight:bold">do</span>
    <span style="color:#a2f;font-weight:bold">for</span> token in <span style="color:#a2f;font-weight:bold">$(</span>kubectl get secrets --namespace <span style="color:#b44">&#34;</span><span style="color:#b8860b">$namespace</span><span style="color:#b44">&#34;</span> --field-selector <span style="color:#b8860b">type</span><span style="color:#666">=</span>kubernetes.io/service-account-token -o name<span style="color:#a2f;font-weight:bold">)</span>; <span style="color:#a2f;font-weight:bold">do</span>
        kubectl get <span style="color:#b8860b">$token</span> --namespace <span style="color:#b44">&#34;</span><span style="color:#b8860b">$namespace</span><span style="color:#b44">&#34;</span> -o yaml | <span style="color:#b62;font-weight:bold">\
</span><span style="color:#b62;font-weight:bold"></span>          /bin/sed <span style="color:#b44">&#34;s/\(ca.crt:\).*/\1 </span><span style="color:#b68;font-weight:bold">${</span><span style="color:#b8860b">base64_encoded_ca</span><span style="color:#b68;font-weight:bold">}</span><span style="color:#b44">/&#34;</span> | <span style="color:#b62;font-weight:bold">\
</span><span style="color:#b62;font-weight:bold"></span>          kubectl apply -f -
    <span style="color:#a2f;font-weight:bold">done</span>
<span style="color:#a2f;font-weight:bold">done</span>
</code></pre></div></li>
</ol>
<!--
1. Restart all pods using in-cluster configs (ex: kube-proxy, coredns, etc) so they can use the updated certificate authority data from *ServiceAccount* secrets.

   * Make sure coredns, kube-proxy and other pods using in-cluster configs are working as expected.

1. Append the both old and new CA to the file against `-client-ca-file` and `-kubelet-certificate-authority` flag in the `kube-apiserver` configuration.

1. Append the both old and new CA to the file against `-client-ca-file` flag in the `kube-scheduler` configuration.
-->
<ol start="4">
<li>
<p>重启所有使用集群内配置的 Pods（例如：<code>kube-proxy</code>、<code>coredns</code> 等），以便这些 Pod 能够使用
来自 <em>ServiceAccount</em> Secret 中的、已更新的证书机构数据。</p>
<ul>
<li>确保 <code>coredns</code>、<code>kube-proxy</code> 和其他使用集群内配置的 Pod 都正按预期方式工作。</li>
</ul>
</li>
<li>
<p>将老的和新的 CA 都追加到 <code>kube-apiserver</code> 配置的 <code>--client-ca-file</code> 和 <code>--kubelet-certificate-authority</code> 标志所指的文件。</p>
</li>
<li>
<p>将老的和新的 CA 都追加到 <code>kube-scheduler</code> 配置的 <code>--client-ca-file</code> 标志所指的文件。</p>
</li>
</ol>
<!--
1. Update certificates for user accounts by replacing the content of `client-certificate-data` and `client-key-data` respectively.

   For information about creating certificates for individual user accounts, see
   [Configure certificates for user accounts](/docs/setup/best-practices/certificates/#configure-certificates-for-user-accounts).

   Additionally, update the `certificate-authority-data` section in the kubeconfig files,
   respectively with Base64-encoded old and new certificate authority data
-->
<ol start="7">
<li>
<p>通过替换 <code>client-certificate-data</code> 和 <code>client-key-data</code>
中的内容，更新用户账号的证书。</p>
<p>有关为独立用户账号创建证书的更多信息，可参阅
<a href="/zh/docs/setup/best-practices/certificates/#configure-certificates-for-user-accounts">为用户帐号配置证书</a>。</p>
<p>另外，还要更新 kubeconfig 文件中的 <code>certificate-authority-data</code>
节，使之包含 Base64 编码的老的和新的证书机构数据。</p>
</li>
</ol>
<!--
1. Follow below steps in a rolling fashion.

   1. Restart any other *[aggregated api servers](/docs/concepts/extend-kubernetes/api-extension/apiserver-aggregation/)*
      or *webhook handlers* to trust the new CA certificates.

   1. Restart the kubelet by update the file against `clientCAFile` in kubelet configuration and
      `certificate-authority-data` in kubelet.conf to use both the old and new CA on all nodes.

      If your kubelet is not using client certificate rotation update `client-certificate-data` and
      `client-key-data` in kubelet.conf on all nodes along with the kubelet client certificate file
      usually found in `/var/lib/kubelet/pki`.
-->
<ol start="8">
<li>
<p>遵循下列步骤执行滚动更新</p>
<ol>
<li>
<p>重新启动所有其他 <em><a href="/zh/docs/concepts/extend-kubernetes/api-extension/apiserver-aggregation/">被聚合的 API 服务器</a></em>
或者 <em>Webhook 处理程序</em>，使之信任新的 CA 证书。</p>
</li>
<li>
<p>在所有节点上更新 kubelet 配置中的 <code>clientCAFile</code> 所指文件以及 kubelet.conf 中的
<code>certificate-authority-data</code> 并重启 kubelet 以同时使用老的和新的 CA 证书。</p>
<p>如果你的 kubelet 并未使用客户端证书轮换，则在所有节点上更新 kubelet.conf 中
<code>client-certificate-data</code> 和 <code>client-key-data</code> 以及 kubelet
客户端证书文件（通常位于 <code>/var/lib/kubelet/pki</code> 目录下）</p>
</li>
</ol>
<!--
1. Restart API servers with the certificates (`apiserver.crt`, `apiserver-kubelet-client.crt` and
   `front-proxy-client.crt`) signed by new CA.
   You can use the existing private keys or new private keys.
   If you changed the private keys then update these in the Kubernetes certificates directory as well.
-->
<ol start="3">
<li>
<p>使用用新的 CA 签名的证书
（<code>apiserver.crt</code>、<code>apiserver-kubelet-client.crt</code> 和 <code>front-proxy-client.crt</code>）
来重启 API 服务器。
你可以使用现有的私钥，也可以使用新的私钥。
如果你改变了私钥，则要将更新的私钥也放到 Kubernetes 证书目录下。</p>
<p>由于 Pod 既信任老的 CA 也信任新的 CA，Pod 中的客户端会经历短暂的连接断开状态，
之后再连接到使用新的 CA 所签名的证书的新的 API 服务器。</p>
<!--
* Restart Scheduler to use the new CAs.
* Make sure control plane components logs no TLS errors.
-->
<ul>
<li>重启调度器以使用新的 CA 证书。</li>
<li>确保控制面组件的日志中没有 TLS 相关的错误信息。</li>
</ul>
<!--
To generate certificates and private keys for your cluster using the `openssl`
command line tool, see [Certificates (`openssl`)](/docs/tasks/administer-cluster/certificates/#openssl).
You can also use [`cfssl`](/docs/tasks/administer-cluster/certificates/#cfssl).
-->
<blockquote class="note callout">
  <div><strong>说明：</strong> 要使用 <code>openssl</code> 命令行为集群生成新的证书和私钥，可参阅
<a href="/zh/docs/tasks/administer-cluster/certificates/#openssl">证书（<code>openssl</code>）</a>。
你也可以使用<a href="/zh/docs/tasks/administer-cluster/certificates/#cfssl"><code>cfssl</code></a>.</div>
</blockquote>
</li>
</ol>
<!--
1. Annotate any Daemonsets and Deployments to trigger pod replacement in a safer rolling fashion.

   Example:
-->
<ol start="4">
<li>
<p>为 Daemonset 和 Deployment 添加注解，从而触发较安全的滚动更新，替换 Pod。</p>
<p>示例：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="color:#a2f;font-weight:bold">for</span> namespace in <span style="color:#a2f;font-weight:bold">$(</span>kubectl get namespace -o <span style="color:#b8860b">jsonpath</span><span style="color:#666">=</span><span style="color:#b44">&#39;{.items[*].metadata.name}&#39;</span><span style="color:#a2f;font-weight:bold">)</span>; <span style="color:#a2f;font-weight:bold">do</span>
    <span style="color:#a2f;font-weight:bold">for</span> name in <span style="color:#a2f;font-weight:bold">$(</span>kubectl get deployments -n <span style="color:#b8860b">$namespace</span> -o <span style="color:#b8860b">jsonpath</span><span style="color:#666">=</span><span style="color:#b44">&#39;{.items[*].metadata.name}&#39;</span><span style="color:#a2f;font-weight:bold">)</span>; <span style="color:#a2f;font-weight:bold">do</span>
        kubectl patch deployment -n <span style="color:#b68;font-weight:bold">${</span><span style="color:#b8860b">namespace</span><span style="color:#b68;font-weight:bold">}</span> <span style="color:#b68;font-weight:bold">${</span><span style="color:#b8860b">name</span><span style="color:#b68;font-weight:bold">}</span> -p <span style="color:#b44">&#39;{&#34;spec&#34;:{&#34;template&#34;:{&#34;metadata&#34;:{&#34;annotations&#34;:{&#34;ca-rotation&#34;: &#34;1&#34;}}}}}&#39;</span>;
    <span style="color:#a2f;font-weight:bold">done</span>
    <span style="color:#a2f;font-weight:bold">for</span> name in <span style="color:#a2f;font-weight:bold">$(</span>kubectl get daemonset -n <span style="color:#b8860b">$namespace</span> -o <span style="color:#b8860b">jsonpath</span><span style="color:#666">=</span><span style="color:#b44">&#39;{.items[*].metadata.name}&#39;</span><span style="color:#a2f;font-weight:bold">)</span>; <span style="color:#a2f;font-weight:bold">do</span>
        kubectl patch daemonset -n <span style="color:#b68;font-weight:bold">${</span><span style="color:#b8860b">namespace</span><span style="color:#b68;font-weight:bold">}</span> <span style="color:#b68;font-weight:bold">${</span><span style="color:#b8860b">name</span><span style="color:#b68;font-weight:bold">}</span> -p <span style="color:#b44">&#39;{&#34;spec&#34;:{&#34;template&#34;:{&#34;metadata&#34;:{&#34;annotations&#34;:{&#34;ca-rotation&#34;: &#34;1&#34;}}}}}&#39;</span>;
    <span style="color:#a2f;font-weight:bold">done</span>
<span style="color:#a2f;font-weight:bold">done</span>
</code></pre></div><!--
To limit the number of concurrent disruptions that your application experiences,
see [configure pod disruption budget](/docs/tasks/run-application/configure-pdb/).
-->
<blockquote class="note callout">
  <div><strong>说明：</strong> 要限制应用可能受到的并发干扰数量，可以参阅
<a href="/zh/docs/tasks/run-application/configure-pdb/">配置 Pod 干扰预算</a>.</div>
</blockquote>
</li>
</ol>
</li>
</ol>
<!--
1. If your cluster is using bootstrap tokens to join nodes, update the ConfigMap `cluster-info` in the `kube-public` namespace with new CA.
-->
<ol start="9">
<li>
<p>如果你的集群使用启动引导令牌来添加节点，则需要更新 <code>kube-public</code> 名字空间下的
ConfigMap <code>cluster-info</code>，使之包含新的 CA 证书。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="color:#b8860b">base64_encoded_ca</span><span style="color:#666">=</span><span style="color:#b44">&#34;</span><span style="color:#a2f;font-weight:bold">$(</span>base64 -w0 /etc/kubernetes/pki/ca.crt<span style="color:#a2f;font-weight:bold">)</span><span style="color:#b44">&#34;</span>

kubectl get cm/cluster-info --namespace kube-public -o yaml | <span style="color:#b62;font-weight:bold">\
</span><span style="color:#b62;font-weight:bold"></span>    /bin/sed <span style="color:#b44">&#34;s/\(certificate-authority-data:\).*/\1 </span><span style="color:#b68;font-weight:bold">${</span><span style="color:#b8860b">base64_encoded_ca</span><span style="color:#b68;font-weight:bold">}</span><span style="color:#b44">/&#34;</span> | <span style="color:#b62;font-weight:bold">\
</span><span style="color:#b62;font-weight:bold"></span>    kubectl apply -f -
</code></pre></div></li>
</ol>
<!--
1. Verify the cluster functionality.

   1. Validate the logs from control plane components, along with the kubelet and the
      kube-proxy are not throwing any tls errors, see
      [looking at the logs](/docs/tasks/debug-application-cluster/debug-cluster/#looking-at-logs).

   1. Validate logs from any aggregated api servers and pods using in-cluster config.
-->
<ol start="10">
<li>
<p>验证集群的功能正常</p>
<ol>
<li>
<p>验证控制面组件的日志，以及 <code>kubelet</code> 和 <code>kube-proxy</code> 的日志，确保其中没有
抛出 TLS 错误，参阅
<a href="/zh/docs/tasks/debug-application-cluster/debug-cluster/#looking-at-logs">查看日志</a>.</p>
</li>
<li>
<p>验证被聚合的 API 服务器的日志，以及所有使用集群内配置的 Pod 的日志。</p>
</li>
</ol>
</li>
</ol>
<!--
1. Once the cluster functionality is successfully verified:

   1. Update all service account tokens to include new CA certificate only.

      * All pods using an in-cluster kubeconfig will eventually need to be restarted to pick up the new SA secret for the old CA to be completely untrusted.

   1. Restart the control plane components by removing the old CA from the kubeconfig files and the files against `--client-ca-file`, `--root-ca-file` flags resp.

   1. Restart kubelet by removing the old CA from file against the `clientCAFile` flag and kubelet kubeconfig file.
-->
<ol start="11">
<li>
<p>完成集群功能的检查之后：</p>
<ol>
<li>
<p>更新所有的服务账号令牌，使之仅包含新的 CA 证书。</p>
<ul>
<li>使用集群内 kubeconfig 的 Pod 最终也需要被重启，以获得新的服务账号 Secret
数据，进而不再信任老的 CA 证书。</li>
</ul>
</li>
<li>
<p>从 kubeconfig 文件和 <code>--client-ca-file</code> 以及 <code>--root-ca-file</code> 标志所指向的文件
中去除老的 CA 数据，之后重启控制面组件。</p>
</li>
<li>
<p>重启 kubelet，移除 <code>clientCAFile</code> 标志所指向的文件以及 kubelet kubeconfig 文件中
的老的 CA 数据。</p>
</li>
</ol>
</li>
</ol>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-9a87de8ee8332cb487f34a05debb1125">3 - 管理集群中的 TLS 认证</h1>
    
	<!--
title: Manage TLS Certificates in a Cluster
content_type: task
reviewers:
- mikedanese
- beacham
- liggit
-->
<!-- overview -->
<!--
Kubernetes provides a `certificates.k8s.io` API, which lets you provision TLS
certificates signed by a Certificate Authority (CA) that you control. These CA
and certificates can be used by your workloads to establish trust.

`certificates.k8s.io` API uses a protocol that is similar to the [ACME
draft](https://github.com/ietf-wg-acme/acme/).
-->
<p>Kubernetes 提供 <code>certificates.k8s.io</code> API，可让你配置由你控制的证书颁发机构（CA）
签名的 TLS 证书。 你的工作负载可以使用这些 CA 和证书来建立信任。</p>
<p><code>certificates.k8s.io</code> API使用的协议类似于
<a href="https://github.com/ietf-wg-acme/acme/">ACME 草案</a>。</p>
<blockquote class="note callout">
  <div><strong>说明：</strong> <!--
Certificates created using the `certificates.k8s.io` API are signed by a
dedicated CA. It is possible to configure your cluster to use the cluster root
CA for this purpose, but you should never rely on this. Do not assume that
these certificates will validate against the cluster root CA.
-->
<p>使用 <code>certificates.k8s.io</code> API 创建的证书由指定 CA 颁发。将集群配置为使用集群根目录
CA 可以达到这个目的，但是你永远不要依赖这一假定。不要以为
这些证书将针对群根目录 CA 进行验证。</div>
</blockquote>
<h2 id="准备开始">准备开始</h2>
<p><p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
如果你还没有集群，你可以通过 <a href="/zh/docs/tasks/tools/#minikube">Minikube</a> 构建一
个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p>
<!--
You need to have a Kubernetes cluster, and the kubectl command-line tool must
be configured to communicate with your cluster. If you do not already have a
cluster, you can create one by using
[minikube](/docs/tasks/tools/#minikube)
or you can use one of these Kubernetes playgrounds:
-->
<ul>
<li><a href="https://www.katacoda.com/courses/kubernetes/playground">Katacoda</a></li>
<li><a href="http://labs.play-with-k8s.com/">玩转 Kubernetes</a></li>
</ul>
 
 要获知版本信息，请输入 <code>kubectl version</code>.
</p>
<!-- steps -->
<!--
## Trusting TLS in a Cluster

Trusting the custom CA from an application running as a pod usually requires
some extra application configuration. You will need to add the CA certificate
bundle to the list of CA certificates that the TLS client or server trusts. For
example, you would do this with a golang TLS config by parsing the certificate
chain and adding the parsed certificates to the `RootCAs` field in the
[`tls.Config`](https://godoc.org/crypto/tls#Config) struct.

You can distribute the CA certificate as a
[ConfigMap](/docs/tasks/configure-pod-container/configure-pod-configmap) that your
pods have access to use.
-->
<h2 id="集群中的-tls-信任">集群中的 TLS 信任</h2>
<p>信任 Pod 中运行的应用程序所提供的 CA 通常需要一些额外的应用程序配置。
你需要将 CA 证书包添加到 TLS 客户端或服务器信任的 CA 证书列表中。
例如，你可以使用 Golang TLS 配置通过解析证书链并将解析的证书添加到
<a href="https://godoc.org/crypto/tls#Config"><code>tls.Config</code></a> 结构中的 <code>RootCAs</code>
字段中。</p>
<p>你可以用你的应用能够访问到的
<a href="/zh/docs/tasks/configure-pod-container/configure-pod-configmap">ConfigMap</a>
的形式来发布 CA 证书。</p>
<!--
## Requesting a Certificate

The following section demonstrates how to create a TLS certificate for a
Kubernetes service accessed through DNS.

<blockquote class="note callout">
  <div><strong>说明：</strong> This tutorial uses CFSSL: Cloudflare's PKI and TLS toolkit <a href="https://blog.cloudflare.com/introducing-cfssl/">click here</a> to know more.</div>
</blockquote>
-->
<h2 id="请求证书">请求证书</h2>
<p>以下部分演示如何为通过 DNS 访问的 Kubernetes 服务创建 TLS 证书。</p>
<blockquote class="note callout">
  <div><strong>说明：</strong> 本教程使用 CFSSL：Cloudflare's PKI 和 TLS 工具包
<a href="https://blog.cloudflare.com/introducing-cfssl/">点击此处</a>了解更多信息。</div>
</blockquote>
<!--
## Download and install CFSSL

The cfssl tools used in this example can be downloaded at
[https://github.com/cloudflare/cfssl/releases](https://github.com/cloudflare/cfssl/releases).
-->
<h2 id="下载并安装-cfssl">下载并安装 CFSSL</h2>
<p>本例中使用的 cfssl 工具可以在 <a href="https://github.com/cloudflare/cfssl/releases">github.com/cloudflare/cfssl/releases</a> 下载。</p>
<!--
## Create a Certificate Signing Request

Generate a private key and certificate signing request (or CSR) by running
the following command:
-->
<h2 id="创建证书签名请求">创建证书签名请求</h2>
<p>通过运行以下命令生成私钥和证书签名请求（或 CSR）:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">cat <span style="color:#b44">&lt;&lt;EOF | cfssl genkey - | cfssljson -bare server
</span><span style="color:#b44">{
</span><span style="color:#b44">  &#34;hosts&#34;: [
</span><span style="color:#b44">    &#34;my-svc.my-namespace.svc.cluster.local&#34;,
</span><span style="color:#b44">    &#34;my-pod.my-namespace.pod.cluster.local&#34;,
</span><span style="color:#b44">    &#34;192.0.2.24&#34;,
</span><span style="color:#b44">    &#34;10.0.34.2&#34;
</span><span style="color:#b44">  ],
</span><span style="color:#b44">  &#34;CN&#34;: &#34;system:node:my-pod.my-namespace.pod.cluster.local&#34;,
</span><span style="color:#b44">  &#34;key&#34;: {
</span><span style="color:#b44">    &#34;algo&#34;: &#34;ecdsa&#34;,
</span><span style="color:#b44">    &#34;size&#34;: 256
</span><span style="color:#b44">  },
</span><span style="color:#b44">  &#34;names&#34;: [
</span><span style="color:#b44">    {
</span><span style="color:#b44">      &#34;O&#34;: &#34;system:nodes&#34;
</span><span style="color:#b44">    }
</span><span style="color:#b44">  ]
</span><span style="color:#b44">}
</span><span style="color:#b44">EOF</span>
</code></pre></div><!--
Where `192.0.2.24` is the service's cluster IP,
`my-svc.my-namespace.svc.cluster.local` is the service's DNS name,
`10.0.34.2` is the pod's IP and `my-pod.my-namespace.pod.cluster.local`
is the pod's DNS name. You should see the following output:
-->
<p>其中 <code>192.0.2.24</code> 是服务的集群 IP，<code>my-svc.my-namespace.svc.cluster.local</code>
是服务的 DNS 名称，<code>10.0.34.2</code> 是 Pod 的 IP，而
<code>my-pod.my-namespace.pod.cluster.local</code> 是 Pod 的 DNS 名称。
你能看到以下的输出：</p>
<pre tabindex="0"><code>2017/03/21 06:48:17 [INFO] generate received request
2017/03/21 06:48:17 [INFO] received CSR
2017/03/21 06:48:17 [INFO] generating key: ecdsa-256
2017/03/21 06:48:17 [INFO] encoded CSR
</code></pre><!--
This command generates two files; it generates `server.csr` containing the PEM
encoded [pkcs#10](https://tools.ietf.org/html/rfc2986) certification request,
and `server-key.pem` containing the PEM encoded key to the certificate that
is still to be created.
-->
<p>此命令生成两个文件；它生成包含 PEM 编码
<a href="https://tools.ietf.org/html/rfc2986">pkcs#10</a> 证书请求的 <code>server.csr</code>，
以及 PEM 编码密钥的 <code>server-key.pem</code>，用于待生成的证书。</p>
<!--
## Create a Certificate Signing Request object to send to the Kubernetes API

Generate a CSR yaml blob and send it to the apiserver by running the following
command:
-->
<h2 id="创建证书签名请求对象发送到-kubernetes-api">创建证书签名请求对象发送到 Kubernetes API</h2>
<p>使用以下命令创建 CSR YAML 文件，并发送到 API 服务器：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">cat <span style="color:#b44">&lt;&lt;EOF | kubectl apply -f -
</span><span style="color:#b44">apiVersion: certificates.k8s.io/v1
</span><span style="color:#b44">kind: CertificateSigningRequest
</span><span style="color:#b44">metadata:
</span><span style="color:#b44">  name: my-svc.my-namespace
</span><span style="color:#b44">spec:
</span><span style="color:#b44">  request: $(cat server.csr | base64 | tr -d &#39;\n&#39;)
</span><span style="color:#b44">  signerName: kubernetes.io/kubelet-serving
</span><span style="color:#b44">  usages:
</span><span style="color:#b44">  - digital signature
</span><span style="color:#b44">  - key encipherment
</span><span style="color:#b44">  - server auth
</span><span style="color:#b44">EOF</span>
</code></pre></div><!--
Notice that the `server.csr` file created in step 1 is base64 encoded
and stashed in the `.spec.request` field. We are also requesting a
certificate with the "digital signature", "key encipherment", and "server
auth" key usages, signed by the `kubernetes.io/kubelet-serving` signer.
A specific `signerName` must be requested.
View documentation for [supported signer names](/docs/reference/access-authn-authz/certificate-signing-requests/#signers)
for more information.

The CSR should now be visible from the API in a Pending state. You can see
it by running:
-->
<p>请注意，在步骤 1 中创建的 <code>server.csr</code> 文件是 base64 编码并存储在
<code>.spec.request</code> 字段中的。我们还要求提供 “digital signature（数字签名）”，
“密钥加密（key encipherment）” 和 “服务器身份验证（server auth）” 密钥用途，
由 <code>kubernetes.io/kubelet-serving</code> 签名程序签名的证书。
你也可以要求使用特定的 <code>signerName</code>。更多信息可参阅
<a href="/zh/docs/reference/access-authn-authz/certificate-signing-requests/#signers">支持的签署者名称</a>。</p>
<p>在 API server 中可以看到这些 CSR 处于 Pending 状态。执行下面的命令你将可以看到：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl describe csr my-svc.my-namespace
</code></pre></div><pre tabindex="0"><code class="language-none" data-lang="none">Name:                   my-svc.my-namespace
Labels:                 &lt;none&gt;
Annotations:            &lt;none&gt;
CreationTimestamp:      Tue, 21 Mar 2017 07:03:51 -0700
Requesting User:        yourname@example.com
Status:                 Pending
Subject:
        Common Name:    my-svc.my-namespace.svc.cluster.local
        Serial Number:
Subject Alternative Names:
        DNS Names:      my-svc.my-namespace.svc.cluster.local
        IP Addresses:   192.0.2.24
                        10.0.34.2
Events: &lt;none&gt;
</code></pre><!--
## Get the Certificate Signing Request Approved

Approving the certificate signing request is either done by an automated
approval process or on a one off basis by a cluster administrator. More
information on what this involves is covered below.
-->
<h2 id="批准证书签名请求">批准证书签名请求</h2>
<p>批准证书签名请求是通过自动批准过程完成的，或由集群管理员一次性完成。
有关这方面涉及的更多信息，请参见下文。</p>
<!--
## Download the Certificate and Use It

Once the CSR is signed and approved you should see the following:
-->
<h2 id="下载证书并使用它">下载证书并使用它</h2>
<p>CSR 被签署并获得批准后，你应该看到以下内容：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl get csr
</code></pre></div><pre tabindex="0"><code class="language-none" data-lang="none">NAME                  AGE       REQUESTOR               CONDITION
my-svc.my-namespace   10m       yourname@example.com    Approved,Issued
</code></pre><!--
You can download the issued certificate and save it to a `server.crt` file
by running the following:
-->
<p>你可以通过运行以下命令下载颁发的证书并将其保存到 <code>server.crt</code> 文件中：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl get csr my-svc.my-namespace -o <span style="color:#b8860b">jsonpath</span><span style="color:#666">=</span><span style="color:#b44">&#39;{.status.certificate}&#39;</span> <span style="color:#b62;font-weight:bold">\
</span><span style="color:#b62;font-weight:bold"></span>    | base64 --decode &gt; server.crt
</code></pre></div><!--
Now you can use `server.crt` and `server-key.pem` as the keypair to start
your HTTPS server.
-->
<p>现在你可以将 <code>server.crt</code> 和 <code>server-key.pem</code> 作为键值对来启动 HTTPS 服务器。</p>
<!--
## Approving Certificate Signing Requests

A Kubernetes administrator (with appropriate permissions) can manually approve
(or deny) Certificate Signing Requests by using the `kubectl certificate
approve` and `kubectl certificate deny` commands. However if you intend
to make heavy usage of this API, you might consider writing an automated
certificates controller.
-->
<h2 id="批准证书签名请求-1">批准证书签名请求</h2>
<p>Kubernetes 管理员（具有适当权限）可以使用 <code>kubectl certificate approve</code> 和
<code>kubectl certificate deny</code> 命令手动批准（或拒绝）证书签名请求。
但是，如果你打算大量使用此 API，则可以考虑编写自动化的证书控制器。</p>
<!--
Whether a machine or a human using kubectl as above, the role of the approver is
to verify that the CSR satisfies two requirements:
-->
<p>无论上述机器或人使用 kubectl，批准者的作用是验证 CSR 满足如下两个要求：</p>
<!--
1. The subject of the CSR controls the private key used to sign the CSR. This
   addresses the threat of a third party masquerading as an authorized subject.
   In the above example, this step would be to verify that the pod controls the
   private key used to generate the CSR.
2. The subject of the CSR is authorized to act in the requested context. This
   addresses the threat of an undesired subject joining the cluster. In the
   above example, this step would be to verify that the pod is allowed to
   participate in the requested service.
-->
<ol>
<li>CSR 的 subject 控制用于签署 CSR 的私钥。这解决了伪装成授权主体的第三方的威胁。
在上述示例中，此步骤将验证该 Pod 控制了用于生成 CSR 的私钥。</li>
<li>CSR 的 subject 被授权在请求的上下文中执行。
这点用于处理不期望的主体被加入集群的威胁。
在上述示例中，此步骤将是验证该 Pod 是否被允许加入到所请求的服务中。</li>
</ol>
<!--
If and only if these two requirements are met, the approver should approve
the CSR and otherwise should deny the CSR.
-->
<p>当且仅当满足这两个要求时，审批者应该批准 CSR，否则拒绝 CSR。</p>
<!--
## A Word of Warning on the Approval Permission

The ability to approve CSRs decides who trusts who within the cluster. This
includes who the Kubernetes API trusts. The ability to approve CSRs should
not be granted broadly or lightly. The requirements of the challenge
noted in the previous section and the repercussions of issuing a specific
certificate should be fully understood before granting this permission.
-->
<h2 id="关于批准权限的警告">关于批准权限的警告</h2>
<p>批准 CSR 的能力决定了群集中的信任关系。这也包括 Kubernetes API 所信任的人。
批准 CSR 的能力不能过于广泛和轻率。
在给予本许可之前，应充分了解上一节中提到的挑战和发布特定证书的后果。</p>
<!--
## A Note to Cluster Administrators

This tutorial assumes that a signer is setup to serve the certificates API. The
Kubernetes controller manager provides a default implementation of a signer. To
enable it, pass the `--cluster-signing-cert-file` and
`--cluster-signing-key-file` parameters to the controller manager with paths to
your Certificate Authority's keypair.
-->
<h2 id="给集群管理员的一个建议">给集群管理员的一个建议</h2>
<p>本教程假设已经为 certificates API 配置了签名者。Kubernetes 控制器管理器
提供了一个签名者的默认实现。要启用它，请为控制器管理器设置
<code>--cluster-signing-cert-file</code> 和 <code>--cluster-signing-key-file</code> 参数，
使之取值为你的证书机构的密钥对的路径。</p>

</div>



    
	
  



          </main>
        </div>
      </div>
      
<footer class="d-print-none">
  <div class="footer__links">
    <nav>
      
      
      
      <a class="text-white" href="/zh/docs/home/">主页</a>
      
      <a class="text-white" href="/zh/blog/">博客</a>
      
      <a class="text-white" href="/zh/training/">培训</a>
      
      <a class="text-white" href="/zh/partners/">合作伙伴</a>
      
      <a class="text-white" href="/zh/community/">社区</a>
      
      <a class="text-white" href="/zh/case-studies/">案例分析</a>
      
    </nav>
  </div>
  <div class="container-fluid">
    <div class="row">
      <div class="col-6 col-sm-2 text-xs-center order-sm-2">
        
        
        
<ul class="list-inline mb-0">
  
  <li class="list-inline-item mx-2 h3" data-toggle="tooltip" data-placement="top" title="User mailing list" aria-label="User mailing list">
    <a class="text-white" target="_blank" href="https://discuss.kubernetes.io">
      <i class="fa fa-envelope"></i>
    </a>
  </li>
  
  <li class="list-inline-item mx-2 h3" data-toggle="tooltip" data-placement="top" title="Twitter" aria-label="Twitter">
    <a class="text-white" target="_blank" href="https://twitter.com/kubernetesio">
      <i class="fab fa-twitter"></i>
    </a>
  </li>
  
  <li class="list-inline-item mx-2 h3" data-toggle="tooltip" data-placement="top" title="Calendar" aria-label="Calendar">
    <a class="text-white" target="_blank" href="https://calendar.google.com/calendar/embed?src=calendar%40kubernetes.io">
      <i class="fas fa-calendar-alt"></i>
    </a>
  </li>
  
  <li class="list-inline-item mx-2 h3" data-toggle="tooltip" data-placement="top" title="Youtube" aria-label="Youtube">
    <a class="text-white" target="_blank" href="https://youtube.com/kubernetescommunity">
      <i class="fab fa-youtube"></i>
    </a>
  </li>
  
</ul>

        
        
      </div>
      <div class="col-6 col-sm-2 text-right text-xs-center order-sm-3">
        
        
        
<ul class="list-inline mb-0">
  
  <li class="list-inline-item mx-2 h3" data-toggle="tooltip" data-placement="top" title="GitHub" aria-label="GitHub">
    <a class="text-white" target="_blank" href="https://github.com/kubernetes/kubernetes">
      <i class="fab fa-github"></i>
    </a>
  </li>
  
  <li class="list-inline-item mx-2 h3" data-toggle="tooltip" data-placement="top" title="Slack" aria-label="Slack">
    <a class="text-white" target="_blank" href="https://slack.k8s.io">
      <i class="fab fa-slack"></i>
    </a>
  </li>
  
  <li class="list-inline-item mx-2 h3" data-toggle="tooltip" data-placement="top" title="Contribute" aria-label="Contribute">
    <a class="text-white" target="_blank" href="https://git.k8s.io/community/contributors/guide">
      <i class="fas fa-edit"></i>
    </a>
  </li>
  
  <li class="list-inline-item mx-2 h3" data-toggle="tooltip" data-placement="top" title="Stack Overflow" aria-label="Stack Overflow">
    <a class="text-white" target="_blank" href="https://stackoverflow.com/questions/tagged/kubernetes">
      <i class="fab fa-stack-overflow"></i>
    </a>
  </li>
  
</ul>

        
        
      </div>
      <div class="col-12 col-sm-8 text-center order-sm-2">
        <small class="text-white">&copy; 2021 The Kubernetes 作者 | 文档发布基于 <a href="https://git.k8s.io/website/LICENSE" class="light-text">CC BY 4.0</a> 授权许可</small>
        <br/>
        <small class="text-white">Copyright &copy; 2021 Linux 基金会&reg;。保留所有权利。Linux 基金会已注册并使用商标。如需了解 Linux 基金会的商标列表，请访问<a href="https://www.linuxfoundation.org/trademark-usage" class="light-text">商标使用页面</a></small>
        <br/>
        <small class="text-white">ICP license: 京ICP备17074266号-3</small>
        
        
          
        
      </div>
    </div>
  </div>
</footer>


    </div>
    
<script src="/js/popper-1.14.3.min.js" integrity="sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49" crossorigin="anonymous"></script>
<script src="/js/bootstrap-4.3.1.min.js" integrity="sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM" crossorigin="anonymous"></script>











<script src="/js/main.min.40616251a9b6e4b689e7769be0340661efa4d7ebb73f957404e963e135b4ed52.js" integrity="sha256-QGFiUam25LaJ53ab4DQGYe&#43;k1&#43;u3P5V0BOlj4TW07VI=" crossorigin="anonymous"></script>






  </body>
</html>
