<!doctype html>
<html lang="zh" class="no-js">
  <head>
    

<script async src="https://www.googletagmanager.com/gtag/js?id=UA-36037335-10"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-36037335-10');
</script>


<link rel="alternate" hreflang="en" href="https://kubernetes.io/docs/tasks/administer-cluster/">
<link rel="alternate" hreflang="ko" href="https://kubernetes.io/ko/docs/tasks/administer-cluster/">
<link rel="alternate" hreflang="ja" href="https://kubernetes.io/ja/docs/tasks/administer-cluster/">
<link rel="alternate" hreflang="fr" href="https://kubernetes.io/fr/docs/tasks/administer-cluster/">
<link rel="alternate" hreflang="de" href="https://kubernetes.io/de/docs/tasks/administer-cluster/">
<link rel="alternate" hreflang="es" href="https://kubernetes.io/es/docs/tasks/administer-cluster/">
<link rel="alternate" hreflang="id" href="https://kubernetes.io/id/docs/tasks/administer-cluster/">

<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="generator" content="Hugo 0.88.1" />

<META NAME="ROBOTS" CONTENT="NOINDEX, NOFOLLOW">

<link rel="canonical" type="text/html" href="https://kubernetes.io/zh/docs/tasks/administer-cluster/">
<link rel="shortcut icon" type="image/png" href="/images/favicon.png">
<link rel="apple-touch-icon" href="/favicons/apple-touch-icon-180x180.png" sizes="180x180">
<link rel="manifest" href="/manifest.webmanifest">
<link rel="apple-touch-icon" href="/images/kubernetes-192x192.png">
<title>管理集群 | Kubernetes</title><meta property="og:title" content="管理集群" />
<meta property="og:description" content="了解管理集群的常见任务。" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://kubernetes.io/zh/docs/tasks/administer-cluster/" /><meta property="og:site_name" content="Kubernetes" />

<meta itemprop="name" content="管理集群">
<meta itemprop="description" content="了解管理集群的常见任务。"><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="管理集群"/>
<meta name="twitter:description" content="了解管理集群的常见任务。"/>





<link rel="preload" href="/scss/main.min.0bda2f3af46d1514ab4d3cad78295716cfd9557a35a41868b7db38040502bb54.css" as="style">
<link href="/scss/main.min.0bda2f3af46d1514ab4d3cad78295716cfd9557a35a41868b7db38040502bb54.css" rel="stylesheet" integrity="">


<script
  src="/js/jquery-3.3.1.min.js"
  integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8="
  crossorigin="anonymous"></script>





<script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@type": "Organization",
    "url": "https://kubernetes.io",
    "logo": "https://kubernetes.io/images/favicon.png",
    "potentialAction": {
      "@type": "SearchAction",
      "target": "https://kubernetes.io/search/?q={search_term_string}",
      "query-input": "required name=search_term_string"
    }

  }
</script>
<meta name="theme-color" content="#326ce5">




<link rel="stylesheet" href="/css/feature-states.css">



<meta name="description" content="了解管理集群的常见任务。">
<meta property="og:description" content="了解管理集群的常见任务。">
<meta name="twitter:description" content="了解管理集群的常见任务。">
<meta property="og:url" content="https://kubernetes.io/zh/docs/tasks/administer-cluster/">
<meta property="og:title" content="管理集群">
<meta name="twitter:title" content="管理集群">
<meta name="twitter:image" content="https://kubernetes.io/images/favicon.png" />

<meta name="twitter:image:alt" content="Kubernetes">

<meta property="og:image" content="/images/kubernetes-horizontal-color.png">

<meta property="og:type" content="article">



<script src="/js/script.js"></script>


  </head>
  <body class="td-section">
    <header>
      
<nav class="js-navbar-scroll navbar navbar-expand navbar-dark  flex-row td-navbar" data-auto-burger="primary">
        <a class="navbar-brand" href="/zh/"></a>
	<div class="td-navbar-nav-scroll ml-md-auto" id="main_navbar">
		
		<ul class="navbar-nav mt-2 mt-lg-0">
			
			
			
			
			<li class="nav-item mr-2 mb-lg-0">
				
				<a class="nav-link active" href="/zh/docs/" >文档</span></a>
			</li>
			
			
			
			<li class="nav-item mr-2 mb-lg-0">
				
				<a class="nav-link" href="/zh/blog/" >Kubernetes 博客</span></a>
			</li>
			
			
			
			<li class="nav-item mr-2 mb-lg-0">
				
				<a class="nav-link" href="/zh/training/" >培训</span></a>
			</li>
			
			
			
			<li class="nav-item mr-2 mb-lg-0">
				
				<a class="nav-link" href="/zh/partners/" >合作伙伴</span></a>
			</li>
			
			
			
			<li class="nav-item mr-2 mb-lg-0">
				
				<a class="nav-link" href="/zh/community/" >社区</span></a>
			</li>
			
			
			
			<li class="nav-item mr-2 mb-lg-0">
				
				<a class="nav-link" href="/zh/case-studies/" >案例分析</span></a>
			</li>
			
			
			
			<li class="nav-item dropdown">
				<a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
	版本列表
</a>
<div class="dropdown-menu dropdown-menu-right" aria-labelledby="navbarDropdownMenuLink">
	
	<a class="dropdown-item" href="/releases">Release Information</a>
	
	<a class="dropdown-item" href="https://kubernetes.io/zh/docs/tasks/administer-cluster/">v1.22</a>
	
	<a class="dropdown-item" href="https://v1-21.docs.kubernetes.io/zh/docs/tasks/administer-cluster/">v1.21</a>
	
	<a class="dropdown-item" href="https://v1-20.docs.kubernetes.io/zh/docs/tasks/administer-cluster/">v1.20</a>
	
	<a class="dropdown-item" href="https://v1-19.docs.kubernetes.io/zh/docs/tasks/administer-cluster/">v1.19</a>
	
	<a class="dropdown-item" href="https://v1-18.docs.kubernetes.io/zh/docs/tasks/administer-cluster/">v1.18</a>
	
</div>
			</li>
			
			
			<li class="nav-item dropdown">
				

<a class="nav-link dropdown-toggle" href="#" id="navbarDropdownMenuLink" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
	中文 Chinese
</a>
<div class="dropdown-menu dropdown-menu-right" aria-labelledby="navbarDropdownMenuLink">
	
	<a class="dropdown-item" href="/docs/tasks/administer-cluster/">English</a>
	
	<a class="dropdown-item" href="/ko/docs/tasks/administer-cluster/">한국어 Korean</a>
	
	<a class="dropdown-item" href="/ja/docs/tasks/administer-cluster/">日本語 Japanese</a>
	
	<a class="dropdown-item" href="/fr/docs/tasks/administer-cluster/">Français</a>
	
	<a class="dropdown-item" href="/de/docs/tasks/administer-cluster/">Deutsch</a>
	
	<a class="dropdown-item" href="/es/docs/tasks/administer-cluster/">Español</a>
	
	<a class="dropdown-item" href="/id/docs/tasks/administer-cluster/">Bahasa Indonesia</a>
	
</div>

			</li>
			
		</ul>
	</div>
	<button id="hamburger" onclick="kub.toggleMenu()" data-auto-burger-exclude><div></div></button>
</nav>
    </header>
    <div class="container-fluid td-outer">
      <div class="td-main">
        <div class="row flex-xl-nowrap">
          <div class="col-12 col-md-3 col-xl-2 td-sidebar d-print-none">
          </div>
          <div class="d-none d-xl-block col-xl-2 td-toc d-print-none">
          </div>
          <main class="col-12 col-md-9 col-xl-8 pl-md-5" role="main">
            




<div class="td-content">
<div class="pageinfo pageinfo-primary d-print-none">
<p>
这是本节的多页打印视图。
<a href="#" onclick="print();return false;">点击此处打印</a>.
</p><p>
<a href="/zh/docs/tasks/administer-cluster/">返回本页常规视图</a>.
</p>
</div>



<h1 class="title">管理集群</h1>
<div class="lead">了解管理集群的常见任务。</div>




    <ul>
    
  
  
  
  

  
    
    
	
<li>1: <a href="#pg-adb6c52e773f4d890595e14a9251f59b">从 dockershim 迁移</a></li>


    
    <ul>
        
  
  
  
  

  
    
    
	
<li>1.1: <a href="#pg-58702e4818c09c9b3d574349c1a71cb3">检查弃用 Dockershim 对你的影响</a></li>


    
  
    
    
	
<li>1.2: <a href="#pg-eb3e279a6c5e1224e744080a52ee3f28">从 dockershim 迁移遥测和安全代理</a></li>


    
  

    </ul>
    
  
    
    
	
<li>2: <a href="#pg-8e16d69617b175d61e2e7a6e1642c9d6">用 kubeadm 进行管理</a></li>


    
    <ul>
        
  
  
  
  

  
    
    
	
<li>2.1: <a href="#pg-f62fba1de4084f3be070785757c8079c">使用 kubeadm 进行证书管理</a></li>


    
  
    
    
	
<li>2.2: <a href="#pg-6134c5061298affa145ddb801b5c29da">配置 cgroup 驱动</a></li>


    
  
    
    
	
<li>2.3: <a href="#pg-2e173356df5179cab9eec90a606f0aa4">升级 kubeadm 集群</a></li>


    
  
    
    
	
<li>2.4: <a href="#pg-9133578f1e75663bb031e5a377ca896d">添加 Windows 节点</a></li>


    
  
    
    
	
<li>2.5: <a href="#pg-e805c7d8d4ad6195cb82dbbc843bfc29">升级 Windows 节点</a></li>


    
  

    </ul>
    
  
    
    
	
<li>3: <a href="#pg-47be5dd51f686017f1766e6ec7aa6f41">管理内存，CPU 和 API 资源</a></li>


    
    <ul>
        
  
  
  
  

  
    
    
	
<li>3.1: <a href="#pg-337620c76587e4aeb32009cb23be46de">为命名空间配置默认的内存请求和限制</a></li>


    
  
    
    
	
<li>3.2: <a href="#pg-320af95e480962c538ebef7ae205845c">为命名空间配置默认的 CPU 请求和限制</a></li>


    
  
    
    
	
<li>3.3: <a href="#pg-adb489b1ab985c9215657b0d4c6ae92b">配置命名空间的最小和最大内存约束</a></li>


    
  
    
    
	
<li>3.4: <a href="#pg-a87cbd1f9379dac7a48ae320da68a9ad">为命名空间配置 CPU 最小和最大约束</a></li>


    
  
    
    
	
<li>3.5: <a href="#pg-fe3283559a3df299aae3ee00ecea2fad">为命名空间配置内存和 CPU 配额</a></li>


    
  
    
    
	
<li>3.6: <a href="#pg-40e30a9209e0c9f4153707e43243e9d7">配置命名空间下 Pod 配额</a></li>


    
  

    </ul>
    
  
    
    
	
<li>4: <a href="#pg-7743f043c43f7b12e8654e2227dbc658">证书</a></li>


    
  
    
    
	
<li>5: <a href="#pg-8c31aafd38fad5b0de0bd191758d6f93">安装网络规则驱动</a></li>


    
    <ul>
        
  
  
  
  

  
    
    
	
<li>5.1: <a href="#pg-1239a77618c6278373832a142cd85519">使用 Calico 提供 NetworkPolicy</a></li>


    
  
    
    
	
<li>5.2: <a href="#pg-95039241255a31df196beaa405b68eba">使用 Cilium 提供 NetworkPolicy</a></li>


    
  
    
    
	
<li>5.3: <a href="#pg-505a0a6a7e6eff361bbb3be81c84b2e0">使用 kube-router 提供 NetworkPolicy</a></li>


    
  
    
    
	
<li>5.4: <a href="#pg-2842eac98aa0e229a5c6755c4c83d2a7">使用 Romana 提供 NetworkPolicy</a></li>


    
  
    
    
	
<li>5.5: <a href="#pg-ac075c3fdfd0d41aa753cc70e42be064">使用 Weave Net 提供 NetworkPolicy</a></li>


    
  

    </ul>
    
  
    
    
	
<li>6: <a href="#pg-b45f024608e1b367cdacb1fd9d77278a">IP Masquerade Agent 用户指南</a></li>


    
  
    
    
	
<li>7: <a href="#pg-ce4cd28c8feb9faa783e79b48af37961">Kubernetes 云管理控制器</a></li>


    
  
    
    
	
<li>8: <a href="#pg-c4d0832845adc92b7ccd54aed63fc932">为 Kubernetes 运行 etcd 集群</a></li>


    
  
    
    
	
<li>9: <a href="#pg-b64a1d2bb3f4ed9f7021134e09a75c36">为系统守护进程预留计算资源</a></li>


    
  
    
    
	
<li>10: <a href="#pg-a8f6511197efcd7d0db80ade49620f9d">为节点发布扩展资源</a></li>


    
  
    
    
	
<li>11: <a href="#pg-e1afcdac8d5e8458274b3c481c5ebcda">使用 CoreDNS 进行服务发现</a></li>


    
  
    
    
	
<li>12: <a href="#pg-669c88964b4a9eb2b040057266e4b60d">使用 KMS 驱动进行数据加密</a></li>


    
  
    
    
	
<li>13: <a href="#pg-e77685d5b88d2db5c7631a27b9472eea">使用 Kubernetes API 访问集群</a></li>


    
  
    
    
	
<li>14: <a href="#pg-12001be83d15fcd7f3242313a55777df">保护集群安全</a></li>


    
  
    
    
	
<li>15: <a href="#pg-4a02bcca41439e16655f43fa37c81da4">关键插件 Pod 的调度保证</a></li>


    
  
    
    
	
<li>16: <a href="#pg-fe6b50655c29ab0b7c1ee549ff64c138">升级集群</a></li>


    
  
    
    
	
<li>17: <a href="#pg-56de8c25b1486599777034111645b803">名字空间演练</a></li>


    
  
    
    
	
<li>18: <a href="#pg-09cc2cf3e0f23a3996e6cb31dc4d867c">启用/禁用 Kubernetes API</a></li>


    
  
    
    
	
<li>19: <a href="#pg-c2f73ef872a65be44f4ab1e6511b8eb9">启用拓扑感知提示</a></li>


    
  
    
    
	
<li>20: <a href="#pg-9ceed97f912df7289ed8872e290cfbad">在 Kubernetes 集群中使用 NodeLocal DNSCache</a></li>


    
  
    
    
	
<li>21: <a href="#pg-fe5ad73163d38596340536ec03a205f0">在 Kubernetes 集群中使用 sysctl</a></li>


    
  
    
    
	
<li>22: <a href="#pg-eec61e72c300dbfbf7302400ca966432">在运行中的集群上重新配置节点的 kubelet</a></li>


    
  
    
    
	
<li>23: <a href="#pg-a3790dfb57271d13517e549dffa805b9">声明网络策略</a></li>


    
  
    
    
	
<li>24: <a href="#pg-b35b8ddb9bbc15620ce9636f4346c05c">安全地清空一个节点</a></li>


    
  
    
    
	
<li>25: <a href="#pg-a24171610b6ea75a142cb9c8c7882390">将重复的控制平面迁至云控制器管理器</a></li>


    
  
    
    
	
<li>26: <a href="#pg-9585dc0efb0450fd68728e7511754717">开发云控制器管理器</a></li>


    
  
    
    
	
<li>27: <a href="#pg-00733cc3747eb3f5fe1c9e0439262967">开启服务拓扑</a></li>


    
  
    
    
	
<li>28: <a href="#pg-7127e6b7344b315b30b1ce8c4d8bfc55">控制节点上的 CPU 管理策略</a></li>


    
  
    
    
	
<li>29: <a href="#pg-8060aed5bf1172fa62199a4c306a4cd1">控制节点上的拓扑管理策略</a></li>


    
  
    
    
	
<li>30: <a href="#pg-0b17e83b6049e53b8ffa864bdfa07c87">搭建高可用的 Kubernetes Masters</a></li>


    
  
    
    
	
<li>31: <a href="#pg-2bffd7f3571cdd609bd97fb2e1bdb2fe">改变默认 StorageClass</a></li>


    
  
    
    
	
<li>32: <a href="#pg-fbc9136f53eccd6eb8c80f4bbea3b8f4">更改 PersistentVolume 的回收策略</a></li>


    
  
    
    
	
<li>33: <a href="#pg-966cd1cc69c69410d8698b3ac74abce2">自动扩缩集群 DNS 服务</a></li>


    
  
    
    
	
<li>34: <a href="#pg-3d0cd7d2f13d4759094f281504cf57b8">自定义 DNS 服务</a></li>


    
  
    
    
	
<li>35: <a href="#pg-bc6e50c405a620aab43b40d41d6375df">访问集群上运行的服务</a></li>


    
  
    
    
	
<li>36: <a href="#pg-8bcf4aeb5bbb6d6969a146e5ab97557b">调试 DNS 问题</a></li>


    
  
    
    
	
<li>37: <a href="#pg-1e966f5d0540bbee0876f9d0d08d54dc">通过名字空间共享集群</a></li>


    
  
    
    
	
<li>38: <a href="#pg-f58763cc9447491b6c40f939a02d441d">通过配置文件设置 Kubelet 参数</a></li>


    
  
    
    
	
<li>39: <a href="#pg-5e59f5575dce11fdaed640afdbeedfc1">配置 API 对象配额</a></li>


    
  
    
    
	
<li>40: <a href="#pg-6f3658d05bf8864be1d96b1d1287cffb">配置资源不足时的处理方式</a></li>


    
  
    
    
	
<li>41: <a href="#pg-a02f35804917d7a269c38d7e2c475005">限制存储消耗</a></li>


    
  
    
    
	
<li>42: <a href="#pg-6b4e7ca6586f448c8533a120c29bdd25">静态加密 Secret 数据</a></li>


    
  

    </ul>


<div class="content">
      
</div>
</div>


  
  
  
  

  
  

  
    
    
	
    

<div class="td-content" style="">
    
	<h1 id="pg-adb6c52e773f4d890595e14a9251f59b">1 - 从 dockershim 迁移</h1>
    
	<!-- 
title: "Migrating from dockershim"
weight: 10
content_type: task 
-->
<!-- overview -->
<!-- 
This section presents information you need to know when migrating from
dockershim to other container runtimes.
-->
<p>本节提供从 dockershim 迁移到其他容器运行时的必备知识。</p>
<!-- 
Since the announcement of [dockershim deprecation](/blog/2020/12/08/kubernetes-1-20-release-announcement/#dockershim-deprecation)
in Kubernetes 1.20, there were questions on how this will affect various workloads and Kubernetes
installations. You can find this blog post useful to understand the problem better: [Dockershim Deprecation FAQ](/blog/2020/12/02/dockershim-faq/)
-->
<p>自从 Kubernetes 1.20 宣布
<a href="/zh/blog/2020/12/08/kubernetes-1-20-release-announcement/#dockershim-deprecation">弃用 dockershim</a>，
各类疑问随之而来：这对各类工作负载和 Kubernetes 部署会产生什么影响。
你会发现这篇博文对于更好地理解此问题非常有用：
<a href="/zh/blog/2020/12/02/dockershim-faq/">弃用 Dockershim 常见问题</a></p>
<!-- It is recommended to migrate from dockershim to alternative container runtimes.
Check out [container runtimes](/docs/setup/production-environment/container-runtimes/)
section to know your options. Make sure to
[report issues](https://github.com/kubernetes/kubernetes/issues) you encountered
with the migration. So the issue can be fixed in a timely manner and your cluster would be
ready for dockershim removal.
-->
<p>建议从 dockershim 迁移到其他替代的容器运行时。
请参阅<a href="/zh/docs/setup/production-environment/container-runtimes/">容器运行时</a>
一节以了解可用的备选项。
当在迁移过程中遇到麻烦，请<a href="https://github.com/kubernetes/kubernetes/issues">上报问题</a>。
那么问题就可以及时修复，你的集群也可以进入移除 dockershim 前的就绪状态。</p>

</div>



    
      
  
  
  
  

  
  

  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-58702e4818c09c9b3d574349c1a71cb3">1.1 - 检查弃用 Dockershim 对你的影响</h1>
    
	<!-- 
title: Check whether Dockershim deprecation affects you
content_type: task 
reviewers:
- SergeyKanzhelev
weight: 20
-->
<!-- overview -->
<!-- 
The `dockershim` component of Kubernetes allows to use Docker as a Kubernetes's
<a class='glossary-tooltip' title='容器运行时是负责运行容器的软件。' data-toggle='tooltip' data-placement='top' href='/zh/docs/setup/production-environment/container-runtimes' target='_blank' aria-label='container runtime'>container runtime</a>.
Kubernetes' built-in `dockershim` component was deprecated in release v1.20.
-->
<p>Kubernetes 的 <code>dockershim</code> 组件使得你可以把 Docker 用作 Kubernetes 的
<a class='glossary-tooltip' title='容器运行时是负责运行容器的软件。' data-toggle='tooltip' data-placement='top' href='/zh/docs/setup/production-environment/container-runtimes' target='_blank' aria-label='容器运行时'>容器运行时</a>。
在 Kubernetes v1.20 版本中，内建组件 <code>dockershim</code> 被弃用。</p>
<!-- 
This page explains how your cluster could be using Docker as a container runtime,
provides details on the role that `dockershim` plays when in use, and shows steps
you can take to check whether any workloads could be affected by `dockershim` deprecation.
-->
<p>本页讲解你的集群把 Docker 用作容器运行时的运作机制，
并提供使用 <code>dockershim</code> 时，它所扮演角色的详细信息，
继而展示了一组验证步骤，可用来检查弃用 <code>dockershim</code> 对你的工作负载的影响。</p>
<!-- 
## Finding if your app has a dependencies on Docker {#find-docker-dependencies} 
-->
<h2 id="find-docker-dependencies">检查你的应用是否依赖于 Docker</h2>
<!-- 
If you are using Docker for building your application containers, you can still
run these containers on any container runtime. This use of Docker does not count
as a dependency on Docker as a container runtime.
-->
<p>虽然你通过 Docker 创建了应用容器，但这些容器却可以运行于所有容器运行时。
所以这种使用 Docker 容器运行时的方式并不构成对 Docker 的依赖。</p>
<!-- 
When alternative container runtime is used, executing Docker commands may either
not work or yield unexpected output. This is how you can find whether you have a
dependency on Docker:
-->
<p>当用了替代的容器运行时之后，Docker 命令可能不工作，甚至产生意外的输出。
这才是判定你是否依赖于 Docker 的方法。</p>
<!-- 
1. Make sure no privileged Pods execute Docker commands.
2. Check that scripts and apps running on nodes outside of Kubernetes
   infrastructure do not execute Docker commands. It might be:
   - SSH to nodes to troubleshoot;
   - Node startup scripts;
   - Monitoring and security agents installed on nodes directly.
3. Third-party tools that perform above mentioned privileged operations. See
   [Migrating telemetry and security agents from dockershim](/docs/tasks/administer-cluster/migrating-from-dockershim/migrating-telemetry-and-security-agents)
   for more information.
4. Make sure there is no indirect dependencies on dockershim behavior.
   This is an edge case and unlikely to affect your application. Some tooling may be configured
   to react to Docker-specific behaviors, for example, raise alert on specific metrics or search for
   a specific log message as part of troubleshooting instructions.
   If you have such tooling configured, test the behavior on test
   cluster before migration.
 -->
<ol>
<li>确认没有特权 Pod 执行 docker 命令。</li>
<li>检查 Kubernetes 基础架构外部节点上的脚本和应用，确认它们没有执行 Docker 命令。可能的命令有：
<ul>
<li>SSH 到节点排查故障；</li>
<li>节点启动脚本；</li>
<li>直接安装在节点上的监视和安全代理。</li>
</ul>
</li>
<li>检查执行了上述特权操作的第三方工具。详细操作请参考:
<a href="/zh/docs/tasks/administer-cluster/migrating-from-dockershim/migrating-telemetry-and-security-agents/">从 dockershim 迁移遥测和安全代理</a></li>
<li>确认没有对 dockershim 行为的间接依赖。这是一种极端情况，不太可能影响你的应用。
一些工具很可能被配置为使用了 Docker 特性，比如，基于特定指标发警报，或者在故障排查指令的一个环节中搜索特定的日志信息。
如果你有此类配置的工具，需要在迁移之前，在测试集群上完成功能验证。</li>
</ol>
<!-- 
## Dependency on Docker explained {#role-of-dockershim}  
-->
<h2 id="role-of-dockershim">Docker 依赖详解</h2>
<!-- 
A [container runtime](/docs/concepts/containers/#container-runtimes) is software that can
execute the containers that make up a Kubernetes pod. Kubernetes is responsible for orchestration
and scheduling of Pods; on each node, the <a class='glossary-tooltip' title='一个在集群中每个节点上运行的代理。它保证容器都运行在 Pod 中。' data-toggle='tooltip' data-placement='top' href='/docs/reference/generated/kubelet' target='_blank' aria-label='kubelet'>kubelet</a>
uses the container runtime interface as an abstraction so that you can use any compatible
container runtime.
 -->
<p><a href="/zh/docs/concepts/containers/#container-runtimes">容器运行时</a>是一个软件，用来运行组成 Kubernetes Pod 的容器。
Kubernetes 负责编排和调度 Pod；在每一个节点上，
<a class='glossary-tooltip' title='一个在集群中每个节点上运行的代理。它保证容器都运行在 Pod 中。' data-toggle='tooltip' data-placement='top' href='/docs/reference/generated/kubelet' target='_blank' aria-label='kubelet'>kubelet</a>
使用抽象的容器运行时接口，所以你可以任意选用兼容的容器运行时。</p>
<!-- 
In its earliest releases, Kubernetes offered compatibility with just one container runtime: Docker.
Later in the Kubernetes project's history, cluster operators wanted to adopt additional container runtimes.
The CRI was designed to allow this kind of flexibility - and the kubelet began supporting CRI. However,
because Docker existed before the CRI specification was invented, the Kubernetes project created an
adapter component, `dockershim`. The dockershim adapter allows the kubelet to interact with Docker as
if Docker were a CRI compatible runtime.
 -->
<p>在早期版本中，Kubernetes 提供的兼容性只支持一个容器运行时：Docker。
在 Kubernetes 发展历史中，集群运营人员希望采用更多的容器运行时。
于是 CRI 被设计出来满足这类灵活性需要 - 而 kubelet 亦开始支持 CRI。
然而，因为 Docker 在 CRI 规范创建之前就已经存在，Kubernetes 就创建了一个适配器组件：<code>dockershim</code>。
dockershim 适配器允许 kubelet 与 Docker交互，就好像 Docker 是一个 CRI 兼容的运行时一样。</p>
<!-- 
You can read about it in [Kubernetes Containerd integration goes GA](/blog/2018/05/24/kubernetes-containerd-integration-goes-ga/) blog post.
 -->
<p>你可以阅读博文
<a href="/zh/blog/2018/05/24/kubernetes-containerd-integration-goes-ga/">Kubernetes 容器集成功能的正式发布</a></p>
<!-- Dockershim vs. CRI with Containerd -->
<p><img src="/images/blog/2018-05-24-kubernetes-containerd-integration-goes-ga/cri-containerd.png" alt="Dockershim 和 Containerd CRI 的实现对比图"></p>
<!-- 
Switching to Containerd as a container runtime eliminates the middleman. All the
same containers can be run by container runtimes like Containerd as before. But
now, since containers schedule directly with the container runtime, they are not visible to Docker.
So any Docker tooling or fancy UI you might have used
before to check on these containers is no longer available.
 -->
<p>切换到容器运行时 Containerd 可以消除掉中间环节。
所有以前遗留的容器可由 Containerd 这类容器运行时来运行和管理，操作体验也和以前一样。
但是现在，由于直接用容器运行时调度容器，所以它们对 Docker 来说是不可见的。
因此，你以前用来检查这些容器的 Docker 工具或漂亮的 UI 都不再可用。</p>
<!-- 
You cannot get container information using `docker ps` or `docker inspect`
commands. As you cannot list containers, you cannot get logs, stop containers,
or execute something inside container using `docker exec`.
 -->
<p>你不能再使用 <code>docker ps</code> 或 <code>docker inspect</code> 命令来获取容器信息。
由于你不能列出容器，因此你不能获取日志、停止容器，甚至不能通过 <code>docker exec</code> 在容器中执行命令。</p>
<!-- 
If you're running workloads via Kubernetes, the best way to stop a container is through
the Kubernetes API rather than directly through the container runtime (this advice applies
for all container runtimes, not just Docker).
 -->
<blockquote class="note callout">
  <div><strong>说明：</strong> 如果你用 Kubernetes 运行工作负载，最好通过 Kubernetes API停止容器，而不是通过容器运行时
（此建议适用于所有容器运行时，不仅仅是针对 Docker）。</div>
</blockquote>
<!-- 
You can still pull images or build them using `docker build` command. But images
built or pulled by Docker would not be visible to container runtime and
Kubernetes. They needed to be pushed to some registry to allow them to be used
by Kubernetes.
 -->
<p>你仍然可以下载镜像，或者用 <code>docker build</code> 命令创建它们。
但用 Docker 创建、下载的镜像，对于容器运行时和 Kubernetes，均不可见。
为了在 Kubernetes 中使用，需要把镜像推送（push）到某注册中心。</p>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-eb3e279a6c5e1224e744080a52ee3f28">1.2 - 从 dockershim 迁移遥测和安全代理</h1>
    
	<!-- 
title: Migrating telemetry and security agents from dockershim
content_type: task 
reviewers:
- SergeyKanzhelev
weight: 70
-->
<!-- overview -->
<!-- 
With Kubernetes 1.20 dockershim was deprecated. From the
[Dockershim Deprecation FAQ](/blog/2020/12/02/dockershim-faq/)
you might already know that most apps do not have a direct dependency on runtime hosting
containers. However, there are still a lot of telemetry and security agents
that has a dependency on docker to collect containers metadata, logs and
metrics. This document aggregates information on how to detect tese
dependencies and links on how to migrate these agents to use generic tools or
alternative runtimes.
-->
<p>在 Kubernetes 1.20 版本中，dockershim 被弃用。
在博文<a href="/zh/blog/2020/12/02/dockershim-faq/">弃用 Dockershim 常见问题</a>中，
你大概已经了解到，大多数应用并没有直接通过运行时来托管容器。
但是，仍然有大量的遥测和安全代理依赖 docker 来收集容器元数据、日志和指标。
本文汇总了一些信息和链接：信息用于阐述如何探查这些依赖，链接用于解释如何迁移这些代理去使用通用的工具或其他容器运行。</p>
<!-- 
## Telemetry and security agents 
-->
<h2 id="telemetry-and-security-agents">遥测和安全代理</h2>
<!-- 
There are a few ways agents may run on Kubernetes cluster. Agents may run on
nodes directly or as DaemonSets.
-->
<p>为了让代理运行在 Kubernetes 集群中，我们有几种办法。
代理既可以直接在节点上运行，也可以作为守护进程运行。</p>
<!-- 
### Why do telemetry agents rely on Docker?
-->
<h3 id="why-do-telemetry-agents-relyon-docker">为什么遥测代理依赖于 Docker？</h3>
<!-- 
Historically, Kubernetes was built on top of Docker. Kubernetes is managing
networking and scheduling, Docker was placing and operating containers on a
node. So you can get scheduling-related metadata like a pod name from Kubernetes
and containers state information from Docker. Over time more runtimes were
created to manage containers. Also there are projects and Kubernetes features
that generalize container status information extraction across many runtimes.
-->
<p>因为历史原因，Kubernetes 建立在 Docker 之上。
Kubernetes 管理网络和调度，Docker 则在具体的节点上定位并操作容器。
所以，你可以从 Kubernetes 取得调度相关的元数据，比如 Pod 名称；从 Docker 取得容器状态信息。
后来，人们开发了更多的运行时来管理容器。
同时一些项目和 Kubernetes 特性也不断涌现，支持跨多个运行时收集容器状态信息。</p>
<!-- 
Some agents are tied specifically to the Docker tool. The agents may run
commands like [`docker ps`](https://docs.docker.com/engine/reference/commandline/ps/)
or [`docker top`](https://docs.docker.com/engine/reference/commandline/top/) to list
containers and processes or [docker logs](https://docs.docker.com/engine/reference/commandline/logs/)
to subscribe on docker logs. With the deprecating of Docker as a container runtime,
these commands will not work any longer.
-->
<p>一些代理和 Docker 工具紧密绑定。此类代理可以这样运行命令，比如用
<a href="https://docs.docker.com/engine/reference/commandline/ps/"><code>docker ps</code></a>
或 <a href="https://docs.docker.com/engine/reference/commandline/top/"><code>docker top</code></a>
这类命令来列出容器和进程，用
<a href="https://docs.docker.com/engine/reference/commandline/logs/">docker logs</a>
订阅 Docker 的日志。
但随着 Docker 作为容器运行时被弃用，这些命令将不再工作。</p>
<!-- 
### Identify DaemonSets that depend on Docker {#identify-docker-dependency }
-->
<h3 id="identify-docker-dependency">识别依赖于 Docker 的 DaemonSet</h3>
<!-- 
If a pod wants to make calls to the `dockerd` running on the node, the pod must either:

- mount the filesystem containing the Docker daemon's privileged socket, as a
  <a class='glossary-tooltip' title='包含可被 Pod 中容器访问的数据的目录。' data-toggle='tooltip' data-placement='top' href='/zh/docs/concepts/storage/volumes/' target='_blank' aria-label='volume'>volume</a>; or
- mount the specific path of the Docker daemon's privileged socket directly, also as a volume.
-->
<p>如果某 Pod 想调用运行在节点上的 <code>dockerd</code>，该 Pod 必须满足以下两个条件之一：</p>
<ul>
<li>将包含 Docker 守护进程特权套接字的文件系统挂载为一个<a class='glossary-tooltip' title='包含可被 Pod 中容器访问的数据的目录。' data-toggle='tooltip' data-placement='top' href='/zh/docs/concepts/storage/volumes/' target='_blank' aria-label='卷'>卷</a>；或</li>
<li>直接以卷的形式挂载 Docker 守护进程特权套接字的特定路径。</li>
</ul>
<!-- 
For example: on COS images, Docker exposes its Unix domain socket at
`/var/run/docker.sock` This means that the pod spec will include a
`hostPath` volume mount of `/var/run/docker.sock`.
-->
<p>举例来说：在 COS 镜像中，Docker 通过 <code>/var/run/docker.sock</code> 开放其 Unix 域套接字。
这意味着 Pod 的规约中需要包含 <code>hostPath</code> 卷以挂载 <code>/var/run/docker.sock</code>。</p>
<!-- 
Here's a sample shell script to find Pods that have a mount directly mapping the
Docker socket. This script outputs the namespace and name of the pod. You can
remove the grep `/var/run/docker.sock` to review other mounts.
-->
<p>下面是一个 shell 示例脚本，用于查找包含直接映射 Docker 套接字的挂载点的 Pod。
你也可以删掉 grep <code>/var/run/docker.sock</code> 这一代码片段以查看其它挂载信息。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">kubectl get pods --all-namespaces <span style="color:#b62;font-weight:bold">\
</span><span style="color:#b62;font-weight:bold"></span>-o<span style="color:#666">=</span><span style="color:#b8860b">jsonpath</span><span style="color:#666">=</span><span style="color:#b44">&#39;{range .items[*]}{&#34;\n&#34;}{.metadata.namespace}{&#34;:\t&#34;}{.metadata.name}{&#34;:\t&#34;}{range .spec.volumes[*]}{.hostPath.path}{&#34;, &#34;}{end}{end}&#39;</span> <span style="color:#b62;font-weight:bold">\
</span><span style="color:#b62;font-weight:bold"></span>| sort <span style="color:#b62;font-weight:bold">\
</span><span style="color:#b62;font-weight:bold"></span>| grep <span style="color:#b44">&#39;/var/run/docker.sock&#39;</span>
</code></pre></div><!-- 
There are alternative ways for a pod to access Docker on the host. For instance, the parent
directory `/var/run` may be mounted instead of the full path (like in [this
example](https://gist.github.com/itaysk/7bc3e56d69c4d72a549286d98fd557dd)).
The script above only detects the most common uses.
-->
<blockquote class="note callout">
  <div><strong>说明：</strong> 对于 Pod 来说，访问宿主机上的 Docker 还有其他方式。
例如，可以挂载 <code>/var/run</code> 的父目录而非其完整路径
（就像<a href="https://gist.github.com/itaysk/7bc3e56d69c4d72a549286d98fd557dd">这个例子</a>）。
上述脚本只检测最常见的使用方式。</div>
</blockquote>
<!-- 
### Detecting Docker dependency from node agents
-->
<h3 id="detecting-docker-dependency-from-node-agents">检测节点代理对 Docker 的依赖性</h3>
<!-- 
In case your cluster nodes are customized and install additional security and
telemetry agents on the node, make sure to check with the vendor of the agent whether it has dependency on Docker.
-->
<p>在你的集群节点被定制、且在各个节点上均安装了额外的安全和遥测代理的场景下，
一定要和代理的供应商确认：该代理是否依赖于 Docker。</p>
<!-- 
### Telemetry and security agent vendors
-->
<h3 id="telemetry-and-security-agent-vendors">遥测和安全代理的供应商</h3>
<!-- 
We keep the work in progress version of migration instructions for various telemetry and security agent vendors
in [Google doc](https://docs.google.com/document/d/1ZFi4uKit63ga5sxEiZblfb-c23lFhvy6RXVPikS8wf0/edit#).
Please contact the vendor to get up to date instructions for migrating from dockershim.
-->
<p>我们通过
<a href="https://docs.google.com/document/d/1ZFi4uKit63ga5sxEiZblfb-c23lFhvy6RXVPikS8wf0/edit#">谷歌文档</a>
提供了为各类遥测和安全代理供应商准备的持续更新的迁移指导。
请与供应商联系，获取从 dockershim 迁移的最新说明。</p>

</div>



    
	
  

    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-8e16d69617b175d61e2e7a6e1642c9d6">2 - 用 kubeadm 进行管理</h1>
    
	
</div>



    
      
  
  
  
  

  
  

  
    
    
	
    

<div class="td-content" style="">
    
	<h1 id="pg-f62fba1de4084f3be070785757c8079c">2.1 - 使用 kubeadm 进行证书管理</h1>
    
	<!--
reviewers:
- sig-cluster-lifecycle
title: Certificate Management with kubeadm
content_type: task
weight: 10
-->
<!-- overview -->





<div style="margin-top: 10px; margin-bottom: 10px;">
<b>FEATURE STATE:</b> <code>Kubernetes v1.15 [stable]</code>
</div>

<!-- 
Client certificates generated by [kubeadm](/docs/reference/setup-tools/kubeadm/) expire after 1 year. This page explains how to manage certificate renewals with kubeadm. 
-->
<p>由 <a href="/zh/docs/reference/setup-tools/kubeadm/">kubeadm</a> 生成的客户端证书在 1 年后到期。
本页说明如何使用 kubeadm 管理证书续订。</p>
<h2 id="准备开始">准备开始</h2>
<!--
You should be familiar with [PKI certificates and requirements in Kubernetes](/docs/setup/best-practices/certificates/).
-->
<p>你应该熟悉 <a href="/zh/docs/setup/best-practices/certificates/">Kubernetes 中的 PKI 证书和要求</a>。</p>
<!-- steps -->
<!--
## Using custom certificates {#custom-certificates}

By default, kubeadm generates all the certificates needed for a cluster to run.
You can override this behavior by providing your own certificates.
-->
<h2 id="custom-certificates">使用自定义的证书</h2>
<p>默认情况下, kubeadm 会生成运行一个集群所需的全部证书。
你可以通过提供你自己的证书来改变这个行为策略。</p>
<!--
To do so, you must place them in whatever directory is specified by the
`--cert-dir` flag or the `CertificatesDir`field of kubeadm's `ClusterConfiguration` . By default this
is `/etc/kubernetes/pki`.
-->
<p>如果要这样做, 你必须将证书文件放置在通过 <code>--cert-dir</code> 命令行参数或者 kubeadm 配置中的
<code>CertificatesDir</code> 配置项指明的目录中。默认的值是 <code>/etc/kubernetes/pki</code>。</p>
<!--
If a given certificate and private key pair exists before running `kubeadm init`,
kubeadm does not overwrite them. This means you can, for example, copy an existing
CA into `/etc/kubernetes/pki/ca.crt` and `/etc/kubernetes/pki/ca.key`,
and kubeadm will use this CA for signing the rest of the certificates.
-->
<p>如果在运行 <code>kubeadm init</code> 之前存在给定的证书和私钥对，kubeadm 将不会重写它们。
例如，这意味着您可以将现有的 CA 复制到 <code>/etc/kubernetes/pki/ca.crt</code> 和
<code>/etc/kubernetes/pki/ca.key</code> 中，而 kubeadm 将使用此 CA 对其余证书进行签名。</p>
<!--
## External CA mode {#external-ca-mode}

It is also possible to provide only the `ca.crt` file and not the
`ca.key` file (this is only available for the root CA file, not other cert pairs).
If all other certificates and kubeconfig files are in place, kubeadm recognizes
this condition and activates the "External CA" mode. kubeadm will proceed without the CA key on disk.
-->
<h2 id="external-ca-mode">外部 CA 模式</h2>
<p>只提供了 <code>ca.crt</code> 文件但是不提供 <code>ca.key</code> 文件也是可以的
（这只对 CA 根证书可用，其它证书不可用）。
如果所有的其它证书和 kubeconfig 文件已就绪，kubeadm 检测到满足以上条件就会激活
&quot;外部 CA&quot; 模式。kubeadm 将会在没有 CA 密钥文件的情况下继续执行。</p>
<!--
Instead, run the controller-manager standalone with `--controllers=csrsigner` and
point to the CA certificate and key.
-->
<p>否则, kubeadm 将独立运行 controller-manager，附加一个
<code>--controllers=csrsigner</code> 的参数，并且指明 CA 证书和密钥。</p>
<!--
[PKI certificates and requirements](/docs/setup/best-practices/certificates/) includes guidance on
setting up a cluster to use an external CA.
-->
<p><a href="/zh/docs/setup/best-practices/certificates/">PKI 证书和要求</a>包括集群使用外部 CA 的设置指南。</p>
<!-- 
## Check certificate expiration 

You can use the `check-expiration` subcommand to check when certificates expire:
-->
<h2 id="检查证书是否过期">检查证书是否过期</h2>
<p>你可以使用 <code>check-expiration</code> 子命令来检查证书何时过期</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubeadm certs check-expiration
</code></pre></div><!-- 
The output is similar to this: 
-->
<p>输出类似于以下内容：</p>
<pre tabindex="0"><code>CERTIFICATE                EXPIRES                  RESIDUAL TIME   CERTIFICATE AUTHORITY   EXTERNALLY MANAGED
admin.conf                 Dec 30, 2020 23:36 UTC   364d                                    no
apiserver                  Dec 30, 2020 23:36 UTC   364d            ca                      no
apiserver-etcd-client      Dec 30, 2020 23:36 UTC   364d            etcd-ca                 no
apiserver-kubelet-client   Dec 30, 2020 23:36 UTC   364d            ca                      no
controller-manager.conf    Dec 30, 2020 23:36 UTC   364d                                    no
etcd-healthcheck-client    Dec 30, 2020 23:36 UTC   364d            etcd-ca                 no
etcd-peer                  Dec 30, 2020 23:36 UTC   364d            etcd-ca                 no
etcd-server                Dec 30, 2020 23:36 UTC   364d            etcd-ca                 no
front-proxy-client         Dec 30, 2020 23:36 UTC   364d            front-proxy-ca          no
scheduler.conf             Dec 30, 2020 23:36 UTC   364d                                    no

CERTIFICATE AUTHORITY   EXPIRES                  RESIDUAL TIME   EXTERNALLY MANAGED
ca                      Dec 28, 2029 23:36 UTC   9y              no
etcd-ca                 Dec 28, 2029 23:36 UTC   9y              no
front-proxy-ca          Dec 28, 2029 23:36 UTC   9y              no
</code></pre><!-- 
The command shows expiration/residual time for the client certificates in the `/etc/kubernetes/pki` folder and for the client certificate embedded in the KUBECONFIG files used by kubeadm (`admin.conf`, `controller-manager.conf` and `scheduler.conf`). 
-->
<p>该命令显示 <code>/etc/kubernetes/pki</code> 文件夹中的客户端证书以及
kubeadm（<code>admin.conf</code>, <code>controller-manager.conf</code> 和 <code>scheduler.conf</code>）
使用的 KUBECONFIG 文件中嵌入的客户端证书的到期时间/剩余时间。</p>
<!-- 
Additionally, kubeadm informs the user if the certificate is externally managed; in this case, the user should take care of managing certificate renewal manually/using other tools. 
-->
<p>另外， kubeadm 会通知用户证书是否由外部管理；
在这种情况下，用户应该小心的手动/使用其他工具来管理证书更新。</p>
<!--
`kubeadm` cannot manage certificates signed by an external CA.
 -->
<blockquote class="warning callout">
  <div><strong>警告：</strong> <code>kubeadm</code> 不能管理由外部 CA 签名的证书</div>
</blockquote>

<!-- 
`kubelet.conf` is not included in the list above because kubeadm configures kubelet
for [automatic certificate renewal](/docs/tasks/tls/certificate-rotation/)
with rotatable certificates under `/var/lib/kubelet/pki`.
To repair an expired kubelet client certificate see
[Kubelet client certificate rotation fails](/docs/setup/production-environment/tools/kubeadm/troubleshooting-kubeadm/#kubelet-client-cert).
-->
<blockquote class="note callout">
  <div><strong>说明：</strong> 上面的列表中没有包含 <code>kubelet.conf</code>，因为 kubeadm 将 kubelet 配置为
<a href="/docs/tasks/tls/certificate-rotation/">自动更新证书</a>。
轮换的证书位于目录 <code>/var/lib/kubelet/pki</code>。
要修复过期的 kubelet 客户端证书，请参阅
<a href="/zh/docs/setup/production-environment/tools/kubeadm/troubleshooting-kubeadm/#kubelet-client-cert">kubelet 客户端证书轮换失败</a>。</div>
</blockquote>
<!--
On nodes created with `kubeadm init`, prior to kubeadm version 1.17, there is a
[bug](https://github.com/kubernetes/kubeadm/issues/1753) where you manually have to modify the contents of `kubelet.conf`. After `kubeadm init` finishes, you should update `kubelet.conf` to point to the
rotated kubelet client certificates, by replacing `client-certificate-data` and `client-key-data` with:
-->
<blockquote class="warning callout">
  <div><strong>警告：</strong> <p>在通过 <code>kubeadm init</code> 创建的节点上，在 kubeadm 1.17 版本之前有一个
<a href="https://github.com/kubernetes/kubeadm/issues/1753">缺陷</a>，该缺陷
使得你必须手动修改 <code>kubelet.conf</code> 文件的内容。
<code>kubeadm init</code> 操作结束之后，你必须更新 <code>kubelet.conf</code> 文件
将 <code>client-certificate-data</code> 和 <code>client-key-data</code> 改为如下所示的内容
以便使用轮换后的 kubelet 客户端证书：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">client-certificate</span>:<span style="color:#bbb"> </span>/var/lib/kubelet/pki/kubelet-client-current.pem<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">client-key</span>:<span style="color:#bbb"> </span>/var/lib/kubelet/pki/kubelet-client-current.pem<span style="color:#bbb">
</span></code></pre></div></div>
</blockquote>

<!-- 
## Automatic certificate renewal

`kubeadm` renews all the certificates during control plane [upgrade](/docs/tasks/administer-cluster/kubeadm/kubeadm-upgrade-1-15/). 
-->
<h2 id="自动更新证书">自动更新证书</h2>
<p><code>kubeadm</code> 会在控制面
<a href="/zh/docs/tasks/administer-cluster/kubeadm/kubeadm-upgrade/">升级</a>
的时候更新所有证书。</p>
<!-- 
This feature is designed for addressing the simplest use cases; 
if you don't have specific requirements on certificate renewal and perform Kubernetes version upgrades regularly (less than 1 year in between each upgrade), kubeadm will take care of keeping your cluster up to date and reasonably secure. 
-->
<p>这个功能旨在解决最简单的用例；如果你对此类证书的更新没有特殊要求，
并且定期执行 Kubernetes 版本升级（每次升级之间的间隔时间少于 1 年），
则 kubeadm 将确保你的集群保持最新状态并保持合理的安全性。</p>
<!-- 
It is a best practice to upgrade your cluster frequently in order to stay secure.
-->
<blockquote class="note callout">
  <div><strong>说明：</strong> 最佳的做法是经常升级集群以确保安全。</div>
</blockquote>
<!-- 
If you have more complex requirements for certificate renewal, you can opt out from the default behavior by passing `--certificate-renewal=false` to `kubeadm upgrade apply` or to `kubeadm upgrade node`. 
-->
<p>如果你对证书更新有更复杂的需求，则可通过将 <code>--certificate-renewal=false</code> 传递给
<code>kubeadm upgrade apply</code> 或者 <code>kubeadm upgrade node</code>，从而选择不采用默认行为。</p>
<!--
Prior to kubeadm version 1.17 there is a [bug](https://github.com/kubernetes/kubeadm/issues/1818)
where the default value for `--certificate-renewal` is `false` for the `kubeadm upgrade node`
command. In that case, you should explicitly set `--certificate-renewal=true`.
-->
<blockquote class="warning callout">
  <div><strong>警告：</strong> kubeadm 在 1.17 版本之前有一个<a href="https://github.com/kubernetes/kubeadm/issues/1818">缺陷</a>，
该缺陷导致 <code>kubeadm update node</code> 执行时 <code>--certificate-renewal</code> 的默认值被设置为 <code>false</code>。
在这种情况下，你需要显式地设置 <code>--certificate-renewal=true</code>。</div>
</blockquote>

<!-- 
## Manual certificate renewal 

You can renew your certificates manually at any time with the `kubeadm certs renew` command. 
-->
<h2 id="手动更新证书">手动更新证书</h2>
<p>你能随时通过 <code>kubeadm certs renew</code> 命令手动更新你的证书。</p>
<!-- 
This command performs the renewal using CA (or front-proxy-CA) certificate and key stored in `/etc/kubernetes/pki`. 
-->
<p>此命令用 CA （或者 front-proxy-CA ）证书和存储在 <code>/etc/kubernetes/pki</code> 中的密钥执行更新。</p>
<!-- 
If you are running an HA cluster, this command needs to be executed on all the control-plane nodes. 
-->
<blockquote class="warning callout">
  <div><strong>警告：</strong> 如果你运行了一个 HA 集群，这个命令需要在所有控制面板节点上执行。</div>
</blockquote>

<!-- 
` certs renew` uses the existing certificates as the authoritative source for attributes (Common Name, Organization, SAN, etc.) instead of the kubeadm-config ConfigMap. It is strongly recommended to keep them both in sync.
-->
<blockquote class="note callout">
  <div><strong>说明：</strong> <code>certs renew</code> 使用现有的证书作为属性 (Common Name、Organization、SAN 等) 的权威来源，
而不是 kubeadm-config ConfigMap 。强烈建议使它们保持同步。</div>
</blockquote>
<!--
`kubeadm certs renew` provides the following options:
-->
<p><code>kubeadm certs renew</code>提供以下选项：</p>
<!--
The Kubernetes certificates normally reach their expiration date after one year.
-->
<p>Kubernetes 证书通常在一年后到期。</p>
<!-- 

- `--csr-only` can be used to renew certificats with an external CA by generating certificate signing requests (without actually renewing certificates in place); see next paragraph for more information. 
- It's also possible to renew a single certificate instead of all.
 -->
<ul>
<li><code>--csr-only</code> 可用于经过一个外部 CA 生成的证书签名请求来更新证书（无需实际替换更新证书）；
更多信息请参见下节。</li>
<li>可以更新单个证书而不是全部证书。</li>
</ul>
<!--
## Renew certificates with the Kubernetes certificates API

This section provide more details about how to execute manual certificate renewal using the Kubernetes certificates API.
-->
<h2 id="用-kubernetes-证书-api-更新证书">用 Kubernetes 证书 API 更新证书</h2>
<p>本节提供有关如何使用 Kubernetes 证书 API 执行手动证书更新的更多详细信息。</p>
<!-- 
These are advanced topics for users who need to integrate their organization's certificate infrastructure into a kubeadm-built cluster. If the default kubeadm configuration satisfies your needs, you should let kubeadm manage certificates instead. 
-->
<blockquote class="caution callout">
  <div><strong>注意：</strong> 这些是针对需要将其组织的证书基础结构集成到 kubeadm 构建的集群中的用户的高级主题。
如果默认的 kubeadm 配置满足了你的需求，则应让 kubeadm 管理证书。</div>
</blockquote>

<!--
### Set up a signer

The Kubernetes Certificate Authority does not work out of the box.
You can configure an external signer such as [cert-manager](https://docs.cert-manager.io/en/latest/tasks/issuers/setup-ca.html), or you can use the build-in signer.
The built-in signer is part of [`kube-controller-manager`](/docs/reference/command-line-tools-reference/kube-controller-manager/).
To activate the build-in signer, you must pass the `--cluster-signing-cert-file` and `--cluster-signing-key-file` flags.
-->
<h3 id="设置一个签名者-signer">设置一个签名者（Signer）</h3>
<p>Kubernetes 证书颁发机构不是开箱即用。
你可以配置外部签名者，例如
<a href="https://docs.cert-manager.io/en/latest/tasks/issuers/setup-ca.html">cert-manager</a>，
也可以使用内置签名者。
内置签名者是
<a href="/zh/docs/reference/command-line-tools-reference/kube-controller-manager/"><code>kube-controller-manager</code></a>
的一部分。
要激活内置签名者，请传递 <code>--cluster-signing-cert-file</code> 和 <code>--cluster-signing-key-file</code> 参数。</p>
<!--
If you're creating a new cluster, you can use a kubeadm [configuration file](/docs/reference/config-api/kubeadm-config.v1beta2/): 
-->
<p>如果你正在创建一个新的集群，你可以使用 kubeadm 的
<a href="/docs/reference/config-api/kubeadm-config.v1beta2/">配置文件</a>。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>kubeadm.k8s.io/v1beta2<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>ClusterConfiguration<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">controllerManager</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">extraArgs</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">cluster-signing-cert-file</span>:<span style="color:#bbb"> </span>/etc/kubernetes/pki/ca.crt<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">cluster-signing-key-file</span>:<span style="color:#bbb"> </span>/etc/kubernetes/pki/ca.key<span style="color:#bbb">
</span></code></pre></div><!-- 
### Create certificate signing requests (CSR)
-->
<h3 id="创建证书签名请求-csr">创建证书签名请求 (CSR)</h3>
<!--
See [Create CertificateSigningRequest](/docs/reference/access-authn-authz/certificate-signing-requests/#create-certificatesigningrequest) for creating CSRs with the Kubernetes API.
-->
<p>有关使用 Kubernetes API 创建 CSR 的信息，
请参见<a href="/zh/docs/reference/access-authn-authz/certificate-signing-requests/#create-certificatesigningrequest">创建 CertificateSigningRequest</a>。</p>
<!--
## Renew certificates with external CA

This section provides more details about how to execute manual certificate renewal using an external CA.
-->
<h2 id="通过外部-ca-更新证书">通过外部 CA 更新证书</h2>
<p>本节提供有关如何使用外部 CA 执行手动更新证书的更多详细信息。</p>
<!--
To better integrate with external CAs, kubeadm can also produce certificate signing requests (CSRs).
A CSR represents a request to a CA for a signed certificate for a client.
In kubeadm terms, any certificate that would normally be signed by an on-disk CA can be produced as a CSR instead. A CA, however, cannot be produced as a CSR.
-->
<p>为了更好的与外部 CA 集成，kubeadm 还可以生成证书签名请求（CSR）。
CSR 表示向 CA 请求客户的签名证书。
在 kubeadm 术语中，通常由磁盘 CA 签名的任何证书都可以作为 CSR 生成。但是，CA 不能作为 CSR 生成。</p>
<!-- 
### Create certificate signing requests (CSR) 

You can create certificate signing requests with `kubeadm certs renew --csr-only`.

Both the CSR and the accompanying private key are given in the output.
You can pass in a directory with `--csr-dir` to output the CSRs to the specified location.
If `--csr-dir` is not specified, the default certificate directory (`/etc/kubernetes/pki`) is used.
-->
<h3 id="创建证书签名请求-csr-1">创建证书签名请求 (CSR)</h3>
<p>你可以通过 <code>kubeadm certs renew --csr-only</code> 命令创建证书签名请求。</p>
<p>CSR 和随附的私钥都在输出中给出。
你可以传入一个带有 <code>--csr-dir</code> 的目录，将 CRS 输出到指定位置。
如果未指定 <code>--csr-dir</code> ，则使用默认证书目录（<code>/etc/kubernetes/pki</code>）。</p>
<!--
Certificates can be renewed with `kubeadm certs renew --csr-only`.
As with `kubeadm init`, an output directory can be specified with the `--csr-dir` flag.
-->
<p>证书可以通过 <code>kubeadm certs renew --csr-only</code> 来续订。
和 <code>kubeadm init</code> 一样，可以使用 <code>--csr-dir</code> 标志指定一个输出目录。</p>
<p>CSR 签署证书后，必须将证书和私钥复制到 PKI 目录（默认情况下为 <code>/etc/kubernetes/pki</code>）。</p>
<!--
A CSR contains a certificate's name, domains, and IPs, but it does not specify usages.
It is the responsibility of the CA to specify [the correct cert usages](/docs/setup/best-practices/certificates/#all-certificates)
when issuing a certificate.
-->
<p>CSR 中包含一个证书的名字，域和 IP，但是未指定用法。
颁发证书时，CA 有责任指定<a href="/zh/docs/setup/best-practices/certificates/#all-certificates">正确的证书用法</a></p>
<!-- 
* In `openssl` this is done with the
  [`openssl ca` command](https://superuser.com/questions/738612/openssl-ca-keyusage-extension).
* In `cfssl` you specify
  [usages in the config file](https://github.com/cloudflare/cfssl/blob/master/doc/cmd/cfssl.txt#L170).
-->
<ul>
<li>在 <code>openssl</code> 中，这是通过
<a href="https://superuser.com/questions/738612/openssl-ca-keyusage-extension"><code>openssl ca</code> 命令</a>
来完成的。</li>
<li>在 <code>cfssl</code> 中，这是通过
<a href="https://github.com/cloudflare/cfssl/blob/master/doc/cmd/cfssl.txt#L170">在配置文件中指定用法</a>
来完成的。</li>
</ul>
<!-- 
After a certificate is signed using your preferred method, the certificate and the private key must be copied to the PKI directory (by default `/etc/kubernetes/pki`). 
-->
<p>使用首选方法对证书签名后，必须将证书和私钥复制到 PKI 目录（默认为 <code>/etc/kubernetes/pki</code> ）。</p>
<!--
## Certificate authority (CA) rotation {#certificate-authority-rotation}

Kubeadm does not support rotation or replacement of CA certificates out of the box.

For more information about manual rotation or replacement of CA, see [manual rotation of CA certificates](/docs/tasks/tls/manual-rotation-of-ca-certificates/).
-->
<h2 id="certificate-authority-rotation">证书机构（CA）轮换    </h2>
<p>kubeadm 并不直接支持对 CA 证书的轮换或者替换。</p>
<p>关于手动轮换或者置换 CA 的更多信息，可参阅
<a href="/zh/docs/tasks/tls/manual-rotation-of-ca-certificates/">手动轮换 CA 证书</a>。</p>
<!--
## Enabling signed kubelet serving certificates {#kubelet-serving-certs}

By default the kubelet serving certificate deployed by kubeadm is self-signed.
This means a connection from external services like the
[metrics-server](https://github.com/kubernetes-sigs/metrics-server) to a
kubelet cannot be secured with TLS.

To configure the kubelets in a new kubeadm cluster to obtain properly signed serving
certificates you must pass the following minimal configuration to `kubeadm init`:
-->
<h2 id="kubelet-serving-certs">启用已签名的 kubelet 服务证书  </h2>
<p>默认情况下，kubeadm 所部署的 kubelet 服务证书是自签名（Self-Signed））。
这意味着从 <a href="https://github.com/kubernetes-sigs/metrics-server">metrics-server</a>
这类外部服务发起向 kubelet 的链接时无法使用 TLS 来完成保护。</p>
<p>要在新的 kubeadm 集群中配置 kubelet 以使用被正确签名的服务证书，
你必须向 <code>kubeadm init</code> 传递如下最小配置数据：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>kubeadm.k8s.io/v1beta2<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>ClusterConfiguration<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#00f;font-weight:bold">---</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>kubelet.config.k8s.io/v1beta1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>KubeletConfiguration<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">serverTLSBootstrap</span>:<span style="color:#bbb"> </span><span style="color:#a2f;font-weight:bold">true</span><span style="color:#bbb">
</span></code></pre></div><!--
If you have already created the cluster you must adapt it by doing the following:
 - Find and edit the `kubelet-config-1.22` ConfigMap in the `kube-system` namespace.
In that ConfigMap, the `kubelet` key has a
[KubeletConfiguration](/docs/reference/config-api/kubelet-config.v1beta1/#kubelet-config-k8s-io-v1beta1-KubeletConfiguration)
document as its value. Edit the KubeletConfiguration document to set `serverTLSBootstrap: true`.
- On each node, add the `serverTLSBootstrap: true` field in `/var/lib/kubelet/config.yaml`
and restart the kubelet with `systemctl restart kubelet`
-->
<p>如果你已经创建了集群，你必须通过执行下面的操作来完成适配：</p>
<ul>
<li>找到 <code>kube-system</code> 名字空间中名为 <code>kubelet-config-1.22</code>
的 ConfigMap 并编辑之。
在该 ConfigMap 中，<code>kubelet</code> 键下面有一个
<a href="/zh/docs/reference/config-api/kubelet-config.v1beta1/#kubelet-config-k8s-io-v1beta1-KubeletConfiguration">KubeletConfiguration</a>
文档作为其取值。编辑该 KubeletConfiguration 文档以设置
<code>serverTLSBootstrap: true</code>。</li>
<li>在每个节点上，在 <code>/var/lib/kubelet/config.yaml</code> 文件中添加
<code>serverTLSBootstrap: true</code> 字段，并使用 <code>systemctl restart kubelet</code>
来重启 kubelet。</li>
</ul>
<!--
The field `serverTLSBootstrap: true` will enable the bootstrap of kubelet serving
certificates by requesting them from the `certificates.k8s.io` API. One known limitation
is that the CSRs (Certificate Signing Requests) for these certificates cannot be automatically
approved by the default signer in the kube-controller-manager -
[`kubernetes.io/kubelet-serving`](/docs/reference/access-authn-authz/certificate-signing-requests/#kubernetes-signers).
This will require action from the user or a third party controller.

These CSRs can be viewed using:
-->
<p>字段 <code>serverTLSBootstrap</code> 将允许启动引导 kubelet 的服务证书，方式
是从 <code>certificates.k8s.io</code> API 处读取。这种方式的一种局限在于这些
证书的 CSR（证书签名请求）不能被 kube-controller-manager 中默认的
签名组件
<a href="/zh/docs/reference/access-authn-authz/certificate-signing-requests/#kubernetes-signers"><code>kubernetes.io/kubelet-serving</code></a>
批准。需要用户或者第三方控制器来执行此操作。</p>
<p>可以使用下面的命令来查看 CSR：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl get csr
</code></pre></div><pre tabindex="0"><code class="language-none" data-lang="none">NAME        AGE     SIGNERNAME                        REQUESTOR                      CONDITION
csr-9wvgt   112s    kubernetes.io/kubelet-serving     system:node:worker-1           Pending
csr-lz97v   1m58s   kubernetes.io/kubelet-serving     system:node:control-plane-1    Pending
</code></pre><!--
To approve them you can do the following:
-->
<p>你可以执行下面的操作来批准这些请求：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl certificate approve &lt;CSR-名称&gt;
</code></pre></div><!--
By default, these serving certificate will expire after one year. Kubeadm sets the
`KubeletConfiguration` field `rotateCertificates` to `true`, which means that close
to expiration a new set of CSRs for the serving certificates will be created and must
be approved to complete the rotation. To understand more see
[Certificate Rotation](/docs/reference/command-line-tools-reference/kubelet-tls-bootstrapping/#certificate-rotation).
-->
<p>默认情况下，这些服务证书上会在一年后过期。
kubeadm 将 <code>KubeletConfiguration</code> 的 <code>rotateCertificates</code> 字段设置为
<code>true</code>；这意味着证书快要过期时，会生成一组针对服务证书的新的 CSR，而
这些 CSR 也要被批准才能完成证书轮换。
要进一步了解这里的细节，可参阅
<a href="/zh/docs/reference/command-line-tools-reference/kubelet-tls-bootstrapping/#certificate-rotation">证书轮换</a>
文档。</p>
<!--
If you are looking for a solution for automatic approval of these CSRs it is recommended
that you contact your cloud provider and ask if they have a CSR signer that verifies
the node identity with an out of band mechanism.
-->
<p>如果你在寻找一种能够自动批准这些 CSR 的解决方案，建议你与你的云提供商
联系，询问他们是否有 CSR 签名组件，用来以带外（out-of-band）的方式检查
节点的标识符。</p>
<blockquote class="callout caution" role="alert">
  <strong>注意：</strong>
  本部分链接到提供 Kubernetes 所需功能的第三方项目。Kubernetes 项目作者不负责这些项目。此页面遵循<a href="https://github.com/cncf/foundation/blob/master/website-guidelines.md" target="_blank">CNCF 网站指南</a>，按字母顺序列出项目。要将项目添加到此列表中，请在提交更改之前阅读<a href="/docs/contribute/style/content-guide/#third-party-content">内容指南</a>。
</blockquote>
<!--
Third party custom controllers can be used:
- [kubelet-rubber-stamp](https://github.com/kontena/kubelet-rubber-stamp)

Such a controller is not a secure mechanism unless it not only verifies the CommonName
in the CSR but also verifies the requested IPs and domain names. This would prevent
a malicious actor that has access to a kubelet client certificate to create
CSRs requesting serving certificates for any IP or domain name.
-->
<p>也可以使用第三方定制的控制器：</p>
<ul>
<li><a href="https://github.com/kontena/kubelet-rubber-stamp">kubelet-rubber-stamp</a></li>
</ul>
<p>除非既能够验证 CSR 中的 CommonName，也能检查请求的 IP 和域名，
这类控制器还算不得安全的机制。
只有完成彻底的检查，才有可能避免有恶意的、能够访问 kubelet 客户端证书的第三方
为任何 IP 或域名请求服务证书。</p>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-6134c5061298affa145ddb801b5c29da">2.2 - 配置 cgroup 驱动</h1>
    
	<!-- 
---
title: Configuring a cgroup driver
content_type: task
weight: 10
---
-->
<!-- overview -->
<!-- 
This page explains how to configure the kubelet cgroup driver to match the container
runtime cgroup driver for kubeadm clusters.
-->
<p>本页阐述如何配置 kubelet 的 cgroup 驱动以匹配 kubeadm 集群中的容器运行时的 cgroup 驱动。</p>
<h2 id="准备开始">准备开始</h2>
<!-- 
You should be familiar with the Kubernetes
[container runtime requirements](/docs/setup/production-environment/container-runtimes).
-->
<p>你应该熟悉 Kubernetes 的<a href="/zh/docs/setup/production-environment/container-runtimes">容器运行时需求</a>。</p>
<!-- steps -->
<!-- 
## Configuring the container runtime cgroup driver
-->
<h2 id="configuring-the-container-runtime-cgroup-driver">配置容器运行时 cgroup 驱动</h2>
<!-- 
The [Container runtimes](/docs/setup/production-environment/container-runtimes) page
explains that the `systemd` driver is recommended for kubeadm based setups instead
of the `cgroupfs` driver, because kubeadm manages the kubelet as a systemd service.
-->
<p><a href="/zh/docs/setup/production-environment/container-runtimes">容器运行时</a>页面提到：
由于 kubeadm 把 kubelet 视为一个系统服务来管理，所以对基于 kubeadm 的安装，
我们推荐使用 <code>systemd</code> 驱动，不推荐 <code>cgroupfs</code> 驱动。</p>
<!-- 
The page also provides details on how to setup a number of different container runtimes with the
`systemd` driver by default.
-->
<p>此页还详述了如何安装若干不同的容器运行时，并将 <code>systemd</code> 设为其默认驱动。</p>
<!-- 
## Configuring the kubelet cgroup driver
-->
<h2 id="配置-kubelet-的-cgroup-驱动">配置 kubelet 的 cgroup 驱动</h2>
<!-- 
kubeadm allows you to pass a `KubeletConfiguration` structure during `kubeadm init`.
This `KubeletConfiguration` can include the `cgroupDriver` field which controls the cgroup
driver of the kubelet.
-->
<p>kubeadm 支持在执行 <code>kubeadm init</code> 时，传递一个 <code>KubeletConfiguration</code> 结构体。
<code>KubeletConfiguration</code> 包含 <code>cgroupDriver</code> 字段，可用于控制 kubelet 的 cgroup 驱动。</p>
<!-- 
If the user is not setting the `cgroupDriver` field under `KubeletConfiguration`,
`kubeadm init` will default it to `systemd`.
-->





<div style="margin-top: 10px; margin-bottom: 10px;">
<b>FEATURE STATE:</b> <code>Kubernetes v1.21 [stable]</code>
</div>

<blockquote class="note callout">
  <div><strong>说明：</strong> 如果用户没有在 <code>KubeletConfiguration</code> 中设置 <code>cgroupDriver</code> 字段，
<code>kubeadm init</code> 会将它设置为默认值 <code>systemd</code>。</div>
</blockquote>
<!-- 
A minimal example of configuring the field explicitly:
-->
<p>这是一个最小化的示例，其中显式的配置了此字段：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#080;font-style:italic"># kubeadm-config.yaml</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>ClusterConfiguration<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>kubeadm.k8s.io/v1beta2<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kubernetesVersion</span>:<span style="color:#bbb"> </span>v1.21.0<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#00f;font-weight:bold">---</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>KubeletConfiguration<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>kubelet.config.k8s.io/v1beta1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">cgroupDriver</span>:<span style="color:#bbb"> </span>systemd<span style="color:#bbb">
</span></code></pre></div><!-- 
Such a configuration file can then be passed to the kubeadm command:
-->
<p>这样一个配置文件就可以传递给 kubeadm 命令了：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubeadm init --config kubeadm-config.yaml
</code></pre></div><!-- 
Kubeadm uses the same `KubeletConfiguration` for all nodes in the cluster.
The `KubeletConfiguration` is stored in a [ConfigMap](/docs/concepts/configuration/configmap)
object under the `kube-system` namespace.

Executing the sub commands `init`, `join` and `upgrade` would result in kubeadm
writing the `KubeletConfiguration` as a file under `/var/lib/kubelet/config.yaml`
and passing it to the local node kubelet.
-->
<blockquote class="note callout">
  <div><strong>说明：</strong> <p>Kubeadm 对集群所有的节点，使用相同的 <code>KubeletConfiguration</code>。
<code>KubeletConfiguration</code> 存放于 <code>kube-system</code> 命名空间下的某个
<a href="/zh/docs/concepts/configuration/configmap">ConfigMap</a> 对象中。</p>
<p>执行 <code>init</code>、<code>join</code> 和 <code>upgrade</code> 等子命令会促使 kubeadm
将 <code>KubeletConfiguration</code> 写入到文件 <code>/var/lib/kubelet/config.yaml</code> 中，
继而把它传递给本地节点的 kubelet。</p>
</div>
</blockquote>
<!-- 
## Using the `cgroupfs` driver
-->
<h1 id="使用-cgroupfs-驱动">使用 <code>cgroupfs</code> 驱动</h1>
<!-- 
As this guide explains using the `cgroupfs` driver with kubeadm is not recommended.

To continue using `cgroupfs` and to prevent `kubeadm upgrade` from modifying the
`KubeletConfiguration` cgroup driver on existing setups, you must be explicit
about its value. This applies to a case where you do not wish future versions
of kubeadm to apply the `systemd` driver by default.
-->
<p>正如本指南阐述的：不推荐与 kubeadm 一起使用 <code>cgroupfs</code> 驱动。</p>
<p>如仍需使用 <code>cgroupfs</code>，
且要防止 <code>kubeadm upgrade</code> 修改现有系统中 <code>KubeletConfiguration</code> 的 cgroup 驱动，
你必须显式声明它的值。
此方法应对的场景为：在将来某个版本的 kubeadm 中，你不想使用默认的 <code>systemd</code> 驱动。</p>
<!-- 
See the below section on "Modify the kubelet ConfigMap" for details on
how to be explicit about the value.

If you wish to configure a container runtime to use the `cgroupfs` driver,
you must refer to the documentation of the container runtime of your choice.
-->
<p>参阅以下章节“修改 kubelet 的 ConfigMap”，了解显式设置该值的方法。</p>
<p>如果你希望配置容器运行时来使用 <code>cgroupfs</code> 驱动，
则必须参考所选容器运行时的文档。</p>
<!-- 
## Migrating to the `systemd` driver
-->
<h2 id="迁移到-systemd-驱动">迁移到 <code>systemd</code> 驱动</h2>
<!-- 
To change the cgroup driver of an existing kubeadm cluster to `systemd` in-place,
a similar procedure to a kubelet upgrade is required. This must include both
steps outlined below.
-->
<p>要将现有 kubeadm 集群的 cgroup 驱动就地升级为 <code>systemd</code>，
需要执行一个与 kubelet 升级类似的过程。
该过程必须包含下面两个步骤：</p>
<!-- 
Alternatively, it is possible to replace the old nodes in the cluster with new ones
that use the `systemd` driver. This requires executing only the first step below
before joining the new nodes and ensuring the workloads can safely move to the new
nodes before deleting the old nodes.
-->
<blockquote class="note callout">
  <div><strong>说明：</strong> 还有一种方法，可以用已配置了 <code>systemd</code> 的新节点替换掉集群中的老节点。
按这种方法，在加入新节点、确保工作负载可以安全迁移到新节点、及至删除旧节点这一系列操作之前，
只需执行以下第一个步骤。</div>
</blockquote>
<!-- 
### Modify the kubelet ConfigMap
-->
<h3 id="修改-kubelet-的-configmap">修改 kubelet 的 ConfigMap</h3>
<!-- 
- Find the kubelet ConfigMap name using `kubectl get cm -n kube-system | grep kubelet-config`.
- Call `kubectl edit cm kubelet-config-x.yy -n kube-system` (replace `x.yy` with
the Kubernetes version).
- Either modify the existing `cgroupDriver` value or add a new field that looks like this:
-->
<ul>
<li>
<p>用命令 <code>kubectl get cm -n kube-system | grep kubelet-config</code> 找到 kubelet 的 ConfigMap 名称。</p>
</li>
<li>
<p>运行 <code>kubectl edit cm kubelet-config-x.yy -n kube-system</code> （把 <code>x.yy</code> 替换为 Kubernetes 版本）。</p>
</li>
<li>
<p>修改现有 <code>cgroupDriver</code> 的值，或者新增如下式样的字段：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">cgroupDriver</span>:<span style="color:#bbb"> </span>systemd<span style="color:#bbb">
</span></code></pre></div><!-- 
This field must be present under the `kubelet:` section of the ConfigMap.
-->
<p>该字段必须出现在 ConfigMap 的 <code>kubelet:</code> 小节下。</p>
</li>
</ul>
<!-- 
### Update the cgroup driver on all nodes
-->
<h3 id="更新所有节点的-cgroup-驱动">更新所有节点的 cgroup 驱动</h3>
<!-- 
For each node in the cluster:

- [Drain the node](/docs/tasks/administer-cluster/safely-drain-node) using `kubectl drain <node-name> --ignore-daemonsets`
- Stop the kubelet using `systemctl stop kubelet`
- Stop the container runtime
- Modify the container runtime cgroup driver to `systemd`
- Set `cgroupDriver: systemd` in `/var/lib/kubelet/config.yaml`
- Start the container runtime
- Start the kubelet using `systemctl start kubelet`
- [Uncordon the node](/docs/tasks/administer-cluster/safely-drain-node) using `kubectl uncordon <node-name>`
-->
<p>对于集群中的每一个节点：</p>
<ul>
<li>执行命令 <code>kubectl drain &lt;node-name&gt; --ignore-daemonsets</code>，以
<a href="/zh/docs/tasks/administer-cluster/safely-drain-node">腾空节点</a></li>
<li>执行命令 <code>systemctl stop kubelet</code>，以停止 kubelet</li>
<li>停止容器运行时</li>
<li>修改容器运行时 cgroup 驱动为 <code>systemd</code></li>
<li>在文件 <code>/var/lib/kubelet/config.yaml</code> 中添加设置 <code>cgroupDriver: systemd</code></li>
<li>启动容器运行时</li>
<li>执行命令 <code>systemctl start kubelet</code>，以启动 kubelet</li>
<li>执行命令 <code>kubectl uncordon &lt;node-name&gt;</code>，以
<a href="/zh/docs/tasks/administer-cluster/safely-drain-node">取消节点隔离</a></li>
</ul>
<!-- 
Execute these steps on nodes one at a time to ensure workloads
have sufficient time to schedule on different nodes.

Once the process is complete ensure that all nodes and workloads are healthy.
-->
<p>在节点上依次执行上述步骤，确保工作负载有充足的时间被调度到其他节点。</p>
<p>流程完成后，确认所有节点和工作负载均健康如常。</p>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-2e173356df5179cab9eec90a606f0aa4">2.3 - 升级 kubeadm 集群</h1>
    
	<!--
reviewers:
- sig-cluster-lifecycle
title: Upgrading kubeadm clusters
content_type: task
weight: 20
min-kubernetes-server-version: 1.18
-->
<!-- overview -->
<!--
This page explains how to upgrade a Kubernetes cluster created with kubeadm from version
1.21.x to version 1.22.x, and from version
1.22.x to 1.22.y (where `y > x`). Skipping MINOR versions
when upgrading is unsupported.
-->
<p>本页介绍如何将 <code>kubeadm</code> 创建的 Kubernetes 集群从 1.21.x 版本
升级到 1.22.x 版本以及从 1.22.x
升级到 1.22.y（其中 <code>y &gt; x</code>）。略过次版本号的升级是
不被支持的。</p>
<!--
To see information about upgrading clusters created using older versions of kubeadm,
please refer to following pages instead:
-->
<p>要查看 kubeadm 创建的有关旧版本集群升级的信息，请参考以下页面：</p>
<!--
- [Upgrading kubeadm cluster from 1.17 to 1.18](https://v1-18.docs.kubernetes.io/docs/tasks/administer-cluster/kubeadm/kubeadm-upgrade/)
- [Upgrading kubeadm cluster from 1.16 to 1.17](https://v1-17.docs.kubernetes.io/docs/tasks/administer-cluster/kubeadm/kubeadm-upgrade/)
- [Upgrading kubeadm cluster from 1.15 to 1.16](https://v1-16.docs.kubernetes.io/docs/tasks/administer-cluster/kubeadm/kubeadm-upgrade/)
- [Upgrading kubeadm cluster from 1.14 to 1.15](https://v1-15.docs.kubernetes.io/docs/tasks/administer-cluster/kubeadm/kubeadm-upgrade-1-15/)
- [Upgrading kubeadm cluster from 1.13 to 1.14](https://v1-15.docs.kubernetes.io/docs/tasks/administer-cluster/kubeadm/kubeadm-upgrade-1-14/)
-->
<ul>
<li><a href="https://v1-18.docs.kubernetes.io/zh/docs/tasks/administer-cluster/kubeadm/kubeadm-upgrade/">将 kubeadm 集群从 1.17 升级到 1.18</a></li>
<li><a href="https://v1-17.docs.kubernetes.io/zh/docs/tasks/administer-cluster/kubeadm/kubeadm-upgrade/">将 kubeadm 集群从 1.16 升级到 1.17</a></li>
<li><a href="https://v1-16.docs.kubernetes.io/zh/docs/tasks/administer-cluster/kubeadm/kubeadm-upgrade/">将 kubeadm 集群从 1.15 升级到 1.16</a></li>
<li><a href="https://v1-15.docs.kubernetes.io/zh/docs/tasks/administer-cluster/kubeadm/kubeadm-upgrade-1-15/">将 kubeadm 集群从 1.14 升级到 1.15</a></li>
<li><a href="https://v1-15.docs.kubernetes.io/zh/docs/tasks/administer-cluster/kubeadm/kubeadm-upgrade-1-14/">将 kubeadm 集群从 1.13 升级到 1.14</a></li>
</ul>
<!--
The upgrade workflow at high level is the following:

1. Upgrade a primary control plane node.
1. Upgrade additional control plane nodes.
1. Upgrade worker nodes.
-->
<p>升级工作的基本流程如下：</p>
<ol>
<li>升级主控制平面节点</li>
<li>升级其他控制平面节点</li>
<li>升级工作节点</li>
</ol>
<h2 id="准备开始">准备开始</h2>
<!--
- Make sure you read the [release notes](https://git.k8s.io/kubernetes/CHANGELOG/CHANGELOG-1.22.md
) carefully.
- The cluster should use a static control plane and etcd pods or external etcd.
- Make sure to back up any important components, such as app-level state stored in a database.
  `kubeadm upgrade` does not touch your workloads, only components internal to Kubernetes, but backups are always a best practice.
-->
<ul>
<li>务必仔细认真阅读<a href="https://git.k8s.io/kubernetes/CHANGELOG/CHANGELOG-1.22.md
">发行说明</a>。</li>
<li>集群应使用静态的控制平面和 etcd Pod 或者外部 etcd。</li>
<li>务必备份所有重要组件，例如存储在数据库中应用层面的状态。
<code>kubeadm upgrade</code> 不会影响你的工作负载，只会涉及 Kubernetes 内部的组件，但备份终究是好的。</li>
<li><a href="https://serverfault.com/questions/684771/best-way-to-disable-swap-in-linux">必须禁用交换分区</a>。</li>
</ul>
<!--
### Additional information

- [Draining nodes](/docs/tasks/administer-cluster/safely-drain-node/) before kubelet MINOR version
  upgrades is required. In the case of control plane nodes, they could be running CoreDNS Pods or other critical workloads.
- All containers are restarted after upgrade, because the container spec hash value is changed.
-->
<h3 id="附加信息">附加信息</h3>
<ul>
<li>在对 kubelet 作次版本升版时需要<a href="/zh/docs/tasks/administer-cluster/safely-drain-node/">腾空节点</a>。
对于控制面节点，其上可能运行着 CoreDNS Pods 或者其它非常重要的负载。</li>
<li>升级后，因为容器规约的哈希值已更改，所有容器都会被重新启动。</li>
</ul>
<!-- steps -->
<!--
## Determine which version to upgrade to

Find the latest stable 1.22 version using the OS package manager:
-->
<h2 id="确定要升级到哪个版本">确定要升级到哪个版本</h2>
<p>使用操作系统的包管理器找到最新的稳定 1.22：</p>
<ul class="nav nav-tabs" id="k8s-install-versions" role="tablist"><li class="nav-item"><a data-toggle="tab" class="nav-link active" href="#k8s-install-versions-0" role="tab" aria-controls="k8s-install-versions-0" aria-selected="true">Ubuntu、Debian 或 HypriotOS</a></li>
	  
		<li class="nav-item"><a data-toggle="tab" class="nav-link" href="#k8s-install-versions-1" role="tab" aria-controls="k8s-install-versions-1">CentOS、RHEL 或 Fedora</a></li></ul>
<div class="tab-content" id="k8s-install-versions"><div id="k8s-install-versions-0" class="tab-pane show active" role="tabpanel" aria-labelledby="k8s-install-versions-0">

<p><pre tabindex="0"><code>apt update
apt-cache policy kubeadm
# 在列表中查找最新的 1.22 版本
# 它看起来应该是 1.22.x-00，其中 x 是最新的补丁版本
</code></pre></div>
  <div id="k8s-install-versions-1" class="tab-pane" role="tabpanel" aria-labelledby="k8s-install-versions-1">

<p><pre tabindex="0"><code>yum list --showduplicates kubeadm --disableexcludes=kubernetes
# 在列表中查找最新的 1.22 版本
# 它看起来应该是 1.22.x-0，其中 x 是最新的补丁版本
</code></pre></div></div>

<!--
## Upgrade the control plane node

The upgrade procedure on control plane nodes should be executed one node at a time.
Pick a control plane node that you wish to upgrade first. It must have the `/etc/kubernetes/admin.conf` file.

### Call "kubeadm upgrade"
-->
<h2 id="升级控制平面节点">升级控制平面节点</h2>
<p>控制面节点上的升级过程应该每次处理一个节点。
首先选择一个要先行升级的控制面节点。该节点上必须拥有
<code>/etc/kubernetes/admin.conf</code> 文件。</p>
<h3 id="执行-kubeadm-upgrade">执行 &quot;kubeadm upgrade&quot;</h3>
<!--
**Upgrade the first control plane node**
-->
<p><strong>升级第一个控制面节点</strong></p>
<!--
- Upgrade kubeadm:
-->
<ul>
<li>升级 kubeadm：</li>
</ul>
<ul class="nav nav-tabs" id="k8s-install-kubeadm-first-cp" role="tablist"><li class="nav-item"><a data-toggle="tab" class="nav-link active" href="#k8s-install-kubeadm-first-cp-0" role="tab" aria-controls="k8s-install-kubeadm-first-cp-0" aria-selected="true">Ubuntu、Debian 或 HypriotOS</a></li>
	  
		<li class="nav-item"><a data-toggle="tab" class="nav-link" href="#k8s-install-kubeadm-first-cp-1" role="tab" aria-controls="k8s-install-kubeadm-first-cp-1">CentOS、RHEL 或 Fedora</a></li></ul>
<div class="tab-content" id="k8s-install-kubeadm-first-cp"><div id="k8s-install-kubeadm-first-cp-0" class="tab-pane show active" role="tabpanel" aria-labelledby="k8s-install-kubeadm-first-cp-0">

<p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="color:#080;font-style:italic"># 用最新的补丁版本号替换 1.22.x-00 中的 x</span>
apt-mark unhold kubeadm <span style="color:#666">&amp;&amp;</span> <span style="color:#b62;font-weight:bold">\
</span><span style="color:#b62;font-weight:bold"></span>apt-get update <span style="color:#666">&amp;&amp;</span> apt-get install -y <span style="color:#b8860b">kubeadm</span><span style="color:#666">=</span>1.22.x-00 <span style="color:#666">&amp;&amp;</span> <span style="color:#b62;font-weight:bold">\
</span><span style="color:#b62;font-weight:bold"></span>apt-mark hold kubeadm
-
<span style="color:#080;font-style:italic"># 从 apt-get 1.1 版本起，你也可以使用下面的方法</span>
apt-get update <span style="color:#666">&amp;&amp;</span> <span style="color:#b62;font-weight:bold">\
</span><span style="color:#b62;font-weight:bold"></span>apt-get install -y --allow-change-held-packages <span style="color:#b8860b">kubeadm</span><span style="color:#666">=</span>1.22.x-00
</code></pre></div></div>
  <div id="k8s-install-kubeadm-first-cp-1" class="tab-pane" role="tabpanel" aria-labelledby="k8s-install-kubeadm-first-cp-1">

<p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="color:#080;font-style:italic"># 用最新的补丁版本号替换 1.22.x-0 中的 x</span>
yum install -y kubeadm-1.22.x-0 --disableexcludes<span style="color:#666">=</span>kubernetes
</code></pre></div></div></div>

<!--
- Verify that the download works and has the expected version:
-->
<ul>
<li>
<p>验证下载操作正常，并且 kubeadm 版本正确：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubeadm version
</code></pre></div></li>
</ul>
<!--
- Verify the upgrade plan:
-->
<ul>
<li>
<p>验证升级计划：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubeadm upgrade plan
</code></pre></div><!--
This command checks that your cluster can be upgraded, and fetches the versions you can upgrade to.
It also shows a table with the component config version states.
-->
<p>此命令检查你的集群是否可被升级，并取回你要升级的目标版本。
命令也会显示一个包含组件配置版本状态的表格。</p>
<blockquote class="note callout">
  <div><strong>说明：</strong> <!--
  `kubeadm upgrade` also automatically renews the certificates that it manages on this node.
  To opt-out of certificate renewal the flag `--certificate-renewal=false` can be used.
  For more information see the [certificate management guide](/docs/tasks/administer-cluster/kubeadm/kubeadm-certs).
  -->
<p><code>kubeadm upgrade</code> 也会自动对 kubeadm 在节点上所管理的证书执行续约操作。
如果需要略过证书续约操作，可以使用标志 <code>--certificate-renewal=false</code>。
更多的信息，可参阅<a href="/zh/docs/tasks/administer-cluster/kubeadm/kubeadm-certs">证书管理指南</a>。</div>
</blockquote>
<blockquote class="note callout">
  <div><strong>说明：</strong> <!--
  If `kubeadm upgrade plan` shows any component configs that require manual upgrade, users must provide
  a config file with replacement configs to `kubeadm upgrade apply` via the `--config` command line flag.
  Failing to do so will cause `kubeadm upgrade apply` to exit with an error and not perform an upgrade.
  -->
<p>如果 <code>kubeadm upgrade plan</code> 给出任何需要手动升级的组件配置，用户必须
通过 <code>--config</code> 命令行标志向 <code>kubeadm upgrade apply</code> 命令提供替代的配置文件。
如果不这样做，<code>kubeadm upgrade apply</code> 会出错并退出，不再执行升级操作。</div>
</blockquote>
</li>
</ul>
<!--
- Choose a version to upgrade to, and run the appropriate command. For example:

  ```shell
  # replace x with the patch version you picked for this upgrade
  sudo kubeadm upgrade apply v1.22.x
  ```
-->
<p>选择要升级到的目标版本，运行合适的命令。例如：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="color:#080;font-style:italic"># 将 x 替换为你为此次升级所选择的补丁版本号</span>
sudo kubeadm upgrade apply v1.22.x
</code></pre></div>  <!--
  Once the command finishes you should see:
  -->
<p>一旦该命令结束，你应该会看到：</p>
<pre tabindex="0"><code>[upgrade/successful] SUCCESS! Your cluster was upgraded to &quot;v1.22.x&quot;. Enjoy!

[upgrade/kubelet] Now that your control plane is upgraded, please proceed with upgrading your kubelets if you haven't already done so.
</code></pre><!--
- Manually upgrade your CNI provider plugin.

  Your Container Network Interface (CNI) provider may have its own upgrade instructions to follow.
  Check the [addons](/docs/concepts/cluster-administration/addons/) page to
  find your CNI provider and see whether additional upgrade steps are required.

  This step is not required on additional control plane nodes if the CNI provider runs as a DaemonSet.
-->
<ul>
<li>
<p>手动升级你的 CNI 驱动插件。</p>
<p>你的容器网络接口（CNI）驱动应该提供了程序自身的升级说明。
参阅<a href="/zh/docs/concepts/cluster-administration/addons/">插件</a>页面查找你的 CNI 驱动，
并查看是否需要其他升级步骤。</p>
<p>如果 CNI 驱动作为 DaemonSet 运行，则在其他控制平面节点上不需要此步骤。</p>
</li>
</ul>
<!--
**For the other control plane nodes**
-->
<p><strong>对于其它控制面节点</strong></p>
<!--
Same as the first control plane node but use:
-->
<p>与第一个控制面节点相同，但是使用：</p>
<pre tabindex="0"><code>sudo kubeadm upgrade node
</code></pre><!--
instead of:
-->
<p>而不是：</p>
<pre tabindex="0"><code>sudo kubeadm upgrade apply
</code></pre><!--
Also calling `kubeadm upgrade plan` and upgrading the CNI provider plugin is no longer needed.
-->
<p>此外，不需要执行 <code>kubeadm upgrade plan</code> 和更新 CNI 驱动插件的操作。</p>
<!--
### Drain the node

-  Prepare the node for maintenance by marking it unschedulable and evicting the workloads:

    ```shell
    # replace <node-to-drain> with the name of your node you are draining
    kubectl drain <node-to-drain> --ignore-daemonsets
    ```
-->
<h3 id="腾空节点">腾空节点</h3>
<ul>
<li>
<p>通过将节点标记为不可调度并腾空节点为节点作升级准备：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="color:#080;font-style:italic"># 将 &lt;node-to-drain&gt; 替换为你要腾空的控制面节点名称</span>
kubectl drain &lt;node-to-drain&gt; --ignore-daemonsets
</code></pre></div></li>
</ul>
<!--
### Upgrade kubelet and kubectl

-  Upgrade the kubelet and kubectl
-->
<h3 id="升级-kubelet-和-kubectl">升级 kubelet 和 kubectl</h3>
<ul>
<li>
<p>升级 kubelet 和 kubectl</p>
<ul class="nav nav-tabs" id="k8s-install-kubelet" role="tablist"><li class="nav-item"><a data-toggle="tab" class="nav-link active" href="#k8s-install-kubelet-0" role="tab" aria-controls="k8s-install-kubelet-0" aria-selected="true">Ubuntu、Debian 或 HypriotOS</a></li>
	  
		<li class="nav-item"><a data-toggle="tab" class="nav-link" href="#k8s-install-kubelet-1" role="tab" aria-controls="k8s-install-kubelet-1">CentOS、RHEL 或 Fedora</a></li></ul>
<div class="tab-content" id="k8s-install-kubelet"><div id="k8s-install-kubelet-0" class="tab-pane show active" role="tabpanel" aria-labelledby="k8s-install-kubelet-0">

<p>  <pre>
  # 用最新的补丁版本替换 1.22.x-00 中的 x
  apt-mark unhold kubelet kubectl && \
  apt-get update && apt-get install -y kubelet=1.22.x-00 kubectl=1.22.x-00 && \
  apt-mark hold kubelet kubectl
  - 
  # 从 apt-get 的 1.1 版本开始，你也可以使用下面的方法：
  apt-get update && \
  apt-get install -y --allow-change-held-packages kubelet=1.22.x-00 kubectl=1.22.x-00
  </pre>
</div>
  <div id="k8s-install-kubelet-1" class="tab-pane" role="tabpanel" aria-labelledby="k8s-install-kubelet-1">

<p>  <pre> 
  # 用最新的补丁版本号替换 1.22.x-00 中的 x
  yum install -y kubelet-1.22.x-0 kubectl-1.22.x-0 --disableexcludes=kubernetes
  </pre>
</div></div>

</li>
</ul>
<!--
- Restart the kubelet
-->
<ul>
<li>
<p>重启 kubelet</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">sudo systemctl daemon-reload
sudo systemctl restart kubelet
</code></pre></div></li>
</ul>
<!--
### Uncordon the node

- Bring the node back online by marking it schedulable:

  ```shell
  # replace <node-to-drain> with the name of your node
  kubectl uncordon <node-to-drain>

-->
<h3 id="解除节点的保护">解除节点的保护</h3>
<ul>
<li>
<p>通过将节点标记为可调度，让其重新上线：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="color:#080;font-style:italic"># 将 &lt;node-to-drain&gt; 替换为你的节点名称</span>
kubectl uncordon &lt;node-to-drain&gt;
</code></pre></div></li>
</ul>
<!--
## Upgrade worker nodes

The upgrade procedure on worker nodes should be executed one node at a time or few nodes at a time,
without compromising the minimum required capacity for running your workloads.
-->
<h2 id="升级工作节点">升级工作节点</h2>
<p>工作节点上的升级过程应该一次执行一个节点，或者一次执行几个节点，
以不影响运行工作负载所需的最小容量。</p>
<!--
### Upgrade kubeadm
-->
<h3 id="升级-kubeadm">升级 kubeadm</h3>
<!--
- Upgrade kubeadm:
-->
<ul>
<li>
<p>升级 kubeadm：</p>
<ul class="nav nav-tabs" id="k8s-install-kubeadm-worker-nodes" role="tablist"><li class="nav-item"><a data-toggle="tab" class="nav-link active" href="#k8s-install-kubeadm-worker-nodes-0" role="tab" aria-controls="k8s-install-kubeadm-worker-nodes-0" aria-selected="true">Ubuntu、Debian 或 HypriotOS</a></li>
	  
		<li class="nav-item"><a data-toggle="tab" class="nav-link" href="#k8s-install-kubeadm-worker-nodes-1" role="tab" aria-controls="k8s-install-kubeadm-worker-nodes-1">CentOS、RHEL 或 Fedora</a></li></ul>
<div class="tab-content" id="k8s-install-kubeadm-worker-nodes"><div id="k8s-install-kubeadm-worker-nodes-0" class="tab-pane show active" role="tabpanel" aria-labelledby="k8s-install-kubeadm-worker-nodes-0">

<p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="color:#080;font-style:italic"># 将 1.22.x-00 中的 x 替换为最新的补丁版本号</span>
apt-mark unhold kubeadm <span style="color:#666">&amp;&amp;</span> <span style="color:#b62;font-weight:bold">\
</span><span style="color:#b62;font-weight:bold"></span>apt-get update <span style="color:#666">&amp;&amp;</span> apt-get install -y <span style="color:#b8860b">kubeadm</span><span style="color:#666">=</span>1.22.x-00 <span style="color:#666">&amp;&amp;</span> <span style="color:#b62;font-weight:bold">\
</span><span style="color:#b62;font-weight:bold"></span>apt-mark hold kubeadm
- 
<span style="color:#080;font-style:italic"># 从 apt-get 的 1.1 版本开始，你也可以使用下面的方法：</span>
apt-get update <span style="color:#666">&amp;&amp;</span> <span style="color:#b62;font-weight:bold">\
</span><span style="color:#b62;font-weight:bold"></span>apt-get install -y --allow-change-held-packages <span style="color:#b8860b">kubeadm</span><span style="color:#666">=</span>1.22.x-00
</code></pre></div></div>
  <div id="k8s-install-kubeadm-worker-nodes-1" class="tab-pane" role="tabpanel" aria-labelledby="k8s-install-kubeadm-worker-nodes-1">

<p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="color:#080;font-style:italic"># 用最新的补丁版本替换 1.22.x-00 中的 x</span>
yum install -y kubeadm-1.22.x-0 --disableexcludes<span style="color:#666">=</span>kubernetes
</code></pre></div></div></div>

</li>
</ul>
<!--
### Call "kubeadm upgrade"

-  For worker nodes this upgrades the local kubelet configuration:
-->
<h3 id="执行-kubeadm-upgrade-1">执行 &quot;kubeadm upgrade&quot;</h3>
<ul>
<li>
<p>对于工作节点，下面的命令会升级本地的 kubelet 配置：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">sudo kubeadm upgrade node
</code></pre></div></li>
</ul>
<!--
### Drain the node

- Prepare the node for maintenance by marking it unschedulable and evicting the workloads:

  ```shell
  # replace <node-to-drain> with the name of your node you are draining
  kubectl drain <node-to-drain> --ignore-daemonsets
  ```
-->
<h3 id="腾空节点-1">腾空节点</h3>
<ul>
<li>
<p>将节点标记为不可调度并驱逐所有负载，准备节点的维护：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="color:#080;font-style:italic"># 将 &lt;node-to-drain&gt; 替换为你正在腾空的节点的名称</span>
kubectl drain &lt;node-to-drain&gt; --ignore-daemonsets
</code></pre></div></li>
</ul>
<!--
### Upgrade kubelet and kubectl
-->
<h3 id="升级-kubelet-和-kubectl-1">升级 kubelet 和 kubectl</h3>
<!--
-  Upgrade the kubelet and kubectl:
-->
<ul>
<li>
<p>升级 kubelet 和 kubectl：</p>
<ul class="nav nav-tabs" id="k8s-kubelet-and-kubectl" role="tablist"><li class="nav-item"><a data-toggle="tab" class="nav-link active" href="#k8s-kubelet-and-kubectl-0" role="tab" aria-controls="k8s-kubelet-and-kubectl-0" aria-selected="true">Ubuntu、Debian 或 HypriotOS</a></li>
	  
		<li class="nav-item"><a data-toggle="tab" class="nav-link" href="#k8s-kubelet-and-kubectl-1" role="tab" aria-controls="k8s-kubelet-and-kubectl-1">CentOS, RHEL or Fedora</a></li></ul>
<div class="tab-content" id="k8s-kubelet-and-kubectl"><div id="k8s-kubelet-and-kubectl-0" class="tab-pane show active" role="tabpanel" aria-labelledby="k8s-kubelet-and-kubectl-0">

<p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="color:#080;font-style:italic"># 将 1.22.x-00 中的 x 替换为最新的补丁版本</span>
apt-mark unhold kubelet kubectl <span style="color:#666">&amp;&amp;</span> <span style="color:#b62;font-weight:bold">\
</span><span style="color:#b62;font-weight:bold"></span>apt-get update <span style="color:#666">&amp;&amp;</span> apt-get install -y <span style="color:#b8860b">kubelet</span><span style="color:#666">=</span>1.22.x-00 <span style="color:#b8860b">kubectl</span><span style="color:#666">=</span>1.22.x-00 <span style="color:#666">&amp;&amp;</span> <span style="color:#b62;font-weight:bold">\
</span><span style="color:#b62;font-weight:bold"></span>apt-mark hold kubelet kubectl

<span style="color:#080;font-style:italic"># 从 apt-get 的 1.1 版本开始，你也可以使用下面的方法：</span>

apt-get update <span style="color:#666">&amp;&amp;</span> <span style="color:#b62;font-weight:bold">\
</span><span style="color:#b62;font-weight:bold"></span>apt-get install -y --allow-change-held-packages <span style="color:#b8860b">kubelet</span><span style="color:#666">=</span>1.22.x-00 <span style="color:#b8860b">kubectl</span><span style="color:#666">=</span>1.22.x-00
</code></pre></div></div>
  <div id="k8s-kubelet-and-kubectl-1" class="tab-pane" role="tabpanel" aria-labelledby="k8s-kubelet-and-kubectl-1">

<p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="color:#080;font-style:italic"># 将 1.22.x-0 x 替换为最新的补丁版本</span>
yum install -y kubelet-1.22.x-0 kubectl-1.22.x-0 --disableexcludes<span style="color:#666">=</span>kubernetes
</code></pre></div></div></div>

</li>
</ul>
<!--
- Restart the kubelet

    ```shell
    sudo systemctl daemon-reload
    sudo systemctl restart kubelet
    ```
-->
<ul>
<li>
<p>重启 kubelet</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">sudo systemctl daemon-reload
sudo systemctl restart kubelet
</code></pre></div></li>
</ul>
<!--
### Uncordon the node
-->
<h3 id="取消对节点的保护">取消对节点的保护</h3>
<!--
-  Bring the node back online by marking it schedulable:

    ```shell
    # replace <node-to-drain> with the name of your node
    kubectl uncordon <node-to-drain>
    ```
-->
<ul>
<li>
<p>通过将节点标记为可调度，让节点重新上线:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="color:#080;font-style:italic"># 将 &lt;node-to-drain&gt; 替换为当前节点的名称</span>
kubectl uncordon &lt;node-to-drain&gt;
</code></pre></div></li>
</ul>
<!--
## Verify the status of the cluster

After the kubelet is upgraded on all nodes verify that all nodes are available again by running the following command
from anywhere kubectl can access the cluster:

```shell
kubectl get nodes
```
-->
<h2 id="验证集群的状态">验证集群的状态</h2>
<p>在所有节点上升级 kubelet 后，通过从 kubectl 可以访问集群的任何位置运行以下命令，
验证所有节点是否再次可用：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl get nodes
</code></pre></div><!--
The `STATUS` column should show `Ready` for all your nodes, and the version number should be updated.
-->
<p><code>STATUS</code> 应显示所有节点为 <code>Ready</code> 状态，并且版本号已经被更新。</p>
<!--
## Recovering from a failure state

If `kubeadm upgrade` fails and does not roll back, for example because of an unexpected shutdown during execution, you can run `kubeadm upgrade` again.
This command is idempotent and eventually makes sure that the actual state is the desired state you declare.

To recover from a bad state, you can also run `kubeadm upgrade--force` without changing the version that your cluster is running.
-->
<h2 id="从故障状态恢复">从故障状态恢复</h2>
<p>如果 <code>kubeadm upgrade</code> 失败并且没有回滚，例如由于执行期间节点意外关闭，
你可以再次运行 <code>kubeadm upgrade</code>。
此命令是幂等的，并最终确保实际状态是你声明的期望状态。
要从故障状态恢复，你还可以运行 <code>kubeadm upgrade --force</code> 而无需更改集群正在运行的版本。</p>
<!--
During upgrade kubeadm writes the following backup folders under `/etc/kubernetes/tmp`:
- `kubeadm-backup-etcd-<date>-<time>`
- `kubeadm-backup-manifests-<date>-<time>`

`kubeadm-backup-etcd` contains a backup of the local etcd member data for this control-plane Node.
In case of an etcd upgrade failure and if the automatic rollback does not work, the contents of this folder
can be manually restored in `/var/lib/etcd`. In case external etcd is used this backup folder will be empty.

`kubeadm-backup-manifests` contains a backup of the static Pod manifest files for this control-plane Node.
In case of a upgrade failure and if the automatic rollback does not work, the contents of this folder can be
manually restored in `/etc/kubernetes/manifests`. If for some reason there is no difference between a pre-upgrade
and post-upgrade manifest file for a certain component, a backup file for it will not be written.
-->
<p>在升级期间，kubeadm 向 <code>/etc/kubernetes/tmp</code> 目录下的如下备份文件夹写入数据：</p>
<ul>
<li><code>kubeadm-backup-etcd-&lt;date&gt;-&lt;time&gt;</code></li>
<li><code>kubeadm-backup-manifests-&lt;date&gt;-&lt;time&gt;</code></li>
</ul>
<p><code>kubeadm-backup-etcd</code> 包含当前控制面节点本地 etcd 成员数据的备份。
如果 etcd 升级失败并且自动回滚也无法修复，则可以将此文件夹中的内容复制到
<code>/var/lib/etcd</code> 进行手工修复。如果使用的是外部的 etcd，则此备份文件夹为空。</p>
<p><code>kubeadm-backup-manifests</code> 包含当前控制面节点的静态 Pod 清单文件的备份版本。
如果升级失败并且无法自动回滚，则此文件夹中的内容可以复制到
<code>/etc/kubernetes/manifests</code> 目录实现手工恢复。
如果由于某些原因，在升级前后某个组件的清单未发生变化，则 kubeadm 也不会为之
生成备份版本。</p>
<!--
## How it works

`kubeadm upgrade apply` does the following:

- Checks that your cluster is in an upgradeable state:
  - The API server is reachable
  - All nodes are in the `Ready` state
  - The control plane is healthy
- Enforces the version skew policies.
- Makes sure the control plane images are available or available to pull to the machine.
- Generates replacements and/or uses user supplied overwrites if component configs require version upgrades.
- Upgrades the control plane components or rollbacks if any of them fails to come up.
- Applies the new `CoreDNS` and `kube-proxy` manifests and makes sure that all necessary RBAC rules are created.
- Creates new certificate and key files of the API server and backs up old files if they're about to expire in 180 days.
-->
<h2 id="how-it-works">工作原理  </h2>
<p><code>kubeadm upgrade apply</code> 做了以下工作：</p>
<ul>
<li>检查你的集群是否处于可升级状态:
<ul>
<li>API 服务器是可访问的</li>
<li>所有节点处于 <code>Ready</code> 状态</li>
<li>控制面是健康的</li>
</ul>
</li>
<li>强制执行版本偏差策略。</li>
<li>确保控制面的镜像是可用的或可拉取到服务器上。</li>
<li>如果组件配置要求版本升级，则生成替代配置与/或使用用户提供的覆盖版本配置。</li>
<li>升级控制面组件或回滚（如果其中任何一个组件无法启动）。</li>
<li>应用新的 <code>CoreDNS</code> 和 <code>kube-proxy</code> 清单，并强制创建所有必需的 RBAC 规则。</li>
<li>如果旧文件在 180 天后过期，将创建 API 服务器的新证书和密钥文件并备份旧文件。</li>
</ul>
<!--
`kubeadm upgrade node` does the following on additional control plane nodes:

- Fetches the kubeadm `ClusterConfiguration` from the cluster.
- Optionally backups the kube-apiserver certificate.
- Upgrades the static Pod manifests for the control plane components.
- Upgrades the kubelet configuration for this node.
-->
<p><code>kubeadm upgrade node</code> 在其他控制平节点上执行以下操作：</p>
<ul>
<li>从集群中获取 kubeadm <code>ClusterConfiguration</code>。</li>
<li>（可选操作）备份 kube-apiserver 证书。</li>
<li>升级控制平面组件的静态 Pod 清单。</li>
<li>为本节点升级 kubelet 配置</li>
</ul>
<!--
`kubeadm upgrade node` does the following on worker nodes:

- Fetches the kubeadm `ClusterConfiguration` from the cluster.
- Upgrades the kubelet configuration for this node.
-->
<p><code>kubeadm upgrade node</code> 在工作节点上完成以下工作：</p>
<ul>
<li>从集群取回 kubeadm <code>ClusterConfiguration</code>。</li>
<li>为本节点升级 kubelet 配置。</li>
</ul>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-9133578f1e75663bb031e5a377ca896d">2.4 - 添加 Windows 节点</h1>
    
	<!--
reviewers:
- michmike
- patricklang
title: Adding Windows nodes
min-kubernetes-server-version: 1.17
content_type: tutorial
weight: 30
-->
<!-- overview -->





<div style="margin-top: 10px; margin-bottom: 10px;">
<b>FEATURE STATE:</b> <code>Kubernetes v1.18 [beta]</code>
</div>

<!--
You can use Kubernetes to run a mixture of Linux and Windows nodes, so you can mix Pods that run on Linux on with Pods that run on Windows. This page shows how to register Windows nodes to your cluster.
-->
<p>你可以使用 Kubernetes 来混合运行 Linux 和 Windows 节点，这样你就可以
混合使用运行于 Linux 上的 Pod 和运行于 Windows 上的 Pod。
本页面展示如何将 Windows 节点注册到你的集群。</p>
<h2 id="准备开始">准备开始</h2>


您的 Kubernetes 服务器版本必须不低于版本 1.17.
 要获知版本信息，请输入 <code>kubectl version</code>.

<!--
* Obtain a [Windows Server 2019 license](https://www.microsoft.com/en-us/cloud-platform/windows-server-pricing)
(or higher) in order to configure the Windows node that hosts Windows containers.
If you are using VXLAN/Overlay networking you must have also have [KB4489899](https://support.microsoft.com/help/4489899) installed.

* A Linux-based Kubernetes kubeadm cluster in which you have access to the control plane (see [Creating a single control-plane cluster with kubeadm](/docs/setup/production-environment/tools/kubeadm/create-cluster-kubeadm/)).
-->
<ul>
<li>
<p>获取 <a href="https://www.microsoft.com/en-us/cloud-platform/windows-server-pricing">Windows Server 2019 或更高版本的授权</a>
以便配置托管 Windows 容器的 Windows 节点。
如果你在使用 VXLAN/覆盖（Overlay）联网设施，则你还必须安装 <a href="https://support.microsoft.com/help/4489899">KB4489899</a>。</p>
</li>
<li>
<p>一个利用 kubeadm 创建的基于 Linux 的 Kubernetes 集群；你能访问该集群的控制面
（参见<a href="/zh/docs/setup/production-environment/tools/kubeadm/create-cluster-kubeadm/">使用 kubeadm 创建一个单控制面的集群</a>)。</p>
</li>
</ul>
<h2 id="教程目标">教程目标</h2>
<!--
* Register a Windows node to the cluster
* Configure networking so Pods and Services on Linux and Windows can communicate with each other
-->
<ul>
<li>将一个 Windows 节点注册到集群上</li>
<li>配置网络，以便 Linux 和 Windows 上的 Pod 和 Service 之间能够相互通信。</li>
</ul>
<!-- lessoncontent -->
<!--
## Getting Started: Adding a Windows Node to Your Cluster

### Networking Configuration

Once you have a Linux-based Kubernetes control-plane node you are ready to choose a networking solution. This guide illustrates using Flannel in VXLAN mode for simplicity.
-->
<h2 id="开始行动-向你的集群添加一个-windows-节点">开始行动：向你的集群添加一个 Windows 节点</h2>
<h3 id="networking-configuration">联网配置  </h3>
<p>一旦你有了一个基于 Linux 的 Kubernetes 控制面节点，你就可以为其选择联网方案。
出于简单考虑，本指南展示如何使用 VXLAN 模式的 Flannel。</p>
<!--
#### Configuring Flannel

1. Prepare Kubernetes control plane for Flannel

    Some minor preparation is recommended on the Kubernetes control plane in our cluster. It is recommended to enable bridged IPv4 traffic to iptables chains when using Flannel. The following command must be run on all Linux nodes:

    ```bash
    sudo sysctl net.bridge.bridge-nf-call-iptables=1
    ```
-->
<h4 id="configuring-flannel">配置 Flannel </h4>
<ol>
<li>
<p>为 Flannel 准备 Kubernetes 的控制面</p>
<p>在我们的集群中，建议对 Kubernetes 的控制面进行少许准备处理。
建议在使用 Flannel 时为 iptables 链启用桥接方式的 IPv4 流处理，
必须在所有 Linux 节点上执行如下命令：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">sudo sysctl net.bridge.bridge-nf-call-iptables<span style="color:#666">=</span><span style="color:#666">1</span>
</code></pre></div></li>
</ol>
<!--
1. Download & configure Flannel for Linux

    Download the most recent Flannel manifest:

    ```bash
    wget https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml
    ```

    Modify the `net-conf.json` section of the flannel manifest in order to set the VNI to 4096 and the Port to 4789. It should look as follows:

    ```json
    net-conf.json: |
        {
          "Network": "10.244.0.0/16",
          "Backend": {
            "Type": "vxlan",
            "VNI": 4096,
            "Port": 4789
          }
        }
    ```

    The VNI must be set to 4096 and port 4789 for Flannel on Linux to interoperate with Flannel on Windows. See the [VXLAN documentation](https://github.com/coreos/flannel/blob/master/Documentation/backends.md#vxlan).
    for an explanation of these fields.

    To use L2Bridge/Host-gateway mode instead change the value of `Type` to `"host-gw"` and omit `VNI` and `Port`.
-->
<ol start="2">
<li>
<p>下载并配置 Linux 版本的 Flannel</p>
<p>下载最新的 Flannel 清单文件：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">wget https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml
</code></pre></div><p>修改 Flannel 清单中的 <code>net-conf.json</code> 部分，将 VNI 设置为 4096，并将 Port 设置为 4789。
结果看起来像下面这样：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-json" data-lang="json"><span style="">net-conf.json:</span> <span style="">|</span>
    {
      <span style="color:#008000;font-weight:bold">&#34;Network&#34;</span>: <span style="color:#b44">&#34;10.244.0.0/16&#34;</span>,
      <span style="color:#008000;font-weight:bold">&#34;Backend&#34;</span>: {
         <span style="color:#008000;font-weight:bold">&#34;Type&#34;</span>: <span style="color:#b44">&#34;vxlan&#34;</span>,
         <span style="color:#008000;font-weight:bold">&#34;VNI&#34;</span>: <span style="color:#666">4096</span>,
         <span style="color:#008000;font-weight:bold">&#34;Port&#34;</span>: <span style="color:#666">4789</span>
    }
}
</code></pre></div><blockquote class="note callout">
  <div><strong>说明：</strong> 在 Linux 节点上 VNI 必须设置为 4096，端口必须设置为 4789，这样才能令其与 Windows 上的
Flannel 互操作。关于这些字段的详细说明，请参见
<a href="https://github.com/coreos/flannel/blob/master/Documentation/backends.md#vxlan">VXLAN 文档</a>。</div>
</blockquote>
<blockquote class="note callout">
  <div><strong>说明：</strong> 如要使用 L2Bridge/Host-gateway 模式，则可将 <code>Type</code> 值设置为
<code>&quot;host-gw&quot;</code>，并忽略 <code>VNI</code> 和 <code>Port</code> 的设置。</div>
</blockquote>
</li>
</ol>
<!--
1. Apply the Flannel manifest and validate

    Let's apply the Flannel configuration:

    ```bash
    kubectl apply -f kube-flannel.yml
    ```

    After a few minutes, you should see all the pods as running if the Flannel pod network was deployed.

    ```bash
    kubectl get pods -n kube-system
    ```

    The output should include the Linux flannel DaemonSet as running:

    ```
    NAMESPACE     NAME                                      READY        STATUS    RESTARTS   AGE
    ...
    kube-system   kube-flannel-ds-54954                     1/1          Running   0          1m
    ```
-->
<ol start="3">
<li>
<p>应用 Flannel 清单并验证</p>
<p>首先应用 Flannel 配置：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">kubectl apply -f kube-flannel.yml
</code></pre></div><p>几分钟之后，如果 Flannel Pod 网络被正确部署，你应该会看到所有 Pods 都处于运行中状态。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">kubectl get pods -n kube-system
</code></pre></div><p>输出中应该包含处于运行中状态的 Linux Flannel DaemonSet：</p>
<pre tabindex="0"><code>NAMESPACE     NAME                                      READY        STATUS    RESTARTS   AGE
...
kube-system   kube-flannel-ds-54954                     1/1          Running   0          1m
</code></pre></li>
</ol>
<!--
1. Add Windows Flannel and kube-proxy DaemonSets

    Now you can add Windows-compatible versions of Flannel and kube-proxy. In order
    to ensure that you get a compatible version of kube-proxy, you'll need to substitute
    the tag of the image. The following example shows usage for Kubernetes v1.22.0,
    but you should adjust the version for your own deployment.

    ```bash
    curl -L https://github.com/kubernetes-sigs/sig-windows-tools/releases/latest/download/kube-proxy.yml | sed 's/VERSION/v1.22.0/g' | kubectl apply -f -
    kubectl apply -f https://github.com/kubernetes-sigs/sig-windows-tools/releases/latest/download/flannel-overlay.yml
    ```

    If you're using host-gateway use https://github.com/kubernetes-sigs/sig-windows-tools/releases/latest/download/flannel-host-gw.yml instead

If you're using a different interface rather than Ethernet (i.e. "Ethernet0 2") on the Windows nodes, you have to modify the line:

```powershell
wins cli process run --path /k/flannel/setup.exe --args "--mode=overlay --interface=Ethernet"
```

in the `flannel-host-gw.yml` or `flannel-overlay.yml` file and specify your interface accordingly.

```bash
# Example
curl -L https://github.com/kubernetes-sigs/sig-windows-tools/releases/latest/download/flannel-overlay.yml | sed 's/Ethernet/Ethernet0 2/g' | kubectl apply -f -
```
-->    
<ol start="4">
<li>
<p>添加 Windows Flannel 和 kube-proxy DaemonSet</p>
<p>现在你可以添加 Windows 兼容版本的 Flannel 和 kube-proxy。为了确保你能获得兼容
版本的 kube-proxy，你需要替换镜像中的标签。
下面的例子中展示的是针对 Kubernetes v1.22.0 版本的用法，
不过你应该根据你自己的集群部署调整其中的版本号。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">curl -L https://github.com/kubernetes-sigs/sig-windows-tools/releases/latest/download/kube-proxy.yml | sed <span style="color:#b44">&#39;s/VERSION/v1.22.0/g&#39;</span> | kubectl apply -f -
kubectl apply -f https://github.com/kubernetes-sigs/sig-windows-tools/releases/latest/download/flannel-overlay.yml
</code></pre></div><blockquote class="note callout">
  <div><strong>说明：</strong> 如果你在使用 host-gateway 模式，则应该使用
<a href="https://github.com/kubernetes-sigs/sig-windows-tools/releases/latest/download/flannel-host-gw.yml">https://github.com/kubernetes-sigs/sig-windows-tools/releases/latest/download/flannel-host-gw.yml</a>
这一清单。</div>
</blockquote>
<blockquote class="note callout">
  <div><strong>说明：</strong> <p>如果你在 Windows 节点上使用的不是以太网（即，&quot;Ethernet0 2&quot;）接口，你需要
修改 <code>flannel-host-gw.yml</code> 或 <code>flannel-overlay.yml</code> 文件中的下面这行：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-powershell" data-lang="powershell">wins <span style="color:#a2f">cli </span><span style="color:#a2f;font-weight:bold">process</span> run --path /k/flannel/setup.exe --args <span style="color:#b44">&#34;--mode=overlay --interface=Ethernet&#34;</span>
</code></pre></div><p>在其中根据情况设置要使用的网络接口。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#080;font-style:italic"># Example</span>
curl -L https://github.com/kubernetes-sigs/sig-windows-tools/releases/latest/download/flannel-overlay.yml | sed <span style="color:#b44">&#39;s/Ethernet/Ethernet0 2/g&#39;</span> | kubectl apply -f -
</code></pre></div></div>
</blockquote>
</li>
</ol>
<!--
### Joining a Windows worker node

You must install the `Containers` feature and install Docker. Instructions
to do so are available at [Install Docker Engine - Enterprise on Windows Servers](https://docs.mirantis.com/docker-enterprise/v3.1/dockeree-products/docker-engine-enterprise/dee-windows.html).

All code snippets in Windows sections are to be run in a PowerShell environment
with elevated permissions (Administrator) on the Windows worker node.
-->
<h3 id="joining-a-windows-worker-node">加入 Windows 工作节点  </h3>
<p>你必须安装 <code>Containers</code> 功能特性并安装 Docker 工具。相关的指令可以在
<a href="https://hub.docker.com/editions/enterprise/docker-ee-server-windows">Install Docker Engine - Enterprise on Windows Servers</a>
处找到。</p>
<p>Windows 节的所有代码片段都需要在 PowerShell 环境中执行，并且要求在
Windows 工作节点上具有提升的权限（Administrator）。</p>
<!--
1. Install wins, kubelet, and kubeadm.
-->
<ol>
<li>
<p>安装 wins、kubelet 和 kubeadm</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-PowerShell" data-lang="PowerShell">curl.exe -LO https<span style="">:</span>//github.com/<span style="color:#a2f">kubernetes-sigs</span>/<span style="color:#a2f">sig-windows</span>-tools/releases/latest/download/PrepareNode.ps1
.\PrepareNode.ps1 -KubernetesVersion <span style="color:#a2f">
</code></pre></div></li>
</ol>
<!--
1. Run `kubeadm` to join the node

    Use the command that was given to you when you ran `kubeadm init` on a control plane host.
    If you no longer have this command, or the token has expired, you can run `kubeadm token create -print-join-command`
    (on a control plane host) to generate a new token and join command.
-->
<ol start="2">
<li>
<p>运行 <code>kubeadm</code> 添加节点</p>
<p>当你在控制面主机上运行 <code>kubeadm init</code> 时，输出了一个命令。现在运行这个命令。
如果你找不到这个命令，或者命令中对应的令牌已经过期，你可以（在一个控制面主机上）运行
<code>kubeadm token create --print-join-command</code> 来生成新的令牌和 join 命令。</p>
</li>
</ol>
<!--
#### Verifying your installation

You should now be able to view the Windows node in your cluster by running:
-->
<h4 id="verifying-your-installation">检查你的安装  </h4>
<p>你现在应该能够通过运行下面的命令来查看集群中的 Windows 节点了：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">kubectl get nodes -o wide
</code></pre></div><!--
If your new node is in the `NotReady` state it is likely because the flannel image is still downloading.
You can check the progress as before by checking on the flannel pods in the `kube-system` namespace:
-->
<p>如果你的新节点处于 <code>NotReady</code> 状态，很可能的原因是系统仍在下载 Flannel 镜像。
你可以像之前一样，通过检查 <code>kube-system</code> 名字空间中的 Flannel Pods 来了解
安装进度。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl -n kube-system get pods -l <span style="color:#b8860b">app</span><span style="color:#666">=</span>flannel
</code></pre></div><!--
Once the flannel Pod is running, your node should enter the `Ready` state and then be available to handle workloads.
-->
<p>一旦 Flannel Pod 运行起来，你的节点就应该能进入 <code>Ready</code> 状态并可
用来处理负载。</p>
<h2 id="接下来">接下来</h2>
<!--
- [Upgrading Windows kubeadm nodes](/docs/tasks/administer-cluster/kubeadm/upgrading-windows-nodes)
-->
<ul>
<li><a href="/zh/docs/tasks/administer-cluster/kubeadm/upgrading-windows-nodes">升级 kubeadm 安装的 Windows 节点</a></li>
</ul>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-e805c7d8d4ad6195cb82dbbc843bfc29">2.5 - 升级 Windows 节点</h1>
    
	<!--
title: Upgrading Windows nodes
min-kubernetes-server-version: 1.17
content_type: task
weight: 40
-->
<!-- overview -->





<div style="margin-top: 10px; margin-bottom: 10px;">
<b>FEATURE STATE:</b> <code>Kubernetes v1.18 [beta]</code>
</div>

<!--
This page explains how to upgrade a Windows node [created with kubeadm](/docs/tasks/administer-cluster/kubeadm/adding-windows-nodes).
-->
<p>本页解释如何升级<a href="/zh/docs/tasks/administer-cluster/kubeadm/adding-windows-nodes">用 kubeadm 创建的</a>
Windows 节点。</p>
<h2 id="准备开始">准备开始</h2>
<p><p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
如果你还没有集群，你可以通过 <a href="/zh/docs/tasks/tools/#minikube">Minikube</a> 构建一
个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p>
<!--
You need to have a Kubernetes cluster, and the kubectl command-line tool must
be configured to communicate with your cluster. If you do not already have a
cluster, you can create one by using
[minikube](/docs/tasks/tools/#minikube)
or you can use one of these Kubernetes playgrounds:
-->
<ul>
<li><a href="https://www.katacoda.com/courses/kubernetes/playground">Katacoda</a></li>
<li><a href="http://labs.play-with-k8s.com/">玩转 Kubernetes</a></li>
</ul>
 

您的 Kubernetes 服务器版本必须不低于版本 1.17.
 要获知版本信息，请输入 <code>kubectl version</code>.
</p>
<!--
* Familiarize yourself with [the process for upgrading the rest of your kubeadm
cluster](/docs/tasks/administer-cluster/kubeadm/kubeadm-upgrade). You will want to
upgrade the control plane nodes before upgrading your Windows nodes.
-->
<ul>
<li>熟悉<a href="/zh/docs/tasks/administer-cluster/kubeadm/kubeadm-upgrade">更新 kubeadm 集群中的其余组件</a>。
在升级你的 Windows 节点之前你会想要升级控制面节点。</li>
</ul>
<!-- steps -->
<!--
## Upgrading worker nodes

### Upgrade kubeadm
-->
<h2 id="upgrading-worker-nodes">升级工作节点  </h2>
<h3 id="upgrade-kubeadm">升级 kubeadm   </h3>
<!--
1.  From the Windows node, upgrade kubeadm:

    ```powershell
    # replace v1.22.0 with your desired version
    curl.exe -Lo C:\k\kubeadm.exe https://dl.k8s.io/v1.22.0/bin/windows/amd64/kubeadm.exe
    ```
-->
<ol>
<li>
<p>在 Windows 节点上升级 kubeadm：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-powershell" data-lang="powershell"><span style="color:#080;font-style:italic"># 将 v1.22.0 替换为你希望的版本</span>
curl.exe -Lo C:\k\kubeadm.exe https<span style="">:</span>//dl.k8s.io/<span style="color:#a2f">/bin/windows/amd64/kubeadm.exe
</code></pre></div></li>
</ol>
<!--
### Drain the node

1.  From a machine with access to the Kubernetes API,
    prepare the node for maintenance by marking it unschedulable and evicting the workloads:

    ```shell
    # replace <node-to-drain> with the name of your node you are draining
    kubectl drain <node-to-drain> -ignore-daemonsets
    ```

    You should see output similar to this:

    ```
    node/ip-172-31-85-18 cordoned
    node/ip-172-31-85-18 drained
    ```
-->
<h3 id="drain-the-node">腾空节点  </h3>
<ol>
<li>
<p>在一个能访问到 Kubernetes API 的机器上，将 Windows 节点标记为不可调度并
驱逐其上的所有负载，以便准备节点维护操作：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="color:#080;font-style:italic"># 将 &lt;要腾空的节点&gt; 替换为你要腾空的节点的名称</span>
kubectl drain &lt;要腾空的节点&gt; -ignore-daemonsets
</code></pre></div><p>你应该会看到类似下面的输出：</p>
<pre tabindex="0"><code>node/ip-172-31-85-18 cordoned
node/ip-172-31-85-18 drained
</code></pre></li>
</ol>
<!--
### Upgrade the kubelet configuration

1.  From the Windows node, call the following command to sync new kubelet configuration:

    ```powershell
    kubeadm upgrade node
    ```
-->
<h3 id="upgrade-the-kubelet-configuration">升级 kubelet 配置  </h3>
<ol>
<li>
<p>在 Windows 节点上，执行下面的命令来同步新的 kubelet 配置：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-powershell" data-lang="powershell">kubeadm upgrade node
</code></pre></div></li>
</ol>
<!--
### Upgrade kubelet

1.  From the Windows node, upgrade and restart the kubelet:

    ```powershell
    stop-service kubelet
    curl.exe -Lo C:\k\kubelet.exe https://dl.k8s.io/v1.22.0/bin/windows/amd64/kubelet.exe
    restart-service kubelet
    ```
-->
<h3 id="upgrade-kubelet">升级 kubelet  </h3>
<ol>
<li>
<p>在 Windows 节点上升级并重启 kubelet：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-powershell" data-lang="powershell"><span style="color:#a2f">stop-service</span> kubelet
curl.exe -Lo C:\k\kubelet.exe https<span style="">:</span>//dl.k8s.io/<span style="color:#a2f">/bin/windows/amd64/kubelet.exe
<span style="color:#a2f">restart-service</span> kubelet
</code></pre></div></li>
</ol>
<!--
### Uncordon the node

1.  From a machine with access to the Kubernetes API,
bring the node back online by marking it schedulable:

    ```shell
    # replace <node-to-drain> with the name of your node
    kubectl uncordon <node-to-drain>
    ```
-->
<h3 id="uncordon-the-node">对节点执行 uncordon 操作  </h3>
<ol>
<li>
<p>从一台能够访问到 Kubernetes API 的机器上，通过将节点标记为可调度，使之
重新上线：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="color:#080;font-style:italic"># 将 &lt;要腾空的节点&gt; 替换为你的节点名称</span>
kubectl uncordon &lt;要腾空的节点&gt;
</code></pre></div></li>
</ol>
<!--
### Upgrade kube-proxy

1. From a machine with access to the Kubernetes API, run the following,
again replacing v1.22.0 with your desired version:

    ```shell
    curl -L https://github.com/kubernetes-sigs/sig-windows-tools/releases/latest/download/kube-proxy.yml | sed 's/VERSION/v1.22.0/g' | kubectl apply -f -
    ```
-->
<h3 id="upgrade-kube-proxy">升级 kube-proxy  </h3>
<ol>
<li>
<p>在一台可访问 Kubernetes API 的机器上和，将 v1.22.0 替换成你
期望的版本后再次执行下面的命令：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">curl -L https://github.com/kubernetes-sigs/sig-windows-tools/releases/latest/download/kube-proxy.yml | sed <span style="color:#b44">&#39;s/VERSION/v1.22.0/g&#39;</span> | kubectl apply -f -
</code></pre></div></li>
</ol>

</div>



    
	
  

    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-47be5dd51f686017f1766e6ec7aa6f41">3 - 管理内存，CPU 和 API 资源</h1>
    
	
</div>



    
      
  
  
  
  

  
  

  
    
    
	
    

<div class="td-content" style="">
    
	<h1 id="pg-337620c76587e4aeb32009cb23be46de">3.1 - 为命名空间配置默认的内存请求和限制</h1>
    
	<!--
title: Configure Default Memory Requests and Limits for a Namespace
content_type: task
weight: 10
-->
<!-- overview -->
<!--
This page shows how to configure default memory requests and limits for a namespace.
If a Container is created in a namespace that has a default memory limit, and the Container
does not specify its own memory limit, then the Container is assigned the default memory limit.
Kubernetes assigns a default memory request under certain conditions that are explained later in this topic.
-->
<p>本文介绍怎样给命名空间配置默认的内存请求和限制。
如果在一个有默认内存限制的命名空间创建容器，该容器没有声明自己的内存限制时，
将会被指定默认内存限制。
Kubernetes 还为某些情况指定了默认的内存请求，本章后面会进行介绍。</p>
<h2 id="准备开始">准备开始</h2>
<p><p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
如果你还没有集群，你可以通过 <a href="/zh/docs/tasks/tools/#minikube">Minikube</a> 构建一
个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p>
<!--
You need to have a Kubernetes cluster, and the kubectl command-line tool must
be configured to communicate with your cluster. If you do not already have a
cluster, you can create one by using
[minikube](/docs/tasks/tools/#minikube)
or you can use one of these Kubernetes playgrounds:
-->
<ul>
<li><a href="https://www.katacoda.com/courses/kubernetes/playground">Katacoda</a></li>
<li><a href="http://labs.play-with-k8s.com/">玩转 Kubernetes</a></li>
</ul>
 
 要获知版本信息，请输入 <code>kubectl version</code>.
</p>
<!--
Each node in your cluster must have at least 2 GiB of memory.
-->
<p>你的集群中的每个节点必须至少有 2 GiB 的内存。</p>
<!-- steps -->
<!--
## Create a namespace

Create a namespace so that the resources you create in this exercise are
isolated from the rest of your cluster.
-->
<h2 id="创建命名空间">创建命名空间</h2>
<p>创建一个命名空间，以便本练习中所建的资源与集群的其余资源相隔离。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl create namespace default-mem-example
</code></pre></div><!--
## Create a LimitRange and a Pod

Here's the configuration file for a LimitRange object. The configuration specifies
a default memory request and a default memory limit.
-->
<h2 id="创建-limitrange-和-pod">创建 LimitRange 和 Pod</h2>
<p>这里给出了一个限制范围对象的配置文件。该配置声明了一个默认的内存请求和一个默认的内存限制。</p>


 













<div class="highlight">
    <div class="copy-code-icon" style="text-align:right">
    <a href="https://raw.githubusercontent.com/kubernetes/website/main/content/zh/examples/admin/resource/memory-defaults.yaml" download="admin/resource/memory-defaults.yaml"><code>admin/resource/memory-defaults.yaml</code>
    </a>
    <img src="/images/copycode.svg" style="max-height:24px; cursor: pointer" onclick="copyCode('admin-resource-memory-defaults-yaml')" title="Copy admin/resource/memory-defaults.yaml to clipboard">
    </img>
    </div>
    <div class="includecode" id="admin-resource-memory-defaults-yaml">
    <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>LimitRange<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>mem-limit-range<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">spec</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">limits</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- <span style="color:#008000;font-weight:bold">default</span>:<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">memory</span>:<span style="color:#bbb"> </span>512Mi<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">defaultRequest</span>:<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">memory</span>:<span style="color:#bbb"> </span>256Mi<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">type</span>:<span style="color:#bbb"> </span>Container<span style="color:#bbb">
</span></code></pre></div>
    </div>
</div>


<!--
Create the LimitRange in the default-mem-example namespace:
-->
<p>在 default-mem-example 命名空间创建限制范围：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl apply -f https://k8s.io/examples/admin/resource/memory-defaults.yaml --namespace<span style="color:#666">=</span>default-mem-example
</code></pre></div><!--
Now if a Container is created in the default-mem-example namespace, and the
Container does not specify its own values for memory request and memory limit,
the Container is given a default memory request of 256 MiB and a default
memory limit of 512 MiB.

Here's the configuration file for a Pod that has one Container. The Container
does not specify a memory request and limit.
-->
<p>现在，如果在 default-mem-example 命名空间创建容器，并且该容器没有声明自己的内存请求和限制值，
它将被指定默认的内存请求 256 MiB 和默认的内存限制 512 MiB。</p>
<p>下面是具有一个容器的 Pod 的配置文件。
容器未指定内存请求和限制。</p>


 













<div class="highlight">
    <div class="copy-code-icon" style="text-align:right">
    <a href="https://raw.githubusercontent.com/kubernetes/website/main/content/zh/examples/admin/resource/memory-defaults-pod.yaml" download="admin/resource/memory-defaults-pod.yaml"><code>admin/resource/memory-defaults-pod.yaml</code>
    </a>
    <img src="/images/copycode.svg" style="max-height:24px; cursor: pointer" onclick="copyCode('admin-resource-memory-defaults-pod-yaml')" title="Copy admin/resource/memory-defaults-pod.yaml to clipboard">
    </img>
    </div>
    <div class="includecode" id="admin-resource-memory-defaults-pod-yaml">
    <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>Pod<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>default-mem-demo<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">spec</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">containers</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>default-mem-demo-ctr<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">image</span>:<span style="color:#bbb"> </span>nginx<span style="color:#bbb">
</span></code></pre></div>
    </div>
</div>


<!--
Create the Pod.
-->
<p>创建 Pod</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl apply -f https://k8s.io/examples/admin/resource/memory-defaults-pod.yaml --namespace<span style="color:#666">=</span>default-mem-example
</code></pre></div><!--
View detailed information about the Pod:
-->
<p>查看 Pod 的详情：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl get pod default-mem-demo --output<span style="color:#666">=</span>yaml --namespace<span style="color:#666">=</span>default-mem-example
</code></pre></div><!--
The output shows that the Pod's Container has a memory request of 256 MiB and
a memory limit of 512 MiB. These are the default values specified by the LimitRange.
-->
<p>输出内容显示该 Pod 的容器有 256 MiB 的内存请求和 512 MiB 的内存限制。
这些都是 LimitRange 设置的默认值。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">containers:
- image: nginx
  imagePullPolicy: Always
  name: default-mem-demo-ctr
  resources:
    limits:
      memory: 512Mi
    requests:
      memory: 256Mi
</code></pre></div><!--
Delete your Pod:
-->
<p>删除你的 Pod：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl delete pod default-mem-demo --namespace<span style="color:#666">=</span>default-mem-example
</code></pre></div><!--
## What if you specify a Container's limit, but not its request?

Here's the configuration file for a Pod that has one Container. The Container
specifies a memory limit, but not a request:
-->
<h2 id="声明容器的限制而不声明它的请求会怎么样">声明容器的限制而不声明它的请求会怎么样？</h2>
<p>这里给出了包含一个容器的 Pod 的配置文件。该容器声明了内存限制，而没有声明内存请求：</p>


 













<div class="highlight">
    <div class="copy-code-icon" style="text-align:right">
    <a href="https://raw.githubusercontent.com/kubernetes/website/main/content/zh/examples/admin/resource/memory-defaults-pod-2.yaml" download="admin/resource/memory-defaults-pod-2.yaml"><code>admin/resource/memory-defaults-pod-2.yaml</code>
    </a>
    <img src="/images/copycode.svg" style="max-height:24px; cursor: pointer" onclick="copyCode('admin-resource-memory-defaults-pod-2-yaml')" title="Copy admin/resource/memory-defaults-pod-2.yaml to clipboard">
    </img>
    </div>
    <div class="includecode" id="admin-resource-memory-defaults-pod-2-yaml">
    <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>Pod<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>default-mem-demo-2<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">spec</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">containers</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>default-mem-demo-2-ctr<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">image</span>:<span style="color:#bbb"> </span>nginx<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">resources</span>:<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">limits</span>:<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#008000;font-weight:bold">memory</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;1Gi&#34;</span><span style="color:#bbb">
</span></code></pre></div>
    </div>
</div>


<!--
Create the Pod:
-->
<p>创建 Pod：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl apply -f https://k8s.io/examples/admin/resource/memory-defaults-pod-2.yaml --namespace<span style="color:#666">=</span>default-mem-example
</code></pre></div><!--
View detailed information about the Pod:
-->
<p>查看 Pod 的详情：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl get pod default-mem-demo-2 --output<span style="color:#666">=</span>yaml --namespace<span style="color:#666">=</span>default-mem-example
</code></pre></div><!--
The output shows that the Container's memory request is set to match its memory limit.
Notice that the Container was not assigned the default memory request value of 256Mi.
-->
<p>输出结果显示容器的内存请求被设置为它的内存限制相同的值。注意该容器没有被指定默认的内存请求值 256MiB。</p>
<pre tabindex="0"><code>resources:
  limits:
    memory: 1Gi
  requests:
    memory: 1Gi
</code></pre><!--
## What if you specify a Container's request, but not its limit?
-->
<h2 id="声明容器的内存请求而不声明内存限制会怎么样">声明容器的内存请求而不声明内存限制会怎么样？</h2>
<!--
Here's the configuration file for a Pod that has one Container. The Container
specifies a memory request, but not a limit:
-->
<p>这里给出了一个包含一个容器的 Pod 的配置文件。该容器声明了内存请求，但没有内存限制：</p>


 













<div class="highlight">
    <div class="copy-code-icon" style="text-align:right">
    <a href="https://raw.githubusercontent.com/kubernetes/website/main/content/zh/examples/admin/resource/memory-defaults-pod-3.yaml" download="admin/resource/memory-defaults-pod-3.yaml"><code>admin/resource/memory-defaults-pod-3.yaml</code>
    </a>
    <img src="/images/copycode.svg" style="max-height:24px; cursor: pointer" onclick="copyCode('admin-resource-memory-defaults-pod-3-yaml')" title="Copy admin/resource/memory-defaults-pod-3.yaml to clipboard">
    </img>
    </div>
    <div class="includecode" id="admin-resource-memory-defaults-pod-3-yaml">
    <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>Pod<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>default-mem-demo-3<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">spec</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">containers</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>default-mem-demo-3-ctr<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">image</span>:<span style="color:#bbb"> </span>nginx<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">resources</span>:<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">requests</span>:<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#008000;font-weight:bold">memory</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;128Mi&#34;</span><span style="color:#bbb">
</span></code></pre></div>
    </div>
</div>


<!--
Create the Pod:
-->
<p>创建 Pod：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl apply -f https://k8s.io/examples/admin/resource/memory-defaults-pod-3.yaml --namespace<span style="color:#666">=</span>default-mem-example
</code></pre></div><!--
View the Pod's specification:
-->
<p>查看 Pod 声明：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl get pod default-mem-demo-3 --output<span style="color:#666">=</span>yaml --namespace<span style="color:#666">=</span>default-mem-example
</code></pre></div><!--
The output shows that the Container's memory request is set to the value specified in the
Container's configuration file. The Container's memory limit is set to 512Mi, which is the
default memory limit for the namespace.
-->
<p>输出结果显示该容器的内存请求被设置为了容器配置文件中声明的数值。
容器的内存限制被设置为 512MiB，即命名空间的默认内存限制。</p>
<pre tabindex="0"><code>resources:
  limits:
    memory: 512Mi
  requests:
    memory: 128Mi
</code></pre><!--
## Motivation for default memory limits and requests

If your namespace has a resource quota,
it is helpful to have a default value in place for memory limit.
Here are two of the restrictions that a resource quota imposes on a namespace:
-->
<h2 id="设置默认内存限制和请求的动机">设置默认内存限制和请求的动机</h2>
<p>如果你的命名空间有资源配额，那么默认内存限制是很有帮助的。
下面是一个例子，通过资源配额为命名空间设置两项约束：</p>
<!--
* Every Container that runs in the namespace must have its own memory limit.
* The total amount of memory used by all Containers in the namespace must not exceed a specified limit.
-->
<ul>
<li>运行在命名空间中的每个容器必须有自己的内存限制。</li>
<li>命名空间中所有容器的内存使用量之和不能超过声明的限制值。</li>
</ul>
<!--
If a Container does not specify its own memory limit, it is given the default limit, and then
it can be allowed to run in a namespace that is restricted by a quota.
-->
<p>如果一个容器没有声明自己的内存限制，会被指定默认限制，然后它才会被允许在限定了配额的命名空间中运行。</p>
<!--
## Clean up

Delete your namespace:
-->
<h2 id="清理">清理</h2>
<p>删除你的命名空间：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl delete namespace default-mem-example
</code></pre></div><h2 id="接下来">接下来</h2>
<!--
### For cluster administrators

* [Configure Default CPU Requests and Limits for a Namespace](/docs/tasks/administer-cluster/cpu-default-namespace/)

* [Configure Minimum and Maximum Memory Constraints for a Namespace](/docs/tasks/administer-cluster/memory-constraint-namespace/)

* [Configure Minimum and Maximum CPU Constraints for a Namespace](/docs/tasks/administer-cluster/cpu-constraint-namespace/)

* [Configure Memory and CPU Quotas for a Namespace](/docs/tasks/administer-cluster/quota-memory-cpu-namespace/)

* [Configure a Pod Quota for a Namespace](/docs/tasks/administer-cluster/quota-pod-namespace/)

* [Configure Quotas for API Objects](/docs/tasks/administer-cluster/quota-api-object/)
-->
<h3 id="集群管理员参考">集群管理员参考</h3>
<ul>
<li><a href="/zh/docs/tasks/administer-cluster/manage-resources/cpu-default-namespace/">为命名空间配置默认的 CPU 请求和限制</a></li>
<li><a href="/zh/docs/tasks/administer-cluster/manage-resources/memory-constraint-namespace/">为命名空间配置最小和最大内存限制</a></li>
<li><a href="/zh/docs/tasks/administer-cluster/manage-resources/cpu-constraint-namespace/">为命名空间配置最小和最大 CPU 限制</a></li>
<li><a href="/zh/docs/tasks/administer-cluster/manage-resources/quota-memory-cpu-namespace/">为命名空间配置内存和 CPU 配额</a></li>
<li><a href="/zh/docs/tasks/administer-cluster/manage-resources/quota-pod-namespace/">为命名空间配置 Pod 配额</a></li>
<li><a href="/zh/docs/tasks/administer-cluster/quota-api-object/">为 API 对象配置配额</a></li>
</ul>
<!--
### For app developers

* [Assign Memory Resources to Containers and Pods](/docs/tasks/configure-pod-container/assign-memory-resource/)

* [Assign CPU Resources to Containers and Pods](/docs/tasks/configure-pod-container/assign-cpu-resource/)

* [Configure Quality of Service for Pods](/docs/tasks/configure-pod-container/quality-service-pod/)
-->
<h3 id="应用开发者参考">应用开发者参考</h3>
<ul>
<li><a href="/zh/docs/tasks/configure-pod-container/assign-memory-resource/">为容器和 Pod 分配内存资源</a></li>
<li><a href="/zh/docs/tasks/configure-pod-container/assign-cpu-resource/">为容器和 Pod 分配 CPU 资源</a></li>
<li><a href="/zh/docs/tasks/configure-pod-container/quality-service-pod/">为 Pod 配置服务质量</a></li>
</ul>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-320af95e480962c538ebef7ae205845c">3.2 - 为命名空间配置默认的 CPU 请求和限制</h1>
    
	<!--
title: Configure Default CPU Requests and Limits for a Namespace
content_type: task
weight: 20
-->
<!-- overview -->
<!--
This page shows how to configure default CPU requests and limits for a namespace.
A Kubernetes cluster can be divided into namespaces. If a Container is created in a namespace
that has a default CPU limit, and the Container does not specify its own CPU limit, then
the Container is assigned the default CPU limit. Kubernetes assigns a default CPU request
under certain conditions that are explained later in this topic.
-->
<p>本章介绍怎样为命名空间配置默认的 CPU 请求和限制。
一个 Kubernetes 集群可被划分为多个命名空间。如果在配置了 CPU 限制的命名空间创建容器，
并且该容器没有声明自己的 CPU 限制，那么这个容器会被指定默认的 CPU 限制。
Kubernetes 在一些特定情况还会指定 CPU 请求，本文后续章节将会对其进行解释。</p>
<h2 id="准备开始">准备开始</h2>
<p><p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
如果你还没有集群，你可以通过 <a href="/zh/docs/tasks/tools/#minikube">Minikube</a> 构建一
个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p>
<!--
You need to have a Kubernetes cluster, and the kubectl command-line tool must
be configured to communicate with your cluster. If you do not already have a
cluster, you can create one by using
[minikube](/docs/tasks/tools/#minikube)
or you can use one of these Kubernetes playgrounds:
-->
<ul>
<li><a href="https://www.katacoda.com/courses/kubernetes/playground">Katacoda</a></li>
<li><a href="http://labs.play-with-k8s.com/">玩转 Kubernetes</a></li>
</ul>
 
 要获知版本信息，请输入 <code>kubectl version</code>.
</p>
<!-- steps -->
<!--
## Create a namespace

Create a namespace so that the resources you create in this exercise are
isolated from the rest of your cluster.
-->
<h2 id="创建命名空间">创建命名空间</h2>
<p>创建一个命名空间，以便本练习中创建的资源和集群的其余部分相隔离。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl create namespace default-cpu-example
</code></pre></div><!--
## Create a LimitRange and a Pod

Here's the configuration file for a LimitRange object. The configuration specifies
a default CPU request and a default CPU limit.
-->
<h2 id="创建-limitrange-和-pod">创建 LimitRange 和 Pod</h2>
<p>这里给出了 LimitRange 对象的配置文件。该配置声明了一个默认的 CPU 请求和一个默认的 CPU 限制。</p>


 













<div class="highlight">
    <div class="copy-code-icon" style="text-align:right">
    <a href="https://raw.githubusercontent.com/kubernetes/website/main/content/zh/examples/admin/resource/cpu-defaults.yaml" download="admin/resource/cpu-defaults.yaml"><code>admin/resource/cpu-defaults.yaml</code>
    </a>
    <img src="/images/copycode.svg" style="max-height:24px; cursor: pointer" onclick="copyCode('admin-resource-cpu-defaults-yaml')" title="Copy admin/resource/cpu-defaults.yaml to clipboard">
    </img>
    </div>
    <div class="includecode" id="admin-resource-cpu-defaults-yaml">
    <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>LimitRange<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>cpu-limit-range<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">spec</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">limits</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- <span style="color:#008000;font-weight:bold">default</span>:<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">cpu</span>:<span style="color:#bbb"> </span><span style="color:#666">1</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">defaultRequest</span>:<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">cpu</span>:<span style="color:#bbb"> </span><span style="color:#666">0.5</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">type</span>:<span style="color:#bbb"> </span>Container<span style="color:#bbb">
</span></code></pre></div>
    </div>
</div>


<!--
Create the LimitRange in the default-cpu-example namespace:
-->
<p>在命名空间 default-cpu-example 中创建 LimitRange 对象：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl apply -f https://k8s.io/examples/admin/resource/cpu-defaults.yaml --namespace<span style="color:#666">=</span>default-cpu-example
</code></pre></div><!--
Now if a Container is created in the default-cpu-example namespace, and the
Container does not specify its own values for CPU request and CPU limit,
the Container is given a default CPU request of 0.5 and a default
CPU limit of 1.

Here's the configuration file for a Pod that has one Container. The Container
does not specify a CPU request and limit.
-->
<p>现在如果在 default-cpu-example 命名空间创建一个容器，该容器没有声明自己的 CPU 请求和限制时，
将会给它指定默认的 CPU 请求0.5和默认的 CPU 限制值1.</p>
<p>这里给出了包含一个容器的 Pod 的配置文件。该容器没有声明 CPU 请求和限制。</p>


 













<div class="highlight">
    <div class="copy-code-icon" style="text-align:right">
    <a href="https://raw.githubusercontent.com/kubernetes/website/main/content/zh/examples/admin/resource/cpu-defaults-pod.yaml" download="admin/resource/cpu-defaults-pod.yaml"><code>admin/resource/cpu-defaults-pod.yaml</code>
    </a>
    <img src="/images/copycode.svg" style="max-height:24px; cursor: pointer" onclick="copyCode('admin-resource-cpu-defaults-pod-yaml')" title="Copy admin/resource/cpu-defaults-pod.yaml to clipboard">
    </img>
    </div>
    <div class="includecode" id="admin-resource-cpu-defaults-pod-yaml">
    <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>Pod<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>default-cpu-demo<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">spec</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">containers</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>default-cpu-demo-ctr<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">image</span>:<span style="color:#bbb"> </span>nginx<span style="color:#bbb">
</span></code></pre></div>
    </div>
</div>


<!--
Create the Pod.
-->
<p>创建 Pod。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl apply -f https://k8s.io/examples/admin/resource/cpu-defaults-pod.yaml --namespace<span style="color:#666">=</span>default-cpu-example
</code></pre></div><!--
View the Pod's specification:
-->
<p>查看该 Pod 的声明：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl get pod default-cpu-demo --output<span style="color:#666">=</span>yaml --namespace<span style="color:#666">=</span>default-cpu-example
</code></pre></div><!--
The output shows that the Pod's Container has a CPU request of 500 millicpus and
a CPU limit of 1 cpu. These are the default values specified by the LimitRange.
-->
<p>输出显示该 Pod 的容器有一个500 millicpus的 CPU 请求和一个1 cpu的 CPU 限制。这些是 LimitRange 声明的默认值。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">containers:
- image: nginx
  imagePullPolicy: Always
  name: default-cpu-demo-ctr
  resources:
    limits:
      cpu: <span style="color:#b44">&#34;1&#34;</span>
    requests:
      cpu: 500m
</code></pre></div><!--
## What if you specify a Container's limit, but not its request?

Here's the configuration file for a Pod that has one Container. The Container
specifies a CPU limit, but not a request:
-->
<h2 id="你只声明容器的限制-而不声明请求会怎么样">你只声明容器的限制，而不声明请求会怎么样？</h2>
<p>这是包含一个容器的 Pod 的配置文件。该容器声明了 CPU 限制，而没有声明 CPU 请求。</p>


 













<div class="highlight">
    <div class="copy-code-icon" style="text-align:right">
    <a href="https://raw.githubusercontent.com/kubernetes/website/main/content/zh/examples/admin/resource/cpu-defaults-pod-2.yaml" download="admin/resource/cpu-defaults-pod-2.yaml"><code>admin/resource/cpu-defaults-pod-2.yaml</code>
    </a>
    <img src="/images/copycode.svg" style="max-height:24px; cursor: pointer" onclick="copyCode('admin-resource-cpu-defaults-pod-2-yaml')" title="Copy admin/resource/cpu-defaults-pod-2.yaml to clipboard">
    </img>
    </div>
    <div class="includecode" id="admin-resource-cpu-defaults-pod-2-yaml">
    <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>Pod<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>default-cpu-demo-2<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">spec</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">containers</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>default-cpu-demo-2-ctr<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">image</span>:<span style="color:#bbb"> </span>nginx<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">resources</span>:<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">limits</span>:<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#008000;font-weight:bold">cpu</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;1&#34;</span><span style="color:#bbb">
</span></code></pre></div>
    </div>
</div>


<!--
Create the Pod:
-->
<p>创建 Pod</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl apply -f https://k8s.io/examples/admin/resource/cpu-defaults-pod-2.yaml --namespace<span style="color:#666">=</span>default-cpu-example
</code></pre></div><!--
View the Pod specification:
-->
<p>查看 Pod 的声明：</p>
<pre tabindex="0"><code>kubectl get pod default-cpu-demo-2 --output=yaml --namespace=default-cpu-example
</code></pre><!--
The output shows that the Container's CPU request is set to match its CPU limit.
Notice that the Container was not assigned the default CPU request value of 0.5 cpu.
-->
<p>输出显示该容器的 CPU 请求和 CPU 限制设置相同。注意该容器没有被指定默认的 CPU 请求值0.5 cpu。</p>
<pre tabindex="0"><code>resources:
  limits:
    cpu: &quot;1&quot;
  requests:
    cpu: &quot;1&quot;
</code></pre><!--
## What if you specify a Container's request, but not its limit?

Here's the configuration file for a Pod that has one Container. The Container
specifies a CPU request, but not a limit:
-->
<h2 id="你只声明容器的请求-而不声明它的限制会怎么样">你只声明容器的请求，而不声明它的限制会怎么样？</h2>
<p>这里给出了包含一个容器的 Pod 的配置文件。该容器声明了 CPU 请求，而没有声明 CPU 限制。</p>


 













<div class="highlight">
    <div class="copy-code-icon" style="text-align:right">
    <a href="https://raw.githubusercontent.com/kubernetes/website/main/content/zh/examples/admin/resource/cpu-defaults-pod-3.yaml" download="admin/resource/cpu-defaults-pod-3.yaml"><code>admin/resource/cpu-defaults-pod-3.yaml</code>
    </a>
    <img src="/images/copycode.svg" style="max-height:24px; cursor: pointer" onclick="copyCode('admin-resource-cpu-defaults-pod-3-yaml')" title="Copy admin/resource/cpu-defaults-pod-3.yaml to clipboard">
    </img>
    </div>
    <div class="includecode" id="admin-resource-cpu-defaults-pod-3-yaml">
    <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>Pod<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>default-cpu-demo-3<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">spec</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">containers</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>default-cpu-demo-3-ctr<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">image</span>:<span style="color:#bbb"> </span>nginx<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">resources</span>:<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">requests</span>:<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#008000;font-weight:bold">cpu</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;0.75&#34;</span><span style="color:#bbb">
</span></code></pre></div>
    </div>
</div>


<!--
Create the Pod:
-->
<p>创建 Pod：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl apply -f https://k8s.io/examples/admin/resource/cpu-defaults-pod-3.yaml --namespace<span style="color:#666">=</span>default-cpu-example
</code></pre></div><!--
View the Pod specification:
-->
<p>查看 Pod 的规约：</p>
<pre tabindex="0"><code>kubectl get pod default-cpu-demo-3 --output=yaml --namespace=default-cpu-example
</code></pre><!--
The output shows that the Container's CPU request is set to the value specified in the
Container's configuration file. The Container's CPU limit is set to 1 cpu, which is the
default CPU limit for the namespace.
-->
<p>结果显示该容器的 CPU 请求被设置为容器配置文件中声明的数值。
容器的CPU限制被设置为 1 CPU，即该命名空间的默认 CPU 限制值。</p>
<pre tabindex="0"><code>resources:
  limits:
    cpu: &quot;1&quot;
  requests:
    cpu: 750m
</code></pre><!--
## Motivation for default CPU limits and requests

If your namespace has a
[resource quota](/docs/tasks/administer-cluster/manage-resources/quota-memory-cpu-namespace/),
it is helpful to have a default value in place for CPU limit.
Here are two of the restrictions that a resource quota imposes on a namespace:

* Every Container that runs in the namespace must have its own CPU limit.
* The total amount of CPU used by all Containers in the namespace must not exceed a specified limit.

If a Container does not specify its own CPU limit, it is given the default limit, and then
it can be allowed to run in a namespace that is restricted by a quota.
-->
<h2 id="默认-cpu-限制和请求的动机">默认 CPU 限制和请求的动机</h2>
<p>如果你的命名空间有一个
<a href="/zh/docs/tasks/administer-cluster/manage-resources/quota-memory-cpu-namespace/">资源配额</a>，
那么有一个默认的 CPU 限制是有帮助的。这里有资源配额强加给命名空间的两条限制：</p>
<ul>
<li>命名空间中运行的每个容器必须有自己的 CPU 限制。</li>
<li>命名空间中所有容器使用的 CPU 总和不能超过一个声明值。</li>
</ul>
<p>如果容器没有声明自己的 CPU 限制，将会给它一个默认限制，这样它就能被允许运行在一个有配额限制的命名空间中。</p>
<!--
## Clean up

Delete your namespace:

```shell
kubectl delete namespace default-cpu-example
```
-->
<h2 id="清理">清理</h2>
<p>删除你的命名空间：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl delete namespace constraints-cpu-example
</code></pre></div><h2 id="接下来">接下来</h2>
<!--
### For cluster administrators

* [Configure Default Memory Requests and Limits for a Namespace](/docs/tasks/administer-cluster/memory-default-namespace/)
* [Configure Minimum and Maximum Memory Constraints for a Namespace](/docs/tasks/administer-cluster/memory-constraint-namespace/)
* [Configure Minimum and Maximum CPU Constraints for a Namespace](/docs/tasks/administer-cluster/cpu-constraint-namespace/)
* [Configure Memory and CPU Quotas for a Namespace](/docs/tasks/administer-cluster/quota-memory-cpu-namespace/)
* [Configure a Pod Quota for a Namespace](/docs/tasks/administer-cluster/quota-pod-namespace/)
* [Configure Quotas for API Objects](/docs/tasks/administer-cluster/quota-api-object/)
-->
<h3 id="集群管理员参考">集群管理员参考</h3>
<ul>
<li><a href="/zh/docs/tasks/administer-cluster/manage-resources/memory-default-namespace/">为命名空间配置默认内存请求和限制</a></li>
<li><a href="/zh/docs/tasks/administer-cluster/manage-resources/memory-constraint-namespace/">为命名空间配置内存限制的最小值和最大值</a></li>
<li><a href="/zh/docs/tasks/administer-cluster/manage-resources/cpu-constraint-namespace/">为命名空间配置 CPU 限制的最小值和最大值</a></li>
<li><a href="/zh/docs/tasks/administer-cluster/manage-resources/quota-memory-cpu-namespace/">为命名空间配置内存和 CPU 配额</a></li>
<li><a href="/zh/docs/tasks/administer-cluster/manage-resources/quota-pod-namespace/">为命名空间配置 Pod 配额</a></li>
<li><a href="/zh/docs/tasks/administer-cluster/quota-api-object/">为 API 对象配置配额</a></li>
</ul>
<!--
### For app developers

* [Assign Memory Resources to Containers and Pods](/docs/tasks/configure-pod-container/assign-memory-resource/)
* [Assign CPU Resources to Containers and Pods](/docs/tasks/configure-pod-container/assign-cpu-resource/)
* [Configure Quality of Service for Pods](/docs/tasks/configure-pod-container/quality-service-pod/)
-->
<h3 id="应用开发者参考">应用开发者参考</h3>
<ul>
<li><a href="/zh/docs/tasks/configure-pod-container/assign-memory-resource/">为容器和 Pod 分配内存资源</a></li>
<li><a href="/zh/docs/tasks/configure-pod-container/assign-cpu-resource/">为容器和 Pod 分配 CPU 资源</a></li>
<li><a href="/zh/docs/tasks/configure-pod-container/quality-service-pod/">为 Pod 配置服务质量</a></li>
</ul>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-adb489b1ab985c9215657b0d4c6ae92b">3.3 - 配置命名空间的最小和最大内存约束</h1>
    
	<!--
title: Configure Minimum and Maximum Memory Constraints for a Namespace
content_type: task
weight: 30
-->
<!-- overview -->
<!--
This page shows how to set minimum and maximum values for memory used by Containers
running in a namespace. You specify minimum and maximum memory values in a
[LimitRange](/docs/reference/generated/kubernetes-api/v1.22/#limitrange-v1-core)
object. If a Pod does not meet the constraints imposed by the LimitRange,
it cannot be created in the namespace.
-->
<p>本页介绍如何设置在命名空间中运行的容器使用的内存的最小值和最大值。 你可以在
<a href="/docs/reference/generated/kubernetes-api/v1.22/#limitrange-v1-core">LimitRange</a>
对象中指定最小和最大内存值。如果 Pod 不满足 LimitRange 施加的约束，则无法在命名空间中创建它。</p>
<h2 id="准备开始">准备开始</h2>
<p><p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
如果你还没有集群，你可以通过 <a href="/zh/docs/tasks/tools/#minikube">Minikube</a> 构建一
个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p>
<!--
You need to have a Kubernetes cluster, and the kubectl command-line tool must
be configured to communicate with your cluster. If you do not already have a
cluster, you can create one by using
[minikube](/docs/tasks/tools/#minikube)
or you can use one of these Kubernetes playgrounds:
-->
<ul>
<li><a href="https://www.katacoda.com/courses/kubernetes/playground">Katacoda</a></li>
<li><a href="http://labs.play-with-k8s.com/">玩转 Kubernetes</a></li>
</ul>
 
 要获知版本信息，请输入 <code>kubectl version</code>.
</p>
<!--
Each node in your cluster must have at least 1 GiB of memory.
-->
<p>集群中每个节点必须至少要有 1 GiB 的内存。</p>
<!-- steps -->
<!--
## Create a namespace

Create a namespace so that the resources you create in this exercise are
isolated from the rest of your cluster.
-->
<h2 id="创建命名空间">创建命名空间</h2>
<p>创建一个命名空间，以便在此练习中创建的资源与群集的其余资源隔离。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl create namespace constraints-mem-example
</code></pre></div><!--
## Create a LimitRange and a Pod

Here's the configuration file for a LimitRange:
-->
<h2 id="创建-limitrange-和-pod">创建 LimitRange 和 Pod</h2>
<p>下面是 LimitRange 的配置文件：</p>


 













<div class="highlight">
    <div class="copy-code-icon" style="text-align:right">
    <a href="https://raw.githubusercontent.com/kubernetes/website/main/content/zh/examples/admin/resource/memory-constraints.yaml" download="admin/resource/memory-constraints.yaml"><code>admin/resource/memory-constraints.yaml</code>
    </a>
    <img src="/images/copycode.svg" style="max-height:24px; cursor: pointer" onclick="copyCode('admin-resource-memory-constraints-yaml')" title="Copy admin/resource/memory-constraints.yaml to clipboard">
    </img>
    </div>
    <div class="includecode" id="admin-resource-memory-constraints-yaml">
    <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>LimitRange<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>mem-min-max-demo-lr<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">spec</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">limits</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- <span style="color:#008000;font-weight:bold">max</span>:<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">memory</span>:<span style="color:#bbb"> </span>1Gi<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">min</span>:<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">memory</span>:<span style="color:#bbb"> </span>500Mi<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">type</span>:<span style="color:#bbb"> </span>Container<span style="color:#bbb">
</span></code></pre></div>
    </div>
</div>


<!--
Create the LimitRange:
-->
<p>创建 LimitRange:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl apply -f https://k8s.io/examples/admin/resource/memory-constraints.yaml --namespace<span style="color:#666">=</span>constraints-mem-example
</code></pre></div><!--
View detailed information about the LimitRange:
-->
<p>查看 LimitRange 的详情：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl get limitrange mem-min-max-demo-lr --namespace<span style="color:#666">=</span>constraints-mem-example --output<span style="color:#666">=</span>yaml
</code></pre></div><!--
The output shows the minimum and maximum memory constraints as expected. But
notice that even though you didn't specify default values in the configuration
file for the LimitRange, they were created automatically.
-->
<p>输出显示预期的最小和最大内存约束。 但请注意，即使你没有在 LimitRange 的配置文件中指定默认值，也会自动创建它们。</p>
<pre tabindex="0"><code>  limits:
  - default:
      memory: 1Gi
    defaultRequest:
      memory: 1Gi
    max:
      memory: 1Gi
    min:
      memory: 500Mi
    type: Container
</code></pre><!--
Now whenever a Container is created in the constraints-mem-example namespace, Kubernetes
performs these steps:

* If the Container does not specify its own memory request and limit, assign the default
memory request and limit to the Container.

* Verify that the Container has a memory request that is greater than or equal to 500 MiB.

* Verify that the Container has a memory limit that is less than or equal to 1 GiB.

Here's the configuration file for a Pod that has one Container. The Container manifest
specifies a memory request of 600 MiB and a memory limit of 800 MiB. These satisfy the
minimum and maximum memory constraints imposed by the LimitRange.
-->
<p>现在，只要在 constraints-mem-example 命名空间中创建容器，Kubernetes 就会执行下面的步骤：</p>
<ul>
<li>
<p>如果 Container 未指定自己的内存请求和限制，将为它指定默认的内存请求和限制。</p>
</li>
<li>
<p>验证 Container 的内存请求是否大于或等于500 MiB。</p>
</li>
<li>
<p>验证 Container 的内存限制是否小于或等于1 GiB。</p>
</li>
</ul>
<p>这里给出了包含一个 Container 的 Pod 配置文件。Container 声明了 600 MiB 的内存请求和
800 MiB 的内存限制， 这些满足了 LimitRange 施加的最小和最大内存约束。</p>


 













<div class="highlight">
    <div class="copy-code-icon" style="text-align:right">
    <a href="https://raw.githubusercontent.com/kubernetes/website/main/content/zh/examples/admin/resource/memory-constraints-pod.yaml" download="admin/resource/memory-constraints-pod.yaml"><code>admin/resource/memory-constraints-pod.yaml</code>
    </a>
    <img src="/images/copycode.svg" style="max-height:24px; cursor: pointer" onclick="copyCode('admin-resource-memory-constraints-pod-yaml')" title="Copy admin/resource/memory-constraints-pod.yaml to clipboard">
    </img>
    </div>
    <div class="includecode" id="admin-resource-memory-constraints-pod-yaml">
    <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>Pod<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>constraints-mem-demo<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">spec</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">containers</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>constraints-mem-demo-ctr<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">image</span>:<span style="color:#bbb"> </span>nginx<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">resources</span>:<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">limits</span>:<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#008000;font-weight:bold">memory</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;800Mi&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">requests</span>:<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#008000;font-weight:bold">memory</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;600Mi&#34;</span><span style="color:#bbb">
</span></code></pre></div>
    </div>
</div>


<!--
Create the Pod:
-->
<p>创建 Pod：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl apply -f https://k8s.io/examples/admin/resource/memory-constraints-pod.yaml --namespace<span style="color:#666">=</span>constraints-mem-example
</code></pre></div><!--
Verify that the Pod's Container is running:
-->
<p>确认下 Pod 中的容器在运行：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl get pod constraints-mem-demo --namespace<span style="color:#666">=</span>constraints-mem-example
</code></pre></div><!--
View detailed information about the Pod:
-->
<p>查看 Pod 详情：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl get pod constraints-mem-demo --output<span style="color:#666">=</span>yaml --namespace<span style="color:#666">=</span>constraints-mem-example
</code></pre></div><!--
The output shows that the Container has a memory request of 600 MiB and a memory limit
of 800 MiB. These satisfy the constraints imposed by the LimitRange.
-->
<p>输出结果显示容器的内存请求为600 MiB，内存限制为800 MiB。这些满足了 LimitRange 设定的限制范围。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">resources</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">limits</span>:<span style="color:#bbb">
</span><span style="color:#bbb">     </span><span style="color:#008000;font-weight:bold">memory</span>:<span style="color:#bbb"> </span>800Mi<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">requests</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">memory</span>:<span style="color:#bbb"> </span>600Mi<span style="color:#bbb">
</span></code></pre></div><!--
Delete your Pod:
-->
<p>删除你创建的 Pod：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl delete pod constraints-mem-demo --namespace<span style="color:#666">=</span>constraints-mem-example
</code></pre></div><!--
## Attempt to create a Pod that exceeds the maximum memory constraint

Here's the configuration file for a Pod that has one Container. The Container specifies a
memory request of 800 MiB and a memory limit of 1.5 GiB.
-->
<h2 id="尝试创建一个超过最大内存限制的-pod">尝试创建一个超过最大内存限制的 Pod</h2>
<p>这里给出了包含一个容器的 Pod 的配置文件。容器声明了800 MiB 的内存请求和1.5 GiB 的内存限制。</p>


 













<div class="highlight">
    <div class="copy-code-icon" style="text-align:right">
    <a href="https://raw.githubusercontent.com/kubernetes/website/main/content/zh/examples/admin/resource/memory-constraints-pod-2.yaml" download="admin/resource/memory-constraints-pod-2.yaml"><code>admin/resource/memory-constraints-pod-2.yaml</code>
    </a>
    <img src="/images/copycode.svg" style="max-height:24px; cursor: pointer" onclick="copyCode('admin-resource-memory-constraints-pod-2-yaml')" title="Copy admin/resource/memory-constraints-pod-2.yaml to clipboard">
    </img>
    </div>
    <div class="includecode" id="admin-resource-memory-constraints-pod-2-yaml">
    <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>Pod<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>constraints-mem-demo-2<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">spec</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">containers</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>constraints-mem-demo-2-ctr<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">image</span>:<span style="color:#bbb"> </span>nginx<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">resources</span>:<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">limits</span>:<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#008000;font-weight:bold">memory</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;1.5Gi&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">requests</span>:<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#008000;font-weight:bold">memory</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;800Mi&#34;</span><span style="color:#bbb">
</span></code></pre></div>
    </div>
</div>


<!--
Attempt to create the Pod:
-->
<p>尝试创建 Pod:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl apply -f https://k8s.io/examples/admin/resource/memory-constraints-pod-2.yaml --namespace<span style="color:#666">=</span>constraints-mem-example
</code></pre></div><!--
The output shows that the Pod does not get created, because the Container specifies a memory limit that is
too large:
-->
<p>输出结果显示 Pod 没有创建成功，因为容器声明的内存限制太大了：</p>
<pre tabindex="0"><code>Error from server (Forbidden): error when creating &quot;examples/admin/resource/memory-constraints-pod-2.yaml&quot;:
pods &quot;constraints-mem-demo-2&quot; is forbidden: maximum memory usage per Container is 1Gi, but limit is 1536Mi.
</code></pre><!--
## Attempt to create a Pod that does not meet the minimum memory request

Here's the configuration file for a Pod that has one Container. The Container specifies a
memory request of 100 MiB and a memory limit of 800 MiB.
-->
<h2 id="尝试创建一个不满足最小内存请求的-pod">尝试创建一个不满足最小内存请求的 Pod</h2>
<p>这里给出了包含一个容器的 Pod 的配置文件。容器声明了100 MiB 的内存请求和800 MiB 的内存限制。</p>


 













<div class="highlight">
    <div class="copy-code-icon" style="text-align:right">
    <a href="https://raw.githubusercontent.com/kubernetes/website/main/content/zh/examples/admin/resource/memory-constraints-pod-3.yaml" download="admin/resource/memory-constraints-pod-3.yaml"><code>admin/resource/memory-constraints-pod-3.yaml</code>
    </a>
    <img src="/images/copycode.svg" style="max-height:24px; cursor: pointer" onclick="copyCode('admin-resource-memory-constraints-pod-3-yaml')" title="Copy admin/resource/memory-constraints-pod-3.yaml to clipboard">
    </img>
    </div>
    <div class="includecode" id="admin-resource-memory-constraints-pod-3-yaml">
    <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>Pod<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>constraints-mem-demo-3<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">spec</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">containers</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>constraints-mem-demo-3-ctr<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">image</span>:<span style="color:#bbb"> </span>nginx<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">resources</span>:<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">limits</span>:<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#008000;font-weight:bold">memory</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;800Mi&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">requests</span>:<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#008000;font-weight:bold">memory</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;100Mi&#34;</span><span style="color:#bbb">
</span></code></pre></div>
    </div>
</div>


<!--
Attempt to create the Pod:
-->
<p>尝试创建 Pod：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl apply -f https://k8s.io/examples/admin/resource/memory-constraints-pod-3.yaml --namespace<span style="color:#666">=</span>constraints-mem-example
</code></pre></div><!--
The output shows that the Pod does not get created, because the Container specifies a memory
request that is too small:
-->
<p>输出结果显示 Pod 没有创建成功，因为容器声明的内存请求太小了：</p>
<pre tabindex="0"><code>Error from server (Forbidden): error when creating &quot;examples/admin/resource/memory-constraints-pod-3.yaml&quot;:
pods &quot;constraints-mem-demo-3&quot; is forbidden: minimum memory usage per Container is 500Mi, but request is 100Mi.
</code></pre><!--
## Create a Pod that does not specify any memory request or limit

Here's the configuration file for a Pod that has one Container. The Container does not
specify a memory request, and it does not specify a memory limit.
-->
<h2 id="创建一个没有声明内存请求和限制的-pod">创建一个没有声明内存请求和限制的 Pod</h2>
<p>这里给出了包含一个容器的 Pod 的配置文件。容器没有声明内存请求，也没有声明内存限制。</p>


 













<div class="highlight">
    <div class="copy-code-icon" style="text-align:right">
    <a href="https://raw.githubusercontent.com/kubernetes/website/main/content/zh/examples/admin/resource/memory-constraints-pod-4.yaml" download="admin/resource/memory-constraints-pod-4.yaml"><code>admin/resource/memory-constraints-pod-4.yaml</code>
    </a>
    <img src="/images/copycode.svg" style="max-height:24px; cursor: pointer" onclick="copyCode('admin-resource-memory-constraints-pod-4-yaml')" title="Copy admin/resource/memory-constraints-pod-4.yaml to clipboard">
    </img>
    </div>
    <div class="includecode" id="admin-resource-memory-constraints-pod-4-yaml">
    <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>Pod<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>constraints-mem-demo-4<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">spec</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">containers</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>constraints-mem-demo-4-ctr<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">image</span>:<span style="color:#bbb"> </span>nginx<span style="color:#bbb">
</span><span style="color:#bbb">
</span></code></pre></div>
    </div>
</div>


<!--
Create the Pod:
-->
<p>创建 Pod：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl apply -f https://k8s.io/examples/admin/resource/memory-constraints-pod-4.yaml --namespace<span style="color:#666">=</span>constraints-mem-example
</code></pre></div><!--
View detailed information about the Pod:
-->
<p>查看 Pod 详情：</p>
<pre tabindex="0"><code>kubectl get pod constraints-mem-demo-4 --namespace=constraints-mem-example --output=yaml
</code></pre><!--
The output shows that the Pod's Container has a memory request of 1 GiB and a memory limit of 1 GiB.
How did the Container get those values?
-->
<p>输出结果显示 Pod 的内存请求为1 GiB，内存限制为1 GiB。容器怎样获得哪些数值呢？</p>
<pre tabindex="0"><code>resources:
  limits:
    memory: 1Gi
  requests:
    memory: 1Gi
</code></pre><!--
Because your Container did not specify its own memory request and limit, it was given the
[default memory request and limit](/docs/tasks/administer-cluster/memory-default-namespace/)
from the LimitRange.
-->
<p>因为你的容器没有声明自己的内存请求和限制，它从 LimitRange 那里获得了
<a href="/zh/docs/tasks/administer-cluster/manage-resources/memory-default-namespace/">默认的内存请求和限制</a>。</p>
<!--
At this point, your Container might be running or it might not be running. Recall that a prerequisite
for this task is that your Nodes have at least 1 GiB of memory. If each of your Nodes has only
1 GiB of memory, then there is not enough allocatable memory on any Node to accommodate a memory
request of 1 GiB. If you happen to be using Nodes with 2 GiB of memory, then you probably have
enough space to accommodate the 1 GiB request.

Delete your Pod:
-->
<p>此时，你的容器可能运行起来也可能没有运行起来。
回想一下我们本次任务的先决条件是你的每个节点都至少有1 GiB 的内存。
如果你的每个节点都只有1 GiB 的内存，那将没有一个节点拥有足够的可分配内存来满足1 GiB 的内存请求。</p>
<p>删除你的 Pod：</p>
<pre tabindex="0"><code>kubectl delete pod constraints-mem-demo-4 --namespace=constraints-mem-example
</code></pre><!--
## Enforcement of minimum and maximum memory constraints

The maximum and minimum memory constraints imposed on a namespace by a LimitRange are enforced only
when a Pod is created or updated. If you change the LimitRange, it does not affect
Pods that were created previously.
-->
<h2 id="强制执行内存最小和最大限制">强制执行内存最小和最大限制</h2>
<p>LimitRange 为命名空间设定的最小和最大内存限制只有在 Pod 创建和更新时才会强制执行。
如果你更新 LimitRange，它不会影响此前创建的 Pod。</p>
<!--
## Motivation for minimum and maximum memory constraints
-->
<h2 id="设置内存最小和最大限制的动因">设置内存最小和最大限制的动因</h2>
<!--
As a cluster administrator, you might want to impose restrictions on the amount of memory that Pods can use.
For example:

* Each Node in a cluster has 2 GB of memory. You do not want to accept any Pod that requests
  more than 2 GB of memory, because no Node in the cluster can support the request.

* A cluster is shared by your production and development departments.
  You want to allow production workloads to consume up to 8 GB of memory, but
  you want development workloads to be limited to 512 MB. You create separate namespaces
  for production and development, and you apply memory constraints to each namespace.
-->
<p>作为集群管理员，你可能想规定 Pod 可以使用的内存总量限制。例如：</p>
<ul>
<li>集群的每个节点有 2 GB 内存。你不想接受任何请求超过 2 GB 的 Pod，因为集群中没有节点可以满足。</li>
<li>集群由生产部门和开发部门共享。你希望允许产品部门的负载最多耗用 8 GB 内存，
但是开发部门的负载最多可使用 512 MiB。
这时，你可以为产品部门和开发部门分别创建名字空间，并为各个名字空间设置内存约束。</li>
</ul>
<!--
## Clean up

Delete your namespace:
-->
<h2 id="清理">清理</h2>
<p>删除你的命名空间：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl delete namespace constraints-mem-example
</code></pre></div><h2 id="接下来">接下来</h2>
<!--
### For cluster administrators

* [Configure Default Memory Requests and Limits for a Namespace](/docs/tasks/administer-cluster/memory-default-namespace/)
* [Configure Default CPU Requests and Limits for a Namespace](/docs/tasks/administer-cluster/cpu-default-namespace/)
* [Configure Minimum and Maximum CPU Constraints for a Namespace](/docs/tasks/administer-cluster/cpu-constraint-namespace/)
* [Configure Memory and CPU Quotas for a Namespace](/docs/tasks/administer-cluster/quota-memory-cpu-namespace/)
* [Configure a Pod Quota for a Namespace](/docs/tasks/administer-cluster/quota-pod-namespace/)
* [Configure Quotas for API Objects](/docs/tasks/administer-cluster/quota-api-object/)
-->
<h3 id="集群管理员参考">集群管理员参考</h3>
<ul>
<li><a href="/zh/docs/tasks/administer-cluster/manage-resources/memory-default-namespace/">为命名空间配置默认内存请求和限制</a></li>
<li><a href="/zh/docs/tasks/administer-cluster/manage-resources/memory-constraint-namespace/">为命名空间配置内存限制的最小值和最大值</a></li>
<li><a href="/zh/docs/tasks/administer-cluster/manage-resources/cpu-constraint-namespace/">为命名空间配置 CPU 限制的最小值和最大值</a></li>
<li><a href="/zh/docs/tasks/administer-cluster/manage-resources/quota-memory-cpu-namespace/">为命名空间配置内存和 CPU 配额</a></li>
<li><a href="/zh/docs/tasks/administer-cluster/manage-resources/quota-pod-namespace/">为命名空间配置 Pod 配额</a></li>
<li><a href="/zh/docs/tasks/administer-cluster/quota-api-object/">为 API 对象配置配额</a></li>
</ul>
<!--
### For app developers

* [Assign Memory Resources to Containers and Pods](/docs/tasks/configure-pod-container/assign-memory-resource/)
* [Assign CPU Resources to Containers and Pods](/docs/tasks/configure-pod-container/assign-cpu-resource/)
* [Configure Quality of Service for Pods](/docs/tasks/configure-pod-container/quality-service-pod/)
-->
<h3 id="应用开发者参考">应用开发者参考</h3>
<ul>
<li><a href="/zh/docs/tasks/configure-pod-container/assign-memory-resource/">为容器和 Pod 分配内存资源</a></li>
<li><a href="/zh/docs/tasks/configure-pod-container/assign-cpu-resource/">为容器和 Pod 分配 CPU 资源</a></li>
<li><a href="/zh/docs/tasks/configure-pod-container/quality-service-pod/">为 Pod 配置服务质量</a></li>
</ul>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-a87cbd1f9379dac7a48ae320da68a9ad">3.4 - 为命名空间配置 CPU 最小和最大约束</h1>
    
	<!--
title: Configure Minimum and Maximum CPU Constraints for a Namespace
content_type: task
weight: 40
-->
<!-- overview -->
<!--
This page shows how to set minimum and maximum values for the CPU resources used by Containers
and Pods in a namespace. You specify minimum and maximum CPU values in a
[LimitRange](/docs/reference/generated/kubernetes-api/v1.22/#limitrange-v1-core)
object. If a Pod does not meet the constraints imposed by the LimitRange, it cannot be created
in the namespace.
-->
<p>本页介绍如何为命名空间中容器和 Pod 使用的 CPU 资源设置最小和最大值。
你可以通过
<a href="/docs/reference/generated/kubernetes-api/v1.22/#limitrange-v1-core">LimitRange</a>
对象声明 CPU 的最小和最大值. 如果 Pod 不能满足 LimitRange 的限制，它就不能在命名空间中创建。</p>
<h2 id="准备开始">准备开始</h2>
<p><p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
如果你还没有集群，你可以通过 <a href="/zh/docs/tasks/tools/#minikube">Minikube</a> 构建一
个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p>
<!--
You need to have a Kubernetes cluster, and the kubectl command-line tool must
be configured to communicate with your cluster. If you do not already have a
cluster, you can create one by using
[minikube](/docs/tasks/tools/#minikube)
or you can use one of these Kubernetes playgrounds:
-->
<ul>
<li><a href="https://www.katacoda.com/courses/kubernetes/playground">Katacoda</a></li>
<li><a href="http://labs.play-with-k8s.com/">玩转 Kubernetes</a></li>
</ul>
 
 要获知版本信息，请输入 <code>kubectl version</code>.
</p>
<!--
Your cluster must have at least 1 CPU available for use to run the task examples.
-->
<p>你的集群中每个节点至少要有 1 个 CPU 可用才能运行本任务示例。</p>
<!-- steps -->
<!--
## Create a namespace

Create a namespace so that the resources you create in this exercise are
isolated from the rest of your cluster.
-->
<h2 id="创建命名空间">创建命名空间</h2>
<p>创建一个命名空间，以便本练习中创建的资源和集群的其余资源相隔离。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl create namespace constraints-cpu-example
</code></pre></div><!--
## Create a LimitRange and a Pod

Here's the configuration file for a LimitRange:
-->
<h2 id="创建-limitrange-和-pod">创建 LimitRange 和 Pod</h2>
<p>这里给出了 LimitRange 的配置文件：</p>


 













<div class="highlight">
    <div class="copy-code-icon" style="text-align:right">
    <a href="https://raw.githubusercontent.com/kubernetes/website/main/content/zh/examples/admin/resource/cpu-constraints.yaml" download="admin/resource/cpu-constraints.yaml"><code>admin/resource/cpu-constraints.yaml</code>
    </a>
    <img src="/images/copycode.svg" style="max-height:24px; cursor: pointer" onclick="copyCode('admin-resource-cpu-constraints-yaml')" title="Copy admin/resource/cpu-constraints.yaml to clipboard">
    </img>
    </div>
    <div class="includecode" id="admin-resource-cpu-constraints-yaml">
    <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>LimitRange<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>cpu-min-max-demo-lr<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">spec</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">limits</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- <span style="color:#008000;font-weight:bold">max</span>:<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">cpu</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;800m&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">min</span>:<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">cpu</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;200m&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">type</span>:<span style="color:#bbb"> </span>Container<span style="color:#bbb">
</span></code></pre></div>
    </div>
</div>


<!--
Create the LimitRange:
-->
<p>创建 LimitRange:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl apply -f https://k8s.io/examples/admin/resource/cpu-constraints.yaml --namespace<span style="color:#666">=</span>constraints-cpu-example
</code></pre></div><!--
View detailed information about the LimitRange:
-->
<p>查看 LimitRange 详情：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl get limitrange cpu-min-max-demo-lr --output<span style="color:#666">=</span>yaml --namespace<span style="color:#666">=</span>constraints-cpu-example
</code></pre></div><!--
The output shows the minimum and maximum CPU constraints as expected. But
notice that even though you didn't specify default values in the configuration
file for the LimitRange, they were created automatically.
-->
<p>输出结果显示 CPU 的最小和最大限制符合预期。但需要注意的是，尽管你在 LimitRange
的配置文件中你没有声明默认值，默认值也会被自动创建。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">limits</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">default</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">cpu</span>:<span style="color:#bbb"> </span>800m<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">defaultRequest</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">cpu</span>:<span style="color:#bbb"> </span>800m<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">max</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">cpu</span>:<span style="color:#bbb"> </span>800m<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">min</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">cpu</span>:<span style="color:#bbb"> </span>200m<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">type</span>:<span style="color:#bbb"> </span>Container<span style="color:#bbb">
</span></code></pre></div><!--
Now whenever a Container is created in the constraints-cpu-example namespace, Kubernetes
performs these steps:

* If the Container does not specify its own CPU request and limit, assign the default
CPU request and limit to the Container.

* Verify that the Container specifies a CPU request that is greater than or equal to 200 millicpu.

* Verify that the Container specifies a CPU limit that is less than or equal to 800 millicpu.
-->
<p>现在不管什么时候在 constraints-cpu-example 命名空间中创建容器，Kubernetes 都会执行下面这些步骤：</p>
<ul>
<li>
<p>如果容器没有声明自己的 CPU 请求和限制，将为容器指定默认 CPU 请求和限制。</p>
</li>
<li>
<p>核查容器声明的 CPU 请求确保其大于或者等于 200 millicpu。</p>
</li>
<li>
<p>核查容器声明的 CPU 限制确保其小于或者等于 800 millicpu。</p>
</li>
</ul>
<!--
When creating a `LimitRange` object, you can specify limits on huge-pages
or GPUs as well. However, when both `default` and `defaultRequest` are specified
on these resources, the two values must be the same.
-->
<blockquote class="note callout">
  <div><strong>说明：</strong> 当创建 LimitRange 对象时，你也可以声明大页面和 GPU 的限制。
当这些资源同时声明了 'default' 和 'defaultRequest' 参数时，两个参数值必须相同。</div>
</blockquote>
<!--
Here's the configuration file for a Pod that has one Container. The Container manifest
specifies a CPU request of 500 millicpu and a CPU limit of 800 millicpu. These satisfy the
minimum and maximum CPU constraints imposed by the LimitRange.
-->
<p>这里给出了包含一个容器的 Pod 的配置文件。
该容器声明了 500 millicpu 的 CPU 请求和 800 millicpu 的 CPU 限制。
这些参数满足了 LimitRange 对象规定的 CPU 最小和最大限制。</p>


 













<div class="highlight">
    <div class="copy-code-icon" style="text-align:right">
    <a href="https://raw.githubusercontent.com/kubernetes/website/main/content/zh/examples/admin/resource/cpu-constraints-pod.yaml" download="admin/resource/cpu-constraints-pod.yaml"><code>admin/resource/cpu-constraints-pod.yaml</code>
    </a>
    <img src="/images/copycode.svg" style="max-height:24px; cursor: pointer" onclick="copyCode('admin-resource-cpu-constraints-pod-yaml')" title="Copy admin/resource/cpu-constraints-pod.yaml to clipboard">
    </img>
    </div>
    <div class="includecode" id="admin-resource-cpu-constraints-pod-yaml">
    <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>Pod<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>constraints-cpu-demo<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">spec</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">containers</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>constraints-cpu-demo-ctr<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">image</span>:<span style="color:#bbb"> </span>nginx<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">resources</span>:<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">limits</span>:<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#008000;font-weight:bold">cpu</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;800m&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">requests</span>:<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#008000;font-weight:bold">cpu</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;500m&#34;</span><span style="color:#bbb">
</span></code></pre></div>
    </div>
</div>


<!--
Create the Pod:
-->
<p>创建Pod：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl apply -f https://k8s.io/examples/admin/resource/cpu-constraints-pod.yaml --namespace<span style="color:#666">=</span>constraints-cpu-example
</code></pre></div><!--
Verify that the Pod's Container is running:
-->
<p>确认一下 Pod 中的容器在运行：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl get pod constraints-cpu-demo --namespace<span style="color:#666">=</span>constraints-cpu-example
</code></pre></div><!--
View detailed information about the Pod:
-->
<p>查看 Pod 的详情：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl get pod constraints-cpu-demo --output<span style="color:#666">=</span>yaml --namespace<span style="color:#666">=</span>constraints-cpu-example
</code></pre></div><!--
The output shows that the Container has a CPU request of 500 millicpu and CPU limit
of 800 millicpu. These satisfy the constraints imposed by the LimitRange.
-->
<p>输出结果表明容器的 CPU 请求为 500 millicpu，CPU 限制为 800 millicpu。
这些参数满足 LimitRange 规定的限制范围。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">resources</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">limits</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">cpu</span>:<span style="color:#bbb"> </span>800m<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">requests</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">cpu</span>:<span style="color:#bbb"> </span>500m<span style="color:#bbb">
</span></code></pre></div><!--
## Delete the Pod
-->
<h2 id="删除-pod">删除 Pod</h2>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl delete pod constraints-cpu-demo --namespace<span style="color:#666">=</span>constraints-cpu-example
</code></pre></div><!--
## Attempt to create a Pod that exceeds the maximum CPU constraint

Here's the configuration file for a Pod that has one Container. The Container specifies a
CPU request of 500 millicpu and a cpu limit of 1.5 cpu.
-->
<h2 id="尝试创建一个超过最大-cpu-限制的-pod">尝试创建一个超过最大 CPU 限制的 Pod</h2>
<p>这里给出了包含一个容器的 Pod 的配置文件。容器声明了 500 millicpu 的 CPU
请求和 1.5 CPU 的 CPU 限制。</p>


 













<div class="highlight">
    <div class="copy-code-icon" style="text-align:right">
    <a href="https://raw.githubusercontent.com/kubernetes/website/main/content/zh/examples/admin/resource/cpu-constraints-pod-2.yaml" download="admin/resource/cpu-constraints-pod-2.yaml"><code>admin/resource/cpu-constraints-pod-2.yaml</code>
    </a>
    <img src="/images/copycode.svg" style="max-height:24px; cursor: pointer" onclick="copyCode('admin-resource-cpu-constraints-pod-2-yaml')" title="Copy admin/resource/cpu-constraints-pod-2.yaml to clipboard">
    </img>
    </div>
    <div class="includecode" id="admin-resource-cpu-constraints-pod-2-yaml">
    <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>Pod<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>constraints-cpu-demo-2<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">spec</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">containers</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>constraints-cpu-demo-2-ctr<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">image</span>:<span style="color:#bbb"> </span>nginx<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">resources</span>:<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">limits</span>:<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#008000;font-weight:bold">cpu</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;1.5&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">requests</span>:<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#008000;font-weight:bold">cpu</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;500m&#34;</span><span style="color:#bbb">
</span></code></pre></div>
    </div>
</div>


<!--
Attempt to create the Pod:
-->
<p>尝试创建 Pod：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl apply -f https://k8s.io/examples/admin/resource/cpu-constraints-pod-2.yaml --namespace<span style="color:#666">=</span>constraints-cpu-example
</code></pre></div><!--
The output shows that the Pod does not get created, because the Container specifies a CPU limit that is
too large:
-->
<p>输出结果表明 Pod 没有创建成功，因为容器声明的 CPU 限制太大了：</p>
<pre tabindex="0"><code>Error from server (Forbidden): error when creating &quot;examples/admin/resource/cpu-constraints-pod-2.yaml&quot;:
pods &quot;constraints-cpu-demo-2&quot; is forbidden: maximum cpu usage per Container is 800m, but limit is 1500m.
</code></pre><!--
## Attempt to create a Pod that does not meet the minimum CPU request

Here's the configuration file for a Pod that has one Container. The Container specifies a
CPU request of 100 millicpu and a CPU limit of 800 millicpu.
-->
<h2 id="尝试创建一个不满足最小-cpu-请求的-pod">尝试创建一个不满足最小 CPU 请求的 Pod</h2>
<p>这里给出了包含一个容器的 Pod 的配置文件。该容器声明了100 millicpu的 CPU 请求和800 millicpu的 CPU 限制。</p>


 













<div class="highlight">
    <div class="copy-code-icon" style="text-align:right">
    <a href="https://raw.githubusercontent.com/kubernetes/website/main/content/zh/examples/admin/resource/cpu-constraints-pod-3.yaml" download="admin/resource/cpu-constraints-pod-3.yaml"><code>admin/resource/cpu-constraints-pod-3.yaml</code>
    </a>
    <img src="/images/copycode.svg" style="max-height:24px; cursor: pointer" onclick="copyCode('admin-resource-cpu-constraints-pod-3-yaml')" title="Copy admin/resource/cpu-constraints-pod-3.yaml to clipboard">
    </img>
    </div>
    <div class="includecode" id="admin-resource-cpu-constraints-pod-3-yaml">
    <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>Pod<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>constraints-cpu-demo-3<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">spec</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">containers</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>constraints-cpu-demo-3-ctr<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">image</span>:<span style="color:#bbb"> </span>nginx<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">resources</span>:<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">limits</span>:<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#008000;font-weight:bold">cpu</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;800m&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">requests</span>:<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#008000;font-weight:bold">cpu</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;100m&#34;</span><span style="color:#bbb">
</span></code></pre></div>
    </div>
</div>


<!--
Attempt to create the Pod:
-->
<p>尝试创建 Pod：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl apply -f https://k8s.io/examples/admin/resource/cpu-constraints-pod-3.yaml --namespace<span style="color:#666">=</span>constraints-cpu-example
</code></pre></div><!--
The output shows that the Pod does not get created, because the Container specifies a CPU
request that is too small:
-->
<p>输出结果显示 Pod 没有创建成功，因为容器声明的 CPU 请求太小了：</p>
<pre tabindex="0"><code>Error from server (Forbidden): error when creating &quot;examples/admin/resource/cpu-constraints-pod-3.yaml&quot;:
pods &quot;constraints-cpu-demo-4&quot; is forbidden: minimum cpu usage per Container is 200m, but request is 100m.
</code></pre><!--
## Create a Pod that does not specify any CPU request or limit

Here's the configuration file for a Pod that has one Container. The Container does not
specify a CPU request, and it does not specify a CPU limit.
-->
<h2 id="创建一个没有声明-cpu-请求和-cpu-限制的-pod">创建一个没有声明 CPU 请求和 CPU 限制的 Pod</h2>
<p>这里给出了包含一个容器的 Pod 的配置文件。该容器没有设定 CPU 请求和 CPU 限制。</p>


 













<div class="highlight">
    <div class="copy-code-icon" style="text-align:right">
    <a href="https://raw.githubusercontent.com/kubernetes/website/main/content/zh/examples/admin/resource/cpu-constraints-pod-4.yaml" download="admin/resource/cpu-constraints-pod-4.yaml"><code>admin/resource/cpu-constraints-pod-4.yaml</code>
    </a>
    <img src="/images/copycode.svg" style="max-height:24px; cursor: pointer" onclick="copyCode('admin-resource-cpu-constraints-pod-4-yaml')" title="Copy admin/resource/cpu-constraints-pod-4.yaml to clipboard">
    </img>
    </div>
    <div class="includecode" id="admin-resource-cpu-constraints-pod-4-yaml">
    <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>Pod<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>constraints-cpu-demo-4<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">spec</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">containers</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>constraints-cpu-demo-4-ctr<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">image</span>:<span style="color:#bbb"> </span>vish/stress<span style="color:#bbb">
</span></code></pre></div>
    </div>
</div>


<!--
Create the Pod:
-->
<p>创建 Pod：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl apply -f https://k8s.io/examples/admin/resource/cpu-constraints-pod-4.yaml --namespace<span style="color:#666">=</span>constraints-cpu-example
</code></pre></div><!--
View detailed information about the Pod:
-->
<p>查看 Pod 的详情：</p>
<pre tabindex="0"><code>kubectl get pod constraints-cpu-demo-4 --namespace=constraints-cpu-example --output=yaml
</code></pre><!--
The output shows that the Pod's Container has a CPU request of 800 millicpu and a CPU limit of 800 millicpu.
How did the Container get those values?
-->
<p>输出结果显示 Pod 的容器有个 800 millicpu 的 CPU 请求和 800 millicpu 的 CPU 限制。
容器是怎样得到那些值的呢？</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">resources</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">limits</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">cpu</span>:<span style="color:#bbb"> </span>800m<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">requests</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">cpu</span>:<span style="color:#bbb"> </span>800m<span style="color:#bbb">
</span></code></pre></div><!--
Because your Container did not specify its own CPU request and limit, it was given the
[default CPU request and limit](/docs/tasks/administer-cluster/cpu-default-namespace/)
from the LimitRange.
-->
<p>因为你的 Container 没有声明自己的 CPU 请求和限制，LimitRange 给它指定了
<a href="/zh/docs/tasks/administer-cluster/manage-resources/cpu-default-namespace/">默认的 CPU 请求和限制</a></p>
<!--
At this point, your Container might be running or it might not be running. Recall that a prerequisite
for this task is that your Nodes have at least 1 CPU. If each of your Nodes has only
1 CPU, then there might not be enough allocatable CPU on any Node to accommodate a request
of 800 millicpu. If you happen to be using Nodes with 2 CPU, then you probably have
enough CPU to accommodate the 800 millicpu request.

Delete your Pod:
-->
<p>此时，你的容器可能运行也可能没有运行。
回想一下，本任务的先决条件是你的节点要有 1 个 CPU。
如果你的每个节点仅有 1 个 CPU，那么可能没有任何一个节点可以满足 800 millicpu 的 CPU 请求。
如果你在用的节点恰好有两个 CPU，那么你才可能有足够的 CPU 来满足 800 millicpu 的请求。</p>
<pre tabindex="0"><code>kubectl delete pod constraints-cpu-demo-4 --namespace=constraints-cpu-example
</code></pre><!--
## Enforcement of minimum and maximum CPU constraints

The maximum and minimum CPU constraints imposed on a namespace by a LimitRange are enforced only
when a Pod is created or updated. If you change the LimitRange, it does not affect
Pods that were created previously.
-->
<h2 id="cpu-最小和最大限制的强制执行">CPU 最小和最大限制的强制执行</h2>
<p>只有当 Pod 创建或者更新时，LimitRange 为命名空间规定的 CPU 最小和最大限制才会被强制执行。
如果你对 LimitRange 进行修改，那不会影响此前创建的 Pod。</p>
<!--
## Motivation for minimum and maximum CPU constraints

As a cluster administrator, you might want to impose restrictions on the CPU resources that Pods can use.
For example:
-->
<h2 id="最小和最大-cpu-限制范围的动机">最小和最大 CPU 限制范围的动机</h2>
<p>作为集群管理员，你可能想设定 Pod 可以使用的 CPU 资源限制。例如：</p>
<!--
* Each Node in a cluster has 2 CPU. You do not want to accept any Pod that requests
more than 2 CPU, because no Node in the cluster can support the request.

* A cluster is shared by your production and development departments.
You want to allow production workloads to consume up to 3 CPU, but you want development workloads to be limited
to 1 CPU. You create separate namespaces for production and development, and you apply CPU constraints to
each namespace.
-->
<ul>
<li>集群中的每个节点有两个 CPU。你不想接受任何请求超过 2 个 CPU 的 Pod，因为集群中没有节点可以支持这种请求。</li>
<li>你的生产和开发部门共享一个集群。你想允许生产工作负载消耗 3 个 CPU，
而开发部门工作负载的消耗限制为 1 个 CPU。
你可以为生产和开发创建不同的命名空间，并且为每个命名空间都应用 CPU 限制。</li>
</ul>
<!--
## Clean up

Delete your namespace:
-->
<h2 id="清理">清理</h2>
<p>删除你的命名空间：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl delete namespace constraints-cpu-example
</code></pre></div><h2 id="接下来">接下来</h2>
<!--
### For cluster administrators

* [Configure Default Memory Requests and Limits for a Namespace](/docs/tasks/administer-cluster/memory-default-namespace/)

* [Configure Default CPU Requests and Limits for a Namespace](/docs/tasks/administer-cluster/cpu-default-namespace/)

* [Configure Minimum and Maximum Memory Constraints for a Namespace](/docs/tasks/administer-cluster/memory-constraint-namespace/)

* [Configure Memory and CPU Quotas for a Namespace](/docs/tasks/administer-cluster/quota-memory-cpu-namespace/)

* [Configure a Pod Quota for a Namespace](/docs/tasks/administer-cluster/quota-pod-namespace/)

* [Configure Quotas for API Objects](/docs/tasks/administer-cluster/quota-api-object/)
-->
<h3 id="集群管理员参考">集群管理员参考：</h3>
<ul>
<li><a href="/zh/docs/tasks/administer-cluster/manage-resources/memory-default-namespace/">为命名空间配置默认内存请求和限制</a></li>
<li><a href="/zh/docs/tasks/administer-cluster/manage-resources/memory-constraint-namespace/">为命名空间配置内存限制的最小值和最大值</a></li>
<li><a href="/zh/docs/tasks/administer-cluster/manage-resources/cpu-constraint-namespace/">为命名空间配置 CPU 限制的最小值和最大值</a></li>
<li><a href="/zh/docs/tasks/administer-cluster/manage-resources/quota-memory-cpu-namespace/">为命名空间配置内存和 CPU 配额</a></li>
<li><a href="/zh/docs/tasks/administer-cluster/manage-resources/quota-pod-namespace/">为命名空间配置 Pod 配额</a></li>
<li><a href="/zh/docs/tasks/administer-cluster/quota-api-object/">为 API 对象配置配额</a></li>
</ul>
<!--
### For app developers

* [Assign Memory Resources to Containers and Pods](/docs/tasks/configure-pod-container/assign-memory-resource/)
* [Assign CPU Resources to Containers and Pods](/docs/tasks/configure-pod-container/assign-cpu-resource/)
* [Configure Quality of Service for Pods](/docs/tasks/configure-pod-container/quality-service-pod/)
-->
<h3 id="应用开发者参考">应用开发者参考：</h3>
<ul>
<li><a href="/zh/docs/tasks/configure-pod-container/assign-memory-resource/">为容器和 Pod 分配内存资源</a></li>
<li><a href="/zh/docs/tasks/configure-pod-container/assign-cpu-resource/">为容器和 Pod 分配 CPU 资源</a></li>
<li><a href="/zh/docs/tasks/configure-pod-container/quality-service-pod/">为 Pod 配置服务质量</a></li>
</ul>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-fe3283559a3df299aae3ee00ecea2fad">3.5 - 为命名空间配置内存和 CPU 配额</h1>
    
	<!--
title: Configure Memory and CPU Quotas for a Namespace
content_type: task
weight: 50
-->
<!-- overview -->
<!--
This page shows how to set quotas for the total amount memory and CPU that
can be used by all Containers running in a namespace. You specify quotas in a
[ResourceQuota](/docs/reference/generated/kubernetes-api/v1.22/#resourcequota-v1-core)
object.
-->
<p>本文介绍怎样为命名空间设置容器可用的内存和 CPU 总量。你可以通过
<a href="/docs/reference/generated/kubernetes-api/v1.22/#resourcequota-v1-core">ResourceQuota</a>
对象设置配额.</p>
<h2 id="准备开始">准备开始</h2>
<p><p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
如果你还没有集群，你可以通过 <a href="/zh/docs/tasks/tools/#minikube">Minikube</a> 构建一
个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p>
<!--
You need to have a Kubernetes cluster, and the kubectl command-line tool must
be configured to communicate with your cluster. If you do not already have a
cluster, you can create one by using
[minikube](/docs/tasks/tools/#minikube)
or you can use one of these Kubernetes playgrounds:
-->
<ul>
<li><a href="https://www.katacoda.com/courses/kubernetes/playground">Katacoda</a></li>
<li><a href="http://labs.play-with-k8s.com/">玩转 Kubernetes</a></li>
</ul>
 
 要获知版本信息，请输入 <code>kubectl version</code>.
</p>
<!--
Each node in your cluster must have at least 1 GiB of memory.
-->
<p>集群中每个节点至少有 1 GiB 的内存。</p>
<!-- steps -->
<!--
## Create a namespace

Create a namespace so that the resources you create in this exercise are
isolated from the rest of your cluster.
-->
<h2 id="创建命名空间">创建命名空间</h2>
<p>创建一个命名空间，以便本练习中创建的资源和集群的其余部分相隔离。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl create namespace quota-mem-cpu-example
</code></pre></div><!--
## Create a ResourceQuota

Here is the configuration file for a ResourceQuota object:
-->
<h2 id="创建-resourcequota">创建 ResourceQuota</h2>
<p>这里给出一个 ResourceQuota 对象的配置文件：</p>


 













<div class="highlight">
    <div class="copy-code-icon" style="text-align:right">
    <a href="https://raw.githubusercontent.com/kubernetes/website/main/content/zh/examples/admin/resource/quota-mem-cpu.yaml" download="admin/resource/quota-mem-cpu.yaml"><code>admin/resource/quota-mem-cpu.yaml</code>
    </a>
    <img src="/images/copycode.svg" style="max-height:24px; cursor: pointer" onclick="copyCode('admin-resource-quota-mem-cpu-yaml')" title="Copy admin/resource/quota-mem-cpu.yaml to clipboard">
    </img>
    </div>
    <div class="includecode" id="admin-resource-quota-mem-cpu-yaml">
    <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>ResourceQuota<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>mem-cpu-demo<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">spec</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">hard</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">requests.cpu</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;1&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">requests.memory</span>:<span style="color:#bbb"> </span>1Gi<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">limits.cpu</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;2&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">limits.memory</span>:<span style="color:#bbb"> </span>2Gi<span style="color:#bbb">
</span></code></pre></div>
    </div>
</div>


<!--
Create the ResourceQuota:
-->
<p>创建 ResourceQuota</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl apply -f https://k8s.io/examples/admin/resource/quota-mem-cpu.yaml --namespace<span style="color:#666">=</span>quota-mem-cpu-example
</code></pre></div><!--
View detailed information about the ResourceQuota:
-->
<p>查看 ResourceQuota 详情：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl get resourcequota mem-cpu-demo --namespace<span style="color:#666">=</span>quota-mem-cpu-example --output<span style="color:#666">=</span>yaml
</code></pre></div><!--
The ResourceQuota places these requirements on the quota-mem-cpu-example namespace:

* Every Container must have a memory request, memory limit, cpu request, and cpu limit.
* The memory request total for all Containers must not exceed 1 GiB.
* The memory limit total for all Containers must not exceed 2 GiB.
* The CPU request total for all Containers must not exceed 1 cpu.
* The CPU limit total for all Containers must not exceed 2 cpu.
-->
<p>ResourceQuota 在 quota-mem-cpu-example 命名空间中设置了如下要求：</p>
<ul>
<li>每个容器必须有内存请求和限制，以及 CPU 请求和限制。</li>
<li>所有容器的内存请求总和不能超过1 GiB。</li>
<li>所有容器的内存限制总和不能超过2 GiB。</li>
<li>所有容器的 CPU 请求总和不能超过1 cpu。</li>
<li>所有容器的 CPU 限制总和不能超过2 cpu。</li>
</ul>
<!--
## Create a Pod

Here is the configuration file for a Pod:
-->
<h2 id="创建-pod">创建 Pod</h2>
<p>这里给出 Pod 的配置文件：</p>


 













<div class="highlight">
    <div class="copy-code-icon" style="text-align:right">
    <a href="https://raw.githubusercontent.com/kubernetes/website/main/content/zh/examples/admin/resource/quota-mem-cpu-pod.yaml" download="admin/resource/quota-mem-cpu-pod.yaml"><code>admin/resource/quota-mem-cpu-pod.yaml</code>
    </a>
    <img src="/images/copycode.svg" style="max-height:24px; cursor: pointer" onclick="copyCode('admin-resource-quota-mem-cpu-pod-yaml')" title="Copy admin/resource/quota-mem-cpu-pod.yaml to clipboard">
    </img>
    </div>
    <div class="includecode" id="admin-resource-quota-mem-cpu-pod-yaml">
    <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>Pod<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>quota-mem-cpu-demo<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">spec</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">containers</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>quota-mem-cpu-demo-ctr<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">image</span>:<span style="color:#bbb"> </span>nginx<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">resources</span>:<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">limits</span>:<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#008000;font-weight:bold">memory</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;800Mi&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#008000;font-weight:bold">cpu</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;800m&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">requests</span>:<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#008000;font-weight:bold">memory</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;600Mi&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#008000;font-weight:bold">cpu</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;400m&#34;</span><span style="color:#bbb">
</span></code></pre></div>
    </div>
</div>


<!--
Create the Pod:
-->
<p>创建 Pod：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl apply -f https://k8s.io/examples/admin/resource/quota-mem-cpu-pod.yaml --namespace<span style="color:#666">=</span>quota-mem-cpu-example
</code></pre></div><!--
Verify that the Pod's Container is running:
-->
<p>检查下 Pod 中的容器在运行：</p>
<pre tabindex="0"><code>kubectl get pod quota-mem-cpu-demo --namespace=quota-mem-cpu-example
</code></pre><!--
Once again, view detailed information about the ResourceQuota:
-->
<p>再查看 ResourceQuota 的详情：</p>
<pre tabindex="0"><code>kubectl get resourcequota mem-cpu-demo --namespace=quota-mem-cpu-example --output=yaml
</code></pre><!--
The output shows the quota along with how much of the quota has been used.
You can see that the memory and CPU requests and limits for your Pod do not
exceed the quota.
-->
<p>输出结果显示了配额以及有多少配额已经被使用。你可以看到 Pod 的内存和 CPU 请求值及限制值没有超过配额。</p>
<pre tabindex="0"><code>status:
  hard:
    limits.cpu: &quot;2&quot;
    limits.memory: 2Gi
    requests.cpu: &quot;1&quot;
    requests.memory: 1Gi
  used:
    limits.cpu: 800m
    limits.memory: 800Mi
    requests.cpu: 400m
    requests.memory: 600Mi
</code></pre><!--
## Attempt to create a second Pod

Here is the configuration file for a second Pod:
-->
<h2 id="尝试创建第二个-pod">尝试创建第二个 Pod</h2>
<p>这里给出了第二个 Pod 的配置文件：</p>


 













<div class="highlight">
    <div class="copy-code-icon" style="text-align:right">
    <a href="https://raw.githubusercontent.com/kubernetes/website/main/content/zh/examples/admin/resource/quota-mem-cpu-pod-2.yaml" download="admin/resource/quota-mem-cpu-pod-2.yaml"><code>admin/resource/quota-mem-cpu-pod-2.yaml</code>
    </a>
    <img src="/images/copycode.svg" style="max-height:24px; cursor: pointer" onclick="copyCode('admin-resource-quota-mem-cpu-pod-2-yaml')" title="Copy admin/resource/quota-mem-cpu-pod-2.yaml to clipboard">
    </img>
    </div>
    <div class="includecode" id="admin-resource-quota-mem-cpu-pod-2-yaml">
    <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>Pod<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>quota-mem-cpu-demo-2<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">spec</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">containers</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>quota-mem-cpu-demo-2-ctr<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">image</span>:<span style="color:#bbb"> </span>redis<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">resources</span>:<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">limits</span>:<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#008000;font-weight:bold">memory</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;1Gi&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#008000;font-weight:bold">cpu</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;800m&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">requests</span>:<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#008000;font-weight:bold">memory</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;700Mi&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#008000;font-weight:bold">cpu</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;400m&#34;</span><span style="color:#bbb">
</span></code></pre></div>
    </div>
</div>


<!--
In the configuration file, you can see that the Pod has a memory request of 700 MiB.
Notice that the sum of the used memory request and this new memory
request exceeds the memory request quota. 600 MiB + 700 MiB > 1 GiB.

Attempt to create the Pod:
-->
<p>配置文件中，你可以看到 Pod 的内存请求为 700 MiB。
请注意新的内存请求与已经使用的内存请求只和超过了内存请求的配额。
600 MiB + 700 MiB &gt; 1 GiB。</p>
<p>尝试创建 Pod：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl apply -f https://k8s.io/examples/admin/resource/quota-mem-cpu-pod-2.yaml --namespace<span style="color:#666">=</span>quota-mem-cpu-example
</code></pre></div><!--
The second Pod does not get created. The output shows that creating the second Pod
would cause the memory request total to exceed the memory request quota.
-->
<p>第二个 Pod 不能被创建成功。输出结果显示创建第二个 Pod 会导致内存请求总量超过内存请求配额。</p>
<pre tabindex="0"><code>Error from server (Forbidden): error when creating &quot;examples/admin/resource/quota-mem-cpu-pod-2.yaml&quot;:
pods &quot;quota-mem-cpu-demo-2&quot; is forbidden: exceeded quota: mem-cpu-demo,
requested: requests.memory=700Mi,used: requests.memory=600Mi, limited: requests.memory=1Gi
</code></pre><!--
## Discussion

As you have seen in this exercise, you can use a ResourceQuota to restrict
the memory request total for all Containers running in a namespace.
You can also restrict the totals for memory limit, cpu request, and cpu limit.

If you want to restrict individual Containers, instead of totals for all Containers, use a
[LimitRange](/docs/tasks/administer-cluster/memory-constraint-namespace/).
-->
<h2 id="讨论">讨论</h2>
<p>如你在本练习中所见，你可以用 ResourceQuota 限制命名空间中所有容器的内存请求总量。
同样你也可以限制内存限制总量、CPU 请求总量、CPU 限制总量。</p>
<p>如果你想对单个容器而不是所有容器进行限制，就请使用
<a href="/zh/docs/tasks/administer-cluster/manage-resources/memory-constraint-namespace/">LimitRange</a>。</p>
<!--
## Clean up

Delete your namespace:
-->
<h2 id="清理">清理</h2>
<p>删除你的命名空间：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl delete namespace quota-mem-cpu-example
</code></pre></div><h2 id="接下来">接下来</h2>
<!--
### For cluster administrators

* [Configure Default Memory Requests and Limits for a Namespace](/docs/tasks/administer-cluster/memory-default-namespace/)
* [Configure Default CPU Requests and Limits for a Namespace](/docs/tasks/administer-cluster/cpu-default-namespace/)
* [Configure Minimum and Maximum Memory Constraints for a Namespace](/docs/tasks/administer-cluster/memory-constraint-namespace/)
* [Configure Minimum and Maximum CPU Constraints for a Namespace](/docs/tasks/administer-cluster/cpu-constraint-namespace/)
* [Configure a Pod Quota for a Namespace](/docs/tasks/administer-cluster/quota-pod-namespace/)
* [Configure Quotas for API Objects](/docs/tasks/administer-cluster/quota-api-object/)
-->
<h3 id="集群管理员参考">集群管理员参考</h3>
<ul>
<li><a href="/zh/docs/tasks/administer-cluster/manage-resources/memory-default-namespace/">为命名空间配置默认内存请求和限制</a></li>
<li><a href="/zh/docs/tasks/administer-cluster/manage-resources/memory-constraint-namespace/">为命名空间配置内存限制的最小值和最大值</a></li>
<li><a href="/zh/docs/tasks/administer-cluster/manage-resources/cpu-constraint-namespace/">为命名空间配置 CPU 限制的最小值和最大值</a></li>
<li><a href="/zh/docs/tasks/administer-cluster/manage-resources/quota-memory-cpu-namespace/">为命名空间配置内存和 CPU 配额</a></li>
<li><a href="/zh/docs/tasks/administer-cluster/manage-resources/quota-pod-namespace/">为命名空间配置 Pod 配额</a></li>
<li><a href="/zh/docs/tasks/administer-cluster/quota-api-object/">为 API 对象配置配额</a></li>
</ul>
<!--
### For app developers

* [Assign Memory Resources to Containers and Pods](/docs/tasks/configure-pod-container/assign-memory-resource/)
* [Assign CPU Resources to Containers and Pods](/docs/tasks/configure-pod-container/assign-cpu-resource/)
* [Configure Quality of Service for Pods](/docs/tasks/configure-pod-container/quality-service-pod/)
-->
<h3 id="应用开发者参考">应用开发者参考</h3>
<ul>
<li><a href="/zh/docs/tasks/configure-pod-container/assign-memory-resource/">为容器和 Pod 分配内存资源</a></li>
<li><a href="/zh/docs/tasks/configure-pod-container/assign-cpu-resource/">为容器和 Pod 分配CPU资源</a></li>
<li><a href="/zh/docs/tasks/configure-pod-container/quality-service-pod/">为 Pod 配置服务质量</a></li>
</ul>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-40e30a9209e0c9f4153707e43243e9d7">3.6 - 配置命名空间下 Pod 配额</h1>
    
	<!-- overview -->
<!--
This page shows how to set a quota for the total number of Pods that can run
in a namespace. You specify quotas in a
[ResourceQuota](/docs/reference/generated/kubernetes-api/v1.22/#resourcequota-v1-core)
object.
-->
<p>本文主要描述如何配置一个命名空间下可运行的 Pod 个数配额。
你可以使用
<a href="/docs/reference/generated/kubernetes-api/v1.22/#resourcequota-v1-core">ResourceQuota</a>
对象来配置配额。</p>
<h2 id="准备开始">准备开始</h2>
<p><p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
如果你还没有集群，你可以通过 <a href="/zh/docs/tasks/tools/#minikube">Minikube</a> 构建一
个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p>
<!--
You need to have a Kubernetes cluster, and the kubectl command-line tool must
be configured to communicate with your cluster. If you do not already have a
cluster, you can create one by using
[minikube](/docs/tasks/tools/#minikube)
or you can use one of these Kubernetes playgrounds:
-->
<ul>
<li><a href="https://www.katacoda.com/courses/kubernetes/playground">Katacoda</a></li>
<li><a href="http://labs.play-with-k8s.com/">玩转 Kubernetes</a></li>
</ul>
 
 要获知版本信息，请输入 <code>kubectl version</code>.
</p>
<!-- steps -->
<!--
## Create a namespace

Create a namespace so that the resources you create in this exercise are
isolated from the rest of your cluster.
-->
<h2 id="创建一个命名空间">创建一个命名空间</h2>
<p>首先创建一个命名空间，这样可以将本次操作中创建的资源与集群其他资源隔离开来。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl create namespace quota-pod-example
</code></pre></div><!--
## Create a ResourceQuota

Here is the configuration file for a ResourceQuota object:
-->
<h2 id="创建-resourcequota">创建 ResourceQuota</h2>
<p>下面是一个 ResourceQuota 的配置文件：</p>


 













<div class="highlight">
    <div class="copy-code-icon" style="text-align:right">
    <a href="https://raw.githubusercontent.com/kubernetes/website/main/content/zh/examples/admin/resource/quota-pod.yaml" download="admin/resource/quota-pod.yaml"><code>admin/resource/quota-pod.yaml</code>
    </a>
    <img src="/images/copycode.svg" style="max-height:24px; cursor: pointer" onclick="copyCode('admin-resource-quota-pod-yaml')" title="Copy admin/resource/quota-pod.yaml to clipboard">
    </img>
    </div>
    <div class="includecode" id="admin-resource-quota-pod-yaml">
    <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>ResourceQuota<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>pod-demo<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">spec</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">hard</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">pods</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;2&#34;</span><span style="color:#bbb">
</span></code></pre></div>
    </div>
</div>


<!-- 创建 ResourceQuota: -->
<p>创建这个 ResourceQuota：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl apply -f https://k8s.io/examples/admin/resource/quota-pod.yaml --namespace<span style="color:#666">=</span>quota-pod-example
</code></pre></div><!--
View detailed information about the ResourceQuota:
-->
<p>查看资源配额的详细信息：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl get resourcequota pod-demo --namespace<span style="color:#666">=</span>quota-pod-example --output<span style="color:#666">=</span>yaml
</code></pre></div><!--
The output shows that the namespace has a quota of two Pods, and that currently there are
no Pods; that is, none of the quota is used.
-->
<p>从输出的信息我们可以看到，该命名空间下 Pod 的配额是 2 个，目前创建的 Pod 数为 0，
配额使用率为 0。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">spec</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">hard</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">pods</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;2&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">status</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">hard</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">pods</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;2&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">used</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">pods</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;0&#34;</span><span style="color:#bbb">
</span></code></pre></div><!--
Here is the configuration file for a Deployment:
-->
<p>下面是一个 Deployment 的配置文件：</p>


 













<div class="highlight">
    <div class="copy-code-icon" style="text-align:right">
    <a href="https://raw.githubusercontent.com/kubernetes/website/main/content/zh/examples/admin/resource/quota-pod-deployment.yaml" download="admin/resource/quota-pod-deployment.yaml"><code>admin/resource/quota-pod-deployment.yaml</code>
    </a>
    <img src="/images/copycode.svg" style="max-height:24px; cursor: pointer" onclick="copyCode('admin-resource-quota-pod-deployment-yaml')" title="Copy admin/resource/quota-pod-deployment.yaml to clipboard">
    </img>
    </div>
    <div class="includecode" id="admin-resource-quota-pod-deployment-yaml">
    <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>apps/v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>Deployment<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>pod-quota-demo<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">spec</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">selector</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">matchLabels</span>:<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">purpose</span>:<span style="color:#bbb"> </span>quota-demo<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">replicas</span>:<span style="color:#bbb"> </span><span style="color:#666">3</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">template</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">labels</span>:<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#008000;font-weight:bold">purpose</span>:<span style="color:#bbb"> </span>quota-demo<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">spec</span>:<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">containers</span>:<span style="color:#bbb">
</span><span style="color:#bbb">      </span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>pod-quota-demo<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#008000;font-weight:bold">image</span>:<span style="color:#bbb"> </span>nginx<span style="color:#bbb">
</span></code></pre></div>
    </div>
</div>


<!--
In the configuration file, `replicas: 3` tells Kubernetes to attempt to create three Pods, all running the same application.

Create the Deployment:
-->
<p>在配置文件中，<code>replicas: 3</code> 告诉 Kubernetes 尝试创建三个 Pods，且运行相同的应用。</p>
<p>创建这个 Deployment：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl apply -f https://k8s.io/examples/admin/resource/quota-pod-deployment.yaml --namespace<span style="color:#666">=</span>quota-pod-example
</code></pre></div><!--
View detailed information about the Deployment:
-->
<p>查看 Deployment 的详细信息：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl get deployment pod-quota-demo --namespace<span style="color:#666">=</span>quota-pod-example --output<span style="color:#666">=</span>yaml
</code></pre></div><!--
The output shows that even though the Deployment specifies three replicas, only two
Pods were created because of the quota.
-->
<p>从输出的信息我们可以看到，尽管尝试创建三个 Pod，但是由于配额的限制，只有两个 Pod 能被成功创建。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">spec</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>...<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">replicas</span>:<span style="color:#bbb"> </span><span style="color:#666">3</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#00f;font-weight:bold">...</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">status</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">availableReplicas</span>:<span style="color:#bbb"> </span><span style="color:#666">2</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#00f;font-weight:bold">...</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">lastUpdateTime</span>:<span style="color:#bbb"> </span>2017-07-07T20:57:05Z<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">message: &#39;unable to create pods</span>:<span style="color:#bbb"> </span>pods &#34;pod-quota-demo-1650323038-&#34; is forbidden:<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">exceeded quota: pod-demo, requested: pods=1, used: pods=2, limited</span>:<span style="color:#bbb"> </span>pods=2&#39;<span style="color:#bbb">
</span></code></pre></div><!--
## Clean up

Delete your namespace:
-->
<h2 id="清理">清理</h2>
<p>删除命名空间：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl delete namespace quota-pod-example
</code></pre></div><h2 id="接下来">接下来</h2>
<!--
### For cluster administrators

* [Configure Default Memory Requests and Limits for a Namespace](/docs/tasks/administer-cluster/manage-resources/memory-default-namespace/)
* [Configure Default CPU Requests and Limits for a Namespace](/docs/tasks/administer-cluster/manage-resources/cpu-default-namespace/)
* [Configure Minimum and Maximum Memory Constraints for a Namespace](/docs/tasks/administer-cluster/manage-resources/memory-constraint-namespace/)
* [Configure Minimum and Maximum CPU Constraints for a Namespace](/docs/tasks/administer-cluster/manage-resources/cpu-constraint-namespace/)
* [Configure Memory and CPU Quotas for a Namespace](/docs/tasks/administer-cluster/manage-resources/quota-memory-cpu-namespace/)
* [Configure Quotas for API Objects](/docs/tasks/administer-cluster/quota-api-object/)
-->
<h3 id="集群管理人员参考">集群管理人员参考</h3>
<ul>
<li><a href="/zh/docs/tasks/administer-cluster/manage-resources/memory-default-namespace/">为命名空间配置默认的内存请求和限制</a></li>
<li><a href="/zh/docs/tasks/administer-cluster/manage-resources/cpu-default-namespace/">为命名空间配置默认的的 CPU 请求和限制</a></li>
<li><a href="/zh/docs/tasks/administer-cluster/manage-resources/memory-constraint-namespace/">为命名空间配置内存的最小值和最大值约束</a></li>
<li><a href="/zh/docs/tasks/administer-cluster/manage-resources/cpu-constraint-namespace/">为命名空间配置 CPU 的最小值和最大值约束</a></li>
<li><a href="/zh/docs/tasks/administer-cluster/manage-resources/quota-memory-cpu-namespace/">为命名空间配置内存和 CPU 配额</a></li>
<li><a href="/zh/docs/tasks/administer-cluster/quota-api-object/">为 API 对象的设置配额</a></li>
</ul>
<!--
### For app developers

* [Assign Memory Resources to Containers and Pods](/docs/tasks/configure-pod-container/assign-memory-resource/)
* [Assign CPU Resources to Containers and Pods](/docs/tasks/configure-pod-container/assign-cpu-resource/)
* [Configure Quality of Service for Pods](/docs/tasks/configure-pod-container/quality-service-pod/)
-->
<h3 id="应用开发人员参考">应用开发人员参考</h3>
<ul>
<li><a href="/zh/docs/tasks/configure-pod-container/assign-memory-resource/">为容器和 Pod 分配内存资源</a></li>
<li><a href="/zh/docs/tasks/configure-pod-container/assign-cpu-resource/">给容器和 Pod 分配 CPU 资源</a></li>
<li><a href="/zh/docs/tasks/configure-pod-container/quality-service-pod/">配置 Pod 的服务质量</a></li>
</ul>

</div>



    
	
  

    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-7743f043c43f7b12e8654e2227dbc658">4 - 证书</h1>
    
	<!-- 
---
title: Certificates
content_type: task
weight: 20
---
-->
<!-- overview -->
<!-- 
When using client certificate authentication, you can generate certificates
manually through `easyrsa`, `openssl` or `cfssl`.
-->
<p>在使用客户端证书认证的场景下，你可以通过 <code>easyrsa</code>、<code>openssl</code> 或 <code>cfssl</code> 等工具以手工方式生成证书。</p>
<!-- body -->
<h3 id="easyrsa">easyrsa</h3>
<!-- 
**easyrsa** can manually generate certificates for your cluster.
-->
<p><strong>easyrsa</strong> 支持以手工方式为你的集群生成证书。</p>
<!-- 
1.  Download, unpack, and initialize the patched version of easyrsa3.
-->
<ol>
<li>
<p>下载、解压、初始化打过补丁的 easyrsa3。</p>
<pre><code>curl -LO https://storage.googleapis.com/kubernetes-release/easy-rsa/easy-rsa.tar.gz
tar xzf easy-rsa.tar.gz
cd easy-rsa-master/easyrsa3
./easyrsa init-pki
</code></pre>
<!-- 
1.  Generate a new certificate authority (CA). `--batch` sets automatic mode;
`--req-cn` specifies the Common Name (CN) for the CA's new root certificate.
-->
</li>
<li>
<p>生成新的证书颁发机构（CA）。参数 <code>--batch</code> 用于设置自动模式；
参数 <code>--req-cn</code> 用于设置新的根证书的通用名称（CN）。</p>
<pre><code>./easyrsa --batch &quot;--req-cn=${MASTER_IP}@`date +%s`&quot; build-ca nopass
</code></pre>
<!-- 
1.  Generate server certificate and key.
The argument `--subject-alt-name` sets the possible IPs and DNS names the API server will
be accessed with. The `MASTER_CLUSTER_IP` is usually the first IP from the service CIDR
that is specified as the `--service-cluster-ip-range` argument for both the API server and
the controller manager component. The argument `--days` is used to set the number of days
after which the certificate expires.
The sample below also assumes that you are using `cluster.local` as the default
DNS domain name.
-->
</li>
<li>
<p>生成服务器证书和秘钥。
参数 <code>--subject-alt-name</code> 设置 API 服务器的 IP 和 DNS 名称。
<code>MASTER_CLUSTER_IP</code> 用于 API 服务器和控制管理器，通常取 CIDR 的第一个 IP，由 <code>--service-cluster-ip-range</code> 的参数提供。
参数 <code>--days</code> 用于设置证书的过期时间。
下面的示例假定你的默认 DNS 域名为 <code>cluster.local</code>。</p>
<pre><code>./easyrsa --subject-alt-name=&quot;IP:${MASTER_IP},&quot;\
&quot;IP:${MASTER_CLUSTER_IP},&quot;\
&quot;DNS:kubernetes,&quot;\
&quot;DNS:kubernetes.default,&quot;\
&quot;DNS:kubernetes.default.svc,&quot;\
&quot;DNS:kubernetes.default.svc.cluster,&quot;\
&quot;DNS:kubernetes.default.svc.cluster.local&quot; \
--days=10000 \
build-server-full server nopass
</code></pre>
<!-- 
1.  Copy `pki/ca.crt`, `pki/issued/server.crt`, and `pki/private/server.key` to your directory.
1.  Fill in and add the following parameters into the API server start parameters:
-->
</li>
<li>
<p>拷贝文件 <code>pki/ca.crt</code>、<code>pki/issued/server.crt</code> 和 <code>pki/private/server.key</code> 到你的目录中。</p>
</li>
<li>
<p>在 API 服务器的启动参数中添加以下参数：</p>
<pre><code>--client-ca-file=/yourdirectory/ca.crt
--tls-cert-file=/yourdirectory/server.crt
--tls-private-key-file=/yourdirectory/server.key
</code></pre>
</li>
</ol>
<h3 id="openssl">openssl</h3>
<!-- 
**openssl** can manually generate certificates for your cluster.
-->
<p><strong>openssl</strong> 支持以手工方式为你的集群生成证书。</p>
<!-- 
1.  Generate a ca.key with 2048bit:
-->
<ol>
<li>
<p>生成一个 2048 位的 ca.key 文件</p>
<pre><code>openssl genrsa -out ca.key 2048
</code></pre>
<!-- 
1.  According to the ca.key generate a ca.crt (use -days to set the certificate effective time):
-->
</li>
<li>
<p>在 ca.key 文件的基础上，生成 ca.crt 文件（用参数 -days 设置证书有效期）</p>
<pre><code>openssl req -x509 -new -nodes -key ca.key -subj &quot;/CN=${MASTER_IP}&quot; -days 10000 -out ca.crt
</code></pre>
<!-- 
1.  Generate a server.key with 2048bit:
-->
</li>
<li>
<p>生成一个 2048 位的 server.key 文件：</p>
<pre><code>openssl genrsa -out server.key 2048
</code></pre>
<!-- 
1.  Create a config file for generating a Certificate Signing Request (CSR).
Be sure to substitute the values marked with angle brackets (e.g. `<MASTER_IP>`)
with real values before saving this to a file (e.g. `csr.conf`).
Note that the value for `MASTER_CLUSTER_IP` is the service cluster IP for the
API server as described in previous subsection.
The sample below also assumes that you are using `cluster.local` as the default
DNS domain name.
-->
</li>
<li>
<p>创建一个用于生成证书签名请求（CSR）的配置文件。
保存文件（例如：<code>csr.conf</code>）前，记得用真实值替换掉尖括号中的值（例如：<code>&lt;MASTER_IP&gt;</code>）。
注意：<code>MASTER_CLUSTER_IP</code> 就像前一小节所述，它的值是 API 服务器的服务集群 IP。
下面的例子假定你的默认 DNS 域名为 <code>cluster.local</code>。</p>
<pre><code>[ req ]
default_bits = 2048
prompt = no
default_md = sha256
req_extensions = req_ext
distinguished_name = dn

[ dn ]
C = &lt;country&gt;
ST = &lt;state&gt;
L = &lt;city&gt;
O = &lt;organization&gt;
OU = &lt;organization unit&gt;
CN = &lt;MASTER_IP&gt;

[ req_ext ]
subjectAltName = @alt_names

[ alt_names ]
DNS.1 = kubernetes
DNS.2 = kubernetes.default
DNS.3 = kubernetes.default.svc
DNS.4 = kubernetes.default.svc.cluster
DNS.5 = kubernetes.default.svc.cluster.local
IP.1 = &lt;MASTER_IP&gt;
IP.2 = &lt;MASTER_CLUSTER_IP&gt;

[ v3_ext ]
authorityKeyIdentifier=keyid,issuer:always
basicConstraints=CA:FALSE
keyUsage=keyEncipherment,dataEncipherment
extendedKeyUsage=serverAuth,clientAuth
subjectAltName=@alt_names
</code></pre>
<!-- 
1.  Generate the certificate signing request based on the config file:
-->
</li>
<li>
<p>基于上面的配置文件生成证书签名请求：</p>
<pre><code>openssl req -new -key server.key -out server.csr -config csr.conf
</code></pre>
<!-- 
1.  Generate the server certificate using the ca.key, ca.crt and server.csr:
-->
</li>
<li>
<p>基于 ca.key、ca.key 和 server.csr 等三个文件生成服务端证书：</p>
<pre><code>openssl x509 -req -in server.csr -CA ca.crt -CAkey ca.key \
-CAcreateserial -out server.crt -days 10000 \
-extensions v3_ext -extfile csr.conf
</code></pre>
<!-- 
1.  View the certificate:
-->
</li>
<li>
<p>查看证书：</p>
<pre><code>openssl x509  -noout -text -in ./server.crt
</code></pre>
</li>
</ol>
<!-- 
Finally, add the same parameters into the API server start parameters.
-->
<p>最后，为 API 服务器添加相同的启动参数。</p>
<h3 id="cfssl">cfssl</h3>
<!-- 
**cfssl** is another tool for certificate generation.
-->
<p><strong>cfssl</strong> 是另一个用于生成证书的工具。</p>
<!-- 
1.  Download, unpack and prepare the command line tools as shown below.
    Note that you may need to adapt the sample commands based on the hardware
    architecture and cfssl version you are using.
-->
<ol>
<li>
<p>下载、解压并准备如下所示的命令行工具。
注意：你可能需要根据所用的硬件体系架构和 cfssl 版本调整示例命令。</p>
<pre><code>curl -L https://github.com/cloudflare/cfssl/releases/download/v1.5.0/cfssl_1.5.0_linux_amd64 -o cfssl
chmod +x cfssl
curl -L https://github.com/cloudflare/cfssl/releases/download/v1.5.0/cfssljson_1.5.0_linux_amd64 -o cfssljson
chmod +x cfssljson
curl -L https://github.com/cloudflare/cfssl/releases/download/v1.5.0/cfssl-certinfo_1.5.0_linux_amd64 -o cfssl-certinfo
chmod +x cfssl-certinfo
</code></pre>
<!-- 
1.  Create a directory to hold the artifacts and initialize cfssl:
-->
</li>
<li>
<p>创建一个目录，用它保存所生成的构件和初始化 cfssl：</p>
<pre><code>mkdir cert
cd cert
../cfssl print-defaults config &gt; config.json
../cfssl print-defaults csr &gt; csr.json
</code></pre>
<!-- 
1.  Create a JSON config file for generating the CA file, for example, `ca-config.json`:
-->
</li>
<li>
<p>创建一个 JSON 配置文件来生成 CA 文件，例如：<code>ca-config.json</code>：</p>
<pre><code>{
  &quot;signing&quot;: {
    &quot;default&quot;: {
      &quot;expiry&quot;: &quot;8760h&quot;
    },
    &quot;profiles&quot;: {
      &quot;kubernetes&quot;: {
        &quot;usages&quot;: [
          &quot;signing&quot;,
          &quot;key encipherment&quot;,
          &quot;server auth&quot;,
          &quot;client auth&quot;
        ],
        &quot;expiry&quot;: &quot;8760h&quot;
      }
    }
  }
}
</code></pre>
<!-- 
1.  Create a JSON config file for CA certificate signing request (CSR), for example,
`ca-csr.json`. Be sure to replace the values marked with angle brackets with
real values you want to use.
-->
</li>
<li>
<p>创建一个 JSON 配置文件，用于 CA 证书签名请求（CSR），例如：<code>ca-csr.json</code>。
确认用你需要的值替换掉尖括号中的值。</p>
<pre><code>{
  &quot;CN&quot;: &quot;kubernetes&quot;,
  &quot;key&quot;: {
    &quot;algo&quot;: &quot;rsa&quot;,
    &quot;size&quot;: 2048
  },
  &quot;names&quot;:[{
    &quot;C&quot;: &quot;&lt;country&gt;&quot;,
    &quot;ST&quot;: &quot;&lt;state&gt;&quot;,
    &quot;L&quot;: &quot;&lt;city&gt;&quot;,
    &quot;O&quot;: &quot;&lt;organization&gt;&quot;,
    &quot;OU&quot;: &quot;&lt;organization unit&gt;&quot;
  }]
}
</code></pre>
<!-- 
1.  Generate CA key (`ca-key.pem`) and certificate (`ca.pem`):
-->
</li>
<li>
<p>生成 CA 秘钥文件（<code>ca-key.pem</code>）和证书文件（<code>ca.pem</code>）：</p>
<pre><code>../cfssl gencert -initca ca-csr.json | ../cfssljson -bare ca
</code></pre>
<!-- 
1.  Create a JSON config file for generating keys and certificates for the API
server, for example, `server-csr.json`. Be sure to replace the values in angle brackets with
real values you want to use. The `MASTER_CLUSTER_IP` is the service cluster
IP for the API server as described in previous subsection.
The sample below also assumes that you are using `cluster.local` as the default
DNS domain name.
-->
</li>
<li>
<p>创建一个 JSON 配置文件，用来为 API 服务器生成秘钥和证书，例如：<code>server-csr.json</code>。
确认用你需要的值替换掉尖括号中的值。<code>MASTER_CLUSTER_IP</code> 是为 API 服务器 指定的服务集群 IP，就像前面小节描述的那样。
以下示例假定你的默认 DSN 域名为<code>cluster.local</code>。</p>
<pre><code>{
  &quot;CN&quot;: &quot;kubernetes&quot;,
  &quot;hosts&quot;: [
    &quot;127.0.0.1&quot;,
    &quot;&lt;MASTER_IP&gt;&quot;,
    &quot;&lt;MASTER_CLUSTER_IP&gt;&quot;,
    &quot;kubernetes&quot;,
    &quot;kubernetes.default&quot;,
    &quot;kubernetes.default.svc&quot;,
    &quot;kubernetes.default.svc.cluster&quot;,
    &quot;kubernetes.default.svc.cluster.local&quot;
  ],
  &quot;key&quot;: {
    &quot;algo&quot;: &quot;rsa&quot;,
    &quot;size&quot;: 2048
  },
  &quot;names&quot;: [{
    &quot;C&quot;: &quot;&lt;country&gt;&quot;,
    &quot;ST&quot;: &quot;&lt;state&gt;&quot;,
    &quot;L&quot;: &quot;&lt;city&gt;&quot;,
    &quot;O&quot;: &quot;&lt;organization&gt;&quot;,
    &quot;OU&quot;: &quot;&lt;organization unit&gt;&quot;
  }]
}
</code></pre>
<!-- 
1.  Generate the key and certificate for the API server, which are by default
saved into file `server-key.pem` and `server.pem` respectively:
-->
</li>
<li>
<p>为 API 服务器生成秘钥和证书，默认会分别存储为<code>server-key.pem</code> 和 <code>server.pem</code> 两个文件。</p>
<pre><code>../cfssl gencert -ca=ca.pem -ca-key=ca-key.pem \
--config=ca-config.json -profile=kubernetes \
server-csr.json | ../cfssljson -bare server
</code></pre>
</li>
</ol>
<!-- 
## Distributing Self-Signed CA Certificate
-->
<h2 id="分发自签名的-ca-证书">分发自签名的 CA 证书</h2>
<!-- 
A client node may refuse to recognize a self-signed CA certificate as valid.
For a non-production deployment, or for a deployment that runs behind a company
firewall, you can distribute a self-signed CA certificate to all clients and
refresh the local list for valid certificates.

On each client, perform the following operations:
-->
<p>客户端节点可能不认可自签名 CA 证书的有效性。
对于非生产环境，或者运行在公司防火墙后的环境，你可以分发自签名的 CA 证书到所有客户节点，并刷新本地列表以使证书生效。</p>
<p>在每一个客户节点，执行以下操作：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">sudo cp ca.crt /usr/local/share/ca-certificates/kubernetes.crt
sudo update-ca-certificates
</code></pre></div><pre tabindex="0"><code>Updating certificates in /etc/ssl/certs...
1 added, 0 removed; done.
Running hooks in /etc/ca-certificates/update.d....
done.
</code></pre><!-- 
## Certificates API
-->
<h2 id="certificates-api">证书 API</h2>
<!-- 
You can use the `certificates.k8s.io` API to provision
x509 certificates to use for authentication as documented
[here](/docs/tasks/tls/managing-tls-in-a-cluster).
-->
<p>你可以通过 <code>certificates.k8s.io</code> API 提供 x509 证书，用来做身份验证，
如<a href="/zh/docs/tasks/tls/managing-tls-in-a-cluster">本</a>文档所述。</p>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-8c31aafd38fad5b0de0bd191758d6f93">5 - 安装网络规则驱动</h1>
    
	
</div>



    
      
  
  
  
  

  
  

  
    
    
	
    

<div class="td-content" style="">
    
	<h1 id="pg-1239a77618c6278373832a142cd85519">5.1 - 使用 Calico 提供 NetworkPolicy</h1>
    
	<!-- overview -->
<!--
This page shows a couple of quick ways to create a Calico cluster on Kubernetes.
-->
<p>本页展示了几种在 Kubernetes 上快速创建 Calico 集群的方法。</p>
<h2 id="准备开始">准备开始</h2>
<!--
Decide whether you want to deploy a [cloud](#creating-a-calico-cluster-with-google-kubernetes-engine-gke) or [local](#creating-a-local-calico-cluster-with-kubeadm) cluster.
-->
<p>确定你想部署一个<a href="#gke-cluster">云版本</a>还是<a href="#local-cluster">本地版本</a>的集群。</p>
<!-- steps -->
<!--
## Creating a Calico cluster with Google Kubernetes Engine (GKE)

**Prerequisite**: [gcloud](https://cloud.google.com/sdk/docs/quickstarts).
-->
<h2 id="gke-cluster">在 Google Kubernetes Engine (GKE) 上创建一个 Calico 集群</h2>
<p><strong>先决条件</strong>: <a href="https://cloud.google.com/sdk/docs/quickstarts">gcloud</a></p>
<!--
1.  To launch a GKE cluster with Calico, just include the `--enable-network-policy` flag.
-->
<ol>
<li>
<p>启动一个带有 Calico 的 GKE 集群，只需加上参数 <code>--enable-network-policy</code>。</p>
<p><strong>语法</strong></p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">gcloud container clusters create <span style="color:#666">[</span>CLUSTER_NAME<span style="color:#666">]</span> --enable-network-policy
</code></pre></div><p><strong>示例</strong></p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">gcloud container clusters create my-calico-cluster --enable-network-policy
</code></pre></div></li>
</ol>
<!--
1.  To verify the deployment, use the following command.
-->
<ol start="2">
<li>
<p>使用如下命令验证部署是否正确。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl get pods --namespace<span style="color:#666">=</span>kube-system
</code></pre></div><!--
The Calico pods begin with `calico`. Check to make sure each one has a status of `Running`.
-->
<p>Calico 的 pods 名以 <code>calico</code> 打头，检查确认每个 pods 状态为 <code>Running</code>。</p>
</li>
</ol>
<!-- 
## Creating a local Calico cluster with kubeadm

To get a local single-host Calico cluster in fifteen minutes using kubeadm, refer to the
[Calico Quickstart](https://docs.projectcalico.org/latest/getting-started/kubernetes/).
-->
<h2 id="local-cluster">使用 kubeadm 创建一个本地 Calico 集群  </h2>
<p>使用 kubeadm 在 15 分钟内得到一个本地单主机 Calico 集群，请参考
<a href="https://docs.projectcalico.org/latest/getting-started/kubernetes/">Calico 快速入门</a>。</p>
<h2 id="接下来">接下来</h2>
<!--
Once your cluster is running, you can follow the [Declare Network Policy](/docs/tasks/administer-cluster/declare-network-policy/) to try out Kubernetes NetworkPolicy.
-->
<p>集群运行后，您可以按照<a href="/zh/docs/tasks/administer-cluster/declare-network-policy/">声明网络策略</a>
去尝试使用 Kubernetes NetworkPolicy。</p>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-95039241255a31df196beaa405b68eba">5.2 - 使用 Cilium 提供 NetworkPolicy</h1>
    
	<!--
reviewers:
- danwent
- aanm
title: Use Cilium for NetworkPolicy
content_type: task
weight: 20
-->
<!-- overview -->
<!--
This page shows how to use Cilium for NetworkPolicy.

For background on Cilium, read the [Introduction to Cilium](https://docs.cilium.io/en/stable/intro).
-->
<p>本页展示如何使用 Cilium 提供 NetworkPolicy。</p>
<p>关于 Cilium 的背景知识，请阅读 <a href="https://docs.cilium.io/en/stable/intro">Cilium 介绍</a>。</p>
<h2 id="准备开始">准备开始</h2>
<p><p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
如果你还没有集群，你可以通过 <a href="/zh/docs/tasks/tools/#minikube">Minikube</a> 构建一
个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p>
<!--
You need to have a Kubernetes cluster, and the kubectl command-line tool must
be configured to communicate with your cluster. If you do not already have a
cluster, you can create one by using
[minikube](/docs/tasks/tools/#minikube)
or you can use one of these Kubernetes playgrounds:
-->
<ul>
<li><a href="https://www.katacoda.com/courses/kubernetes/playground">Katacoda</a></li>
<li><a href="http://labs.play-with-k8s.com/">玩转 Kubernetes</a></li>
</ul>
 
 要获知版本信息，请输入 <code>kubectl version</code>.
</p>
<!-- steps -->
<!--
## Deploying Cilium on Minikube for Basic Testing

To get familiar with Cilium easily you can follow the
[Cilium Kubernetes Getting Started Guide](https://docs.cilium.io/en/stable/gettingstarted/minikube/)
to perform a basic DaemonSet installation of Cilium in minikube.

To start minikube, minimal version required is >= v1.3.1, run the with the
following arguments:
-->
<h2 id="在-minikube-上部署-cilium-用于基本测试">在 Minikube 上部署 Cilium 用于基本测试</h2>
<p>为了轻松熟悉 Cilium 你可以根据
<a href="https://docs.cilium.io/en/stable/gettingstarted/minikube/">Cilium Kubernetes 入门指南</a>
在 minikube 中执行一个 cilium 的基本 DaemonSet 安装。</p>
<p>要启动 minikube，需要的最低版本为 1.3.1，使用下面的参数运行：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">minikube version
</code></pre></div><pre tabindex="0"><code>minikube version: v1.3.1
</code></pre><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">minikube start --network-plugin<span style="color:#666">=</span>cni --memory<span style="color:#666">=</span><span style="color:#666">4096</span>
</code></pre></div><!--
Mount the BPF filesystem:
-->
<p>挂载 BPF 文件系统：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">minikube ssh -- sudo mount bpffs -t bpf /sys/fs/bpf
</code></pre></div><!--
For minikube you can deploy this simple ''all-in-one'' YAML file that includes
DaemonSet configurations for Cilium as well as appropriate RBAC settings:
-->
<p>在 minikube 环境中，你可以部署下面的&quot;一体化&quot; YAML 文件，其中包含 Cilium
的 DaemonSet 配置以及适当的 RBAC 配置：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl create -f https://raw.githubusercontent.com/cilium/cilium/v1.8/install/kubernetes/quick-install.yaml
</code></pre></div><pre tabindex="0"><code>configmap/cilium-config created
serviceaccount/cilium created
serviceaccount/cilium-operator created
clusterrole.rbac.authorization.k8s.io/cilium created
clusterrole.rbac.authorization.k8s.io/cilium-operator created
clusterrolebinding.rbac.authorization.k8s.io/cilium created
clusterrolebinding.rbac.authorization.k8s.io/cilium-operator created
daemonset.apps/cilium create
deployment.apps/cilium-operator created
</code></pre><!--
The remainder of the Getting Started Guide explains how to enforce both L3/L4
(i.e., IP address + port) security policies, as well as L7 (e.g., HTTP) security
policies using an example application.
-->
<p>入门指南其余的部分用一个示例应用说明了如何强制执行 L3/L4（即 IP 地址+端口）的安全策略
以及L7 （如 HTTP）的安全策略。</p>
<!--
## Deploying Cilium for Production Use

For detailed instructions around deploying Cilium for production, see:
[Cilium Kubernetes Installation Guide](https://docs.cilium.io/en/stable/concepts/kubernetes/intro/)
This documentation includes detailed requirements, instructions and example
production DaemonSet files.
 -->
<h2 id="部署-cilium-用于生产用途">部署 Cilium 用于生产用途</h2>
<p>关于部署 Cilium 用于生产的详细说明，请见
<a href="https://docs.cilium.io/en/stable/concepts/kubernetes/intro/">Cilium Kubernetes 安装指南</a>
此文档包括详细的需求、说明和生产用途 DaemonSet 文件示例。</p>
<!-- discussion -->
<!--
##  Understanding Cilium components

Deploying a cluster with Cilium adds Pods to the `kube-system` namespace. To see
this list of Pods run:
 -->
<h2 id="了解-cilium-组件">了解 Cilium 组件</h2>
<p>部署使用 Cilium 的集群会添加 Pods 到 <code>kube-system</code> 命名空间。要查看 Pod 列表，运行：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl get pods --namespace<span style="color:#666">=</span>kube-system
</code></pre></div><!-- You'll see a list of Pods similar to this: -->
<p>你将看到像这样的 Pods 列表：</p>
<pre tabindex="0"><code class="language-console" data-lang="console">NAME            READY   STATUS    RESTARTS   AGE
cilium-6rxbd    1/1     Running   0          1m
...
</code></pre><!--
A `cilium` Pod runs on each node in your cluster and enforces network policy
on the traffic to/from Pods on that node using Linux BPF.
-->
<p>你的集群中的每个节点上都会运行一个 <code>cilium</code> Pod，通过使用 Linux BPF
针对该节点上的 Pod 的入站、出站流量实施网络策略控制。</p>
<h2 id="接下来">接下来</h2>
<!--
Once your cluster is running, you can follow the
[Declare Network Policy](/docs/tasks/administer-cluster/declare-network-policy/)
to try out Kubernetes NetworkPolicy with Cilium.
Have fun, and if you have questions, contact us using the
[Cilium Slack Channel](https://cilium.herokuapp.com/).
-->
<p>集群运行后，你可以按照
<a href="/zh/docs/tasks/administer-cluster/declare-network-policy/">声明网络策略</a>
试用基于 Cilium 的 Kubernetes NetworkPolicy。
玩得开心，如果你有任何疑问，请到 <a href="https://cilium.herokuapp.com/">Cilium Slack 频道</a>
联系我们。</p>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-505a0a6a7e6eff361bbb3be81c84b2e0">5.3 - 使用 kube-router 提供 NetworkPolicy</h1>
    
	<!-- overview -->
<!--
This page shows how to use [Kube-router](https://github.com/cloudnativelabs/kube-router) for NetworkPolicy.
-->
<p>本页展示如何使用 <a href="https://github.com/cloudnativelabs/kube-router">Kube-router</a> 提供 NetworkPolicy。</p>
<h2 id="准备开始">准备开始</h2>
<!--
You need to have a Kubernetes cluster running. If you do not already have a cluster, you can create one by using any of the cluster installers like Kops, Bootkube, Kubeadm etc.
-->
<p>你需要拥有一个运行中的 Kubernetes 集群。如果你还没有集群，可以使用任意的集群
安装程序如 Kops、Bootkube、Kubeadm 等创建一个。</p>
<!-- steps -->
<!--
## Installing Kube-router addon

The Kube-router Addon comes with a Network Policy Controller that watches Kubernetes API server for any NetworkPolicy and pods updated and configures iptables rules and ipsets to allow or block traffic as directed by the policies. Please follow the [trying Kube-router with cluster installers](https://www.kube-router.io/docs/user-guide/#try-kube-router-with-cluster-installers) guide to install Kube-router addon.
-->
<h2 id="安装-kube-router-插件">安装 kube-router 插件</h2>
<p>kube-router 插件自带一个网络策略控制器，监视来自于 Kubernetes API 服务器的
NetworkPolicy 和 Pod 的变化，根据策略指示配置 iptables 规则和 ipsets 来允许或阻止流量。
请根据 <a href="https://www.kube-router.io/docs/user-guide/#try-kube-router-with-cluster-installers">通过集群安装程序尝试 kube-router</a> 指南安装 kube-router 插件。</p>
<h2 id="接下来">接下来</h2>
<!--
Once you have installed the Kube-router addon, you can follow the [Declare Network Policy](/docs/tasks/administer-cluster/declare-network-policy/) to try out Kubernetes NetworkPolicy.
-->
<p>在你安装了 kube-router 插件后，可以参考
<a href="/zh/docs/tasks/administer-cluster/declare-network-policy/">声明网络策略</a>
去尝试使用 Kubernetes NetworkPolicy。</p>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-2842eac98aa0e229a5c6755c4c83d2a7">5.4 - 使用 Romana 提供 NetworkPolicy</h1>
    
	<!--
reviewers:
- chrismarino
title: Romana for NetworkPolicy
content_type: task
weight: 40
-->
<!-- overview -->
<!--
This page shows how to use Romana for NetworkPolicy.
-->
<p>本页展示如何使用 Romana 作为 NetworkPolicy。</p>
<h2 id="准备开始">准备开始</h2>
<!--
Complete steps 1, 2, and 3 of  the [kubeadm getting started guide](/docs/getting-started-guides/kubeadm/).
-->
<p>完成 <a href="/zh/docs/reference/setup-tools/kubeadm/">kubeadm 入门指南</a>中的 1、2、3 步。</p>
<!-- steps -->
<!--
## Installing Romana with kubeadm

Follow the [containerized installation guide](https://github.com/romana/romana/tree/master/containerize) for kubeadm.

## Applying network policies

To apply network policies use one of the following:

* [Romana network policies](https://github.com/romana/romana/wiki/Romana-policies).
    * [Example of Romana network policy](https://github.com/romana/core/blob/master/doc/policy.md).
* The NetworkPolicy API.
 -->
<h2 id="使用-kubeadm-安装-romana">使用 kubeadm 安装 Romana</h2>
<p>按照<a href="https://github.com/romana/romana/tree/master/containerize">容器化安装指南</a>，
使用 kubeadm 安装。</p>
<h2 id="应用网络策略">应用网络策略</h2>
<p>使用以下的一种方式应用网络策略：</p>
<ul>
<li><a href="https://github.com/romana/romana/wiki/Romana-policies">Romana 网络策略</a>
<ul>
<li><a href="https://github.com/romana/core/blob/master/doc/policy.md">Romana 网络策略例子</a></li>
</ul>
</li>
<li>NetworkPolicy API</li>
</ul>
<h2 id="接下来">接下来</h2>
<!--
Once you have installed Romana, you can follow the [Declare Network Policy](/docs/tasks/administer-cluster/declare-network-policy/) to try out Kubernetes NetworkPolicy.
 -->
<p>Romana 安装完成后，你可以按照
<a href="/zh/docs/tasks/administer-cluster/declare-network-policy/">声明网络策略</a>
去尝试使用 Kubernetes NetworkPolicy。</p>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-ac075c3fdfd0d41aa753cc70e42be064">5.5 - 使用 Weave Net 提供 NetworkPolicy</h1>
    
	<!--
reviewers:
- bboreham
title: Weave Net for NetworkPolicy
content_type: task
weight: 50
-->
<!-- overview -->
<!--
This page shows how to use Weave Net for NetworkPolicy.
-->
<p>本页展示如何使用使用 Weave Net 提供 NetworkPolicy。</p>
<h2 id="准备开始">准备开始</h2>
<!--
You need to have a Kubernetes cluster. Follow the
[kubeadm getting started guide](/docs/reference/setup-tools/kubeadm/) to bootstrap one.
 -->
<p>你需要拥有一个 Kubernetes 集群。按照
<a href="/zh/docs/reference/setup-tools/kubeadm/">kubeadm 入门指南</a>
来启动一个。</p>
<!-- steps -->
<!--
## Install the Weave Net addon

Follow the [Integrating Kubernetes via the Addon](https://www.weave.works/docs/net/latest/kubernetes/kube-addon/) guide.

The Weave Net addon for Kubernetes comes with a
[Network Policy Controller](https://www.weave.works/docs/net/latest/kubernetes/kube-addon/#npc)
that automatically monitors Kubernetes for any NetworkPolicy annotations on all
namespaces and configures `iptables` rules to allow or block traffic as directed by the policies.
-->
<h2 id="安装-weave-net-插件">安装 Weave Net 插件</h2>
<p>按照<a href="https://www.weave.works/docs/net/latest/kubernetes/kube-addon/">通过插件集成 Kubernetes</a>
指南执行安装。</p>
<p>Kubernetes 的 Weave Net 插件带有
<a href="https://www.weave.works/docs/net/latest/kubernetes/kube-addon/#npc">网络策略控制器</a>，
可自动监控 Kubernetes 所有名字空间的 NetworkPolicy 注释，
配置 <code>iptables</code> 规则以允许或阻止策略指示的流量。</p>
<!--
## Test the installation

Verify that the weave works.

Enter the following command:
-->
<h2 id="测试安装">测试安装</h2>
<p>验证 weave 是否有效。</p>
<p>输入以下命令：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl get po -n kube-system -o wide
</code></pre></div><!-- The output is similar to this: -->
<p>输出类似这样：</p>
<pre tabindex="0"><code>NAME                                    READY     STATUS    RESTARTS   AGE       IP              NODE
weave-net-1t1qg                         2/2       Running   0          9d        192.168.2.10    worknode3
weave-net-231d7                         2/2       Running   1          7d        10.2.0.17       worknodegpu
weave-net-7nmwt                         2/2       Running   3          9d        192.168.2.131   masternode
weave-net-pmw8w                         2/2       Running   0          9d        192.168.2.216   worknode2
</code></pre><!--
Each Node has a weave Pod, and all Pods are `Running` and `2/2 READY`. (`2/2` means that each Pod has `weave` and `weave-npc`.)
-->
<p>每个 Node 都有一个 weave Pod，所有 Pod 都是<code>Running</code> 和 <code>2/2 READY</code>。
（<code>2/2</code> 表示每个 Pod 都有 <code>weave</code> 和 <code>weave-npc</code>）</p>
<h2 id="接下来">接下来</h2>
<!--
Once you have installed the Weave Net addon, you can follow the [Declare Network Policy](/docs/tasks/administer-cluster/declare-network-policy/) to try out Kubernetes NetworkPolicy. If you have any question, contact us at [#weave-community on Slack or Weave User Group](https://github.com/weaveworks/weave#getting-help).
 -->
<p>安装 Weave Net 插件后，你可以参考
<a href="/zh/docs/tasks/administer-cluster/declare-network-policy/">声明网络策略</a>
来试用 Kubernetes NetworkPolicy。
如果你有任何疑问，请通过
<a href="https://github.com/weaveworks/weave#getting-help">Slack 上的 #weave-community 频道或者 Weave 用户组</a>
联系我们。</p>

</div>



    
	
  

    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-b45f024608e1b367cdacb1fd9d77278a">6 - IP Masquerade Agent 用户指南</h1>
    
	<!--
title: IP Masquerade Agent User Guide
content_type: task
-->
<!-- overview -->
<!--
This page shows how to configure and enable the ip-masq-agent.
-->
<p>此页面展示如何配置和启用 ip-masq-agent。</p>
<h2 id="准备开始">准备开始</h2>
<p><p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
如果你还没有集群，你可以通过 <a href="/zh/docs/tasks/tools/#minikube">Minikube</a> 构建一
个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p>
<!--
You need to have a Kubernetes cluster, and the kubectl command-line tool must
be configured to communicate with your cluster. If you do not already have a
cluster, you can create one by using
[minikube](/docs/tasks/tools/#minikube)
or you can use one of these Kubernetes playgrounds:
-->
<ul>
<li><a href="https://www.katacoda.com/courses/kubernetes/playground">Katacoda</a></li>
<li><a href="http://labs.play-with-k8s.com/">玩转 Kubernetes</a></li>
</ul>
 
 要获知版本信息，请输入 <code>kubectl version</code>.
</p>
<!-- discussion -->
<!--
## IP Masquerade Agent User Guide
-->
<h2 id="ip-masquerade-agent-用户指南">IP Masquerade Agent 用户指南</h2>
<!--
The ip-masq-agent configures iptables rules to hide a pod's IP address behind the cluster node's IP address. This is typically done when sending traffic to destinations outside the cluster's pod [CIDR](https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing) range.
-->
<p>ip-masq-agent 配置 iptables 规则以隐藏位于集群节点 IP 地址后面的 Pod 的 IP 地址。
这通常在将流量发送到集群的 Pod
<a href="https://zh.wikipedia.org/wiki/%E6%97%A0%E7%B1%BB%E5%88%AB%E5%9F%9F%E9%97%B4%E8%B7%AF%E7%94%B1">CIDR</a>
范围之外的目的地时使用。</p>
<!--
### **Key Terms**
-->
<h3 id="关键术语"><strong>关键术语</strong></h3>
<!--
* **NAT (Network Address Translation)**
  Is a method of remapping one IP address to another by modifying either the source and/or destination address information in the IP header.  Typically performed by a device doing IP routing.
-->
<ul>
<li><strong>NAT (网络地址转译)</strong>
是一种通过修改 IP 地址头中的源和/或目标地址信息将一个 IP 地址重新映射
到另一个 IP 地址的方法。通常由执行 IP 路由的设备执行。</li>
</ul>
<!--
* **Masquerading**
  A form of NAT that is typically used to perform a many to one address translation, where multiple source IP addresses are masked behind a single address, which is typically the device doing the IP routing. In Kubernetes this is the Node's IP address.
-->    
<ul>
<li><strong>伪装</strong>
NAT 的一种形式，通常用于执行多对一地址转换，其中多个源 IP 地址被隐藏在
单个地址后面，该地址通常是执行 IP 路由的设备。在 Kubernetes 中，
这是节点的 IP 地址。</li>
</ul>
<!--
* **CIDR (Classless Inter-Domain Routing)**
  Based on the variable-length subnet masking, allows specifying arbitrary-length prefixes. CIDR introduced a new method of representation for IP addresses, now commonly known as **CIDR notation**, in which an address or routing prefix is written with a suffix indicating the number of bits of the prefix, such as 192.168.2.0/24.
-->
<ul>
<li><strong>CIDR (无类别域间路由)</strong>
基于可变长度子网掩码，允许指定任意长度的前缀。
CIDR 引入了一种新的 IP 地址表示方法，现在通常称为<strong>CIDR表示法</strong>，
其中地址或路由前缀后添加一个后缀，用来表示前缀的位数，例如 192.168.2.0/24。</li>
</ul>
<!--
* **Link Local**
  A link-local address is a network address that is valid only for communications within the network segment or the broadcast domain that the host is connected to. Link-local addresses for IPv4 are defined in the address block 169.254.0.0/16 in CIDR notation.
-->
<ul>
<li><strong>本地链路</strong>
本地链路是仅对网段或主机所连接的广播域内的通信有效的网络地址。
IPv4 的本地链路地址在 CIDR 表示法的地址块 169.254.0.0/16 中定义。</li>
</ul>
<!--
The ip-masq-agent configures iptables rules to handle masquerading node/pod IP addresses when sending traffic to destinations outside the cluster node's IP and the Cluster IP range.  This essentially hides pod IP addresses behind the cluster node's IP address.  In some environments, traffic to "external" addresses must come from a known machine address. For example, in Google Cloud, any traffic to the internet must come from a VM's IP.  When containers are used, as in Google Kubernetes Engine, the Pod IP will be rejected for egress. To avoid this, we must hide the Pod IP behind the VM's own IP address - generally known as "masquerade". By default, the agent is configured to treat the three private IP ranges specified by [RFC 1918](https://tools.ietf.org/html/rfc1918) as non-masquerade [CIDR](https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing).  These ranges are 10.0.0.0/8, 172.16.0.0/12, and 192.168.0.0/16. The agent will also treat link-local (169.254.0.0/16) as a non-masquerade CIDR by default.  The agent is configured to reload its configuration from the location */etc/config/ip-masq-agent* every 60 seconds, which is also configurable.
-->
<p>ip-masq-agent 配置 iptables 规则，以便在将流量发送到集群节点的 IP 和集群 IP 范围之外的目标时
处理伪装节点或 Pod 的 IP 地址。这本质上隐藏了集群节点 IP 地址后面的 Pod IP 地址。
在某些环境中，去往“外部”地址的流量必须从已知的机器地址发出。
例如，在 Google Cloud 中，任何到互联网的流量都必须来自 VM 的 IP。
使用容器时，如 Google Kubernetes Engine，从 Pod IP 发出的流量将被拒绝出站。
为了避免这种情况，我们必须将 Pod IP 隐藏在 VM 自己的 IP 地址后面 - 通常称为“伪装”。
默认情况下，代理配置为将
<a href="https://tools.ietf.org/html/rfc1918">RFC 1918</a>
指定的三个私有 IP 范围视为非伪装
<a href="https://zh.wikipedia.org/wiki/%E6%97%A0%E7%B1%BB%E5%88%AB%E5%9F%9F%E9%97%B4%E8%B7%AF%E7%94%B1">CIDR</a>。
这些范围是 10.0.0.0/8,172.16.0.0/12 和 192.168.0.0/16。
默认情况下，代理还将链路本地地址（169.254.0.0/16）视为非伪装 CIDR。
代理程序配置为每隔 60 秒从 <em>/etc/config/ip-masq-agent</em> 重新加载其配置，
这也是可修改的。</p>
<p><img src="/images/docs/ip-masq.png" alt="masq/non-masq example"></p>
<!--
The agent configuration file must be written in YAML or JSON syntax, and may contain three optional keys:
-->
<p>代理配置文件必须使用 YAML 或 JSON 语法编写，并且可能包含三个可选值：</p>
<!--
*   **nonMasqueradeCIDRs:** A list of strings in [CIDR](https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing) notation that specify the non-masquerade ranges.
-->
<ul>
<li><strong>nonMasqueradeCIDRs:</strong>
<a href="https://zh.wikipedia.org/wiki/%E6%97%A0%E7%B1%BB%E5%88%AB%E5%9F%9F%E9%97%B4%E8%B7%AF%E7%94%B1">CIDR</a>
表示法中的字符串列表，用于指定不需伪装的地址范围。</li>
</ul>
<!--
*   **masqLinkLocal:** A Boolean (true / false) which indicates whether to masquerade traffic to the link local prefix 169.254.0.0/16. False by default.
-->
<ul>
<li><strong>masqLinkLocal:</strong> 布尔值 (true / false)，表示是否将流量伪装到
本地链路前缀 169.254.0.0/16。默认为 false。</li>
</ul>
<!--
*   **resyncInterval:** An interval at which the agent attempts to reload config from disk. e.g. '30s' where 's' is seconds, 'ms' is milliseconds etc...
-->
<ul>
<li><strong>resyncInterval:</strong> 代理尝试从磁盘重新加载配置的时间间隔。
例如 '30s'，其中 's' 是秒，'ms' 是毫秒等...</li>
</ul>
<!--
Traffic to 10.0.0.0/8, 172.16.0.0/12 and 192.168.0.0/16) ranges will NOT be masqueraded. Any other traffic (assumed to be internet) will be masqueraded.  An example of a local destination from a pod could be its Node's IP address as well as another node's address or one of the IP addresses in Cluster's IP range.   Any other traffic will be masqueraded by default.  The below entries show the default set of rules that are applied by the ip-masq-agent:
-->
<p>10.0.0.0/8、172.16.0.0/12 和 192.168.0.0/16 范围内的流量不会被伪装。
任何其他流量（假设是互联网）将被伪装。
Pod 访问本地目的地的例子，可以是其节点的 IP 地址、另一节点的地址或集群的 IP 地址范围内的一个 IP 地址。
默认情况下，任何其他流量都将伪装。以下条目展示了 ip-masq-agent 的默认使用的规则：</p>
<pre tabindex="0"><code>iptables -t nat -L IP-MASQ-AGENT
RETURN     all  --  anywhere             169.254.0.0/16       /* ip-masq-agent: cluster-local traffic should not be subject to MASQUERADE */ ADDRTYPE match dst-type !LOCAL
RETURN     all  --  anywhere             10.0.0.0/8           /* ip-masq-agent: cluster-local traffic should not be subject to MASQUERADE */ ADDRTYPE match dst-type !LOCAL
RETURN     all  --  anywhere             172.16.0.0/12        /* ip-masq-agent: cluster-local traffic should not be subject to MASQUERADE */ ADDRTYPE match dst-type !LOCAL
RETURN     all  --  anywhere             192.168.0.0/16       /* ip-masq-agent: cluster-local traffic should not be subject to MASQUERADE */ ADDRTYPE match dst-type !LOCAL
MASQUERADE  all  --  anywhere             anywhere             /* ip-masq-agent: outbound traffic should be subject to MASQUERADE (this match must come after cluster-local CIDR matches) */ ADDRTYPE match dst-type !LOCAL

</code></pre><!--
By default, in GCE/Google Kubernetes Engine starting with Kubernetes version 1.7.0, if network policy is enabled or you are using a cluster CIDR not in the 10.0.0.0/8 range, the ip-masq-agent will run in your cluster.  If you are running in another environment, you can add the ip-masq-agent [DaemonSet](/docs/concepts/workloads/controllers/daemonset/) to your cluster:
-->
<p>默认情况下，从 Kubernetes 1.7.0 版本开始的 GCE/Google Kubernetes Engine 中，
如果启用了网络策略，或者你使用的集群 CIDR 不在 10.0.0.0/8 范围内，
则 ip-masq-agent 将在你的集群中运行。
如果你在其他环境中运行，则可以将 ip-masq-agent
<a href="/zh/docs/concepts/workloads/controllers/daemonset/">DaemonSet</a> 添加到你的集群：</p>
<!-- steps -->
<!--
## Create an ip-masq-agent
To create an ip-masq-agent, run the following kubectl command:
-->
<h2 id="创建-ip-masq-agent">创建 ip-masq-agent</h2>
<p>通过运行以下 kubectl 指令创建 ip-masq-agent:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl apply -f https://raw.githubusercontent.com/kubernetes-sigs/ip-masq-agent/master/ip-masq-agent.yaml
</code></pre></div><!--
You must also apply the appropriate node label to any nodes in your cluster that you want the agent to run on.
-->
<p>你必须同时将适当的节点标签应用于集群中希望代理运行的任何节点。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl label nodes my-node beta.kubernetes.io/masq-agent-ds-ready<span style="color:#666">=</span><span style="color:#a2f">true</span>
</code></pre></div><!--
More information can be found in the ip-masq-agent documentation [here](https://github.com/kubernetes-sigs/ip-masq-agent)
-->
<p>更多信息可以通过 ip-masq-agent 文档 <a href="https://github.com/kubernetes-sigs/ip-masq-agent">这里</a> 找到。</p>
<!--
In most cases, the default set of rules should be sufficient; however, if this is not the case for your cluster, you can create and apply a [ConfigMap](/docs/tasks/configure-pod-container/configure-pod-configmap/) to customize the IP ranges that are affected.  For example, to allow only 10.0.0.0/8 to be considered by the ip-masq-agent, you can create the following [ConfigMap](/docs/tasks/configure-pod-container/configure-pod-configmap/) in a file called "config".
-->
<p>在大多数情况下，默认的规则集应该足够；但是，如果你的群集不是这种情况，则可以创建并应用
<a href="/zh/docs/tasks/configure-pod-container/configure-pod-configmap/">ConfigMap</a>
来自定义受影响的 IP 范围。
例如，要允许 ip-masq-agent 仅作用于 10.0.0.0/8，你可以在一个名为 “config” 的文件中创建以下
<a href="/zh/docs/tasks/configure-pod-container/configure-pod-configmap/">ConfigMap</a> 。</p>
<blockquote class="note callout">
  <div><strong>说明：</strong> <!--
It is important that the file is called config since, by default, that will be used as the key for lookup by the ip-masq-agent:
-->
<p>重要的是，该文件之所以被称为 config，因为默认情况下，该文件将被用作
ip-masq-agent 查找的主键：</p>
<pre tabindex="0"><code>nonMasqueradeCIDRs:
  - 10.0.0.0/8
resyncInterval: 60s
</code></pre></div>
</blockquote>
<!--
Run the following command to add the config map to your cluster:
-->
<p>运行以下命令将配置映射添加到你的集群：</p>
<pre tabindex="0"><code>kubectl create configmap ip-masq-agent --from-file=config --namespace=kube-system
</code></pre><!--
This will update a file located at */etc/config/ip-masq-agent* which is periodically checked every *resyncInterval* and applied to the cluster node.
After the resync interval has expired, you should see the iptables rules reflect your changes:
-->
<p>这将更新位于 <em>/etc/config/ip-masq-agent</em> 的一个文件，该文件以 <em>resyncInterval</em>
为周期定期检查并应用于集群节点。
重新同步间隔到期后，你应该看到你的更改在 iptables 规则中体现：</p>
<pre tabindex="0"><code>iptables -t nat -L IP-MASQ-AGENT
Chain IP-MASQ-AGENT (1 references)
target     prot opt source               destination
RETURN     all  --  anywhere             169.254.0.0/16       /* ip-masq-agent: cluster-local traffic should not be subject to MASQUERADE */ ADDRTYPE match dst-type !LOCAL
RETURN     all  --  anywhere             10.0.0.0/8           /* ip-masq-agent: cluster-local
MASQUERADE  all  --  anywhere             anywhere             /* ip-masq-agent: outbound traffic should be subject to MASQUERADE (this match must come after cluster-local CIDR matches) */ ADDRTYPE match dst-type !LOCAL
</code></pre><!--
By default, the link local range (169.254.0.0/16) is also handled by the ip-masq agent, which sets up the appropriate iptables rules.  To have the ip-masq-agent ignore link local, you can set *masqLinkLocal*  to true in the config map.
-->
<p>默认情况下，本地链路范围 (169.254.0.0/16) 也由 ip-masq agent 处理，
该代理设置适当的 iptables 规则。 要使 ip-masq-agent 忽略本地链路，
可以在配置映射中将 <em>masqLinkLocal</em> 设置为 true。</p>
<pre tabindex="0"><code>nonMasqueradeCIDRs:
  - 10.0.0.0/8
resyncInterval: 60s
masqLinkLocal: true
</code></pre>
</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-ce4cd28c8feb9faa783e79b48af37961">7 - Kubernetes 云管理控制器</h1>
    
	<!--
reviewers:
- luxas
- thockin
- wlan0
title: Kubernetes Cloud Controller Manager
content_type: concept
-->
<!-- overview -->





<div style="margin-top: 10px; margin-bottom: 10px;">
<b>FEATURE STATE:</b> <code>Kubernetes v1.11 [beta]</code>
</div>

<!--
Since cloud providers develop and release at a different pace compared to the Kubernetes project, abstracting the provider-specific code to the `<a class='glossary-tooltip' title='将 Kubernetes 与第三方云提供商进行集成的控制面组件。' data-toggle='tooltip' data-placement='top' href='/zh/docs/concepts/architecture/cloud-controller/' target='_blank' aria-label='cloud-controller-manager'>cloud-controller-manager</a>` binary allows cloud vendors to evolve independently from the core Kubernetes code.
-->
<p>由于云驱动的开发和发布的步调与 Kubernetes 项目不同，将服务提供商专用代码抽象到
<code><a class='glossary-tooltip' title='将 Kubernetes 与第三方云提供商进行集成的控制面组件。' data-toggle='tooltip' data-placement='top' href='/zh/docs/concepts/architecture/cloud-controller/' target='_blank' aria-label='cloud-controller-manager'>cloud-controller-manager</a></code>
二进制中有助于云服务厂商在 Kubernetes 核心代码之外独立进行开发。</p>
<!--
The `cloud-controller-manager` can be linked to any cloud provider that satisfies [cloudprovider.Interface](https://github.com/kubernetes/cloud-provider/blob/master/cloud.go). For backwards compatibility, the [cloud-controller-manager](https://github.com/kubernetes/kubernetes/tree/master/cmd/cloud-controller-manager) provided in the core Kubernetes project uses the same cloud libraries as `kube-controller-manager`. Cloud providers already supported in Kubernetes core are expected to use the in-tree cloud-controller-manager to transition out of Kubernetes core.
-->
<p><code>cloud-controller-manager</code> 可以被链接到任何满足
<a href="https://github.com/kubernetes/cloud-provider/blob/master/cloud.go">cloudprovider.Interface</a>
约束的云服务提供商。为了兼容旧版本，Kubernetes 核心项目中提供的
<a href="https://github.com/kubernetes/kubernetes/tree/master/cmd/cloud-controller-manager">cloud-controller-manager</a>
使用和 <code>kube-controller-manager</code> 相同的云服务类库。
已经在 Kubernetes 核心项目中支持的云服务提供商预计将通过使用 in-tree 的 cloud-controller-manager
过渡为非 Kubernetes 核心代码。</p>
<!-- body -->
<!--
## Administration

### Requirements

Every cloud has their own set of requirements for running their own cloud provider integration, it should not be too different from the requirements when running `kube-controller-manager`. As a general rule of thumb you'll need:

* cloud authentication/authorization: your cloud may require a token or IAM rules to allow access to their APIs
* kubernetes authentication/authorization: cloud-controller-manager may need RBAC rules set to speak to the kubernetes apiserver
* high availability: like kube-controller-manager, you may want a high available setup for cloud controller manager using leader election (on by default).
-->
<h2 id="管理">管理</h2>
<h3 id="需求">需求</h3>
<p>每个云服务都有一套各自的需求用于系统平台的集成，这不应与运行
<code>kube-controller-manager</code> 的需求有太大差异。作为经验法则，你需要：</p>
<ul>
<li>云服务认证/授权：你的云服务可能需要使用令牌或者 IAM 规则以允许对其 API 的访问</li>
<li>kubernetes 认证/授权：cloud-controller-manager 可能需要 RBAC 规则以访问 kubernetes apiserver</li>
<li>高可用：类似于 kube-controller-manager，你可能希望通过主节点选举（默认开启）配置一个高可用的云管理控制器。</li>
</ul>
<!--
### Running cloud-controller-manager

Successfully running cloud-controller-manager requires some changes to your cluster configuration.
-->
<h3 id="运行云管理控制器">运行云管理控制器</h3>
<p>你需要对集群配置做适当的修改以成功地运行云管理控制器：</p>
<!--
* `kube-apiserver` and `kube-controller-manager` MUST NOT specify the `--cloud-provider` flag. This ensures that it does not run any cloud specific loops that would be run by cloud controller manager. In the future, this flag will be deprecated and removed.
* `kubelet` must run with `--cloud-provider=external`. This is to ensure that the kubelet is aware that it must be initialized by the cloud controller manager before it is scheduled any work.
-->
<ul>
<li>一定不要为 <code>kube-apiserver</code> 和 <code>kube-controller-manager</code> 指定 <code>--cloud-provider</code> 标志。
这将保证它们不会运行任何云服务专用循环逻辑，这将会由云管理控制器运行。未来这个标记将被废弃并去除。</li>
<li><code>kubelet</code> 必须使用 <code>--cloud-provider=external</code> 运行。
这是为了保证让 kubelet 知道在执行任何任务前，它必须被云管理控制器初始化。</li>
</ul>
<!--
Keep in mind that setting up your cluster to use cloud controller manager will change your cluster behaviour in a few ways:
-->
<p>请记住，设置群集使用云管理控制器将用多种方式更改群集行为：</p>
<!--
* kubelets specifying `--cloud-provider=external` will add a taint `node.cloudprovider.kubernetes.io/uninitialized` with an effect `NoSchedule` during initialization. This marks the node as needing a second initialization from an external controller before it can be scheduled work. Note that in the event that cloud controller manager is not available, new nodes in the cluster will be left unschedulable. The taint is important since the scheduler may require cloud specific information about nodes such as their region or type (high cpu, gpu, high memory, spot instance, etc).
-->
<ul>
<li>指定了 <code>--cloud-provider=external</code> 的 kubelet 将被添加一个 <code>node.cloudprovider.kubernetes.io/uninitialized</code>
的污点，导致其在初始化过程中不可调度（<code>NoSchedule</code>）。
这将标记该节点在能够正常调度前，需要外部的控制器进行二次初始化。
请注意，如果云管理控制器不可用，集群中的新节点会一直处于不可调度的状态。
这个污点很重要，因为调度器可能需要关于节点的云服务特定的信息，比如他们的区域或类型
（高端 CPU、GPU 支持、内存较大、临时实例等）。</li>
</ul>
<!--
* cloud information about nodes in the cluster will no longer be retrieved using local metadata, but instead all API calls to retrieve node information will go through cloud controller manager. This may mean you can restrict access to your cloud API on the kubelets for better security. For larger clusters you may want to consider if cloud controller manager will hit rate limits since it is now responsible for almost all API calls to your cloud from within the cluster.
-->
<ul>
<li>集群中节点的云服务信息将不再能够从本地元数据中获取，取而代之的是所有获取节点信息的
API 调用都将通过云管理控制器。这意味着你可以通过限制到 kubelet 云服务 API 的访问来提升安全性。
在更大的集群中你可能需要考虑云管理控制器是否会遇到速率限制，
因为它现在负责集群中几乎所有到云服务的 API 调用。</li>
</ul>
<!--
Cloud controller manager can implement:

* node controller - responsible for updating kubernetes nodes using cloud APIs and deleting kubernetes nodes that were deleted on your cloud.
* service controller - responsible for loadbalancers on your cloud against services of type LoadBalancer.
* route controller - responsible for setting up network routes on your cloud
* any other features you would like to implement if you are running an out-of-tree provider.
-->
<p>云管理控制器可以实现：</p>
<ul>
<li>节点控制器 - 负责使用云服务 API 更新 kubernetes 节点并删除在云服务上已经删除的 kubernetes 节点。</li>
<li>服务控制器 - 负责在云服务上为类型为 LoadBalancer 的 service 提供负载均衡器。</li>
<li>路由控制器 - 负责在云服务上配置网络路由。</li>
<li>如果你使用的是 out-of-tree 提供商，请按需实现其余任意特性。</li>
</ul>
<!--
## Examples

If you are using a cloud that is currently supported in Kubernetes core and would like to adopt cloud controller manager, see the [cloud controller manager in kubernetes core](https://github.com/kubernetes/kubernetes/tree/master/cmd/cloud-controller-manager).

For cloud controller managers not in Kubernetes core, you can find the respective projects in repos maintained by cloud vendors or sig leads.
-->
<h2 id="示例">示例</h2>
<p>如果当前 Kubernetes 内核支持你使用的云服务，并且想要采用云管理控制器，请参见
<a href="https://github.com/kubernetes/kubernetes/tree/master/cmd/cloud-controller-manager">kubernetes 内核中的云管理控制器</a>。</p>
<p>对于不在 Kubernetes 核心代码库中的云管理控制器，你可以在云服务厂商或 SIG 领导者的源中找到对应的项目。</p>
<ul>
<li><a href="https://github.com/digitalocean/digitalocean-cloud-controller-manager">DigitalOcean</a></li>
<li><a href="https://github.com/munnerz/keepalived-cloud-provider">keepalived</a></li>
<li><a href="https://github.com/oracle/oci-cloud-controller-manager">Oracle Cloud Infrastructure</a></li>
<li><a href="https://github.com/rancher/rancher-cloud-controller-manager">Rancher</a></li>
</ul>
<!--
For providers already in Kubernetes core, you can run the in-tree cloud controller manager as a Daemonset in your cluster, use the following as a guideline:
-->
<p>对于已经存在于 Kubernetes 内核中的提供商，你可以在集群中将 in-tree 云管理控制器作为守护进程运行。请使用如下指南：</p>


 













<div class="highlight">
    <div class="copy-code-icon" style="text-align:right">
    <a href="https://raw.githubusercontent.com/kubernetes/website/main/content/zh/examples/admin/cloud/ccm-example.yaml" download="admin/cloud/ccm-example.yaml"><code>admin/cloud/ccm-example.yaml</code>
    </a>
    <img src="/images/copycode.svg" style="max-height:24px; cursor: pointer" onclick="copyCode('admin-cloud-ccm-example-yaml')" title="Copy admin/cloud/ccm-example.yaml to clipboard">
    </img>
    </div>
    <div class="includecode" id="admin-cloud-ccm-example-yaml">
    <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#080;font-style:italic"># This is an example of how to setup cloud-controller-manager as a Daemonset in your cluster.</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#080;font-style:italic"># It assumes that your masters can run pods and has the role node-role.kubernetes.io/master</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#080;font-style:italic"># Note that this Daemonset will not work straight out of the box for your cloud, this is</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#080;font-style:italic"># meant to be a guideline.</span><span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#00f;font-weight:bold">---</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>ServiceAccount<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>cloud-controller-manager<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">namespace</span>:<span style="color:#bbb"> </span>kube-system<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#00f;font-weight:bold">---</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>rbac.authorization.k8s.io/v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>ClusterRoleBinding<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>system:cloud-controller-manager<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">roleRef</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">apiGroup</span>:<span style="color:#bbb"> </span>rbac.authorization.k8s.io<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>ClusterRole<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>cluster-admin<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">subjects</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>ServiceAccount<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>cloud-controller-manager<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">namespace</span>:<span style="color:#bbb"> </span>kube-system<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#00f;font-weight:bold">---</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>apps/v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>DaemonSet<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">labels</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">k8s-app</span>:<span style="color:#bbb"> </span>cloud-controller-manager<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>cloud-controller-manager<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">namespace</span>:<span style="color:#bbb"> </span>kube-system<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">spec</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">selector</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">matchLabels</span>:<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">k8s-app</span>:<span style="color:#bbb"> </span>cloud-controller-manager<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">template</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">labels</span>:<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#008000;font-weight:bold">k8s-app</span>:<span style="color:#bbb"> </span>cloud-controller-manager<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">spec</span>:<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">serviceAccountName</span>:<span style="color:#bbb"> </span>cloud-controller-manager<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">containers</span>:<span style="color:#bbb">
</span><span style="color:#bbb">      </span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>cloud-controller-manager<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#080;font-style:italic"># for in-tree providers we use k8s.gcr.io/cloud-controller-manager</span><span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#080;font-style:italic"># this can be replaced with any other image for out-of-tree providers</span><span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#008000;font-weight:bold">image</span>:<span style="color:#bbb"> </span>k8s.gcr.io/cloud-controller-manager:v1.8.0<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#008000;font-weight:bold">command</span>:<span style="color:#bbb">
</span><span style="color:#bbb">        </span>- /usr/local/bin/cloud-controller-manager<span style="color:#bbb">
</span><span style="color:#bbb">        </span>- --cloud-provider=[YOUR_CLOUD_PROVIDER] <span style="color:#bbb"> </span><span style="color:#080;font-style:italic"># Add your own cloud provider here!</span><span style="color:#bbb">
</span><span style="color:#bbb">        </span>- --leader-elect=true<span style="color:#bbb">
</span><span style="color:#bbb">        </span>- --use-service-account-credentials<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#080;font-style:italic"># these flags will vary for every cloud provider</span><span style="color:#bbb">
</span><span style="color:#bbb">        </span>- --allocate-node-cidrs=true<span style="color:#bbb">
</span><span style="color:#bbb">        </span>- --configure-cloud-routes=true<span style="color:#bbb">
</span><span style="color:#bbb">        </span>- --cluster-cidr=172.17.0.0/16<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">tolerations</span>:<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#080;font-style:italic"># this is required so CCM can bootstrap itself</span><span style="color:#bbb">
</span><span style="color:#bbb">      </span>- <span style="color:#008000;font-weight:bold">key</span>:<span style="color:#bbb"> </span>node.cloudprovider.kubernetes.io/uninitialized<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#008000;font-weight:bold">value</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;true&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#008000;font-weight:bold">effect</span>:<span style="color:#bbb"> </span>NoSchedule<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#080;font-style:italic"># this is to have the daemonset runnable on master nodes</span><span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#080;font-style:italic"># the taint may vary depending on your cluster setup</span><span style="color:#bbb">
</span><span style="color:#bbb">      </span>- <span style="color:#008000;font-weight:bold">key</span>:<span style="color:#bbb"> </span>node-role.kubernetes.io/master<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#008000;font-weight:bold">effect</span>:<span style="color:#bbb"> </span>NoSchedule<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#080;font-style:italic"># this is to restrict CCM to only run on master nodes</span><span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#080;font-style:italic"># the node selector may vary depending on your cluster setup</span><span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">nodeSelector</span>:<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#008000;font-weight:bold">node-role.kubernetes.io/master</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;&#34;</span><span style="color:#bbb">
</span></code></pre></div>
    </div>
</div>


<!--
## Limitations

Running cloud controller manager comes with a few possible limitations. Although these limitations are being addressed in upcoming releases, it's important that you are aware of these limitations for production workloads.
-->
<h2 id="限制">限制</h2>
<p>运行云管理控制器会有一些可能的限制。虽然以后的版本将处理这些限制，但是知道这些生产负载的限制很重要。</p>
<!--
### Support for Volumes

Cloud controller manager does not implement any of the volume controllers found in `kube-controller-manager` as the volume integrations also require coordination with kubelets. As we evolve CSI (container storage interface) and add stronger support for flex volume plugins, necessary support will be added to cloud controller manager so that clouds can fully integrate with volumes. Learn more about out-of-tree CSI volume plugins [here](https://github.com/kubernetes/features/issues/178).
-->
<h3 id="对-volume-的支持">对 Volume 的支持</h3>
<p>云管理控制器未实现 <code>kube-controller-manager</code> 中的任何 volume 控制器，因为和 volume 的集成还需要与 kubelet 协作。由于我们引入了 CSI (容器存储接口，container storage interface) 并对弹性 volume 插件添加了更强大的支持，云管理控制器将添加必要的支持，以使云服务同 volume 更好的集成。请在 <a href="https://github.com/kubernetes/features/issues/178">这里</a> 了解更多关于 out-of-tree CSI volume 插件的信息。</p>
<!--
### Scalability

In the previous architecture for cloud providers, we relied on kubelets using a local metadata service to retrieve node information about itself. With this new architecture, we now fully rely on the cloud controller managers to retrieve information for all nodes. For very larger clusters, you should consider possible bottle necks such as resource requirements and API rate limiting.
-->
<h3 id="可扩展性">可扩展性</h3>
<p>在以前为云服务提供商提供的架构中，我们依赖 kubelet 的本地元数据服务来获取关于它本身的节点信息。通过这个新的架构，现在我们完全依赖云管理控制器来获取所有节点的信息。对于非常大的集群，你需要考虑可能的瓶颈，例如资源需求和 API 速率限制。</p>
<!--
### Chicken and Egg

The goal of the cloud controller manager project is to decouple development of cloud features from the core Kubernetes project. Unfortunately, many aspects of the Kubernetes project has assumptions that cloud provider features are tightly integrated into the project. As a result, adopting this new architecture can create several situations where a request is being made for information from a cloud provider, but the cloud controller manager may not be able to return that information without the original request being complete.
-->
<h3 id="鸡和蛋的问题">鸡和蛋的问题</h3>
<p>云管理控制器的目标是将云服务特性的开发从 Kubernetes 核心项目中解耦。
不幸的是，Kubernetes 项目的许多方面都假设云服务提供商的特性同项目紧密结合。
因此，这种新架构的采用可能导致某些场景下，当一个请求需要从云服务提供商获取信息时，
在该请求没有完成的情况下云管理控制器不能返回那些信息。</p>
<!--
A good example of this is the TLS bootstrapping feature in the Kubelet. Currently, TLS bootstrapping assumes that the Kubelet has the ability to ask the cloud provider (or a local metadata service) for all its address types (private, public, etc) but cloud controller manager cannot set a node's address types without being initialized in the first place which requires that the kubelet has TLS certificates to communicate with the apiserver.

As this initiative evolves, changes will be made to address these issues in upcoming releases.
-->
<p>Kubelet 中的 TLS 引导特性是一个很好的例子。
目前，TLS 引导认为 kubelet 有能力从云提供商（或本地元数据服务）获取所有的地址类型（私有、公用等），
但在被初始化之前，云管理控制器不能设置节点地址类型，而这需要 kubelet 拥有
TLS 证书以和 API 服务器通信。</p>
<p>随着整个动议的演进，将来的发行版中将作出改变来解决这些问题。</p>
<h2 id="接下来">接下来</h2>
<!--
To build and develop your own cloud controller manager, read the [Developing Cloud Controller Manager](/docs/tasks/administer-cluster/developing-cloud-controller-manager.md) doc.
-->
<p>要构建和开发你自己的云管理控制器，请阅读
<a href="/zh/docs/tasks/administer-cluster/developing-cloud-controller-manager/">开发云管理控制器</a>
文档。</p>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-c4d0832845adc92b7ccd54aed63fc932">8 - 为 Kubernetes 运行 etcd 集群</h1>
    
	<!--
---
reviewers:
- mml
- wojtek-t
title: Operating etcd clusters for Kubernetes
content_type: task
---
-->
<!-- overview -->
<!--
---
title: etcd
id: etcd
date: 2018-04-12
full_link: /docs/tasks/administer-cluster/configure-upgrade-etcd/
short_description: >
  Consistent and highly-available key value store used as Kubernetes' backing store for all cluster data.

aka: 
tags:
- architecture
- storage
---
-->
<!--
 Consistent and highly-available key value store used as Kubernetes' backing store for all cluster data.
-->
<p>etcd 是兼具一致性和高可用性的键值数据库，可以作为保存 Kubernetes 所有集群数据的后台数据库。</p>
<!--
If your Kubernetes cluster uses etcd as its backing store, make sure you have a
[back up](/docs/tasks/administer-cluster/configure-upgrade-etcd/#backing-up-an-etcd-cluster) plan
for those data.
-->	
<p>您的 Kubernetes 集群的 etcd 数据库通常需要有个备份计划。</p>
<!--
You can find in-depth information about etcd in the official [documentation](https://etcd.io/docs/).
-->
<p>要了解 etcd 更深层次的信息，请参考 <a href="https://etcd.io/docs/">etcd 文档</a>。</p>
<h2 id="准备开始">准备开始</h2>
<p><p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
如果你还没有集群，你可以通过 <a href="/zh/docs/tasks/tools/#minikube">Minikube</a> 构建一
个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p>
<!--
You need to have a Kubernetes cluster, and the kubectl command-line tool must
be configured to communicate with your cluster. If you do not already have a
cluster, you can create one by using
[minikube](/docs/tasks/tools/#minikube)
or you can use one of these Kubernetes playgrounds:
-->
<ul>
<li><a href="https://www.katacoda.com/courses/kubernetes/playground">Katacoda</a></li>
<li><a href="http://labs.play-with-k8s.com/">玩转 Kubernetes</a></li>
</ul>
 
 要获知版本信息，请输入 <code>kubectl version</code>.
</p>
<!-- steps -->
<!--
## Prerequisites

* Run etcd as a cluster of odd members.

* etcd is a leader-based distributed system. Ensure that the leader
  periodically send heartbeats on time to all followers to keep the cluster
  stable.

* Ensure that no resource starvation occurs.

  Performance and stability of the cluster is sensitive to network and disk
  I/O. Any resource starvation can lead to heartbeat timeout, causing instability
  of the cluster. An unstable etcd indicates that no leader is elected. Under
  such circumstances, a cluster cannot make any changes to its current state,
  which implies no new pods can be scheduled.

* Keeping etcd clusters stable is critical to the stability of Kubernetes
  clusters. Therefore, run etcd clusters on dedicated machines or isolated
  environments for [guaranteed resource requirements](https://etcd.io/docs/current/op-guide/hardware/).

* The minimum recommended version of etcd to run in production is `3.2.10+`.
-->
<h2 id="先决条件">先决条件</h2>
<ul>
<li>
<p>运行的 etcd 集群个数成员为奇数。</p>
</li>
<li>
<p>etcd 是一个 leader-based 分布式系统。确保主节点定期向所有从节点发送心跳，以保持集群稳定。</p>
</li>
<li>
<p>确保不发生资源不足。</p>
<p>集群的性能和稳定性对网络和磁盘 I/O 非常敏感。任何资源匮乏都会导致心跳超时，
从而导致集群的不稳定。不稳定的情况表明没有选出任何主节点。
在这种情况下，集群不能对其当前状态进行任何更改，这意味着不能调度新的 pod。</p>
</li>
<li>
<p>保持 etcd 集群的稳定对 Kubernetes 集群的稳定性至关重要。
因此，请在专用机器或隔离环境上运行 etcd 集群，以满足
<a href="https://etcd.io/docs/current/op-guide/hardware/">所需资源需求</a>。</p>
</li>
<li>
<p>在生产中运行的 etcd 的最低推荐版本是 <code>3.2.10+</code>。</p>
</li>
</ul>
<!--
## Resource requirements

Operating etcd with limited resources is suitable only for testing purposes.
For deploying in production, advanced hardware configuration is required.
Before deploying etcd in production, see
[resource requirement reference](https://etcd.io/docs/current/op-guide/hardware/#example-hardware-configurations).

## Starting etcd clusters

This section covers starting a single-node and multi-node etcd cluster. 
-->
<h2 id="资源要求">资源要求</h2>
<p>使用有限的资源运行 etcd 只适合测试目的。为了在生产中部署，需要先进的硬件配置。
在生产中部署 etcd 之前，请查看
<a href="https://etcd.io/docs/current/op-guide/hardware/#example-hardware-configurations">所需资源参考文档</a>。</p>
<h2 id="启动-etcd-集群">启动 etcd 集群</h2>
<p>本节介绍如何启动单节点和多节点 etcd 集群。</p>
<!--
### Single-node etcd cluster

Use a single-node etcd cluster only for testing purpose.

1. Run the following:

   ```sh
   etcd --listen-client-urls=http://$PRIVATE_IP:2379 \
      --advertise-client-urls=http://$PRIVATE_IP:2379
   ```

2. Start the Kubernetes API server with the flag
   `--etcd-servers=$PRIVATE_IP:2379`.

    Make sure `PRIVATE_IP` is set to your etcd client IP.
-->
<h3 id="单节点-etcd-集群">单节点 etcd 集群</h3>
<p>只为测试目的使用单节点 etcd 集群。</p>
<ol>
<li>
<p>运行以下命令：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">etcd --listen-client-urls<span style="color:#666">=</span>http://<span style="color:#b8860b">$PRIVATE_IP</span>:2379 <span style="color:#b62;font-weight:bold">\
</span><span style="color:#b62;font-weight:bold"></span>   --advertise-client-urls<span style="color:#666">=</span>http://<span style="color:#b8860b">$PRIVATE_IP</span>:2379
</code></pre></div></li>
<li>
<p>使用参数 <code>--etcd-servers=$PRIVATE_IP:2379</code> 启动 Kubernetes API 服务器。</p>
<p>确保将 <code>PRIVATE_IP</code> 设置为etcd客户端 IP。</p>
</li>
</ol>
<!--
### Multi-node etcd cluster

For durability and high availability, run etcd as a multi-node cluster in
production and back it up periodically. A five-member cluster is recommended
in production. For more information, see
[FAQ documentation](https://etcd.io/docs/current/faq/#what-is-failure-tolerance).

Configure an etcd cluster either by static member information or by dynamic
discovery. For more information on clustering, see
[etcd clustering documentation](https://etcd.io/docs/current/op-guide/clustering/).

For an example, consider a five-member etcd cluster running with the following
client URLs: `http://$IP1:2379`, `http://$IP2:2379`, `http://$IP3:2379`,
`http://$IP4:2379`, and `http://$IP5:2379`. To start a Kubernetes API server:

1. Run the following:

   ```shell
   etcd --listen-client-urls=http://$IP1:2379,http://$IP2:2379,http://$IP3:2379,http://$IP4:2379,http://$IP5:2379 --advertise-client-urls=http://$IP1:2379,http://$IP2:2379,http://$IP3:2379,http://$IP4:2379,http://$IP5:2379
   ```

2. Start the Kubernetes API servers with the flag
   `--etcd-servers=$IP1:2379,$IP2:2379,$IP3:2379,$IP4:2379,$IP5:2379`.

   Make sure the `IP<n>` variables are set to your client IP addresses.
-->
<h3 id="多节点-etcd-集群">多节点 etcd 集群</h3>
<p>为了耐用性和高可用性，在生产中将以多节点集群的方式运行 etcd，并且定期备份。
建议在生产中使用五个成员的集群。
有关该内容的更多信息，请参阅
<a href="https://etcd.io/docs/current/faq/#what-is-failure-tolerance">常见问题文档</a>。</p>
<p>可以通过静态成员信息或动态发现的方式配置 etcd 集群。
有关集群的详细信息，请参阅
<a href="https://etcd.io/docs/current/op-guide/clustering/">etcd 集群文档</a>。</p>
<p>例如，考虑运行以下客户端 URL 的五个成员的 etcd 集群：<code>http://$IP1:2379</code>，
<code>http://$IP2:2379</code>，<code>http://$IP3:2379</code>，<code>http://$IP4:2379</code> 和 <code>http://$IP5:2379</code>。
要启动 Kubernetes API 服务器：</p>
<ol>
<li>
<p>运行以下命令：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">etcd --listen-client-urls<span style="color:#666">=</span>http://<span style="color:#b8860b">$IP1</span>:2379,http://<span style="color:#b8860b">$IP2</span>:2379,http://<span style="color:#b8860b">$IP3</span>:2379,http://<span style="color:#b8860b">$IP4</span>:2379,http://<span style="color:#b8860b">$IP5</span>:2379 --advertise-client-urls<span style="color:#666">=</span>http://<span style="color:#b8860b">$IP1</span>:2379,http://<span style="color:#b8860b">$IP2</span>:2379,http://<span style="color:#b8860b">$IP3</span>:2379,http://<span style="color:#b8860b">$IP4</span>:2379,http://<span style="color:#b8860b">$IP5</span>:2379
</code></pre></div></li>
<li>
<p>使用参数 <code>--etcd-servers=$IP1:2379,$IP2:2379,$IP3:2379,$IP4:2379,$IP5:2379</code>
启动 Kubernetes API 服务器。</p>
<p>确保将 <code>IP&lt;n&gt;</code> 变量设置为客户端 IP 地址。</p>
</li>
</ol>
<!--
### Multi-node etcd cluster with load balancer

To run a load balancing etcd cluster:

1. Set up an etcd cluster.
2. Configure a load balancer in front of the etcd cluster.
   For example, let the address of the load balancer be `$LB`.
3. Start Kubernetes API Servers with the flag `--etcd-servers=$LB:2379`.
-->
<h3 id="使用负载均衡的多节点-etcd-集群">使用负载均衡的多节点 etcd 集群</h3>
<p>要运行负载均衡的 etcd 集群：</p>
<ol>
<li>建立一个 etcd 集群。</li>
<li>在 etcd 集群前面配置负载均衡器。例如，让负载均衡器的地址为 <code>$LB</code>。</li>
<li>使用参数 <code>--etcd-servers=$LB:2379</code> 启动 Kubernetes API 服务器。</li>
</ol>
<!--
## Securing etcd clusters

Access to etcd is equivalent to root permission in the cluster so ideally only
the API server should have access to it. Considering the sensitivity of the
data, it is recommended to grant permission to only those nodes that require
access to etcd clusters.

To secure etcd, either set up firewall rules or use the security features
provided by etcd. etcd security features depend on x509 Public Key
Infrastructure (PKI). To begin, establish secure communication channels by
generating a key and certificate pair. For example, use key pairs `peer.key`
and `peer.cert` for securing communication between etcd members, and
`client.key` and `client.cert` for securing communication between etcd and its
clients. See the [example scripts](https://github.com/coreos/etcd/tree/master/hack/tls-setup)
provided by the etcd project to generate key pairs and CA files for client
authentication.
-->
<h2 id="安全的-etcd-集群">安全的 etcd 集群</h2>
<p>对 etcd 的访问相当于集群中的 root 权限，因此理想情况下只有 API 服务器才能访问它。
考虑到数据的敏感性，建议只向需要访问 etcd 集群的节点授予权限。</p>
<p>想要确保 etcd 的安全，可以设置防火墙规则或使用 etcd 提供的安全特性，这些安全特性依赖于 x509 公钥基础设施（PKI）。
首先，通过生成密钥和证书对来建立安全的通信通道。
例如，使用密钥对 <code>peer.key</code> 和 <code>peer.cert</code> 来保护 etcd 成员之间的通信，
而 <code>client.key</code> 和 <code>client.cert</code> 用于保护 etcd 与其客户端之间的通信。
请参阅 etcd 项目提供的<a href="https://github.com/coreos/etcd/tree/master/hack/tls-setup">示例脚本</a>，
以生成用于客户端身份验证的密钥对和 CA 文件。</p>
<!--
### Securing communication

To configure etcd with secure peer communication, specify flags
`--peer-key-file=peer.key` and `--peer-cert-file=peer.cert`, and use HTTPS as
the URL schema.

Similarly, to configure etcd with secure client communication, specify flags
`--key-file=k8sclient.key` and `--cert-file=k8sclient.cert`, and use HTTPS as
the URL schema. Here is an example on a client command that uses secure
communication:

```
ETCDCTL_API=3 etcdctl --endpoints 10.2.0.9:2379 \
  --cert=/etc/kubernetes/pki/etcd/server.crt \
  --key=/etc/kubernetes/pki/etcd/server.key \
  --cacert=/etc/kubernetes/pki/etcd/ca.crt \
  member list
```
-->
<h3 id="安全通信">安全通信</h3>
<p>若要使用安全对等通信对 etcd 进行配置，请指定参数 <code>--peer-key-file=peer.key</code>
和 <code>--peer-cert-file=peer.cert</code>，并使用 HTTPS 作为 URL 模式。</p>
<p>类似地，要使用安全客户端通信对 etcd 进行配置，请指定参数 <code>--key-file=k8sclient.key</code>
和 <code>--cert-file=k8sclient.cert</code>，并使用 HTTPS 作为 URL 模式。
使用安全通信的客户端命令的示例：</p>
<pre tabindex="0"><code>ETCDCTL_API=3 etcdctl --endpoints 10.2.0.9:2379 \
  --cert=/etc/kubernetes/pki/etcd/server.crt \
  --key=/etc/kubernetes/pki/etcd/server.key \
  --cacert=/etc/kubernetes/pki/etcd/ca.crt \
  member list
</code></pre><!--
### Limiting access of etcd clusters

After configuring secure communication, restrict the access of etcd cluster to
only the Kubernetes API servers. Use TLS authentication to do so.

For example, consider key pairs `k8sclient.key` and `k8sclient.cert` that are
trusted by the CA `etcd.ca`. When etcd is configured with `--client-cert-auth`
along with TLS, it verifies the certificates from clients by using system CAs
or the CA passed in by `--trusted-ca-file` flag. Specifying flags
`--client-cert-auth=true` and `--trusted-ca-file=etcd.ca` will restrict the
access to clients with the certificate `k8sclient.cert`.

Once etcd is configured correctly, only clients with valid certificates can
access it. To give Kubernetes API servers the access, configure them with the
flags `--etcd-certfile=k8sclient.cert`,`--etcd-keyfile=k8sclient.key` and
`--etcd-cafile=ca.cert`.

<blockquote class="note callout">
  <div><strong>说明：</strong> etcd authentication is not currently supported by Kubernetes. For more
information, see the related issue
<a href="https://github.com/kubernetes/kubernetes/issues/23398">Support Basic Auth for Etcd v2</a>.</div>
</blockquote>
-->
<h3 id="限制-etcd-集群的访问">限制 etcd 集群的访问</h3>
<p>配置安全通信后，将 etcd 集群的访问限制在 Kubernetes API 服务器上。使用 TLS 身份验证来完成此任务。</p>
<p>例如，考虑由 CA <code>etcd.ca</code> 信任的密钥对 <code>k8sclient.key</code> 和 <code>k8sclient.cert</code>。
当 etcd 配置为 <code>--client-cert-auth</code> 和 TLS 时，它使用系统 CA 或由 <code>--trusted-ca-file</code> 参数传入的 CA 验证来自客户端的证书。
指定参数 <code>--client-cert-auth=true</code> 和 <code>--trusted-ca-file=etcd.ca</code> 将限制对具有证书 <code>k8sclient.cert</code> 的客户端的访问。</p>
<p>一旦正确配置了 etcd，只有具有有效证书的客户端才能访问它。要让 Kubernetes API 服务器访问，
可以使用参数 <code>--etcd-certfile=k8sclient.cert</code>,<code>--etcd-keyfile=k8sclient.key</code> 和 <code>--etcd-cafile=ca.cert</code> 配置。</p>
<blockquote class="note callout">
  <div><strong>说明：</strong> Kubernetes 目前不支持 etcd 身份验证。
想要了解更多信息，请参阅相关的问题
<a href="https://github.com/kubernetes/kubernetes/issues/23398">支持 etcd v2 的基本认证</a>。</div>
</blockquote>
<!--
## Replacing a failed etcd member

etcd cluster achieves high availability by tolerating minor member failures.
However, to improve the overall health of the cluster, replace failed members
immediately. When multiple members fail, replace them one by one. Replacing a
failed member involves two steps: removing the failed member and adding a new
member.

Though etcd keeps unique member IDs internally, it is recommended to use a
unique name for each member to avoid human errors. For example, consider a
three-member etcd cluster. Let the URLs be, `member1=http://10.0.0.1`,
`member2=http://10.0.0.2`, and `member3=http://10.0.0.3`. When `member1` fails,
replace it with `member4=http://10.0.0.4`.

1. Get the member ID of the failed `member1`:

   ```shell
   etcdctl --endpoints=http://10.0.0.2,http://10.0.0.3 member list
   ```

   The following message is displayed:

   ```console
   8211f1d0f64f3269, started, member1, http://10.0.0.1:2380, http://10.0.0.1:2379
   91bc3c398fb3c146, started, member2, http://10.0.0.2:2380, http://10.0.0.2:2379
   fd422379fda50e48, started, member3, http://10.0.0.3:2380, http://10.0.0.3:2379
   ```

2. Remove the failed member:

   ```shell
   etcdctl member remove 8211f1d0f64f3269
   ```

   The following message is displayed:

   ```console
   Removed member 8211f1d0f64f3269 from cluster
   ```

3. Add the new member:

   ```shell
   etcdctl member add member4 --peer-urls=http://10.0.0.4:2380
   ```

   The following message is displayed:

   ```console
   Member 2be1eb8f84b7f63e added to cluster ef37ad9dc622a7c4
   ```

4. Start the newly added member on a machine with the IP `10.0.0.4`:

   ```shell
   export ETCD_NAME="member4"
   export ETCD_INITIAL_CLUSTER="member2=http://10.0.0.2:2380,member3=http://10.0.0.3:2380,member4=http://10.0.0.4:2380"
   export ETCD_INITIAL_CLUSTER_STATE=existing
   etcd [flags]
   ```

5. Do either of the following:

   1. Update the `--etcd-servers` flag for the Kubernetes API servers to make
      Kubernetes aware of the configuration changes, then restart the
      Kubernetes API servers.
   2. Update the load balancer configuration if a load balancer is used in the
      deployment.

For more information on cluster reconfiguration, see
[etcd reconfiguration documentation](https://etcd.io/docs/current/op-guide/runtime-configuration/#remove-a-member).
-->
<h2 id="替换失败的-etcd-成员">替换失败的 etcd 成员</h2>
<p>etcd 集群通过容忍少数成员故障实现高可用性。
但是，要改善集群的整体健康状况，请立即替换失败的成员。当多个成员失败时，逐个替换它们。
替换失败成员需要两个步骤：删除失败成员和添加新成员。</p>
<p>虽然 etcd 在内部保留唯一的成员 ID，但建议为每个成员使用唯一的名称，以避免人为错误。
例如，考虑一个三成员的 etcd 集群。让 URL 为：<code>member1=http://10.0.0.1</code>， <code>member2=http://10.0.0.2</code>
和 <code>member3=http://10.0.0.3</code>。当 <code>member1</code> 失败时，将其替换为 <code>member4=http://10.0.0.4</code>。</p>
<ol>
<li>
<p>获取失败的 <code>member1</code> 的成员 ID：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">etcdctl --endpoints<span style="color:#666">=</span>http://10.0.0.2,http://10.0.0.3 member list
</code></pre></div><p>显示以下信息：</p>
<pre tabindex="0"><code class="language-console" data-lang="console">8211f1d0f64f3269, started, member1, http://10.0.0.1:2380, http://10.0.0.1:2379
91bc3c398fb3c146, started, member2, http://10.0.0.2:2380, http://10.0.0.2:2379
fd422379fda50e48, started, member3, http://10.0.0.3:2380, http://10.0.0.3:2379
</code></pre></li>
<li>
<p>移除失败的成员</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">etcdctl member remove 8211f1d0f64f3269
</code></pre></div><p>显示以下信息：</p>
<pre tabindex="0"><code class="language-console" data-lang="console">Removed member 8211f1d0f64f3269 from cluster
</code></pre></li>
<li>
<p>增加新成员：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">etcdctl member add member4 --peer-urls<span style="color:#666">=</span>http://10.0.0.4:2380
</code></pre></div><p>显示以下信息：</p>
<pre tabindex="0"><code class="language-console" data-lang="console">Member 2be1eb8f84b7f63e added to cluster ef37ad9dc622a7c4
</code></pre></li>
<li>
<p>在 IP 为 <code>10.0.0.4</code> 的机器上启动新增加的成员：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="color:#a2f">export</span> <span style="color:#b8860b">ETCD_NAME</span><span style="color:#666">=</span><span style="color:#b44">&#34;member4&#34;</span>
<span style="color:#a2f">export</span> <span style="color:#b8860b">ETCD_INITIAL_CLUSTER</span><span style="color:#666">=</span><span style="color:#b44">&#34;member2=http://10.0.0.2:2380,member3=http://10.0.0.3:2380,member4=http://10.0.0.4:2380&#34;</span>
<span style="color:#a2f">export</span> <span style="color:#b8860b">ETCD_INITIAL_CLUSTER_STATE</span><span style="color:#666">=</span>existing
etcd <span style="color:#666">[</span>flags<span style="color:#666">]</span>
</code></pre></div></li>
<li>
<p>做以下事情之一：</p>
<ol>
<li>更新 Kubernetes API 服务器的 <code>--etcd-servers</code> 参数，使 Kubernetes 知道配置进行了更改，然后重新启动 Kubernetes API 服务器。</li>
<li>如果在 deployment 中使用了负载均衡，更新负载均衡配置。</li>
</ol>
</li>
</ol>
<p>有关集群重新配置的详细信息，请参阅 <a href="https://etcd.io/docs/current/op-guide/runtime-configuration/#remove-a-member">etcd 重构文档</a>。</p>
<!--
## Backing up an etcd cluster

All Kubernetes objects are stored on etcd. Periodically backing up the etcd
cluster data is important to recover Kubernetes clusters under disaster
scenarios, such as losing all control plane nodes. The snapshot file contains
all the Kubernetes states and critical information. In order to keep the
sensitive Kubernetes data safe, encrypt the snapshot files.

Backing up an etcd cluster can be accomplished in two ways: etcd built-in
snapshot and volume snapshot.
-->
<h2 id="备份-etcd-集群">备份 etcd 集群</h2>
<p>所有 Kubernetes 对象都存储在 etcd 上。定期备份 etcd 集群数据对于在灾难场景（例如丢失所有控制平面节点）下恢复 Kubernetes 集群非常重要。
快照文件包含所有 Kubernetes 状态和关键信息。为了保证敏感的 Kubernetes 数据的安全，可以对快照文件进行加密。</p>
<p>备份 etcd 集群可以通过两种方式完成：etcd 内置快照和卷快照。</p>
<!--
### Built-in snapshot

etcd supports built-in snapshot. A snapshot may either be taken from a live
member with the `etcdctl snapshot save` command or by copying the
`member/snap/db` file from an etcd
[data directory](https://etcd.io/docs/current/op-guide/configuration/#--data-dir)
that is not currently used by an etcd process. Taking the snapshot will
not affect the performance of the member.

Below is an example for taking a snapshot of the keyspace served by
`$ENDPOINT` to the file `snapshotdb`:

```shell
ETCDCTL_API=3 etcdctl --endpoints $ENDPOINT snapshot save snapshotdb
```

Verify the snapshot:

```shell
ETCDCTL_API=3 etcdctl --write-out=table snapshot status snapshotdb
```

```console
+----------+----------+------------+------------+
|   HASH   | REVISION | TOTAL KEYS | TOTAL SIZE |
+----------+----------+------------+------------+
| fe01cf57 |       10 |          7 | 2.1 MB     |
+----------+----------+------------+------------+
```
-->
<h3 id="内置快照">内置快照</h3>
<p>etcd 支持内置快照。快照可以从使用 <code>etcdctl snapshot save</code> 命令的活动成员中获取，
也可以通过从 etcd <a href="https://etcd.io/docs/current/op-guide/configuration/#--data-dir">数据目录</a>
复制 <code>member/snap/db</code> 文件，该 etcd 数据目录目前没有被 etcd 进程使用。获取快照不会影响成员的性能。</p>
<p>下面是一个示例，用于获取 <code>$ENDPOINT</code> 所提供的键空间的快照到文件 <code>snapshotdb</code>：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="color:#b8860b">ETCDCTL_API</span><span style="color:#666">=</span><span style="color:#666">3</span> etcdctl --endpoints <span style="color:#b8860b">$ENDPOINT</span> snapshot save snapshotdb
</code></pre></div><p>验证快照:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="color:#b8860b">ETCDCTL_API</span><span style="color:#666">=</span><span style="color:#666">3</span> etcdctl --write-out<span style="color:#666">=</span>table snapshot status snapshotdb
</code></pre></div><pre tabindex="0"><code class="language-console" data-lang="console">+----------+----------+------------+------------+
|   HASH   | REVISION | TOTAL KEYS | TOTAL SIZE |
+----------+----------+------------+------------+
| fe01cf57 |       10 |          7 | 2.1 MB     |
+----------+----------+------------+------------+
</code></pre><!--
### Volume snapshot

If etcd is running on a storage volume that supports backup, such as Amazon
Elastic Block Store, back up etcd data by taking a snapshot of the storage
volume.

### Snapshot using etcdctl options

We can also take the snapshot using various options given by etcdctl. For example 

```shell
ETCDCTL_API=3 etcdctl -h 
``` 

will list various options available from etcdctl. For example, you can take a snapshot by specifying
the endpoint, certificates etc as shown below:

```shell
ETCDCTL_API=3 etcdctl --endpoints=https://127.0.0.1:2379 \
  --cacert=<trusted-ca-file> --cert=<cert-file> --key=<key-file> \
  snapshot save <backup-file-location>
```
where `trusted-ca-file`, `cert-file` and `key-file` can be obtained from the description of the etcd Pod.

## Scaling up etcd clusters

Scaling up etcd clusters increases availability by trading off performance.
Scaling does not increase cluster performance nor capability. A general rule
is not to scale up or down etcd clusters. Do not configure any auto scaling
groups for etcd clusters. It is highly recommended to always run a static
five-member etcd cluster for production Kubernetes clusters at any officially
supported scale.

A reasonable scaling is to upgrade a three-member cluster to a five-member
one, when more reliability is desired. See
[etcd reconfiguration documentation](https://etcd.io/docs/current/op-guide/runtime-configuration/#remove-a-member)
for information on how to add members into an existing cluster.
-->
<h3 id="卷快照">卷快照</h3>
<p>如果 etcd 运行在支持备份的存储卷（如 Amazon Elastic Block 存储）上，则可以通过获取存储卷的快照来备份 etcd 数据。</p>
<h3 id="使用-etcdctl-选项的快照">使用 etcdctl 选项的快照</h3>
<p>我们还可以使用 etcdctl 提供的各种选项来拍摄快照。例如：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="color:#b8860b">ETCDCTL_API</span><span style="color:#666">=</span><span style="color:#666">3</span> etcdctl -h 
</code></pre></div><p>列出 etcdctl 可用的各种选项。例如，你可以通过指定端点，证书等来拍摄快照，如下所示：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="color:#b8860b">ETCDCTL_API</span><span style="color:#666">=</span><span style="color:#666">3</span> etcdctl --endpoints<span style="color:#666">=</span>https://127.0.0.1:2379 <span style="color:#b62;font-weight:bold">\
</span><span style="color:#b62;font-weight:bold"></span>  --cacert<span style="color:#666">=</span>&lt;trusted-ca-file&gt; --cert<span style="color:#666">=</span>&lt;cert-file&gt; --key<span style="color:#666">=</span>&lt;key-file&gt; <span style="color:#b62;font-weight:bold">\
</span><span style="color:#b62;font-weight:bold"></span>  snapshot save &lt;backup-file-location&gt;
</code></pre></div><p>可以从 etcd Pod 的描述中获得 <code>trusted-ca-file</code>, <code>cert-file</code> 和 <code>key-file</code> 。</p>
<h2 id="扩展-etcd-集群">扩展 etcd 集群</h2>
<p>通过交换性能，扩展 etcd 集群可以提高可用性。缩放不会提高集群性能和能力。
一般情况下不要扩大或缩小 etcd 集群的集合。不要为 etcd 集群配置任何自动缩放组。
强烈建议始终在任何官方支持的规模上运行生产 Kubernetes 集群时使用静态的五成员 etcd 集群。</p>
<p>合理的扩展是在需要更高可靠性的情况下，将三成员集群升级为五成员集群。
请参阅 <a href="https://etcd.io/docs/current/op-guide/runtime-configuration/#remove-a-member">etcd 重新配置文档</a>
以了解如何将成员添加到现有集群中的信息。</p>
<!--
## Restoring an etcd cluster

etcd supports restoring from snapshots that are taken from an etcd process of
the [major.minor](http://semver.org/) version. Restoring a version from a
different patch version of etcd also is supported. A restore operation is
employed to recover the data of a failed cluster.

Before starting the restore operation, a snapshot file must be present. It can
either be a snapshot file from a previous backup operation, or from a remaining
[data directory]( https://etcd.io/docs/current/op-guide/configuration/#--data-dir).
Here is an example:

```shell
ETCDCTL_API=3 etcdctl --endpoints 10.2.0.9:2379 snapshot restore snapshotdb
```

For more information and examples on restoring a cluster from a snapshot file, see
[etcd disaster recovery documentation](https://etcd.io/docs/current/op-guide/recovery/#restoring-a-cluster).

If the access URLs of the restored cluster is changed from the previous
cluster, the Kubernetes API server must be reconfigured accordingly. In this
case, restart Kubernetes API servers with the flag
`--etcd-servers=$NEW_ETCD_CLUSTER` instead of the flag
`--etcd-servers=$OLD_ETCD_CLUSTER`. Replace `$NEW_ETCD_CLUSTER` and
`$OLD_ETCD_CLUSTER` with the respective IP addresses. If a load balancer is
used in front of an etcd cluster, you might need to update the load balancer
instead.

If the majority of etcd members have permanently failed, the etcd cluster is
considered failed. In this scenario, Kubernetes cannot make any changes to its
current state. Although the scheduled pods might continue to run, no new pods
can be scheduled. In such cases, recover the etcd cluster and potentially
reconfigure Kubernetes API servers to fix the issue.

<blockquote class="note callout">
  <div><strong>说明：</strong> <p>If any API servers are running in your cluster, you should not attempt to
restore instances of etcd. Instead, follow these steps to restore etcd:</p>
<ul>
<li>stop <em>all</em> API server instances</li>
<li>restore state in all etcd instances</li>
<li>restart all API server instances</li>
</ul>
<p>We also recommend restarting any components (e.g. <code>kube-scheduler</code>,
<code>kube-controller-manager</code>, <code>kubelet</code>) to ensure that they don't rely on some
stale data. Note that in practice, the restore takes a bit of time.  During the
restoration, critical components will lose leader lock and restart themselves.</p>
</div>
</blockquote>
-->
<h2 id="恢复-etcd-集群">恢复 etcd 集群</h2>
<p>etcd 支持从 <a href="http://semver.org/">major.minor</a> 或其他不同 patch 版本的 etcd 进程中获取的快照进行恢复。
还原操作用于恢复失败的集群的数据。</p>
<p>在启动还原操作之前，必须有一个快照文件。它可以是来自以前备份操作的快照文件，
也可以是来自剩余<a href="https://etcd.io/docs/current/op-guide/configuration/#--data-dir">数据目录</a>的快照文件。
例如：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="color:#b8860b">ETCDCTL_API</span><span style="color:#666">=</span><span style="color:#666">3</span> etcdctl --endpoints 10.2.0.9:2379 snapshot restore snapshotdb
</code></pre></div><p>有关从快照文件还原集群的详细信息和示例，请参阅
<a href="https://etcd.io/docs/current/op-guide/recovery/#restoring-a-cluster">etcd 灾难恢复文档</a>。</p>
<p>如果还原的集群的访问 URL 与前一个集群不同，则必须相应地重新配置 Kubernetes API 服务器。
在本例中，使用参数 <code>--etcd-servers=$NEW_ETCD_CLUSTER</code> 而不是参数 <code>--etcd-servers=$OLD_ETCD_CLUSTER</code> 重新启动 Kubernetes API 服务器。
用相应的 IP 地址替换 <code>$NEW_ETCD_CLUSTER</code> 和 <code>$OLD_ETCD_CLUSTER</code>。如果在 etcd 集群前面使用负载平衡，则可能需要更新负载均衡器。</p>
<p>如果大多数 etcd 成员永久失败，则认为 etcd 集群失败。在这种情况下，Kubernetes 不能对其当前状态进行任何更改。
虽然已调度的 pod 可能继续运行，但新的 pod 无法调度。在这种情况下，恢复 etcd 集群并可能需要重新配置 Kubernetes API 服务器以修复问题。</p>
<blockquote class="note callout">
  <div><strong>说明：</strong> <p>如果集群中正在运行任何 API 服务器，则不应尝试还原 etcd 的实例。相反，请按照以下步骤还原 etcd：</p>
<ul>
<li>停止 <em>所有</em> API 服务实例</li>
<li>在所有 etcd 实例中恢复状态</li>
<li>重启所有 API 服务实例</li>
</ul>
<p>我们还建议重启所有组件（例如 <code>kube-scheduler</code>、<code>kube-controller-manager</code>、<code>kubelet</code>），以确保它们不会
依赖一些过时的数据。请注意，实际中还原会花费一些时间。
在还原过程中，关键组件将丢失领导锁并自行重启。</p>
<blockquote class="note callout">
  <div><strong>说明：</strong> </div>
</blockquote></div>
</blockquote>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-b64a1d2bb3f4ed9f7021134e09a75c36">9 - 为系统守护进程预留计算资源</h1>
    
	<!--
reviewers:
- vishh
- derekwaynecarr
- dashpole
title: Reserve Compute Resources for System Daemons
content_type: task
min-kubernetes-server-version: 1.8
-->
<!-- overview -->
<!--
Kubernetes nodes can be scheduled to `Capacity`. Pods can consume all the
available capacity on a node by default. This is an issue because nodes
typically run quite a few system daemons that power the OS and Kubernetes
itself. Unless resources are set aside for these system daemons, pods and system
daemons compete for resources and lead to resource starvation issues on the
node.

The `kubelet` exposes a feature named `Node Allocatable` that helps to reserve
compute resources for system daemons. Kubernetes recommends cluster
administrators to configure `Node Allocatable` based on their workload density
on each node.
-->
<p>Kubernetes 的节点可以按照 <code>Capacity</code> 调度。默认情况下 pod 能够使用节点全部可用容量。
这是个问题，因为节点自己通常运行了不少驱动 OS 和 Kubernetes 的系统守护进程。
除非为这些系统守护进程留出资源，否则它们将与 pod 争夺资源并导致节点资源短缺问题。</p>
<p><code>kubelet</code> 公开了一个名为 <code>Node Allocatable</code> 的特性，有助于为系统守护进程预留计算资源。
Kubernetes 推荐集群管理员按照每个节点上的工作负载密度配置 <code>Node Allocatable</code>。</p>
<h2 id="准备开始">准备开始</h2>
<p><p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
如果你还没有集群，你可以通过 <a href="/zh/docs/tasks/tools/#minikube">Minikube</a> 构建一
个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p>
<!--
You need to have a Kubernetes cluster, and the kubectl command-line tool must
be configured to communicate with your cluster. If you do not already have a
cluster, you can create one by using
[minikube](/docs/tasks/tools/#minikube)
or you can use one of these Kubernetes playgrounds:
-->
<ul>
<li><a href="https://www.katacoda.com/courses/kubernetes/playground">Katacoda</a></li>
<li><a href="http://labs.play-with-k8s.com/">玩转 Kubernetes</a></li>
</ul>
 

您的 Kubernetes 服务器版本必须不低于版本 1.8.
 要获知版本信息，请输入 <code>kubectl version</code>.
</p>
<!-- 
Your Kubernetes server must be at or later than version 1.17 to use
the kubelet command line option `--reserved-cpus` to set an
[explicitly reserved CPU list](#explicitly-reserved-cpu-list).
-->
<p>您的 kubernetes 服务器版本必须至少是 1.17 版本，才能使用 kubelet
命令行选项 <code>--reserved-cpus</code> 设置
<a href="#explicitly-reserved-cpu-list">显式预留 CPU 列表</a>。</p>
<!-- steps -->
<!--
## Node Allocatable

![node capacity](/images/docs/node-capacity.svg)

`Allocatable` on a Kubernetes node is defined as the amount of compute resources
that are available for pods. The scheduler does not over-subscribe
`Allocatable`. `CPU`, `memory` and `ephemeral-storage` are supported as of now.

Node Allocatable is exposed as part of `v1.Node` object in the API and as part
of `kubectl describe node` in the CLI.

Resources can be reserved for two categories of system daemons in the `kubelet`.
-->
<h2 id="node-allocatable">节点可分配  </h2>
<p><img src="/images/docs/node-capacity.svg" alt="节点容量"></p>
<p>Kubernetes 节点上的 <code>Allocatable</code> 被定义为 pod 可用计算资源量。
调度器不会超额申请 <code>Allocatable</code>。
目前支持 <code>CPU</code>, <code>memory</code> 和 <code>ephemeral-storage</code> 这几个参数。</p>
<p>可分配的节点暴露为 API 中 <code>v1.Node</code> 对象的一部分，也是 CLI 中
<code>kubectl describe node</code> 的一部分。</p>
<p>在 <code>kubelet</code> 中，可以为两类系统守护进程预留资源。</p>
<!--
### Enabling QoS and Pod level cgroups

To properly enforce node allocatable constraints on the node, you must
enable the new cgroup hierarchy via the `--cgroups-per-qos` flag. This flag is
enabled by default. When enabled, the `kubelet` will parent all end-user pods
under a cgroup hierarchy managed by the `kubelet`.
-->
<h3 id="启用-qos-和-pod-级别的-cgroups">启用 QoS 和 Pod 级别的 cgroups</h3>
<p>为了恰当的在节点范围实施节点可分配约束，你必须通过 <code>--cgroups-per-qos</code>
标志启用新的 cgroup 层次结构。这个标志是默认启用的。
启用后，<code>kubelet</code> 将在其管理的 cgroup 层次结构中创建所有终端用户的 Pod。</p>
<!--
### Configuring a cgroup driver

The `kubelet` supports manipulation of the cgroup hierarchy on
the host using a cgroup driver. The driver is configured via the
`--cgroup-driver` flag.

The supported values are the following:

* `cgroupfs` is the default driver that performs direct manipulation of the
cgroup filesystem on the host in order to manage cgroup sandboxes.
* `systemd` is an alternative driver that manages cgroup sandboxes using
transient slices for resources that are supported by that init system.

Depending on the configuration of the associated container runtime,
operators may have to choose a particular cgroup driver to ensure
proper system behavior. For example, if operators use the `systemd`
cgroup driver provided by the `docker` runtime, the `kubelet` must
be configured to use the `systemd` cgroup driver.
-->
<h3 id="配置-cgroup-驱动">配置 cgroup 驱动</h3>
<p><code>kubelet</code> 支持在主机上使用 cgroup 驱动操作 cgroup 层次结构。
驱动通过 <code>--cgroup-driver</code> 标志配置。</p>
<p>支持的参数值如下：</p>
<ul>
<li><code>cgroupfs</code> 是默认的驱动，在主机上直接操作 cgroup 文件系统以对 cgroup
沙箱进行管理。</li>
<li><code>systemd</code> 是可选的驱动，使用 init 系统支持的资源的瞬时切片管理
cgroup 沙箱。</li>
</ul>
<p>取决于相关容器运行时的配置，操作员可能需要选择一个特定的 cgroup 驱动
来保证系统正常运行。
例如，如果操作员使用 <code>docker</code> 运行时提供的 <code>systemd</code> cgroup 驱动时，
必须配置 <code>kubelet</code> 使用 <code>systemd</code> cgroup 驱动。</p>
<!--
### Kube Reserved

- **Kubelet Flag**: `--kube-reserved=[cpu=100m][,][memory=100Mi][,][ephemeral-storage=1Gi][,][pid=1000]`
- **Kubelet Flag**: `--kube-reserved-cgroup=`

`kube-reserved` is meant to capture resource reservation for kubernetes system
daemons like the `kubelet`, `container runtime`, `node problem detector`, etc.
It is not meant to reserve resources for system daemons that are run as pods.
`kube-reserved` is typically a function of `pod density` on the nodes.

In addition to `cpu`, `memory`, and `ephemeral-storage`, `pid` may be
specified to reserve the specified number of process IDs for
kubernetes system daemons.
-->
<h3 id="kube-reserved">Kube 预留值 </h3>
<ul>
<li><strong>Kubelet 标志</strong>: <code>--kube-reserved=[cpu=100m][,][memory=100Mi][,][ephemeral-storage=1Gi][,][pid=1000]</code></li>
<li><strong>Kubelet 标志</strong>: <code>--kube-reserved-cgroup=</code></li>
</ul>
<p><code>kube-reserved</code> 用来给诸如 <code>kubelet</code>、容器运行时、节点问题监测器等
kubernetes 系统守护进程记述其资源预留值。
该配置并非用来给以 Pod 形式运行的系统守护进程保留资源。<code>kube-reserved</code>
通常是节点上 <code>pod 密度</code> 的函数。</p>
<p>除了 <code>cpu</code>，<code>内存</code> 和 <code>ephemeral-storage</code> 之外，<code>pid</code> 可用来指定为
kubernetes 系统守护进程预留指定数量的进程 ID。</p>
<!--
To optionally enforce `kube-reserved` on kubernetes system daemons, specify the parent
control group for kube daemons as the value for `--kube-reserved-cgroup` kubelet
flag.

It is recommended that the kubernetes system daemons are placed under a top
level control group (`runtime.slice` on systemd machines for example). Each
system daemon should ideally run within its own child control group. Refer to
[this
doc](https://git.k8s.io/community/contributors/design-proposals/node/node-allocatable.md#recommended-cgroups-setup)
for more details on recommended control group hierarchy.

Note that Kubelet **does not** create `--kube-reserved-cgroup` if it doesn't
exist. Kubelet will fail if an invalid cgroup is specified.
-->
<p>要选择性地对 kubernetes 系统守护进程上执行 <code>kube-reserved</code> 保护，需要把 kubelet 的
<code>--kube-reserved-cgroup</code> 标志的值设置为 kube 守护进程的父控制组。</p>
<p>推荐将 kubernetes 系统守护进程放置于顶级控制组之下（例如 systemd 机器上的
<code>runtime.slice</code>）。
理想情况下每个系统守护进程都应该在其自己的子控制组中运行。
请参考
<a href="https://git.k8s.io/community/contributors/design-proposals/node/node-allocatable.md#recommended-cgroups-setup">这篇文档</a>，
进一步了解关于推荐控制组层次结构的细节。</p>
<p>请注意，如果 <code>--kube-reserved-cgroup</code> 不存在，Kubelet 将 <strong>不会</strong> 创建它。
如果指定了一个无效的 cgroup，Kubelet 将会失败。</p>
<!--
### System Reserved

- **Kubelet Flag**: `--system-reserved=[cpu=100m][,][memory=100Mi][,][ephemeral-storage=1Gi][,][pid=1000]`
- **Kubelet Flag**: `--system-reserved-cgroup=`


`system-reserved` is meant to capture resource reservation for OS system daemons
like `sshd`, `udev`, etc. `system-reserved` should reserve `memory` for the
`kernel` too since `kernel` memory is not accounted to pods in Kubernetes at this time.
Reserving resources for user login sessions is also recommended (`user.slice` in
systemd world).

In addition to `cpu`, `memory`, and `ephemeral-storage`, `pid` may be
specified to reserve the specified number of process IDs for OS system
daemons.
-->
<h3 id="system-reserved">系统预留值 </h3>
<ul>
<li><strong>Kubelet 标志</strong>: <code>--system-reserved=[cpu=100m][,][memory=100Mi][,][ephemeral-storage=1Gi][,][pid=1000]</code></li>
<li><strong>Kubelet 标志</strong>: <code>--system-reserved-cgroup=</code></li>
</ul>
<p><code>system-reserved</code> 用于为诸如 <code>sshd</code>、<code>udev</code> 等系统守护进程记述其资源预留值。
<code>system-reserved</code> 也应该为 <code>kernel</code> 预留 <code>内存</code>，因为目前 <code>kernel</code>
使用的内存并不记在 Kubernetes 的 Pod 上。
同时还推荐为用户登录会话预留资源（systemd 体系中的 <code>user.slice</code>）。</p>
<p>除了 <code>cpu</code>，<code>内存</code> 和 <code>ephemeral-storage</code> 之外，<code>pid</code> 可用来指定为
kubernetes 系统守护进程预留指定数量的进程 ID。</p>
<!--
To optionally enforce `system-reserved` on system daemons, specify the parent
control group for OS system daemons as the value for `--system-reserved-cgroup`
kubelet flag.

It is recommended that the OS system daemons are placed under a top level
control group (`system.slice` on systemd machines for example).

Note that Kubelet **does not** create `--system-reserved-cgroup` if it doesn't
exist. Kubelet will fail if an invalid cgroup is specified.
-->
<p>要想为系统守护进程上可选地实施 <code>system-reserved</code> 约束，请指定 kubelet 的
<code>--system-reserved-cgroup</code> 标志值为 OS 系统守护进程的父级控制组。</p>
<p>推荐将 OS 系统守护进程放在一个顶级控制组之下（例如 systemd 机器上的
<code>system.slice</code>）。</p>
<p>请注意，如果 <code>--system-reserved-cgroup</code> 不存在，Kubelet <strong>不会</strong> 创建它。
如果指定了无效的 cgroup，Kubelet 将会失败。</p>
<!--
### Explicitly Reserved CPU List

- **Kubelet Flag**: `--reserved-cpus=0-3`
-->
<h3 id="explicitly-reserved-cpu-list">显式保留的 CPU 列表</h3>





<div style="margin-top: 10px; margin-bottom: 10px;">
<b>FEATURE STATE:</b> <code>Kubernetes v1.17 [stable]</code>
</div>

<ul>
<li><strong>Kubelet 标志</strong>: <code>--reserved-cpus=0-3</code></li>
</ul>
<!--
`reserved-cpus` is meant to define an explicit CPU set for OS system daemons and
kubernetes system daemons. `reserved-cpus` is for systems that do not intend to
define separate top level cgroups for OS system daemons and kubernetes system daemons
with regard to cpuset resource.
If the Kubelet **does not** have `--system-reserved-cgroup` and `--kube-reserved-cgroup`,
the explicit cpuset provided by `reserved-cpus` will take precedence over the CPUs
defined by `--kube-reserved` and `--system-reserved` options.
-->
<p><code>reserved-cpus</code> 旨在为操作系统守护程序和 kubernetes 系统守护程序保留一组明确指定编号的
CPU。<code>reserved-cpus</code> 适用于不打算针对 cpuset 资源为操作系统守护程序和 kubernetes
系统守护程序定义独立的顶级 cgroups 的系统。
如果 Kubelet <strong>没有</strong> 指定参数 <code>--system-reserved-cgroup</code> 和 <code>--kube-reserved-cgroup</code>，
则 <code>reserved-cpus</code> 的设置将优先于 <code>--kube-reserved</code> 和 <code>--system-reserved</code> 选项。</p>
<!--
This option is specifically designed for Telco/NFV use cases where uncontrolled
interrupts/timers may impact the workload performance. you can use this option
to define the explicit cpuset for the system/kubernetes daemons as well as the
interrupts/timers, so the rest CPUs on the system can be used exclusively for
workloads, with less impact from uncontrolled interrupts/timers. To move the
system daemon, kubernetes daemons and interrupts/timers to the explicit cpuset
defined by this option, other mechanism outside Kubernetes should be used.
For example: in Centos, you can do this using the tuned toolset.
-->
<p>此选项是专门为电信/NFV 用例设计的，在这些用例中不受控制的中断或计时器可能会
影响其工作负载性能。
你可以使用此选项为系统或 kubernetes 守护程序以及中断或计时器显式定义 cpuset，
这样系统上的其余 CPU 可以专门用于工作负载，因不受控制的中断或计时器的影响得以
降低。
要将系统守护程序、kubernetes 守护程序和中断或计时器移动到此选项定义的显式
cpuset 上，应使用 Kubernetes 之外的其他机制。
例如：在 Centos 系统中，可以使用 tuned 工具集来执行此操作。</p>
<!--
### Eviction Thresholds

- **Kubelet Flag**: `--eviction-hard=[memory.available<500Mi]`

Memory pressure at the node level leads to System OOMs which affects the entire
node and all pods running on it. Nodes can go offline temporarily until memory
has been reclaimed. To avoid (or reduce the probability of) system OOMs kubelet
provides [`Out of Resource`](/docs/tasks/administer-cluster/out-of-resource/) management. Evictions are
supported for `memory` and `ephemeral-storage` only. By reserving some memory via
`--eviction-hard` flag, the `kubelet` attempts to `evict` pods whenever memory
availability on the node drops below the reserved value. Hypothetically, if
system daemons did not exist on a node, pods cannot use more than `capacity -
eviction-hard`. For this reason, resources reserved for evictions are not
available for pods.
-->
<h3 id="eviction-Thresholds">驱逐阈值  </h3>
<ul>
<li><strong>Kubelet 标志</strong>: <code>--eviction-hard=[memory.available&lt;500Mi]</code></li>
</ul>
<p>节点级别的内存压力将导致系统内存不足，这将影响到整个节点及其上运行的所有 Pod。
节点可以暂时离线直到内存已经回收为止。
为了防止（或减少可能性）系统内存不足，kubelet 提供了
<a href="/zh/docs/tasks/administer-cluster/out-of-resource/">资源不足</a>管理。
驱逐操作只支持 <code>memory</code> 和 <code>ephemeral-storage</code>。
通过 <code>--eviction-hard</code> 标志预留一些内存后，当节点上的可用内存降至保留值以下时，
<code>kubelet</code> 将尝试<code>驱逐</code> Pod。
如果节点上不存在系统守护进程，Pod 将不能使用超过 <code>capacity-eviction-hard</code> 所
指定的资源量。因此，为驱逐而预留的资源对 Pod 是不可用的。</p>
<!--
### Enforcing Node Allocatable

- **Kubelet Flag**: `--enforce-node-allocatable=pods[,][system-reserved][,][kube-reserved]`

The scheduler treats `Allocatable` as the available `capacity` for pods.

`kubelet` enforce `Allocatable` across pods by default. Enforcement is performed
by evicting pods whenever the overall usage across all pods exceeds
`Allocatable`. More details on eviction policy can be found
[here](/docs/tasks/administer-cluster/out-of-resource/#eviction-policy). This enforcement is controlled by
specifying `pods` value to the kubelet flag `--enforce-node-allocatable`.

Optionally, `kubelet` can be made to enforce `kube-reserved` and
`system-reserved` by specifying `kube-reserved` & `system-reserved` values in
the same flag. Note that to enforce `kube-reserved` or `system-reserved`,
`--kube-reserved-cgroup` or `--system-reserved-cgroup` needs to be specified
respectively.
-->
<h3 id="enforcing-node-allocatable">实施节点可分配约束  </h3>
<ul>
<li><strong>Kubelet 标志</strong>: <code>--enforce-node-allocatable=pods[,][system-reserved][,][kube-reserved]</code></li>
</ul>
<p>调度器将 <code>Allocatable</code> 视为 Pod 可用的 <code>capacity</code>（资源容量）。</p>
<p><code>kubelet</code> 默认对 Pod 执行 <code>Allocatable</code> 约束。
无论何时，如果所有 Pod 的总用量超过了 <code>Allocatable</code>，驱逐 Pod 的措施将被执行。
有关驱逐策略的更多细节可以在
<a href="/zh/docs/tasks/administer-cluster/out-of-resource/#eviction-policy">这里</a>找到。
可通过设置 kubelet <code>--enforce-node-allocatable</code> 标志值为 <code>pods</code> 控制这个措施。</p>
<p>可选地，通过在同一标志中同时指定 <code>kube-reserved</code> 和 <code>system-reserved</code> 值，
可以使 <code>kubelet</code> 强制实施 <code>kube-reserved</code> 和 <code>system-reserved</code>约束。
请注意，要想执行 <code>kube-reserved</code> 或者 <code>system-reserved</code> 约束，
需要对应设置 <code>--kube-reserved-cgroup</code> 或者 <code>--system-reserved-cgroup</code>。</p>
<!--
## General Guidelines

System daemons are expected to be treated similar to `Guaranteed` pods. System
daemons can burst within their bounding control groups and this behavior needs
to be managed as part of kubernetes deployments. For example, `kubelet` should
have its own control group and share `Kube-reserved` resources with the
container runtime. However, Kubelet cannot burst and use up all available Node
resources if `kube-reserved` is enforced.
-->
<h2 id="general-guidelines">一般原则  </h2>
<p>系统守护进程一般会被按照类似 <code>Guaranteed</code> Pod 一样对待。
系统守护进程可以在与其对应的控制组中出现突发资源用量，这一行为要作为
kubernetes 部署的一部分进行管理。
例如，<code>kubelet</code> 应该有它自己的控制组并和容器运行时共享 <code>Kube-reserved</code> 资源。
不过，如果执行了 <code>kube-reserved</code> 约束，则 kubelet 不可出现突发负载并用光
节点的所有可用资源。</p>
<!--
Be extra careful while enforcing `system-reserved` reservation since it can lead
to critical system services being CPU starved, OOM killed, or unable
to fork on the node. The
recommendation is to enforce `system-reserved` only if a user has profiled their
nodes exhaustively to come up with precise estimates and is confident in their
ability to recover if any process in that group is oom_killed.

* To begin with enforce `Allocatable` on `pods`.
* Once adequate monitoring and alerting is in place to track kube system
  daemons, attempt to enforce `kube-reserved` based on usage heuristics.
* If absolutely necessary, enforce `system-reserved` over time.
-->
<p>在执行 <code>system-reserved</code> 预留策略时请加倍小心，因为它可能导致节点上的
关键系统服务出现 CPU 资源短缺、因为内存不足而被终止或者无法在节点上创建进程。
建议只有当用户详尽地描述了他们的节点以得出精确的估计值，
并且对该组中进程因内存不足而被杀死时，有足够的信心将其恢复时，
才可以强制执行 <code>system-reserved</code> 策略。</p>
<ul>
<li>作为起步，可以先针对 <code>pods</code> 上执行 <code>Allocatable</code> 约束。</li>
<li>一旦用于追踪系统守护进程的监控和告警的机制到位，可尝试基于用量估计的
方式执行 <code>kube-reserved</code>策略。</li>
<li>随着时间推进，在绝对必要的时候可以执行 <code>system-reserved</code> 策略。</li>
</ul>
<!--
The resource requirements of kube system daemons may grow over time as more and
more features are added. Over time, kubernetes project will attempt to bring
down utilization of node system daemons, but that is not a priority as of now.
So expect a drop in `Allocatable` capacity in future releases.
-->
<p>随着时间推进和越来越多特性被加入，kube 系统守护进程对资源的需求可能也会增加。
以后 kubernetes 项目将尝试减少对节点系统守护进程的利用，但目前这件事的优先级
并不是最高。
所以，将来的发布版本中 <code>Allocatable</code> 容量是有可能降低的。</p>
<!-- discussion -->
<!--
## Example Scenario

Here is an example to illustrate Node Allocatable computation:

* Node has `32Gi` of `memory`, `16 CPUs` and `100Gi` of `Storage`
* `--kube-reserved` is set to `cpu=1,memory=2Gi,ephemeral-storage=1Gi`
* `--system-reserved` is set to `cpu=500m,memory=1Gi,ephemeral-storage=1Gi`
* `--eviction-hard` is set to `memory.available<500Mi,nodefs.available<10%`
-->
<h2 id="example-scenario">示例场景  </h2>
<p>这是一个用于说明节点可分配（Node Allocatable）计算方式的示例：</p>
<ul>
<li>节点拥有 <code>32Gi</code> <code>memeory</code>，<code>16 CPU</code> 和 <code>100Gi</code> <code>Storage</code> 资源</li>
<li><code>--kube-reserved</code> 被设置为 <code>cpu=1,memory=2Gi,ephemeral-storage=1Gi</code></li>
<li><code>--system-reserved</code> 被设置为 <code>cpu=500m,memory=1Gi,ephemeral-storage=1Gi</code></li>
<li><code>--eviction-hard</code> 被设置为 <code>memory.available&lt;500Mi,nodefs.available&lt;10%</code></li>
</ul>
<!--
Under this scenario, `Allocatable` will be `14.5 CPUs`, `28.5Gi` of memory and
`88Gi` of local storage.
Scheduler ensures that the total memory `requests` across all pods on this node does
not exceed `28.5Gi` and storage doesn't exceed `88Gi`.
Kubelet evicts pods whenever the overall memory usage across pods exceeds `28.5Gi`,
or if overall disk usage exceeds `88Gi` If all processes on the node consume as
much CPU as they can, pods together cannot consume more than `14.5 CPUs`.

If `kube-reserved` and/or `system-reserved` is not enforced and system daemons
exceed their reservation, `kubelet` evicts pods whenever the overall node memory
usage is higher than `31.5Gi` or `storage` is greater than `90Gi`
-->
<p>在这个场景下，<code>Allocatable</code> 将会是 <code>14.5 CPUs</code>、<code>28.5Gi</code> 内存以及 <code>88Gi</code> 本地存储。
调度器保证这个节点上的所有 Pod 的内存 <code>requests</code> 总量不超过 <code>28.5Gi</code>，
存储不超过 <code>88Gi</code>。
当 Pod 的内存使用总量超过 <code>28.5Gi</code> 或者磁盘使用总量超过 <code>88Gi</code> 时，
kubelet 将会驱逐它们。
如果节点上的所有进程都尽可能多地使用 CPU，则 Pod 加起来不能使用超过
<code>14.5 CPUs</code> 的资源。</p>
<p>当没有执行 <code>kube-reserved</code> 和/或 <code>system-reserved</code> 策略且系统守护进程
使用量超过其预留时，如果节点内存用量高于 <code>31.5Gi</code> 或<code>存储</code>大于 <code>90Gi</code>，
kubelet 将会驱逐 Pod。</p>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-a8f6511197efcd7d0db80ade49620f9d">10 - 为节点发布扩展资源</h1>
    
	<!--
title: Advertise Extended Resources for a Node
content_type: task
-->
<!-- overview -->
<!--
This page shows how to specify extended resources for a Node.
Extended resources allow cluster administrators to advertise node-level
resources that would otherwise be unknown to Kubernetes.
-->
<p>本文展示了如何为节点指定扩展资源（Extended Resource）。
扩展资源允许集群管理员发布节点级别的资源，这些资源在不进行发布的情况下无法被 Kubernetes 感知。</p>
<h2 id="准备开始">准备开始</h2>
<p><p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
如果你还没有集群，你可以通过 <a href="/zh/docs/tasks/tools/#minikube">Minikube</a> 构建一
个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p>
<!--
You need to have a Kubernetes cluster, and the kubectl command-line tool must
be configured to communicate with your cluster. If you do not already have a
cluster, you can create one by using
[minikube](/docs/tasks/tools/#minikube)
or you can use one of these Kubernetes playgrounds:
-->
<ul>
<li><a href="https://www.katacoda.com/courses/kubernetes/playground">Katacoda</a></li>
<li><a href="http://labs.play-with-k8s.com/">玩转 Kubernetes</a></li>
</ul>
 
 要获知版本信息，请输入 <code>kubectl version</code>.
</p>
<!-- steps -->
<!--
## Get the names of your Nodes

Choose one of your Nodes to use for this exercise.
-->
<h2 id="获取你的节点名称">获取你的节点名称</h2>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl get nodes
</code></pre></div><p>选择一个节点用于此练习。</p>
<!--
## Advertise a new extended resource on one of your Nodes

To advertise a new extended resource on a Node, send an HTTP PATCH request to
the Kubernetes API server. For example, suppose one of your Nodes has four dongles
attached. Here's an example of a PATCH request that advertises four dongle resources
for your Node.
-->
<h2 id="在你的一个节点上发布一种新的扩展资源">在你的一个节点上发布一种新的扩展资源</h2>
<p>为在一个节点上发布一种新的扩展资源，需要发送一个 HTTP PATCH 请求到 Kubernetes API server。
例如：假设你的一个节点上带有四个 dongle 资源。
下面是一个 PATCH 请求的示例，该请求为你的节点发布四个 dongle 资源。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">PATCH /api/v1/nodes/&lt;your-node-name&gt;/status HTTP/1.1
Accept: application/json
Content-Type: application/json-patch+json
Host: k8s-master:8080

<span style="color:#666">[</span>
  <span style="color:#666">{</span>
    <span style="color:#b44">&#34;op&#34;</span>: <span style="color:#b44">&#34;add&#34;</span>,
    <span style="color:#b44">&#34;path&#34;</span>: <span style="color:#b44">&#34;/status/capacity/example.com~1dongle&#34;</span>,
    <span style="color:#b44">&#34;value&#34;</span>: <span style="color:#b44">&#34;4&#34;</span>
  <span style="color:#666">}</span>
<span style="color:#666">]</span>
</code></pre></div><!--
Note that Kubernetes does not need to know what a dongle is or what a dongle is for.
The preceding PATCH request just tells Kubernetes that your Node has four things that
you call dongles.

Start a proxy, so that you can easily send requests to the Kubernetes API server:
-->
<p>注意：Kubernetes 不需要了解 dongle 资源的含义和用途。
前面的 PATCH 请求仅仅告诉 Kubernetes 你的节点拥有四个你称之为 dongle 的东西。</p>
<p>启动一个代理（proxy），以便你可以很容易地向 Kubernetes API server 发送请求：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl proxy
</code></pre></div><!--
In another command window, send the HTTP PATCH request.
Replace `<your-node-name>` with the name of your Node:
-->
<p>在另一个命令窗口中，发送 HTTP PATCH 请求。 用你的节点名称替换 <code>&lt;your-node-name&gt;</code>：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">curl --header <span style="color:#b44">&#34;Content-Type: application/json-patch+json&#34;</span> <span style="color:#b62;font-weight:bold">\
</span><span style="color:#b62;font-weight:bold"></span>  --request PATCH <span style="color:#b62;font-weight:bold">\
</span><span style="color:#b62;font-weight:bold"></span>  --data <span style="color:#b44">&#39;[{&#34;op&#34;: &#34;add&#34;, &#34;path&#34;: &#34;/status/capacity/example.com~1dongle&#34;, &#34;value&#34;: &#34;4&#34;}]&#39;</span> <span style="color:#b62;font-weight:bold">\
</span><span style="color:#b62;font-weight:bold"></span>  http://localhost:8001/api/v1/nodes/&lt;your-node-name&gt;/status
</code></pre></div><!--
In the preceding request, `~1` is the encoding for the character / in
the patch path. The operation path value in JSON-Patch is interpreted as a
JSON-Pointer. For more details, see
[IETF RFC 6901](https://tools.ietf.org/html/rfc6901), section 3.
-->
<blockquote class="note callout">
  <div><strong>说明：</strong> 在前面的请求中，<code>~1</code> 为 patch 路径中 “/” 符号的编码。
JSON-Patch 中的操作路径值被解析为 JSON 指针。
更多细节，请查看 <a href="https://tools.ietf.org/html/rfc6901">IETF RFC 6901</a> 的第 3 节。</div>
</blockquote>
<!--
The output shows that the Node has a capacity of 4 dongles:
-->
<p>输出显示该节点的 dongle 资源容量（capacity）为 4：</p>
<pre tabindex="0"><code>&quot;capacity&quot;: {
  &quot;cpu&quot;: &quot;2&quot;,
  &quot;memory&quot;: &quot;2049008Ki&quot;,
  &quot;example.com/dongle&quot;: &quot;4&quot;,
</code></pre><!-- Describe your Node: -->
<p>描述你的节点：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl describe node &lt;your-node-name&gt;
</code></pre></div><!-- Once again, the output shows the dongle resource: -->
<p>输出再次展示了 dongle 资源：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">Capacity</span>:<span style="color:#bbb">
</span><span style="color:#bbb"> </span><span style="color:#008000;font-weight:bold">cpu</span>:<span style="color:#bbb">  </span><span style="color:#666">2</span><span style="color:#bbb">
</span><span style="color:#bbb"> </span><span style="color:#008000;font-weight:bold">memory</span>:<span style="color:#bbb">  </span>2049008Ki<span style="color:#bbb">
</span><span style="color:#bbb"> </span><span style="color:#008000;font-weight:bold">example.com/dongle</span>:<span style="color:#bbb">  </span><span style="color:#666">4</span><span style="color:#bbb">
</span></code></pre></div><!--
Now, application developers can create Pods that request a certain
number of dongles. See
[Assign Extended Resources to a Container](/docs/tasks/configure-pod-container/extended-resource/).
-->
<p>现在，应用开发者可以创建请求一定数量 dongle 资源的 Pod 了。
参见<a href="/zh/docs/tasks/configure-pod-container/extended-resource/">将扩展资源分配给容器</a>。</p>
<!--
## Discussion

Extended resources are similar to memory and CPU resources. For example,
just as a Node has a certain amount of memory and CPU to be shared by all components
running on the Node, it can have a certain number of dongles to be shared
by all components running on the Node. And just as application developers
can create Pods that request a certain amount of memory and CPU, they can
create Pods that request a certain number of dongles.
-->
<h2 id="讨论">讨论</h2>
<p>扩展资源类似于内存和 CPU 资源。例如，正如一个节点拥有一定数量的内存和 CPU 资源，
它们被节点上运行的所有组件共享，该节点也可以拥有一定数量的 dongle 资源，
这些资源同样被节点上运行的所有组件共享。
此外，正如应用开发者可以创建请求一定数量的内存和 CPU 资源的 Pod，
他们也可以创建请求一定数量 dongle 资源的 Pod。</p>
<!--
Extended resources are opaque to Kubernetes; Kubernetes does not
know anything about what they are. Kubernetes knows only that a Node
has a certain number of them. Extended resources must be advertised in integer
amounts. For example, a Node can advertise four dongles, but not 4.5 dongles.
-->
<p>扩展资源对 Kubernetes 是不透明的。Kubernetes 不知道扩展资源含义相关的任何信息。
Kubernetes 只了解一个节点拥有一定数量的扩展资源。
扩展资源必须以整形数量进行发布。
例如，一个节点可以发布 4 个 dongle 资源，但是不能发布 4.5 个。</p>
<!--
### Storage example

Suppose a Node has 800 GiB of a special kind of disk storage. You could
create a name for the special storage, say example.com/special-storage.
Then you could advertise it in chunks of a certain size, say 100 GiB. In that case,
your Node would advertise that it has eight resources of type
example.com/special-storage.
-->
<h3 id="存储示例">存储示例</h3>
<p>假设一个节点拥有一种特殊类型的磁盘存储，其容量为 800 GiB。
你可以为该特殊存储创建一个名称，如 <code>example.com/special-storage</code>。
然后你就可以按照一定规格的块（如 100 GiB）对其进行发布。
在这种情况下，你的节点将会通知它拥有八个 <code>example.com/special-storage</code> 类型的资源。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">Capacity</span>:<span style="color:#bbb">
</span><span style="color:#bbb"> </span>...<span style="color:#bbb">
</span><span style="color:#bbb"> </span><span style="color:#008000;font-weight:bold">example.com/special-storage</span>:<span style="color:#bbb"> </span><span style="color:#666">8</span><span style="color:#bbb">
</span></code></pre></div><!--
If you want to allow arbitrary requests for special storage, you
could advertise special storage in chunks of size 1 byte. In that case, you would advertise
800Gi resources of type example.com/special-storage.
-->
<p>如果你想要允许针对特殊存储任意（数量）的请求，你可以按照 1 字节大小的块来发布特殊存储。
在这种情况下，你将会发布 800Gi 数量的 example.com/special-storage 类型的资源。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">Capacity</span>:<span style="color:#bbb">
</span><span style="color:#bbb"> </span>...<span style="color:#bbb">
</span><span style="color:#bbb"> </span><span style="color:#008000;font-weight:bold">example.com/special-storage</span>:<span style="color:#bbb">  </span>800Gi<span style="color:#bbb">
</span></code></pre></div><!--
Then a Container could request any number of bytes of special storage, up to 800Gi.
-->
<p>然后，容器就能够请求任意数量（多达 800Gi）字节的特殊存储。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">Capacity</span>:<span style="color:#bbb">
</span><span style="color:#bbb"> </span>...<span style="color:#bbb">
</span><span style="color:#bbb"> </span><span style="color:#008000;font-weight:bold">example.com/special-storage</span>:<span style="color:#bbb">  </span>800Gi<span style="color:#bbb">
</span></code></pre></div><!--
## Clean up

Here is a PATCH request that removes the dongle advertisement from a Node.
-->
<h2 id="清理">清理</h2>
<p>这里是一个从节点移除 dongle 资源发布的 PATCH 请求。</p>
<pre tabindex="0"><code>PATCH /api/v1/nodes/&lt;your-node-name&gt;/status HTTP/1.1
Accept: application/json
Content-Type: application/json-patch+json
Host: k8s-master:8080

[
  {
    &quot;op&quot;: &quot;remove&quot;,
    &quot;path&quot;: &quot;/status/capacity/example.com~1dongle&quot;,
  }
]
</code></pre><!--
Start a proxy, so that you can easily send requests to the Kubernetes API server:
-->
<p>启动一个代理，以便你可以很容易地向 Kubernetes API 服务器发送请求：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl proxy
</code></pre></div><!--
In another command window, send the HTTP PATCH request.
Replace `<your-node-name>` with the name of your Node:
-->
<p>在另一个命令窗口中，发送 HTTP PATCH 请求。用你的节点名称替换 <code>&lt;your-node-name&gt;</code>：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">curl --header <span style="color:#b44">&#34;Content-Type: application/json-patch+json&#34;</span> <span style="color:#b62;font-weight:bold">\
</span><span style="color:#b62;font-weight:bold"></span>--request PATCH <span style="color:#b62;font-weight:bold">\
</span><span style="color:#b62;font-weight:bold"></span>--data <span style="color:#b44">&#39;[{&#34;op&#34;: &#34;remove&#34;, &#34;path&#34;: &#34;/status/capacity/example.com~1dongle&#34;}]&#39;</span> <span style="color:#b62;font-weight:bold">\
</span><span style="color:#b62;font-weight:bold"></span>http://localhost:8001/api/v1/nodes/&lt;your-node-name&gt;/status
</code></pre></div><!--
Verify that the dongle advertisement has been removed:
-->
<p>验证 dongle 资源的发布已经被移除：</p>
<pre tabindex="0"><code>kubectl describe node &lt;your-node-name&gt; | grep dongle
</code></pre><!--
(you should not see any output)  
-->
<p>(你应该看不到任何输出)</p>
<h2 id="接下来">接下来</h2>
<!--
### For application developers

* [Assign Extended Resources to a Container](/docs/tasks/configure-pod-container/extended-resource/)

### For cluster administrators

* [Configure Minimum and Maximum Memory Constraints for a Namespace](/docs/tasks/administer-cluster/memory-constraint-namespace/)
* [Configure Minimum and Maximum CPU Constraints for a Namespace](/docs/tasks/administer-cluster/cpu-constraint-namespace/)
-->
<h3 id="针对应用开发人员">针对应用开发人员</h3>
<ul>
<li><a href="/zh/docs/tasks/configure-pod-container/extended-resource/">将扩展资源分配给容器</a></li>
</ul>
<h3 id="针对集群管理员">针对集群管理员</h3>
<ul>
<li><a href="/zh/docs/tasks/administer-cluster/manage-resources/memory-constraint-namespace/">为名字空间配置最小和最大内存约束</a></li>
<li><a href="/zh/docs/tasks/administer-cluster/manage-resources/cpu-constraint-namespace/">为名字空间配置最小和最大 CPU 约束</a></li>
</ul>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-e1afcdac8d5e8458274b3c481c5ebcda">11 - 使用 CoreDNS 进行服务发现</h1>
    
	<!--
reviewers:
- johnbelamaric
title: Using CoreDNS for Service Discovery
min-kubernetes-server-version: v1.9
content_type: task
-->
<!-- overview -->
<!--
This page describes the CoreDNS upgrade process and how to install CoreDNS instead of kube-dns.
-->
<p>此页面介绍了 CoreDNS 升级过程以及如何安装 CoreDNS 而不是 kube-dns。</p>
<h2 id="准备开始">准备开始</h2>
<p><p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
如果你还没有集群，你可以通过 <a href="/zh/docs/tasks/tools/#minikube">Minikube</a> 构建一
个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p>
<!--
You need to have a Kubernetes cluster, and the kubectl command-line tool must
be configured to communicate with your cluster. If you do not already have a
cluster, you can create one by using
[minikube](/docs/tasks/tools/#minikube)
or you can use one of these Kubernetes playgrounds:
-->
<ul>
<li><a href="https://www.katacoda.com/courses/kubernetes/playground">Katacoda</a></li>
<li><a href="http://labs.play-with-k8s.com/">玩转 Kubernetes</a></li>
</ul>
 

您的 Kubernetes 服务器版本必须不低于版本 v1.9.
 要获知版本信息，请输入 <code>kubectl version</code>.
</p>
<!-- steps -->
<!--
## About CoreDNS

[CoreDNS](https://coredns.io) is a flexible, extensible DNS server that can serve as the Kubernetes cluster DNS.
Like Kubernetes, the CoreDNS project is hosted by the <a class='glossary-tooltip' title='云原生计算基金会' data-toggle='tooltip' data-placement='top' href='https://cncf.io/' target='_blank' aria-label='CNCF'>CNCF</a>.
-->
<h2 id="关于-coredns">关于 CoreDNS</h2>
<p><a href="https://coredns.io">CoreDNS</a> 是一个灵活可扩展的 DNS 服务器，可以作为 Kubernetes 集群 DNS。
与 Kubernetes 一样，CoreDNS 项目由 <a class='glossary-tooltip' title='云原生计算基金会' data-toggle='tooltip' data-placement='top' href='https://cncf.io/' target='_blank' aria-label='CNCF'>CNCF</a> 托管。</p>
<!--
You can use CoreDNS instead of kube-dns in your cluster by replacing kube-dns in an existing
deployment, or by using tools like kubeadm that will deploy and upgrade the cluster for you.
-->
<p>通过在现有的集群中替换 kube-dns，可以在集群中使用 CoreDNS 代替 kube-dns 部署，
或者使用 kubeadm 等工具来为你部署和升级集群。</p>
<!--
## Installing CoreDNS

For manual deployment or replacement of kube-dns, see the documentation at the
[CoreDNS GitHub project.](https://github.com/coredns/deployment/tree/master/kubernetes)
-->
<h2 id="安装-coredns">安装 CoreDNS</h2>
<p>有关手动部署或替换 kube-dns，请参阅
<a href="https://github.com/coredns/deployment/tree/master/kubernetes">CoreDNS GitHub 工程</a>。</p>
<!--
## Migrating to CoreDNS

### Upgrading an existing cluster with kubeadm
-->
<h2 id="迁移到-coredns">迁移到 CoreDNS</h2>
<h3 id="使用-kubeadm-升级现有集群">使用 kubeadm 升级现有集群</h3>
<!--
In Kubernetes version 1.10 and later, you can also move to CoreDNS when you use `kubeadm` to upgrade
a cluster that is using `kube-dns`. In this case, `kubeadm` will generate the CoreDNS configuration
("Corefile") based upon the `kube-dns` ConfigMap, preserving configurations for federation,
stub domains, and upstream name server.
-->
<p>在 Kubernetes 1.10 及更高版本中，当你使用 <code>kubeadm</code> 升级使用 <code>kube-dns</code> 的集群时，你还可以迁移到 CoreDNS。
在本例中 <code>kubeadm</code> 将生成 CoreDNS 配置（&quot;Corefile&quot;）基于 <code>kube-dns</code> ConfigMap，
保存联邦、存根域和上游名称服务器的配置。</p>
<!--
If you are moving from kube-dns to CoreDNS, make sure to set the `CoreDNS` feature gate to `true`
during an upgrade. For example, here is what a `v1.11.0` upgrade would look like:
-->
<p>如果你正在从 kube-dns 迁移到 CoreDNS，请确保在升级期间将 <code>CoreDNS</code> 特性门设置为 <code>true</code>。
例如，<code>v1.11.0</code> 升级应该是这样的:</p>
<pre tabindex="0"><code>kubeadm upgrade apply v1.11.0 --feature-gates=CoreDNS=true
</code></pre><!--
In Kubernetes version 1.13 and later the `CoreDNS` feature gate is removed and CoreDNS
is used by default. Follow the guide outlined [here](/docs/reference/setup-tools/kubeadm/kubeadm-init-phase#cmd-phase-addon) if you want
your upgraded cluster to use kube-dns.
-->
<p>在 Kubernetes 版本 1.13 和更高版本中，<code>CoreDNS</code>特性门已经删除，CoreDNS 在默认情况下使用。
如果你想升级集群以使用 kube-dns，请遵循
<a href="/zh/docs/reference/setup-tools/kubeadm/kubeadm-init-phase#cmd-phase-addon">此处</a> 。</p>
<!--
In versions prior to 1.11 the Corefile will be **overwritten** by the one created during upgrade.
**You should save your existing ConfigMap if you have customized it.** You may re-apply your
customizations after the new ConfigMap is up and running.
-->
<p>在 1.11 之前的版本中，核心文件将被升级过程中创建的文件覆盖。
<strong>如果已对其进行自定义，则应保存现有的 ConfigMap。</strong>
在新的 ConfigMap 启动并运行后，你可以重新应用自定义。</p>
<!--
If you are running CoreDNS in Kubernetes version 1.11 and later, during upgrade,
your existing Corefile will be retained.
-->
<p>如果你在 Kubernetes 1.11 及更高版本中运行 CoreDNS，则在升级期间，将保留现有的 Corefile。</p>
<!--
## Installing kube-dns instead of CoreDNS with kubeadm
-->
<h2 id="使用-kubeadm-安装-kube-dns-而不是-coredns">使用 kubeadm 安装 kube-dns 而不是 CoreDNS</h2>
<!--
In Kubernetes 1.11, CoreDNS has graduated to General Availability (GA)
and is installed by default.
-->
<blockquote class="note callout">
  <div><strong>说明：</strong> 在 Kubernetes 1.11 中，CoreDNS 已经升级到通用可用性（GA），并默认安装。</div>
</blockquote>
<!--
In Kubernetes 1.18, kube-dns usage with kubeadm has been deprecated and will be removed in a future version.
-->
<blockquote class="warning callout">
  <div><strong>警告：</strong> 在 Kubernetes 1.18 中，用 kubeadm 来安装 kube-dns 这一做法已经被废弃，
会在将来版本中移除。</div>
</blockquote>

<!--
To install kube-dns on versions prior to 1.13, set the `CoreDNS` feature gate
value to `false`:
-->
<p>若要在 1.13 之前版本上安装 kube-dns，请将 <code>CoreDNS</code> 特性门控设置为 <code>false</code>：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubeadm init --feature-gates<span style="color:#666">=</span><span style="color:#b8860b">CoreDNS</span><span style="color:#666">=</span><span style="color:#a2f">false</span>
</code></pre></div><!--
For versions 1.13 and later, follow the guide outlined [here](/docs/reference/setup-tools/kubeadm/kubeadm-init-phase#cmd-phase-addon).
-->
<p>对于 1.13 版和更高版本，请遵循
<a href="/zh/docs/reference/setup-tools/kubeadm/kubeadm-init-phase#cmd-phase-addon">此处</a>概述到指南。</p>
<!--
## Upgrading CoreDNS 

CoreDNS is available in Kubernetes since v1.9. 
You can check the version of CoreDNS shipped with Kubernetes and the changes made to CoreDNS [here](https://github.com/coredns/deployment/blob/master/kubernetes/CoreDNS-k8s_version.md).
-->
<h2 id="升级-coredns">升级 CoreDNS</h2>
<p>从 v1.9 起，Kubernetes 提供了 CoreDNS。
你可以在<a href="https://github.com/coredns/deployment/blob/master/kubernetes/CoreDNS-k8s_version.md">此处</a>
查看 Kubernetes 随附的 CoreDNS 版本以及对 CoreDNS 所做的更改。</p>
<!--
CoreDNS can be upgraded manually in case you want to only upgrade CoreDNS or use your own custom image.
There is a helpful [guideline and walkthrough](https://github.com/coredns/deployment/blob/master/kubernetes/Upgrading_CoreDNS.md) available to ensure a smooth upgrade.
-->
<p>如果你只想升级 CoreDNS 或使用自己的自定义镜像，则可以手动升级 CoreDNS。
参看<a href="https://github.com/coredns/deployment/blob/master/kubernetes/Upgrading_CoreDNS.md">指南和演练</a>
文档了解如何平滑升级。</p>
<!--
## Tuning CoreDNS

When resource utilisation is a concern, it may be useful to tune the configuration of CoreDNS. For more details, check out the
[documentation on scaling CoreDNS]((https://github.com/coredns/deployment/blob/master/kubernetes/Scaling_CoreDNS.md)).
-->
<h2 id="coredns-调优">CoreDNS 调优</h2>
<p>当资源利用方面有问题时，优化 CoreDNS 的配置可能是有用的。
有关详细信息，请参阅<a href="https://github.com/coredns/deployment/blob/master/kubernetes/Scaling_CoreDNS.md">有关扩缩 CoreDNS 的文档</a>。</p>
<h2 id="接下来">接下来</h2>
<!--
You can configure [CoreDNS](https://coredns.io) to support many more use cases than
kube-dns by modifying the `Corefile`. For more information, see the
[CoreDNS site](https://coredns.io/2017/05/08/custom-dns-entries-for-kubernetes/).
-->
<p>你可以通过修改 <code>Corefile</code> 来配置 <a href="https://coredns.io">CoreDNS</a>，以支持比 kube-dns 更多的用例。
请参考 <a href="https://coredns.io/2017/05/08/custom-dns-entries-for-kubernetes/">CoreDNS 网站</a>
以了解更多信息。</p>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-669c88964b4a9eb2b040057266e4b60d">12 - 使用 KMS 驱动进行数据加密</h1>
    
	<!--
reviewers:
- smarterclayton
title: Using a KMS provider for data encryption
content_type: task
-->
<!-- overview -->
<!-- This page shows how to configure a Key Management Service (KMS) provider and plugin to enable secret data encryption. -->
<p>本页展示了如何配置秘钥管理服务—— Key Management Service (KMS) 驱动和插件以启用
Secret 数据加密。</p>
<h2 id="准备开始">准备开始</h2>
<ul>
<li><p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
如果你还没有集群，你可以通过 <a href="/zh/docs/tasks/tools/#minikube">Minikube</a> 构建一
个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p>
<!--
You need to have a Kubernetes cluster, and the kubectl command-line tool must
be configured to communicate with your cluster. If you do not already have a
cluster, you can create one by using
[minikube](/docs/tasks/tools/#minikube)
or you can use one of these Kubernetes playgrounds:
-->
<ul>
<li><a href="https://www.katacoda.com/courses/kubernetes/playground">Katacoda</a></li>
<li><a href="http://labs.play-with-k8s.com/">玩转 Kubernetes</a></li>
</ul>
 
 要获知版本信息，请输入 <code>kubectl version</code>.
</li>
</ul>
<!-- * Kubernetes version 1.10.0 or later is required -->
<!-- * etcd v3 or later is required -->
<ul>
<li>需要 Kubernetes 1.10.0 或更新版本</li>
<li>需要 etcd v3 或更新版本</li>
</ul>





<div style="margin-top: 10px; margin-bottom: 10px;">
<b>FEATURE STATE:</b> <code>Kubernetes v1.12 [beta]</code>
</div>

<!-- steps -->
<!--
The KMS encryption provider uses an envelope encryption scheme to encrypt data in etcd. The data is encrypted using a data encryption key (DEK); a new DEK is generated for each encryption. The DEKs are encrypted with a key encryption key (KEK) that is stored and managed in a remote KMS. The KMS provider uses gRPC to communicate with a specific KMS 
plugin. The KMS plugin, which is implemented as a gRPC server and deployed on the same host(s) as the Kubernetes master(s), is responsible for all communication with the remote KMS.
-->
<p>KMS 加密驱动使用封套加密模型来加密 etcd 中的数据。
数据使用数据加密秘钥（DEK）加密；每次加密都生成一个新的 DEK。
这些 DEK 经一个秘钥加密秘钥（KEK）加密后在一个远端的 KMS 中存储和管理。
KMS 驱动使用 gRPC 与一个特定的 KMS 插件通信。这个 KMS 插件作为一个 gRPC
服务器被部署在 Kubernetes 主服务器的同一个主机上，负责与远端 KMS 的通信。</p>
<!--
## Configuring the KMS provider

To configure a KMS provider on the API server, include a provider of type ```kms``` in the providers array in the encryption configuration file and set the following properties:
-->
<h2 id="配置-kms-驱动">配置 KMS 驱动</h2>
<p>为了在 API 服务器上配置 KMS 驱动，在加密配置文件中的驱动数组中加入一个类型为 <code>kms</code>
的驱动，并设置下列属性：</p>
<!--
* `name`: Display name of the KMS plugin.
* `endpoint`: Listen address of the gRPC server (KMS plugin). The endpoint is a UNIX domain socket.
* `cachesize`: Number of data encryption keys (DEKs) to be cached in the clear. When cached, DEKs can be used without another call to the KMS; whereas DEKs that are not cached require a call to the KMS to unwrap.
* `timeout`: How long should kube-apiserver wait for kms-plugin to respond before returning an error (default is 3 seconds).
-->
<ul>
<li><code>name</code>: KMS 插件的显示名称。</li>
<li><code>endpoint</code>: gRPC 服务器（KMS 插件）的监听地址。该端点是一个 UNIX 域套接字。</li>
<li><code>cachesize</code>: 以明文缓存的数据加密秘钥（DEKs）的数量。一旦被缓存，
就可以直接使用 DEKs 而无需另外调用 KMS；而未被缓存的 DEKs 需要调用一次 KMS 才能解包。</li>
<li><code>timeout</code>: 在返回一个错误之前，kube-apiserver 等待 kms-plugin 响应的时间（默认是 3 秒）。</li>
</ul>
<!-- See [Understanding the encryption at rest configuration.](/docs/tasks/administer-cluster/encrypt-data) -->
<p>参见<a href="/zh/docs/tasks/administer-cluster/encrypt-data">理解静态数据加密配置</a></p>
<!--
## Implementing a KMS plugin

To implement a KMS plugin, you can develop a new plugin gRPC server or enable a KMS plugin already provided by your cloud provider. You then integrate the plugin with the remote KMS and deploy it on the Kubernetes master.
-->
<h2 id="实现-kms-插件">实现 KMS 插件</h2>
<p>为实现一个 KMS 插件，你可以开发一个新的插件 gRPC 服务器或启用一个由你的云服务驱动提供的 KMS 插件。
你可以将这个插件与远程 KMS 集成，并把它部署到 Kubernetes 的主服务器上。</p>
<!--
### Enabling the KMS supported by your cloud provider 
Refer to your cloud provider for instructions on enabling the cloud provider-specific KMS plugin.
-->
<h3 id="启用由云服务驱动支持的-kms">启用由云服务驱动支持的 KMS</h3>
<p>有关启用云服务驱动特定的 KMS 插件的说明，请咨询你的云服务驱动商。</p>
<!--
### Developing a KMS plugin gRPC server

You can develop a KMS plugin gRPC server using a stub file available for Go. For other languages, you use a proto file to create a stub file that you can use to develop the gRPC server code.
-->
<h3 id="开发-kms-插件-grpc-服务器">开发 KMS 插件 gRPC 服务器</h3>
<p>你可以使用 Go 语言的存根文件开发 KMS 插件 gRPC 服务器。
对于其他语言，你可以用 proto 文件创建可以用于开发 gRPC 服务器代码的存根文件。</p>
<!--
* Using Go: Use the functions and data structures in the stub file:
[service.pb.go](https://github.com/kubernetes/kubernetes/blob/master/staging/src/k8s.io/apiserver/pkg/storage/value/encrypt/envelope/v1beta1/service.pb.go) to develop the gRPC server code
-->
<ul>
<li>使用 Go：使用存根文件 <a href="https://github.com/kubernetes/kubernetes/blob/master/staging/src/k8s.io/apiserver/pkg/storage/value/encrypt/envelope/v1beta1/service.pb.go">service.pb.go</a>
中的函数和数据结构开发 gRPC 服务器代码。</li>
</ul>
<!--
* Using languages other than Go: Use the protoc compiler with the proto file: [service.proto](https://github.com/kubernetes/kubernetes/blob/master/staging/src/k8s.io/apiserver/pkg/storage/value/encrypt/envelope/v1beta1/service.proto) to generate a stub file for the specific language
-->
<ul>
<li>使用 Go 以外的其他语言：用 protoc 编译器编译 proto 文件：
<a href="https://github.com/kubernetes/kubernetes/blob/master/staging/src/k8s.io/apiserver/pkg/storage/value/encrypt/envelope/v1beta1/service.proto">service.proto</a>
为指定语言生成存根文件。</li>
</ul>
<!--
Then use the functions and data structures in the stub file to develop the server code.
-->
<p>然后使用存根文件中的函数和数据结构开发服务器代码。</p>
<!-- **Notes:** -->
<p><strong>注意：</strong></p>
<!--
* kms plugin version: `v1beta1`

  In response to procedure call Version, a compatible KMS plugin should return v1beta1 as VersionResponse.version.

* message version: `v1beta1`

  All messages from KMS provider have the version field set to current version v1beta1.

* protocol: UNIX domain socket (`unix`)

  The gRPC server should listen at UNIX domain socket.
-->
<ul>
<li>
<p>kms 插件版本：<code>v1beta1</code></p>
<p>作为对过程调用 Version 的响应，兼容的 KMS 插件应把 v1beta1 作为 VersionResponse.version 返回</p>
</li>
<li>
<p>消息版本：<code>v1beta1</code></p>
<p>所有来自 KMS 驱动的消息都把 version 字段设置为当前版本 v1beta1</p>
</li>
<li>
<p>协议：UNIX 域套接字 (<code>unix</code>)</p>
<p>gRPC 服务器应监听 UNIX 域套接字</p>
</li>
</ul>
<!--
### Integrating a KMS plugin with the remote KMS

The KMS plugin can communicate with the remote KMS using any protocol supported by the KMS.
All configuration data, including authentication credentials the KMS plugin uses to communicate with the remote KMS, 
are stored and managed by the KMS plugin independently. The KMS plugin can encode the ciphertext with additional metadata that may be required before sending it to the KMS for decryption.
-->
<h3 id="将-kms-插件与远程-kms-整合">将 KMS 插件与远程 KMS 整合</h3>
<p>KMS 插件可以用任何受 KMS 支持的协议与远程 KMS 通信。
所有的配置数据，包括 KMS 插件用于与远程 KMS 通信的认证凭据，都由 KMS 插件独立地存储和管理。
KMS 插件可以用额外的元数据对密文进行编码，这些元数据是在把它发往 KMS 进行解密之前可能要用到的。</p>
<!--
### Deploying the KMS plugin 

Ensure that the KMS plugin runs on the same host(s) as the Kubernetes master(s).
-->
<h3 id="部署-kms-插件">部署 KMS 插件</h3>
<p>确保 KMS 插件与 Kubernetes 主服务器运行在同一主机上。</p>
<!--
## Encrypting your data with the KMS provider

To encrypt the data:
-->
<h2 id="使用-kms-驱动加密数据">使用 KMS 驱动加密数据</h2>
<p>为了加密数据：</p>
<!--
1. Create a new encryption configuration file using the appropriate properties for the `kms` provider:
-->
<ol>
<li>
<p>使用 <code>kms</code> 驱动的相应的属性创建一个新的加密配置文件：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>EncryptionConfiguration<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>apiserver.config.k8s.io/v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">resources</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- <span style="color:#008000;font-weight:bold">resources</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span>- secrets<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">providers</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span>- <span style="color:#008000;font-weight:bold">kms</span>:<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>myKmsPlugin<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#008000;font-weight:bold">endpoint</span>:<span style="color:#bbb"> </span>unix:///tmp/socketfile.sock<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#008000;font-weight:bold">cachesize</span>:<span style="color:#bbb"> </span><span style="color:#666">100</span><span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#008000;font-weight:bold">timeout</span>:<span style="color:#bbb"> </span>3s<span style="color:#bbb">
</span><span style="color:#bbb">    </span>- <span style="color:#008000;font-weight:bold">identity</span>:<span style="color:#bbb"> </span>{}<span style="color:#bbb">
</span></code></pre></div></li>
</ol>
<!--
2. Set the `--encryption-provider-config` flag on the kube-apiserver to point to the location of the configuration file.
3. Restart your API server.
-->
<ol start="2">
<li>设置 kube-apiserver 的 <code>--encryption-provider-config</code> 参数指向配置文件的位置。</li>
<li>重启 API 服务器。</li>
</ol>
<!--
## Verifying that the data is encrypted

Data is encrypted when written to etcd. After restarting your kube-apiserver, any newly created or updated secret should be encrypted when stored. To verify, you can use the etcdctl command line program to retrieve the contents of your secret.
-->
<h2 id="验证数据已经加密">验证数据已经加密</h2>
<p>写入 etcd 时数据被加密。重启 kube-apiserver 后，任何新建或更新的 Secret 在存储时应该已被加密。
要验证这点，你可以用 etcdctl 命令行程序获取 Secret 内容。</p>
<!--
1. Create a new secret called secret1 in the default namespace:
-->
<ol>
<li>
<p>在默认的命名空间里创建一个名为 secret1 的 Secret：</p>
<pre tabindex="0"><code>kubectl create secret generic secret1 -n default --from-literal=mykey=mydata
</code></pre></li>
</ol>
<!--
2. Using the etcdctl command line, read that secret out of etcd:
-->
<ol start="2">
<li>
<p>用 etcdctl 命令行，从 etcd 读取出 Secret：</p>
<pre tabindex="0"><code>ETCDCTL_API=3 etcdctl get /kubernetes.io/secrets/default/secret1 [...] | hexdump -C
</code></pre><!--
where `[...]` must be the additional arguments for connecting to the etcd server.
-->
<p>其中 <code>[...]</code> 是用于连接 etcd 服务器的额外参数。</p>
</li>
</ol>
<!--
3. Verify the stored secret is prefixed with `k8s:enc:kms:v1:`, which indicates that the `kms` provider has encrypted the resulting data.
-->
<ol start="3">
<li>验证保存的 Secret 是否是以 <code>k8s:enc:kms:v1:</code> 开头的，这表明 <code>kms</code> 驱动已经对结果数据加密。</li>
</ol>
<!--
4. Verify that the secret is correctly decrypted when retrieved via the API:
-->
<ol start="4">
<li>
<p>验证 Secret 在被 API 获取时已被正确解密：</p>
<pre tabindex="0"><code>kubectl describe secret secret1 -n default
</code></pre><p>结果应该是 <code>mykey: mydata</code>。</p>
</li>
</ol>
<!--
## Ensuring all secrets are encrypted

Because secrets are encrypted on write, performing an update on a secret encrypts that content.
-->
<h2 id="确保所有-secret-都已被加密">确保所有 Secret 都已被加密</h2>
<p>因为 Secret 是在写入时被加密的，所以在更新 Secret 时也会加密该内容。</p>
<!--
The following command reads all secrets and then updates them to apply server side encryption. If an error occurs due to a conflicting write, retry the command.
For larger clusters, you may wish to subdivide the secrets by namespace or script an update.
-->
<p>下列命令读取所有 Secret 并更新它们以便应用服务器端加密。如果因为写入冲突导致错误发生，
请重试此命令。对较大的集群，你可能希望根据命名空间或脚本更新去细分 Secret 内容。</p>
<pre tabindex="0"><code>kubectl get secrets --all-namespaces -o json | kubectl replace -f -
</code></pre><!--
## Switching from a local encryption provider to the KMS provider

To switch from a local encryption provider to the `kms` provider and re-encrypt all of the secrets:
-->
<h2 id="从本地加密驱动切换到-kms-驱动">从本地加密驱动切换到 KMS 驱动</h2>
<p>为了从本地加密驱动切换到 <code>kms</code> 驱动并重新加密所有 Secret 内容：</p>
<!--
1. Add the `kms` provider as the first entry in the configuration file as shown in the following example.
-->
<ol>
<li>
<p>在配置文件中加入 <code>kms</code> 驱动作为第一个条目，如下列样例所示</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>EncryptionConfiguration<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>apiserver.config.k8s.io/v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">resources</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- <span style="color:#008000;font-weight:bold">resources</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span>- secrets<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">providers</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span>- <span style="color:#008000;font-weight:bold">kms</span>:<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#008000;font-weight:bold">name </span>:<span style="color:#bbb"> </span>myKmsPlugin<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#008000;font-weight:bold">endpoint</span>:<span style="color:#bbb"> </span>unix:///tmp/socketfile.sock<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#008000;font-weight:bold">cachesize</span>:<span style="color:#bbb"> </span><span style="color:#666">100</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span>- <span style="color:#008000;font-weight:bold">aescbc</span>:<span style="color:#bbb">
</span><span style="color:#bbb">         </span><span style="color:#008000;font-weight:bold">keys</span>:<span style="color:#bbb">
</span><span style="color:#bbb">         </span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>key1<span style="color:#bbb">
</span><span style="color:#bbb">           </span><span style="color:#008000;font-weight:bold">secret</span>:<span style="color:#bbb"> </span>&lt;BASE 64 ENCODED SECRET&gt;<span style="color:#bbb">
</span></code></pre></div></li>
</ol>
<!--
2. Restart all kube-apiserver processes.
3. Run the following command to force all secrets to be re-encrypted using the `kms` provider.
-->
<ol start="2">
<li>
<p>重启所有 kube-apiserver 进程。</p>
</li>
<li>
<p>运行下列命令使用 <code>kms</code> 驱动强制重新加密所有 Secret。</p>
<pre tabindex="0"><code>kubectl get secrets --all-namespaces -o json| kubectl replace -f -
</code></pre></li>
</ol>
<!--
## Disabling encryption at rest
To disable encryption at rest:
-->
<h2 id="禁用静态数据加密">禁用静态数据加密</h2>
<p>要禁用静态数据加密：</p>
<!--
1. Place the `identity` provider as the first entry in the configuration file:
-->
<ol>
<li>
<p>将 <code>identity</code> 驱动作为配置文件中的第一个条目：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>EncryptionConfiguration<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>apiserver.config.k8s.io/v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">resources</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- <span style="color:#008000;font-weight:bold">resources</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span>- secrets<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">providers</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span>- <span style="color:#008000;font-weight:bold">identity</span>:<span style="color:#bbb"> </span>{}<span style="color:#bbb">
</span><span style="color:#bbb">    </span>- <span style="color:#008000;font-weight:bold">kms</span>:<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#008000;font-weight:bold">name </span>:<span style="color:#bbb"> </span>myKmsPlugin<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#008000;font-weight:bold">endpoint</span>:<span style="color:#bbb"> </span>unix:///tmp/socketfile.sock<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#008000;font-weight:bold">cachesize</span>:<span style="color:#bbb"> </span><span style="color:#666">100</span><span style="color:#bbb">
</span></code></pre></div></li>
</ol>
<!--
2.  Restart all kube-apiserver processes.
3. Run the following command to force all secrets to be decrypted.
-->
<ol start="2">
<li>
<p>重启所有 kube-apiserver 进程。</p>
</li>
<li>
<p>运行下列命令强制重新加密所有 Secret。</p>
<pre tabindex="0"><code>kubectl get secrets --all-namespaces -o json | kubectl replace -f -
</code></pre></li>
</ol>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-e77685d5b88d2db5c7631a27b9472eea">13 - 使用 Kubernetes API 访问集群</h1>
    
	<!--
title: Access Clusters Using the Kubernetes API
content_type: task
-->
<!-- overview -->
<!--
This page shows how to access clusters using the Kubernetes API.
-->
<p>本页展示了如何使用 Kubernetes API 访问集群</p>
<h2 id="准备开始">准备开始</h2>
<p><p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
如果你还没有集群，你可以通过 <a href="/zh/docs/tasks/tools/#minikube">Minikube</a> 构建一
个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p>
<!--
You need to have a Kubernetes cluster, and the kubectl command-line tool must
be configured to communicate with your cluster. If you do not already have a
cluster, you can create one by using
[minikube](/docs/tasks/tools/#minikube)
or you can use one of these Kubernetes playgrounds:
-->
<ul>
<li><a href="https://www.katacoda.com/courses/kubernetes/playground">Katacoda</a></li>
<li><a href="http://labs.play-with-k8s.com/">玩转 Kubernetes</a></li>
</ul>
 
 要获知版本信息，请输入 <code>kubectl version</code>.
</p>
<!-- steps -->
<!--
## Accessing the cluster API

### Accessing for the first time with kubectl
-->
<h2 id="访问集群-api">访问集群 API</h2>
<h3 id="使用-kubectl-进行首次访问">使用 kubectl 进行首次访问</h3>
<!--
When accessing the Kubernetes API for the first time, use the
Kubernetes command-line tool, `kubectl`.
-->
<p>首次访问 Kubernetes API 时，请使用 Kubernetes 命令行工具 <code>kubectl</code> 。</p>
<!--
To access a cluster, you need to know the location of the cluster and have credentials
to access it. Typically, this is automatically set-up when you work through
a [Getting started guide](/docs/setup/),
or someone else setup the cluster and provided you with credentials and a location.
-->
<p>要访问集群，你需要知道集群位置并拥有访问它的凭证。
通常，当你完成<a href="/zh/docs/setup/">入门指南</a>时，这会自动设置完成，或者由其他人设置好集群并将凭证和位置提供给你。</p>
<!--
Check the location and credentials that kubectl knows about with this command:
-->
<p>使用此命令检查 kubectl 已知的位置和凭证：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl config view
</code></pre></div><!--
Many of the [examples](https://github.com/kubernetes/examples/tree/master/) provide an introduction to using
kubectl. Complete documentation is found in the [kubectl manual](/docs/reference/kubectl/overview/).
-->
<p>许多<a href="https://github.com/kubernetes/examples/tree/master/">样例</a>
提供了使用 kubectl 的介绍。完整文档请见 <a href="/zh/docs/reference/kubectl/overview/">kubectl 手册</a>。</p>
<!--
### Directly accessing the REST API

kubectl handles locating and authenticating to the API server. If you want to directly access the REST API with an http client like
`curl` or `wget`, or a browser, there are multiple ways you can locate and authenticate against the API server:
-->
<h3 id="直接访问-rest-api">直接访问 REST API</h3>
<p>kubectl 处理对 API 服务器的定位和身份验证。如果你想通过 http 客户端（如 <code>curl</code> 或 <code>wget</code>，或浏览器）直接访问 REST API，你可以通过多种方式对 API 服务器进行定位和身份验证：</p>
 <!--
1. Run kubectl in proxy mode (recommended). This method is recommended, since it uses the stored apiserver location and verifies the identity of the API server using a self-signed cert. No man-in-the-middle (MITM) attack is possible using this method.
 1. Alternatively, you can provide the location and credentials directly to the http client. This works with client code that is confused by proxies. To protect against man in the middle attacks, you'll need to import a root cert into your browser.
-->
<ol>
<li>以代理模式运行 kubectl（推荐）。
推荐使用此方法，因为它用存储的 apiserver 位置并使用自签名证书验证 API 服务器的标识。
使用这种方法无法进行中间人（MITM）攻击。</li>
<li>另外，你可以直接为 HTTP 客户端提供位置和身份认证。
这适用于被代理混淆的客户端代码。
为防止中间人攻击，你需要将根证书导入浏览器。</li>
</ol>
<!--
Using the Go or Python client libraries provides accessing kubectl in proxy mode.
-->
<p>使用 Go 或 Python 客户端库可以在代理模式下访问 kubectl。</p>
<!--
#### Using kubectl proxy

The following command runs kubectl in a mode where it acts as a reverse proxy. It handles
locating the API server and authenticating.
-->
<h4 id="使用-kubectl-代理">使用 kubectl 代理</h4>
<p>下列命令使 kubectl 运行在反向代理模式下。它处理 API 服务器的定位和身份认证。</p>
<!-- Run it like this: -->
<p>像这样运行它：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl proxy --port<span style="color:#666">=</span><span style="color:#666">8080</span> &amp;
</code></pre></div><!--
See [kubectl proxy](/docs/reference/generated/kubectl/kubectl-commands/#proxy) for more details.
-->
<p>参见 <a href="/docs/reference/generated/kubectl/kubectl-commands/#proxy">kubectl 代理</a> 获取更多细节。</p>
<!--
Then you can explore the API with curl, wget, or a browser, like so:
-->
<p>然后你可以通过 curl，wget，或浏览器浏览 API，像这样：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">curl http://localhost:8080/api/
</code></pre></div><!-- The output is similar to this: -->
<p>输出类似如下：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-json" data-lang="json">{
  <span style="color:#008000;font-weight:bold">&#34;versions&#34;</span>: [
    <span style="color:#b44">&#34;v1&#34;</span>
  ],
  <span style="color:#008000;font-weight:bold">&#34;serverAddressByClientCIDRs&#34;</span>: [
    {
      <span style="color:#008000;font-weight:bold">&#34;clientCIDR&#34;</span>: <span style="color:#b44">&#34;0.0.0.0/0&#34;</span>,
      <span style="color:#008000;font-weight:bold">&#34;serverAddress&#34;</span>: <span style="color:#b44">&#34;10.0.1.149:443&#34;</span>
    }
  ]
}
</code></pre></div><!--
#### Without kubectl proxy

It is possible to avoid using kubectl proxy by passing an authentication token
directly to the API server, like this:

Using `grep/cut` approach:
-->
<h4 id="不使用-kubectl-代理">不使用 kubectl 代理</h4>
<p>通过将身份认证令牌直接传给 API 服务器，可以避免使用 kubectl 代理，像这样：</p>
<p>使用 <code>grep/cut</code> 方式：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="color:#080;font-style:italic"># 查看所有的集群，因为你的 .kubeconfig 文件中可能包含多个上下文</span>
kubectl config view -o <span style="color:#b8860b">jsonpath</span><span style="color:#666">=</span><span style="color:#b44">&#39;{&#34;Cluster name\tServer\n&#34;}{range .clusters[*]}{.name}{&#34;\t&#34;}{.cluster.server}{&#34;\n&#34;}{end}&#39;</span>

<span style="color:#080;font-style:italic"># 从上述命令输出中选择你要与之交互的集群的名称</span>
<span style="color:#a2f">export</span> <span style="color:#b8860b">CLUSTER_NAME</span><span style="color:#666">=</span><span style="color:#b44">&#34;some_server_name&#34;</span>

<span style="color:#080;font-style:italic"># 指向引用该集群名称的 API 服务器</span>
<span style="color:#b8860b">APISERVER</span><span style="color:#666">=</span><span style="color:#a2f;font-weight:bold">$(</span>kubectl config view -o <span style="color:#b8860b">jsonpath</span><span style="color:#666">=</span><span style="color:#b44">&#34;{.clusters[?(@.name==\&#34;</span><span style="color:#b8860b">$CLUSTER_NAME</span><span style="color:#b44">\&#34;)].cluster.server}&#34;</span><span style="color:#a2f;font-weight:bold">)</span>

<span style="color:#080;font-style:italic"># 获得令牌</span>
<span style="color:#b8860b">TOKEN</span><span style="color:#666">=</span><span style="color:#a2f;font-weight:bold">$(</span>kubectl get secrets -o <span style="color:#b8860b">jsonpath</span><span style="color:#666">=</span><span style="color:#b44">&#34;{.items[?(@.metadata.annotations[&#39;kubernetes\.io/service-account\.name&#39;]==&#39;default&#39;)].data.token}&#34;</span>|base64 -d<span style="color:#a2f;font-weight:bold">)</span>

<span style="color:#080;font-style:italic"># 使用令牌玩转 API</span>
curl -X GET <span style="color:#b8860b">$APISERVER</span>/api --header <span style="color:#b44">&#34;Authorization: Bearer </span><span style="color:#b8860b">$TOKEN</span><span style="color:#b44">&#34;</span> --insecure
</code></pre></div><!-- The output is similar to this: -->
<p>输出类似如下：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-json" data-lang="json">{
  <span style="color:#008000;font-weight:bold">&#34;kind&#34;</span>: <span style="color:#b44">&#34;APIVersions&#34;</span>,
  <span style="color:#008000;font-weight:bold">&#34;versions&#34;</span>: [
    <span style="color:#b44">&#34;v1&#34;</span>
  ],
  <span style="color:#008000;font-weight:bold">&#34;serverAddressByClientCIDRs&#34;</span>: [
    {
      <span style="color:#008000;font-weight:bold">&#34;clientCIDR&#34;</span>: <span style="color:#b44">&#34;0.0.0.0/0&#34;</span>,
      <span style="color:#008000;font-weight:bold">&#34;serverAddress&#34;</span>: <span style="color:#b44">&#34;10.0.1.149:443&#34;</span>
    }
  ]
}
</code></pre></div><!-- Using `jsonpath` approach: -->
<p>使用 <code>jsonpath</code> 方式：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="color:#b8860b">APISERVER</span><span style="color:#666">=</span><span style="color:#a2f;font-weight:bold">$(</span>kubectl config view --minify -o <span style="color:#b8860b">jsonpath</span><span style="color:#666">=</span><span style="color:#b44">&#39;{.clusters[0].cluster.server}&#39;</span><span style="color:#a2f;font-weight:bold">)</span>
<span style="color:#b8860b">TOKEN</span><span style="color:#666">=</span><span style="color:#a2f;font-weight:bold">$(</span>kubectl get secret <span style="color:#a2f;font-weight:bold">$(</span>kubectl get serviceaccount default -o <span style="color:#b8860b">jsonpath</span><span style="color:#666">=</span><span style="color:#b44">&#39;{.secrets[0].name}&#39;</span><span style="color:#a2f;font-weight:bold">)</span> -o <span style="color:#b8860b">jsonpath</span><span style="color:#666">=</span><span style="color:#b44">&#39;{.data.token}&#39;</span> | base64 --decode <span style="color:#a2f;font-weight:bold">)</span>
curl <span style="color:#b8860b">$APISERVER</span>/api --header <span style="color:#b44">&#34;Authorization: Bearer </span><span style="color:#b8860b">$TOKEN</span><span style="color:#b44">&#34;</span> --insecure
</code></pre></div><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-json" data-lang="json">{
  <span style="color:#008000;font-weight:bold">&#34;kind&#34;</span>: <span style="color:#b44">&#34;APIVersions&#34;</span>,
  <span style="color:#008000;font-weight:bold">&#34;versions&#34;</span>: [
    <span style="color:#b44">&#34;v1&#34;</span>
  ],
  <span style="color:#008000;font-weight:bold">&#34;serverAddressByClientCIDRs&#34;</span>: [
    {
      <span style="color:#008000;font-weight:bold">&#34;clientCIDR&#34;</span>: <span style="color:#b44">&#34;0.0.0.0/0&#34;</span>,
      <span style="color:#008000;font-weight:bold">&#34;serverAddress&#34;</span>: <span style="color:#b44">&#34;10.0.1.149:443&#34;</span>
    }
  ]
}
</code></pre></div><!--
The above example uses the `--insecure` flag. This leaves it subject to MITM
attacks. When kubectl accesses the cluster it uses a stored root certificate
and client certificates to access the server. (These are installed in the
`~/.kube` directory). Since cluster certificates are typically self-signed, it
may take special configuration to get your http client to use root
certificate.
-->
<p>上面例子使用了 <code>--insecure</code> 标志位。这使它易受到 MITM 攻击。
当 kubectl 访问集群时，它使用存储的根证书和客户端证书访问服务器。
（已安装在 <code>~/.kube</code> 目录下）。
由于集群认证通常是自签名的，因此可能需要特殊设置才能让你的 http 客户端使用根证书。</p>
<!--
On some clusters, the API server does not require authentication; it may serve
on localhost, or be protected by a firewall. There is not a standard
for this. [Controlling Access to the Kubernetes API](/docs/concepts/security/controlling-access)
describes how you can configure this as a cluster administrator.
-->
<p>在一些集群中，API 服务器不需要身份认证；它运行在本地，或由防火墙保护着。
对此并没有一个标准。
<a href="/zh/docs/concepts/security/controlling-access/">配置对 API 的访问</a>
讲解了作为集群管理员可如何对此进行配置。</p>
<!--
### Programmatic access to the API

Kubernetes officially supports client libraries for [Go](#go-client), [Python](#python-client), [Java](#java-client), [dotnet](#dotnet-client), [Javascript](#javascript-client), and [Haskell](#haskell-client). There are other client libraries that are provided and maintained by their authors, not the Kubernetes team. See [client libraries](/docs/reference/using-api/client-libraries/) for accessing the API from other languages and how they authenticate.
-->
<h3 id="编程方式访问-api">编程方式访问 API</h3>
<p>Kubernetes 官方支持 <a href="#go-client">Go</a>、<a href="#python-client">Python</a>、<a href="#java-client">Java</a>、
<a href="#dotnet-client">dotnet</a>、<a href="#javascript-client">Javascript</a> 和 <a href="#haskell-client">Haskell</a>
语言的客户端库。还有一些其他客户端库由对应作者而非 Kubernetes 团队提供并维护。
参考<a href="/zh/docs/reference/using-api/client-libraries/">客户端库</a>了解如何使用其他语言
来访问 API 以及如何执行身份认证。</p>
<!-- #### Go client -->
<h4 id="go-client">Go 客户端 </h4>
<!--
* To get the library, run the following command: `go get k8s.io/client-go@kubernetes-<kubernetes-version-number>` See [https://github.com/kubernetes/client-go/releases](https://github.com/kubernetes/client-go/releases) to see which versions are supported.
* Write an application atop of the client-go clients.
-->
<ul>
<li>要获取库，运行下列命令：<code>go get k8s.io/client-go/kubernetes-&lt;kubernetes 版本号&gt;</code>，
参见 <a href="https://github.com/kubernetes/client-go/releases">https://github.com/kubernetes/client-go/releases</a> 查看受支持的版本。</li>
<li>基于 client-go 客户端编写应用程序。</li>
</ul>
<!--
Note that client-go defines its own API objects, so if needed, please import API definitions from client-go rather than from the main repository, e.g., `import "k8s.io/client-go/kubernetes"` is correct.
-->
<blockquote class="note callout">
  <div><strong>说明：</strong> 注意 client-go 定义了自己的 API 对象，因此如果需要，请从 client-go 而不是主仓库导入
API 定义，例如 <code>import &quot;k8s.io/client-go/kubernetes&quot;</code> 是正确做法。</div>
</blockquote>
<!--
The Go client can use the same [kubeconfig file](/docs/concepts/cluster-administration/authenticate-across-clusters-kubeconfig/)
as the kubectl CLI does to locate and authenticate to the API server. See this [example](https://git.k8s.io/client-go/examples/out-of-cluster-client-configuration/main.go):
-->
<p>Go 客户端可以使用与 kubectl 命令行工具相同的
<a href="/zh/docs/concepts/configuration/organize-cluster-access-kubeconfig/">kubeconfig 文件</a>
定位和验证 API 服务器。参见这个
<a href="https://git.k8s.io/client-go/examples/out-of-cluster-client-configuration/main.go">例子</a>：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#a2f;font-weight:bold">package</span> main

<span style="color:#a2f;font-weight:bold">import</span> (
   <span style="color:#b44">&#34;context&#34;</span>
   <span style="color:#b44">&#34;fmt&#34;</span>
   <span style="color:#b44">&#34;k8s.io/apimachinery/pkg/apis/meta/v1&#34;</span>
   <span style="color:#b44">&#34;k8s.io/client-go/kubernetes&#34;</span>
   <span style="color:#b44">&#34;k8s.io/client-go/tools/clientcmd&#34;</span>
)

<span style="color:#a2f;font-weight:bold">func</span> <span style="color:#00a000">main</span>() {
  <span style="color:#080;font-style:italic">// uses the current context in kubeconfig
</span><span style="color:#080;font-style:italic"></span>  <span style="color:#080;font-style:italic">// path-to-kubeconfig -- for example, /root/.kube/config
</span><span style="color:#080;font-style:italic"></span>  config, _ <span style="color:#666">:=</span> clientcmd.<span style="color:#00a000">BuildConfigFromFlags</span>(<span style="color:#b44">&#34;&#34;</span>, <span style="color:#b44">&#34;&lt;path-to-kubeconfig&gt;&#34;</span>)
  <span style="color:#080;font-style:italic">// creates the clientset
</span><span style="color:#080;font-style:italic"></span>  clientset, _ <span style="color:#666">:=</span> kubernetes.<span style="color:#00a000">NewForConfig</span>(config)
  <span style="color:#080;font-style:italic">// access the API to list pods
</span><span style="color:#080;font-style:italic"></span>  pods, _ <span style="color:#666">:=</span> clientset.<span style="color:#00a000">CoreV1</span>().<span style="color:#00a000">Pods</span>(<span style="color:#b44">&#34;&#34;</span>).<span style="color:#00a000">List</span>(context.<span style="color:#00a000">TODO</span>(), v1.ListOptions{})
  fmt.<span style="color:#00a000">Printf</span>(<span style="color:#b44">&#34;There are %d pods in the cluster\n&#34;</span>, <span style="color:#a2f">len</span>(pods.Items))
}
</code></pre></div><!--
If the application is deployed as a Pod in the cluster, see [Accessing the API from within a Pod](/docs/tasks/access-application-cluster/access-cluster/#accessing-the-api-from-a-pod).
-->
<p>如果该应用程序部署为集群中的一个
Pod，请参阅<a href="/zh/docs/tasks/access-application-cluster/access-cluster/#accessing-the-api-from-a-pod">从 Pod 内访问 API</a>。</p>
<!-- #### Python client -->
<h4 id="python-client">Python 客户端</h4>
<!--
To use [Python client](https://github.com/kubernetes-client/python), run the following command: `pip install kubernetes` See [Python Client Library page](https://github.com/kubernetes-client/python) for more installation options.
-->
<p>要使用 <a href="https://github.com/kubernetes-client/python">Python 客户端</a>，运行下列命令：
<code>pip install kubernetes</code>。
参见 <a href="https://github.com/kubernetes-client/python">Python 客户端库主页</a> 了解更多安装选项。</p>
<!--
The Python client can use the same [kubeconfig file](/docs/concepts/cluster-administration/authenticate-across-clusters-kubeconfig/)
as the kubectl CLI does to locate and authenticate to the API server. See this [example](https://github.com/kubernetes-client/python/blob/master/examples/out_of_cluster_config.py):
-->
<p>Python 客户端可以使用与 kubectl 命令行工具相同的
<a href="/zh/docs/concepts/configuration/organize-cluster-access-kubeconfig/">kubeconfig 文件</a>
定位和验证 API 服务器。参见这个
<a href="https://github.com/kubernetes-client/python/blob/master/examples/out_of_cluster_config.py">例子</a>：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#a2f;font-weight:bold">from</span> <span style="color:#00f;font-weight:bold">kubernetes</span> <span style="color:#a2f;font-weight:bold">import</span> client, config

config<span style="color:#666">.</span>load_kube_config()

v1<span style="color:#666">=</span>client<span style="color:#666">.</span>CoreV1Api()
<span style="color:#a2f">print</span>(<span style="color:#b44">&#34;Listing pods with their IPs:&#34;</span>)
ret <span style="color:#666">=</span> v1<span style="color:#666">.</span>list_pod_for_all_namespaces(watch<span style="color:#666">=</span><span style="color:#a2f;font-weight:bold">False</span>)
<span style="color:#a2f;font-weight:bold">for</span> i <span style="color:#a2f;font-weight:bold">in</span> ret<span style="color:#666">.</span>items:
    <span style="color:#a2f">print</span>(<span style="color:#b44">&#34;</span><span style="color:#b68;font-weight:bold">%s</span><span style="color:#b62;font-weight:bold">\t</span><span style="color:#b68;font-weight:bold">%s</span><span style="color:#b62;font-weight:bold">\t</span><span style="color:#b68;font-weight:bold">%s</span><span style="color:#b44">&#34;</span> <span style="color:#666">%</span> (i<span style="color:#666">.</span>status<span style="color:#666">.</span>pod_ip, i<span style="color:#666">.</span>metadata<span style="color:#666">.</span>namespace, i<span style="color:#666">.</span>metadata<span style="color:#666">.</span>name))
</code></pre></div><!-- #### Java client -->
<h4 id="java-client">Java 客户端   </h4>
<!--
To install the [Java Client](https://github.com/kubernetes-client/java), run:
-->
<p>要安装 <a href="https://github.com/kubernetes-client/java">Java 客户端</a>，运行：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="color:#080;font-style:italic"># 克隆 Java 库</span>
git clone --recursive https://github.com/kubernetes-client/java

<span style="color:#080;font-style:italic"># 安装项目文件、POM 等</span>
<span style="color:#a2f">cd</span> java
mvn install
</code></pre></div><!--
See [https://github.com/kubernetes-client/java/releases](https://github.com/kubernetes-client/java/releases) to see which versions are supported.

The Java client can use the same [kubeconfig file](/docs/concepts/configuration/organize-cluster-access-kubeconfig/)
as the kubectl CLI does to locate and authenticate to the API server. See this [example](https://github.com/kubernetes-client/java/blob/master/examples/src/main/java/io/kubernetes/client/examples/KubeConfigFileClientExample.java):
-->
<p>参阅<a href="https://github.com/kubernetes-client/java/releases">https://github.com/kubernetes-client/java/releases</a>
了解当前支持的版本。</p>
<p>Java 客户端可以使用 kubectl 命令行所使用的
<a href="/zh/docs/concepts/configuration/organize-cluster-access-kubeconfig/">kubeconfig 文件</a>
以定位 API 服务器并向其认证身份。
参看此<a href="https://github.com/kubernetes-client/java/blob/master/examples/src/main/java/io/kubernetes/client/examples/KubeConfigFileClientExample.java">示例</a>：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#a2f;font-weight:bold">package</span> <span style="color:#00f;font-weight:bold">io.kubernetes.client.examples</span><span style="color:#666">;</span>

<span style="color:#a2f;font-weight:bold">import</span> <span style="color:#00f;font-weight:bold">io.kubernetes.client.ApiClient</span><span style="color:#666">;</span>
<span style="color:#a2f;font-weight:bold">import</span> <span style="color:#00f;font-weight:bold">io.kubernetes.client.ApiException</span><span style="color:#666">;</span>
<span style="color:#a2f;font-weight:bold">import</span> <span style="color:#00f;font-weight:bold">io.kubernetes.client.Configuration</span><span style="color:#666">;</span>
<span style="color:#a2f;font-weight:bold">import</span> <span style="color:#00f;font-weight:bold">io.kubernetes.client.apis.CoreV1Api</span><span style="color:#666">;</span>
<span style="color:#a2f;font-weight:bold">import</span> <span style="color:#00f;font-weight:bold">io.kubernetes.client.models.V1Pod</span><span style="color:#666">;</span>
<span style="color:#a2f;font-weight:bold">import</span> <span style="color:#00f;font-weight:bold">io.kubernetes.client.models.V1PodList</span><span style="color:#666">;</span>
<span style="color:#a2f;font-weight:bold">import</span> <span style="color:#00f;font-weight:bold">io.kubernetes.client.util.ClientBuilder</span><span style="color:#666">;</span>
<span style="color:#a2f;font-weight:bold">import</span> <span style="color:#00f;font-weight:bold">io.kubernetes.client.util.KubeConfig</span><span style="color:#666">;</span>
<span style="color:#a2f;font-weight:bold">import</span> <span style="color:#00f;font-weight:bold">java.io.FileReader</span><span style="color:#666">;</span>
<span style="color:#a2f;font-weight:bold">import</span> <span style="color:#00f;font-weight:bold">java.io.IOException</span><span style="color:#666">;</span>

<span style="color:#080;font-style:italic">/**
</span><span style="color:#080;font-style:italic"> * A simple example of how to use the Java API from an application outside a kubernetes cluster
</span><span style="color:#080;font-style:italic"> *
</span><span style="color:#080;font-style:italic"> * &lt;p&gt;Easiest way to run this: mvn exec:java
</span><span style="color:#080;font-style:italic"> * -Dexec.mainClass=&#34;io.kubernetes.client.examples.KubeConfigFileClientExample&#34;
</span><span style="color:#080;font-style:italic"> *
</span><span style="color:#080;font-style:italic"> */</span>
<span style="color:#a2f;font-weight:bold">public</span> <span style="color:#a2f;font-weight:bold">class</span> <span style="color:#00f">KubeConfigFileClientExample</span> <span style="color:#666">{</span>
  <span style="color:#a2f;font-weight:bold">public</span> <span style="color:#a2f;font-weight:bold">static</span> <span style="color:#0b0;font-weight:bold">void</span> <span style="color:#00a000">main</span><span style="color:#666">(</span>String<span style="color:#666">[]</span> args<span style="color:#666">)</span> <span style="color:#a2f;font-weight:bold">throws</span> IOException<span style="color:#666">,</span> ApiException <span style="color:#666">{</span>

    <span style="color:#080;font-style:italic">// file path to your KubeConfig
</span><span style="color:#080;font-style:italic"></span>    String kubeConfigPath <span style="color:#666">=</span> <span style="color:#b44">&#34;~/.kube/config&#34;</span><span style="color:#666">;</span>

    <span style="color:#080;font-style:italic">// loading the out-of-cluster config, a kubeconfig from file-system
</span><span style="color:#080;font-style:italic"></span>    ApiClient client <span style="color:#666">=</span>
        ClientBuilder<span style="color:#666">.</span><span style="color:#b44">kubeconfig</span><span style="color:#666">(</span>KubeConfig<span style="color:#666">.</span><span style="color:#b44">loadKubeConfig</span><span style="color:#666">(</span><span style="color:#a2f;font-weight:bold">new</span> FileReader<span style="color:#666">(</span>kubeConfigPath<span style="color:#666">))).</span><span style="color:#b44">build</span><span style="color:#666">();</span>

    <span style="color:#080;font-style:italic">// set the global default api-client to the in-cluster one from above
</span><span style="color:#080;font-style:italic"></span>    Configuration<span style="color:#666">.</span><span style="color:#b44">setDefaultApiClient</span><span style="color:#666">(</span>client<span style="color:#666">);</span>

    <span style="color:#080;font-style:italic">// the CoreV1Api loads default api-client from global configuration.
</span><span style="color:#080;font-style:italic"></span>    CoreV1Api api <span style="color:#666">=</span> <span style="color:#a2f;font-weight:bold">new</span> CoreV1Api<span style="color:#666">();</span>

    <span style="color:#080;font-style:italic">// invokes the CoreV1Api client
</span><span style="color:#080;font-style:italic"></span>    V1PodList list <span style="color:#666">=</span> api<span style="color:#666">.</span><span style="color:#b44">listPodForAllNamespaces</span><span style="color:#666">(</span><span style="color:#a2f;font-weight:bold">null</span><span style="color:#666">,</span> <span style="color:#a2f;font-weight:bold">null</span><span style="color:#666">,</span> <span style="color:#a2f;font-weight:bold">null</span><span style="color:#666">,</span> <span style="color:#a2f;font-weight:bold">null</span><span style="color:#666">,</span> <span style="color:#a2f;font-weight:bold">null</span><span style="color:#666">,</span> <span style="color:#a2f;font-weight:bold">null</span><span style="color:#666">,</span> <span style="color:#a2f;font-weight:bold">null</span><span style="color:#666">,</span> <span style="color:#a2f;font-weight:bold">null</span><span style="color:#666">,</span> <span style="color:#a2f;font-weight:bold">null</span><span style="color:#666">);</span>
    System<span style="color:#666">.</span><span style="color:#b44">out</span><span style="color:#666">.</span><span style="color:#b44">println</span><span style="color:#666">(</span><span style="color:#b44">&#34;Listing all pods: &#34;</span><span style="color:#666">);</span>
    <span style="color:#a2f;font-weight:bold">for</span> <span style="color:#666">(</span>V1Pod item <span style="color:#666">:</span> list<span style="color:#666">.</span><span style="color:#b44">getItems</span><span style="color:#666">())</span> <span style="color:#666">{</span>
      System<span style="color:#666">.</span><span style="color:#b44">out</span><span style="color:#666">.</span><span style="color:#b44">println</span><span style="color:#666">(</span>item<span style="color:#666">.</span><span style="color:#b44">getMetadata</span><span style="color:#666">().</span><span style="color:#b44">getName</span><span style="color:#666">());</span>
    <span style="color:#666">}</span>
  <span style="color:#666">}</span>
<span style="color:#666">}</span>
</code></pre></div><!--
#### dotnet client

To use [dotnet client](https://github.com/kubernetes-client/csharp), run the following command: `dotnet add package KubernetesClient --version 1.6.1` See [dotnet Client Library page](https://github.com/kubernetes-client/csharp) for more installation options. See [https://github.com/kubernetes-client/csharp/releases](https://github.com/kubernetes-client/csharp/releases) to see which versions are supported.

The dotnet client can use the same [kubeconfig file](/docs/concepts/configuration/organize-cluster-access-kubeconfig/)
as the kubectl CLI does to locate and authenticate to the API server. See this [example](https://github.com/kubernetes-client/csharp/blob/master/examples/simple/PodList.cs):
-->
<h4 id="dotnet-client">.Net 客户端   </h4>
<p>要使用<a href="https://github.com/kubernetes-client/csharp">.Net 客户端</a>，运行下面的命令：
<code>dotnet add package KubernetesClient --version 1.6.1</code>。
参见<a href="https://github.com/kubernetes-client/csharp">.Net 客户端库页面</a>了解更多安装选项。
关于可支持的版本，参见<a href="https://github.com/kubernetes-client/csharp/releases">https://github.com/kubernetes-client/csharp/releases</a>。</p>
<p>.Net 客户端可以使用与 kubectl CLI 相同的 <a href="/zh/docs/concepts/configuration/organize-cluster-access-kubeconfig/">kubeconfig 文件</a>
来定位并验证 API 服务器。
参见<a href="https://github.com/kubernetes-client/csharp/blob/master/examples/simple/PodList.cs">样例</a>:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp"><span style="color:#a2f;font-weight:bold">using</span> <span style="color:#00f;font-weight:bold">System</span>;
<span style="color:#a2f;font-weight:bold">using</span> <span style="color:#00f;font-weight:bold">k8s</span>;

<span style="color:#a2f;font-weight:bold">namespace</span> <span style="color:#00f;font-weight:bold">simple</span>
{
    <span style="color:#a2f;font-weight:bold">internal</span> <span style="color:#a2f;font-weight:bold">class</span> <span style="color:#00f">PodList</span>
    {
        <span style="color:#a2f;font-weight:bold">private</span> <span style="color:#a2f;font-weight:bold">static</span> <span style="color:#a2f;font-weight:bold">void</span> Main(<span style="color:#0b0;font-weight:bold">string</span>[] args)
        {
            <span style="color:#0b0;font-weight:bold">var</span> config = KubernetesClientConfiguration.BuildDefaultConfig();
            IKubernetes client = <span style="color:#a2f;font-weight:bold">new</span> Kubernetes(config);
            Console.WriteLine(<span style="color:#b44">&#34;Starting Request!&#34;</span>);

            <span style="color:#0b0;font-weight:bold">var</span> list = client.ListNamespacedPod(<span style="color:#b44">&#34;default&#34;</span>);
            <span style="color:#a2f;font-weight:bold">foreach</span> (<span style="color:#0b0;font-weight:bold">var</span> item <span style="color:#a2f;font-weight:bold">in</span> list.Items)
            {
                Console.WriteLine(item.Metadata.Name);
            }
            <span style="color:#a2f;font-weight:bold">if</span> (list.Items.Count == <span style="color:#666">0</span>)
            {
                Console.WriteLine(<span style="color:#b44">&#34;Empty!&#34;</span>);
            }
        }
    }
}
</code></pre></div><!--
#### JavaScript client

To install [JavaScript client](https://github.com/kubernetes-client/javascript), run the following command: `npm install @kubernetes/client-node`. See [https://github.com/kubernetes-client/javascript/releases](https://github.com/kubernetes-client/javascript/releases) to see which versions are supported.

The JavaScript client can use the same [kubeconfig file](/docs/concepts/configuration/organize-cluster-access-kubeconfig/)
as the kubectl CLI does to locate and authenticate to the API server. See this [example](https://github.com/kubernetes-client/javascript/blob/master/examples/example.js):
-->
<h4 id="javascript-client">JavaScript 客户端   </h4>
<p>要安装 <a href="https://github.com/kubernetes-client/javascript">JavaScript 客户端</a>，运行下面的命令：
<code>npm install @kubernetes/client-node</code>。
参考<a href="https://github.com/kubernetes-client/javascript/releases">https://github.com/kubernetes-client/javascript/releases</a>了解可支持的版本。</p>
<p>JavaScript 客户端可以使用 kubectl 命令行所使用的
<a href="/zh/docs/concepts/configuration/organize-cluster-access-kubeconfig/">kubeconfig 文件</a>
以定位 API 服务器并向其认证身份。
参见<a href="https://github.com/kubernetes-client/javascript/blob/master/examples/example.js">此例</a>：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#a2f;font-weight:bold">const</span> k8s <span style="color:#666">=</span> require(<span style="color:#b44">&#39;@kubernetes/client-node&#39;</span>);

<span style="color:#a2f;font-weight:bold">const</span> kc <span style="color:#666">=</span> <span style="color:#a2f;font-weight:bold">new</span> k8s.KubeConfig();
kc.loadFromDefault();

<span style="color:#a2f;font-weight:bold">const</span> k8sApi <span style="color:#666">=</span> kc.makeApiClient(k8s.CoreV1Api);

k8sApi.listNamespacedPod(<span style="color:#b44">&#39;default&#39;</span>).then((res) =&gt; {
    console.log(res.body);
});
</code></pre></div><!--
#### Haskell client

See [https://github.com/kubernetes-client/haskell/releases](https://github.com/kubernetes-client/haskell/releases) to see which versions are supported.

The [Haskell client](https://github.com/kubernetes-client/haskell) can use the same [kubeconfig file](/docs/concepts/configuration/organize-cluster-access-kubeconfig/)
as the kubectl CLI does to locate and authenticate to the API server. See this [example](https://github.com/kubernetes-client/haskell/blob/master/kubernetes-client/example/App.hs):
-->
<h4 id="haskell-client">Haskell 客户端   </h4>
<p>参考 <a href="https://github.com/kubernetes-client/haskell/releases">https://github.com/kubernetes-client/haskell/releases</a> 了解支持的版本。</p>
<p><a href="https://github.com/kubernetes-client/haskell">Haskell 客户端</a>
可以使用 kubectl 命令行所使用的
<a href="/zh/docs/concepts/configuration/organize-cluster-access-kubeconfig/">kubeconfig 文件</a>
以定位 API 服务器并向其认证身份。
参见<a href="https://github.com/kubernetes-client/haskell/blob/master/kubernetes-client/example/App.hs">此例</a>：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#00a000">exampleWithKubeConfig</span> <span style="color:#a2f;font-weight:bold">::</span> <span style="color:#0b0;font-weight:bold">IO</span> <span style="color:#a2f">()</span>
<span style="color:#00a000">exampleWithKubeConfig</span> <span style="color:#a2f;font-weight:bold">=</span> <span style="color:#a2f;font-weight:bold">do</span>
    oidcCache <span style="color:#a2f;font-weight:bold">&lt;-</span> atomically <span style="color:#666">$</span> newTVar <span style="color:#666">$</span> <span style="color:#0b0;font-weight:bold">Map</span><span style="color:#666">.</span>fromList <span style="color:#0b0;font-weight:bold">[]</span>
    (mgr, kcfg) <span style="color:#a2f;font-weight:bold">&lt;-</span> mkKubeClientConfig oidcCache <span style="color:#666">$</span> <span style="color:#0b0;font-weight:bold">KubeConfigFile</span> <span style="color:#b44">&#34;/path/to/kubeconfig&#34;</span>
    dispatchMime
            mgr
            kcfg
            (<span style="color:#0b0;font-weight:bold">CoreV1</span><span style="color:#666">.</span>listPodForAllNamespaces (<span style="color:#0b0;font-weight:bold">Accept</span> <span style="color:#0b0;font-weight:bold">MimeJSON</span>))
        <span style="color:#666">&gt;&gt;=</span> print
</code></pre></div><h2 id="接下来">接下来</h2>
<!--
* [Accessing the Kubernetes API from a Pod](/docs/tasks/run-application/access-api-from-pod/)
-->
<ul>
<li><a href="/zh/docs/tasks/run-application/access-api-from-pod/">从 Pod 中访问 API</a></li>
</ul>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-12001be83d15fcd7f3242313a55777df">14 - 保护集群安全</h1>
    
	<!--
reviewers:
- smarterclayton
- liggitt
- ericchiang
- destijl
title: Securing a Cluster
content_type: task
-->
<!-- overview -->
<!--
This document covers topics related to protecting a cluster from accidental or malicious access
and provides recommendations on overall security.
-->
<p>本文档涉及与保护集群免受意外或恶意访问有关的主题，并对总体安全性提出建议。</p>
<h2 id="准备开始">准备开始</h2>
<ul>
<li><p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
如果你还没有集群，你可以通过 <a href="/zh/docs/tasks/tools/#minikube">Minikube</a> 构建一
个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p>
<!--
You need to have a Kubernetes cluster, and the kubectl command-line tool must
be configured to communicate with your cluster. If you do not already have a
cluster, you can create one by using
[minikube](/docs/tasks/tools/#minikube)
or you can use one of these Kubernetes playgrounds:
-->
<ul>
<li><a href="https://www.katacoda.com/courses/kubernetes/playground">Katacoda</a></li>
<li><a href="http://labs.play-with-k8s.com/">玩转 Kubernetes</a></li>
</ul>
 
 要获知版本信息，请输入 <code>kubectl version</code>.
</li>
</ul>
<!-- steps -->
<!--
## Controlling access to the Kubernetes API

As Kubernetes is entirely API driven, controlling and limiting who can access the cluster and what actions
they are allowed to perform is the first line of defense.
-->
<h2 id="控制对-kubernetes-api-的访问">控制对 Kubernetes API 的访问</h2>
<p>因为 Kubernetes 是完全通过 API 驱动的，所以，控制和限制谁可以通过 API 访问集群，以及允许这些访问者执行什么样的 API 动作，就成为了安全控制的第一道防线。</p>
<!--
### Use Transport Layer Security (TLS) for all API traffic

Kubernetes expects that all API communication in the cluster is encrypted by default with TLS, and the
majority of installation methods will allow the necessary certificates to be created and distributed to
the cluster components. Note that some components and installation methods may enable local ports over
HTTP and administrators should familiarize themselves with the settings of each component to identify
potentially unsecured traffic.
-->
<h3 id="为所有-api-交互使用传输层安全-tls">为所有 API 交互使用传输层安全 （TLS）</h3>
<p>Kubernetes 期望集群中所有的 API 通信在默认情况下都使用 TLS 加密，大多数安装方法也允许创建所需的证书并且分发到集群组件中。请注意，某些组件和安装方法可能使用 HTTP 来访问本地端口， 管理员应该熟悉每个组件的设置，以识别潜在的不安全的流量。</p>
<!--
### API Authentication

Choose an authentication mechanism for the API servers to use that matches the common access patterns
when you install a cluster. For instance, small single user clusters may wish to use a simple certificate
or static Bearer token approach. Larger clusters may wish to integrate an existing OIDC or LDAP server that
allow users to be subdivided into groups.

All API clients must be authenticated, even those that are part of the infrastructure like nodes,
proxies, the scheduler, and volume plugins. These clients are typically [service accounts](/docs/reference/access-authn-authz/service-accounts-admin/) or use x509 client certificates, and they are created automatically at cluster startup or are setup as part of the cluster installation.

Consult the [authentication reference document](/docs/reference/access-authn-authz/authentication/) for more information.
-->
<h3 id="api-认证">API 认证</h3>
<p>安装集群时，选择一个 API 服务器的身份验证机制，去使用与之匹配的公共访问模式。
例如，小型的单用户集群可能希望使用简单的证书或静态承载令牌方法。
更大的集群则可能希望整合现有的、OIDC、LDAP 等允许用户分组的服务器。</p>
<p>所有 API 客户端都必须经过身份验证，即使它是基础设施的一部分，比如节点、代理、调度程序和卷插件。
这些客户端通常使用 <a href="/zh/docs/reference/access-authn-authz/service-accounts-admin/">服务帐户</a>
或 X509 客户端证书，并在集群启动时自动创建或是作为集群安装的一部分进行设置。</p>
<p>如果你希望获取更多信息，请参考<a href="/zh/docs/reference/access-authn-authz/authentication/">认证参考文档</a>。</p>
<!--
### API Authorization

Once authenticated, every API call is also expected to pass an authorization check. Kubernetes ships
an integrated [Role-Based Access Control (RBAC)](/docs/reference/access-authn-authz/rbac/) component that matches an incoming user or group to a
set of permissions bundled into roles. These permissions combine verbs (get, create, delete) with
resources (pods, services, nodes) and can be namespace or cluster scoped. A set of out of the box
roles are provided that offer reasonable default separation of responsibility depending on what
actions a client might want to perform. It is recommended that you use the [Node](/docs/reference/access-authn-authz/node/) and [RBAC](/docs/reference/access-authn-authz/rbac/) authorizers together, in combination with the
[NodeRestriction](/docs/reference/access-authn-authz/admission-controllers/#noderestriction) admission plugin.
-->
<h3 id="api-授权">API 授权</h3>
<p>一旦通过身份认证，每个 API 的调用都将通过鉴权检查。
Kubernetes 集成<a href="/zh/docs/reference/access-authn-authz/rbac/">基于角色的访问控制（RBAC）</a>组件，
将传入的用户或组与一组绑定到角色的权限匹配。
这些权限将动作（get，create，delete）和资源（pod，service, node）在命名空间或者集群范围内结合起来，
根据客户可能希望执行的操作，提供了一组提供合理的违约责任分离的外包角色。
建议你将<a href="/zh/docs/reference/access-authn-authz/node/">节点</a> 和
<a href="/zh/docs/reference/access-authn-authz/rbac/">RBAC</a> 一起作为授权者，再与
<a href="/zh/docs/reference/access-authn-authz/admission-controllers/#noderestriction">NodeRestriction</a>
准入插件结合使用。</p>
<!--
As with authentication, simple and broad roles may be appropriate for smaller clusters, but as
more users interact with the cluster, it may become necessary to separate teams into separate
namespaces with more limited roles.
-->
<p>与身份验证一样，简单而广泛的角色可能适合于较小的集群，但是随着更多的用户与集群交互，
可能需要将团队划分成有更多角色限制的单独的命名空间。</p>
<!--
With authorization, it is important to understand how updates on one object may cause actions in
other places. For instance, a user may not be able to create pods directly, but allowing them to
create a deployment, which creates pods on their behalf, will let them create those pods
indirectly. Likewise, deleting a node from the API will result in the pods scheduled to that node
being terminated and recreated on other nodes. The out of the box roles represent a balance
between flexibility and the common use cases, but more limited roles should be carefully reviewed
to prevent accidental escalation. You can make roles specific to your use case if the out-of-box ones don't meet your needs.

Consult the [authorization reference section](/docs/reference/access-authn-authz/authorization/) for more information.
-->
<p>就鉴权而言，理解怎么样更新一个对象可能导致在其它地方的发生什么样的行为是非常重要的。
例如，用户可能不能直接创建 Pod，但允许他们通过创建一个 Deployment 来创建这些 Pod，
这将让他们间接创建这些 Pod。
同样地，从 API 删除一个节点将导致调度到这些节点上的 Pod 被中止，并在其他节点上重新创建。
原生的角色设计代表了灵活性和常见用例之间的平衡，但有限制的角色应该仔细审查，
以防止意外升级。如果外包角色不满足你的需求，则可以为用例指定特定的角色。</p>
<p>如果你希望获取更多信息，请参阅<a href="/zh/docs/reference/access-authn-authz/authorization/">鉴权参考</a>。</p>
<!--
## Controlling access to the Kubelet

Kubelets expose HTTPS endpoints which grant powerful control over the node and containers. By default Kubelets allow unauthenticated access to this API.

Production clusters should enable Kubelet authentication and authorization.

Consult the [Kubelet authentication/authorization reference](/docs/admin/kubelet-authentication-authorization) for more information.
-->
<h2 id="控制对-kubelet-的访问">控制对 Kubelet 的访问</h2>
<p>Kubelet 公开 HTTPS 端点，这些端点授予节点和容器强大的控制权。
默认情况下，Kubelet 允许对此 API 进行未经身份验证的访问。</p>
<p>生产级别的集群应启用 Kubelet 身份验证和授权。</p>
<p>如果你希望获取更多信息，请参考
<a href="/zh/docs/reference/command-line-tools-reference/kubelet-authentication-authorization/">Kubelet 身份验证/授权参考</a>。</p>
<!--
## Controlling the capabilities of a workload or user at runtime

Authorization in Kubernetes is intentionally high level, focused on coarse actions on resources.
More powerful controls exist as **policies** to limit by use case how those objects act on the
cluster, themselves, and other resources.
-->
<h2 id="控制运行时负载或用户的能力">控制运行时负载或用户的能力</h2>
<p>Kubernetes 中的授权故意设置为了高层级，它侧重于对资源的粗粒度行为。
更强大的控制是以通过用例限制这些对象如何作用于集群、自身和其他资源上的<strong>策略</strong>存在的。</p>
<!--
### Limiting resource usage on a cluster

[Resource quota](/docs/concepts/policy/resource-quotas/) limits the number or capacity of
resources granted to a namespace. This is most often used to limit the amount of CPU, memory,
or persistent disk a namespace can allocate, but can also control how many pods, services, or
volumes exist in each namespace.

[Limit ranges](/docs/tasks/administer-cluster/memory-default-namespace/) restrict the maximum or minimum size of some of the
resources above, to prevent users from requesting unreasonably high or low values for commonly
reserved resources like memory, or to provide default limits when none are specified.
-->
<h3 id="限制集群上的资源使用">限制集群上的资源使用</h3>
<p><a href="/zh/docs/concepts/policy/resource-quotas/">资源配额</a>
限制了授予命名空间的资源的数量或容量。
这通常用于限制命名空间可以分配的 CPU、内存或持久磁盘的数量，但也可以控制
每个命名空间中有多少个 Pod、服务或卷的存在。</p>
<p><a href="/zh/docs/tasks/administer-cluster/manage-resources/memory-default-namespace/">限制范围</a>限制
上述某些资源的最大值或者最小值，以防止用户使用类似内存这样的通用保留资源时请求
不合理的过高或过低的值，或者在没有指定的情况下提供默认限制。</p>
<!--
### Controlling what privileges containers run with

A pod definition contains a [security context](/docs/tasks/configure-pod-container/security-context/)
that allows it to request access to running as a specific Linux user on a node (like root),
access to run privileged or access the host network, and other controls that would otherwise
allow it to run unfettered on a hosting node. [Pod security policies](/docs/concepts/policy/pod-security-policy/)
can limit which users or service accounts can provide dangerous security context settings. For example, pod security policies can limit volume mounts, especially `hostPath`, which are aspects of a pod that should be controlled.
-->
<h3 id="控制容器运行的特权">控制容器运行的特权</h3>
<p>Pod 定义包含了一个<a href="/zh/docs/tasks/configure-pod-container/security-context/">安全上下文</a>，
用于描述允许它请求访问某个节点上的特定 Linux 用户（如 root）、获得特权或访问主机网络、
以及允许它在主机节点上不受约束地运行的其它控件。
<a href="/zh/docs/concepts/policy/pod-security-policy/">Pod 安全策略</a>
可以限制哪些用户或服务帐户可以提供危险的安全上下文设置。
例如，Pod 的安全策略可以限制卷挂载，尤其是 <code>hostpath</code>，这些都是 Pod 应该控制的一些方面。</p>
<!--
Generally, most application workloads need limited access to host resources so they can
successfully run as a root process (uid 0) without access to host information. However,
considering the privileges associated with the root user, you should write application
containers to run as a non-root user. Similarly, administrators who wish to prevent
client applications from escaping their containers should use a restrictive pod security
policy.
-->
<p>一般来说，大多数应用程序需要限制对主机资源的访问，
他们可以在不能访问主机信息的情况下成功以根进程（UID 0）运行。
但是，考虑到与 root 用户相关的特权，在编写应用程序容器时，你应该使用非 root 用户运行。
类似地，希望阻止客户端应用程序逃避其容器的管理员，应该使用限制性的 pod 安全策略。</p>
<!--
### Restricting network access

The [network policies](/docs/tasks/administer-cluster/declare-network-policy/) for a namespace
allows application authors to restrict which pods in other namespaces may access pods and ports
within their namespaces. Many of the supported [Kubernetes networking providers](/docs/concepts/cluster-administration/networking/)
now respect network policy.
-->
<h3 id="限制网络访问">限制网络访问</h3>
<p>基于命名空间的<a href="/zh/docs/tasks/administer-cluster/declare-network-policy/">网络策略</a>
允许应用程序作者限制其它命名空间中的哪些 Pod 可以访问它们命名空间内的 Pod 和端口。
现在已经有许多支持网络策略的
<a href="/zh/docs/concepts/cluster-administration/networking/">Kubernetes 网络供应商</a>。</p>
<!--
Quota and limit ranges can also be used to control whether users may request node ports or
load balanced services, which on many clusters can control whether those users applications
are visible outside of the cluster.

Additional protections may be available that control network rules on a per plugin or per
environment basis, such as per-node firewalls, physically separating cluster nodes to
prevent cross talk, or advanced networking policy.
-->
<p>对于可以控制用户的应用程序是否在集群之外可见的许多集群，配额和限制范围也可用于
控制用户是否可以请求节点端口或负载均衡服务。</p>
<p>在插件或者环境基础上控制网络规则可以增加额外的保护措施，比如节点防火墙、物理分离
群集节点以防止串扰、或者高级的网络策略。</p>
<!--
### Restricting cloud metadata API access

Cloud platforms (AWS, Azure, GCE, etc.) often expose metadata services locally to instances.
By default these APIs are accessible by pods running on an instance and can contain cloud
credentials for that node, or provisioning data such as kubelet credentials. These credentials
can be used to escalate within the cluster or to other cloud services under the same account.

When running Kubernetes on a cloud platform limit permissions given to instance credentials, use
[network policies](/docs/tasks/administer-cluster/declare-network-policy/) to restrict pod access
to the metadata API, and avoid using provisioning data to deliver secrets.
-->
<h3 id="限制云-metadata-api-访问">限制云 metadata API 访问</h3>
<p>云平台（AWS,  Azure, GCE 等）经常讲 metadate 本地服务暴露给实例。
默认情况下，这些 API 可由运行在实例上的 Pod 访问，并且可以包含
该云节点的凭据或配置数据（如 kubelet 凭据）。
这些凭据可以用于在集群内升级或在同一账户下升级到其他云服务。</p>
<p>在云平台上运行 Kubernetes 时，限制对实例凭据的权限，使用
<a href="/zh/docs/tasks/administer-cluster/declare-network-policy/">网络策略</a>
限制对 metadata API 的 pod 访问，并避免使用配置数据来传递机密。</p>
<!--
### Controlling which nodes pods may access

By default, there are no restrictions on which nodes may run a pod.  Kubernetes offers a
[rich set of policies for controlling placement of pods onto nodes](/docs/concepts/configuration/assign-pod-node/)
and the [taint based pod placement and eviction](/docs/concepts/configuration/taint-and-toleration/)
that are available to end users. For many clusters use of these policies to separate workloads
can be a convention that authors adopt or enforce via tooling.

As an administrator, a beta admission plugin `PodNodeSelector` can be used to force pods
within a namespace to default or require a specific node selector, and if end users cannot
alter namespaces, this can strongly limit the placement of all of the pods in a specific workload.
-->
<h3 id="控制-pod-可以访问哪些节点">控制 Pod 可以访问哪些节点</h3>
<p>默认情况下，对哪些节点可以运行 pod 没有任何限制。
Kubernetes 给最终用户提供了
<a href="/zh/docs/concepts/scheduling-eviction/assign-pod-node/">一组丰富的策略用于控制 pod 放在节点上的位置</a>，
以及<a href="/zh/docs/concepts/scheduling-eviction/taint-and-toleration/">基于污点的 Pod 放置和驱逐</a>。
对于许多集群，可以约定由作者采用或者强制通过工具使用这些策略来分离工作负载。</p>
<p>对于管理员，Beta 阶段的准入插件 <code>PodNodeSelector</code> 可用于强制命名空间中的 Pod
使用默认或需要使用特定的节点选择器。
如果最终用户无法改变命名空间，这可以强烈地限制所有的 pod 在特定工作负载的位置。</p>
<!--
## Protecting cluster components from compromise

This section describes some common patterns for protecting clusters from compromise.
-->
<h2 id="保护集群组件免受破坏">保护集群组件免受破坏</h2>
<p>本节描述保护集群免受破坏的一些常见模式。</p>
<!--
### Restrict access to etcd

Write access to the etcd backend for the API is equivalent to gaining root on the entire cluster,
and read access can be used to escalate fairly quickly. Administrators should always use strong
credentials from the API servers to their etcd server, such as mutual auth via TLS client certificates,
and it is often recommended to isolate the etcd servers behind a firewall that only the API servers
may access.

<blockquote class="caution callout">
  <div><strong>注意：</strong> Allowing other components within the cluster to access the master etcd instance with
read or write access to the full keyspace is equivalent to granting cluster-admin access. Using
separate etcd instances for non-master components or using etcd ACLs to restrict read and write
access to a subset of the keyspace is strongly recommended.</div>
</blockquote>

-->
<h3 id="限制访问-etcd">限制访问 etcd</h3>
<p>对于 API 来说，拥有 etcd 后端的写访问权限，相当于获得了整个集群的 root 权限，
并且可以使用写访问权限来相当快速地升级。
从 API 服务器访问它们的 etcd 服务器，管理员应该使用广受信任的凭证，
如通过 TLS 客户端证书的相互认证。
通常，我们建议将 etcd 服务器隔离到只有API服务器可以访问的防火墙后面。</p>
<blockquote class="caution callout">
  <div><strong>注意：</strong> 允许集群中其它组件拥有读或写全空间的权限去访问 etcd 实例，相当于授予群集管理员访问的权限。
对于非主控组件，强烈推荐使用单独的 etcd 实例，或者使用 etcd 的访问控制列表
去限制只能读或者写空间的一个子集。</div>
</blockquote>

<!--
### Enable audit logging

The [audit logger](/docs/tasks/debug-application-cluster/audit/) is a beta feature that records actions taken by the
API for later analysis in the event of a compromise. It is recommended to enable audit logging
and archive the audit file on a secure server.
-->
<h3 id="开启审计日志">开启审计日志</h3>
<p><a href="/zh/docs/tasks/debug-application-cluster/audit/">审计日志</a>是 Beta 特性，
负责记录 API 操作以便在发生破坏时进行事后分析。
建议启用审计日志，并将审计文件归档到安全服务器上。</p>
<!--
### Restrict access to alpha or beta features

Alpha and beta Kubernetes features are in active development and may have limitations or bugs
that result in security vulnerabilities. Always assess the value an alpha or beta feature may
provide against the possible risk to your security posture. When in doubt, disable features you
do not use.
-->
<h3 id="限制使用-alpha-和-beta-特性">限制使用 alpha 和 beta 特性</h3>
<p>Kubernetes 的 alpha 和 beta 特性还在努力开发中，可能存在导致安全漏洞的缺陷或错误。
要始终评估 alpha 和 beta 特性可能为你的安全态势带来的风险。
当你怀疑存在风险时，可以禁用那些不需要使用的特性。</p>
<!--
### Rotate infrastructure credentials frequently

The shorter the lifetime of a secret or credential the harder it is for an attacker to make
use of that credential. Set short lifetimes on certificates and automate their rotation. Use
an authentication provider that can control how long issued tokens are available and use short
lifetimes where possible. If you use service account tokens in external integrations, plan to
rotate those tokens frequently. For example, once the bootstrap phase is complete, a bootstrap token used for setting up nodes should be revoked or its authorization removed.
-->
<h3 id="频繁回收基础设施证书">频繁回收基础设施证书</h3>
<p>一个 Secret 或凭据的寿命越短，攻击者就越难使用该凭据。
在证书上设置短生命周期并实现自动回收，是控制安全的一个好方法。
因此，使用身份验证提供程序时，应该要求可以控制发布令牌的可用时间，并尽可能使用短寿命。
如果在外部集成中使用服务帐户令牌，则应该频繁地回收这些令牌。
例如，一旦引导阶段完成，就应该撤销用于设置节点的引导令牌，或者取消它的授权。</p>
<!--
### Review third party integrations before enabling them

Many third party integrations to Kubernetes may alter the security profile of your cluster. When
enabling an integration, always review the permissions that an extension requests before granting
it access. For example, many security integrations may request access to view all secrets on
your cluster which is effectively making that component a cluster admin. When in doubt,
restrict the integration to functioning in a single namespace if possible.

Components that create pods may also be unexpectedly powerful if they can do so inside namespaces
like the `kube-system` namespace, because those pods can gain access to service account secrets
or run with elevated permissions if those service accounts are granted access to permissive
[pod security policies](/docs/concepts/policy/pod-security-policy/).
-->
<h3 id="在启用第三方集成之前-请先审查它们">在启用第三方集成之前，请先审查它们</h3>
<p>许多集成到 Kubernetes 的第三方都可以改变你集群的安全配置。
启用集成时，在授予访问权限之前，你应该始终检查扩展所请求的权限。
例如，许多安全集成可以请求访问来查看集群上的所有 Secret，
从而有效地使该组件成为集群管理。
当有疑问时，如果可能的话，将集成限制在单个命名空间中运行。</p>
<p>如果组件创建的 Pod 能够在命名空间中做一些类似 <code>kube-system</code> 命名空间中的事情，
那么它也可能是出乎意料的强大。
因为这些 Pod 可以访问服务账户的 Secret，或者，如果这些服务帐户被授予访问许可的
<a href="/zh/docs/concepts/policy/pod-security-policy/">Pod 安全策略</a>的权限，它们能以高权限运行。</p>
<!--
### Encrypt secrets at rest

In general, the etcd database will contain any information accessible via the Kubernetes API
and may grant an attacker significant visibility into the state of your cluster. Always encrypt
your backups using a well reviewed backup and encryption solution, and consider using full disk
encryption where possible.

Kubernetes 1.7 contains [encryption at rest](/docs/tasks/administer-cluster/encrypt-data/), an alpha feature that will encrypt `Secret` resources in etcd, preventing
parties that gain access to your etcd backups from viewing the content of those secrets. While
this feature is currently experimental, it may offer an additional level of defense when backups
are not encrypted or an attacker gains read access to etcd.
-->
<h3 id="对-secret-进行静态加密">对 Secret 进行静态加密</h3>
<p>一般情况下，etcd 数据库包含了通过 Kubernetes API 可以访问到的所有信息，
并且可以授予攻击者对集群状态的可见性。
始终使用经过良好审查的备份和加密解决方案来加密备份，并考虑在可能的情况下使用全磁盘加密。</p>
<p>Kubernetes 1.7 包含了<a href="/zh/docs/tasks/administer-cluster/encrypt-data/">静态数据加密</a>，
它是一个 alpha 特性，会加密 etcd 里面的 <code>Secret</code> 资源，以防止某一方通过查看
etcd 的备份文件查看到这些 Secret 的内容。虽然目前这还只是实验性的功能，
但是在备份没有加密或者攻击者获取到 etcd 的读访问权限的时候，它能提供额外的防御层级。</p>
<!--
### Receiving alerts for security updates and reporting vulnerabilities

Join the [kubernetes-announce](https://groups.google.com/forum/#!forum/kubernetes-announce)
group for emails about security announcements. See the [security reporting](/security/)
page for more on how to report vulnerabilities.
-->
<h3 id="接收安全更新和报告漏洞的警报">接收安全更新和报告漏洞的警报</h3>
<p>加入 <a href="https://groups.google.com/forum/#!forum/kubernetes-announce">kubernetes-announce</a>
组，能够获取有关安全公告的邮件。有关如何报告漏洞的更多信息，请参见
<a href="/zh/docs/reference/issues-security/security/">安全报告</a>页面。</p>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-4a02bcca41439e16655f43fa37c81da4">15 - 关键插件 Pod 的调度保证</h1>
    
	<!-- overview -->
<!-- 
In addition to Kubernetes core components like api-server, scheduler, controller-manager running on a master machine
there are a number of add-ons which, for various reasons, must run on a regular cluster node (rather than the Kubernetes master).
Some of these add-ons are critical to a fully functional cluster, such as metrics-server, DNS, and UI.
A cluster may stop working properly if a critical add-on is evicted (either manually or as a side effect of another operation like upgrade)
and becomes pending (for example when the cluster is highly utilized and either there are other pending pods that schedule into the space
vacated by the evicted critical add-on pod or the amount of resources available on the node changed for some other reason).
-->
<p>除了在主机上运行的 Kubernetes 核心组件（如 api-server 、scheduler 、controller-manager）之外，还有许多插件，由于各种原因，
必须在常规集群节点（而不是 Kubernetes 主节点）上运行。
其中一些插件对于功能完备的群集至关重要，例如 Heapster、DNS 和 UI。
如果关键插件被逐出（手动或作为升级等其他操作的副作用）或者变成挂起状态，群集可能会停止正常工作。
关键插件进入挂起状态的例子有：集群利用率过高；被逐出的关键插件 Pod 释放了空间，但该空间被之前悬决的 Pod 占用；由于其它原因导致节点上可用资源的总量发生变化。</p>
<!-- body -->
<!--
### Marking pod as critical
-->
<h3 id="标记关键-pod">标记关键 Pod</h3>
<!--
To be considered critical, the pod has to run in the `kube-system` namespace (configurable via flag) and
* Have the priorityClassName set as "system-cluster-critical" or "system-node-critical", the latter being the highest for entire cluster. Alternatively, you could add an annotation `scheduler.alpha.kubernetes.io/critical-pod` as key and empty string as value to your pod, but this annotation is deprecated as of version 1.13 and will be removed in 1.14.
-->
<p>要将 pod 标记为关键性（critical），pod 必须在 kube-system 命名空间中运行（可通过参数配置）。
同时，需要将 <code>priorityClassName</code> 设置为 <code>system-cluster-critical</code> 或 <code>system-node-critical</code> ，后者是整个群集的最高级别。
或者，也可以为 Pod 添加名为 <code>scheduler.alpha.kubernetes.io/critical-pod</code>、值为空字符串的注解。
不过，这一注解从 1.13 版本开始不再推荐使用，并将在 1.14 中删除。</p>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-fe6b50655c29ab0b7c1ee549ff64c138">16 - 升级集群</h1>
    
	<!-- 
---
title: Upgrade A Cluster
content_type: task
---
-->
<!-- overview -->
<!-- 
This page provides an overview of the steps you should follow to upgrade a
Kubernetes cluster.

The way that you upgrade a cluster depends on how you initially deployed it
and on any subsequent changes.

At a high level, the steps you perform are:
-->
<p>本页概述升级 Kubernetes 集群的步骤。</p>
<p>升级集群的方式取决于你最初部署它的方式、以及后续更改它的方式。</p>
<p>从高层规划的角度看，要执行的步骤是：</p>
<!-- 
- Upgrade the <a class='glossary-tooltip' title='控制平面是指容器编排层，它暴露 API 和接口来定义、部署容器和管理容器的生命周期。' data-toggle='tooltip' data-placement='top' href='/zh/docs/reference/glossary/?all=true#term-control-plane' target='_blank' aria-label='control plane'>control plane</a>
- Upgrade the nodes in your cluster
- Upgrade clients such as <a class='glossary-tooltip' title='kubectl 是用来和 Kubernetes API 服务器进行通信的命令行工具。' data-toggle='tooltip' data-placement='top' href='/docs/user-guide/kubectl-overview/' target='_blank' aria-label='kubectl'>kubectl</a>
- Adjust manifests and other resources based on the API changes that accompany the
  new Kubernetes version
-->
<ul>
<li>升级<a class='glossary-tooltip' title='控制平面是指容器编排层，它暴露 API 和接口来定义、部署容器和管理容器的生命周期。' data-toggle='tooltip' data-placement='top' href='/zh/docs/reference/glossary/?all=true#term-control-plane' target='_blank' aria-label='控制平面'>控制平面</a></li>
<li>升级集群中的节点</li>
<li>升级 <a class='glossary-tooltip' title='kubectl 是用来和 Kubernetes API 服务器进行通信的命令行工具。' data-toggle='tooltip' data-placement='top' href='/docs/user-guide/kubectl-overview/' target='_blank' aria-label='kubectl'>kubectl</a> 之类的客户端</li>
<li>根据新 Kubernetes 版本带来的 API 变化，调整清单文件和其他资源</li>
</ul>
<h2 id="准备开始">准备开始</h2>
<!-- 
You must have an existing cluster. This page is about upgrading from Kubernetes
1.21 to Kubernetes 1.22. If your cluster
is not currently running Kubernetes 1.21 then please check
the documentation for the version of Kubernetes that you plan to upgrade to.
-->
<p>你必须有一个集群。
本页内容涉及从 Kubernetes 1.21
升级到 Kubernetes 1.22。
如果你的集群未运行 Kubernetes 1.21，
那请参考目标 Kubernetes 版本的文档。</p>
<!-- ## Upgrade approaches -->
<h2 id="upgrade-approaches">升级方法</h2>
<h3 id="upgrade-kubeadm">kubeadm</h3>
<!-- 
If your cluster was deployed using the `kubeadm` tool, refer to 
[Upgrading kubeadm clusters](/docs/tasks/administer-cluster/kubeadm/kubeadm-upgrade/)
for detailed information on how to upgrade the cluster.

Once you have upgraded the cluster, remember to
[install the latest version of `kubectl`](/docs/tasks/tools/).
-->
<p>如果你的集群是使用 <code>kubeadm</code> 安装工具部署而来，
那么升级群集的详细信息，请参阅
<a href="/zh/docs/tasks/administer-cluster/kubeadm/kubeadm-upgrade/">升级 kubeadm 集群</a>。</p>
<p>升级集群之后，要记得
<a href="/zh/docs/tasks/tools/">安装最新版本的 <code>kubectl</code></a>.</p>
<!-- ### Manual deployments -->
<h3 id="manual-deployments">手动部署</h3>
<!-- 
These steps do not account for third-party extensions such as network and storage
plugins.

You should manually update the control plane following this sequence:
-->
<blockquote class="caution callout">
  <div><strong>注意：</strong> 这些步骤不考虑第三方扩展，例如网络和存储插件。</div>
</blockquote>

<p>你应该跟随下面操作顺序，手动更新控制平面：</p>
<!-- 
- etcd (all instances)
- kube-apiserver (all control plane hosts)
- kube-controller-manager
- kube-scheduler
- cloud controller manager, if you use one
-->
<ul>
<li>etcd (所有实例)</li>
<li>kube-apiserver (所有控制平面的宿主机)</li>
<li>kube-controller-manager</li>
<li>kube-scheduler</li>
<li>cloud controller manager, 在你用到时</li>
</ul>
<!-- 
At this point you should
[install the latest version of `kubectl`](/docs/tasks/tools/).

For each node in your cluster, [drain](/docs/tasks/administer-cluster/safely-drain-node/)
that node and then either replace it with a new node that uses the 1.22
kubelet, or upgrade the 1.22
kubelet on that node and bring the node back into service.
-->
<p>现在，你应该
<a href="/zh/docs/tasks/tools/">安装最新版本的 <code>kubectl</code></a>.</p>
<p>对于群集中的每个节点，
<a href="/zh/docs/tasks/administer-cluster/safely-drain-node/">排空</a>
节点，然后，或者用一个运行了 1.22 kubelet 的新节点替换它；
或者升级此节点的 kubelet，并使节点恢复服务。</p>
<!-- 
### Other deployments {#upgrade-other}

Refer to the documentation for your cluster deployment tool to learn the recommended set
up steps for maintenance.

## Post-upgrade tasks

### Switch your cluster's storage API version
-->
<h3 id="upgrade-other">其他部署方式</h3>
<p>参阅你的集群部署工具对应的文档，了解用于维护的推荐设置步骤。</p>
<h2 id="post-upgrade-tasks">升级后的任务</h2>
<h3 id="switch-your-clusters-storage-api-version">切换群集的存储 API 版本</h3>
<!-- 
The objects that are serialized into etcd for a cluster's internal
representation of the Kubernetes resources active in the cluster are
written using a particular version of the API.

When the supported API changes, these objects may need to be rewritten
in the newer API. Failure to do this will eventually result in resources
that are no longer decodable or usable by the Kubernetes API server.

For each affected object, fetch it using the latest supported API and then
write it back also using the latest supported API.
-->
<p>对象序列化到 etcd，是为了提供集群中活动 Kubernetes 资源的内部表示法，
这些对象都使用特定版本的 API 编写。</p>
<p>当底层的 API 更改时，这些对象可能需要用新 API 重写。
如果不能做到这一点，会导致再也不能用 Kubernetes API 服务器解码、使用该对象。</p>
<p>对于每个受影响的对象，用最新支持的 API 获取它，然后再用最新支持的 API 写回来。</p>
<!-- 
### Update manifests

Upgrading to a new Kubernetes version can provide new APIs.

You can use `kubectl convert` command to convert manifests between different API versions.
For example:
-->
<h3 id="update-manifests">更新清单</h3>
<p>升级到新版本 Kubernetes 就可以提供新的 API。</p>
<p>你可以使用 <code>kubectl convert</code> 命令在不同 API 版本之间转换清单。
例如：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl convert -f pod.yaml --output-version v1
</code></pre></div><!-- 
The `kubectl` tool replaces the contents of `pod.yaml` with a manifest that sets `kind` to
Pod (unchanged), but with a revised `apiVersion`.
-->
<p><code>kubectl</code> 替换了 <code>pod.yaml</code> 的内容，
在新的清单文件中，<code>kind</code> 被设置为 Pod（未变），
但 <code>apiVersion</code> 则被修订了。</p>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-56de8c25b1486599777034111645b803">17 - 名字空间演练</h1>
    
	<!--
reviewers:
- derekwaynecarr
- janetkuo
title: Namespaces Walkthrough
content_type: task
-->
<!-- overview -->
<!--
Kubernetes <a class='glossary-tooltip' title='名字空间是 Kubernetes 为了在同一物理集群上支持多个虚拟集群而使用的一种抽象。' data-toggle='tooltip' data-placement='top' href='/zh/docs/concepts/overview/working-with-objects/namespaces/' target='_blank' aria-label='namespaces'>namespaces</a>
help different projects, teams, or customers to share a Kubernetes cluster.
-->
<p>Kubernetes <a class='glossary-tooltip' title='名字空间是 Kubernetes 为了在同一物理集群上支持多个虚拟集群而使用的一种抽象。' data-toggle='tooltip' data-placement='top' href='/zh/docs/concepts/overview/working-with-objects/namespaces/' target='_blank' aria-label='名字空间'>名字空间</a>
有助于不同的项目、团队或客户去共享 Kubernetes 集群。</p>
<!--
It does this by providing the following:

1. A scope for [Names](/docs/concepts/overview/working-with-objects/names/).
2. A mechanism to attach authorization and policy to a subsection of the cluster.
-->
<p>名字空间通过以下方式实现这点：</p>
<ol>
<li>为<a href="/zh/docs/concepts/overview/working-with-objects/names/">名字</a>设置作用域.</li>
<li>为集群中的部分资源关联鉴权和策略的机制。</li>
</ol>
<!--
Use of multiple namespaces is optional.

This example demonstrates how to use Kubernetes namespaces to subdivide your cluster.
-->
<p>使用多个名字空间是可选的。</p>
<p>此示例演示了如何使用 Kubernetes 名字空间细分群集。</p>
<h2 id="准备开始">准备开始</h2>
<p><p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
如果你还没有集群，你可以通过 <a href="/zh/docs/tasks/tools/#minikube">Minikube</a> 构建一
个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p>
<!--
You need to have a Kubernetes cluster, and the kubectl command-line tool must
be configured to communicate with your cluster. If you do not already have a
cluster, you can create one by using
[minikube](/docs/tasks/tools/#minikube)
or you can use one of these Kubernetes playgrounds:
-->
<ul>
<li><a href="https://www.katacoda.com/courses/kubernetes/playground">Katacoda</a></li>
<li><a href="http://labs.play-with-k8s.com/">玩转 Kubernetes</a></li>
</ul>
 
 要获知版本信息，请输入 <code>kubectl version</code>.
</p>
<!-- steps -->
<!--
## Prerequisites

This example assumes the following:

1. You have an [existing Kubernetes cluster](/docs/setup/).
2. You have a basic understanding of Kubernetes _[Pods](/docs/concepts/workloads/pods/pod/)_, _[Services](/docs/concepts/services-networking/service/)_, and _[Deployments](/docs/concepts/workloads/controllers/deployment/)_.
-->
<h2 id="环境准备">环境准备</h2>
<p>此示例作如下假设：</p>
<ol>
<li>你已拥有一个<a href="/zh/docs/setup/">配置好的 Kubernetes 集群</a>。</li>
<li>你已对 Kubernetes 的 <em><a href="/zh/docs/concepts/workloads/pods/">Pods</a></em>、
<em><a href="/zh/docs/concepts/services-networking/service/">Services</a></em> 和
<em><a href="/zh/docs/concepts/workloads/controllers/deployment/">Deployments</a></em>
有基本理解。</li>
</ol>
<!--
## Understand the default namespace

By default, a Kubernetes cluster will instantiate a default namespace when provisioning the cluster to hold the default set of Pods,
Services, and Deployments used by the cluster.
-->
<ol>
<li>理解默认名字空间</li>
</ol>
<p>默认情况下，Kubernetes 集群会在配置集群时实例化一个默认名字空间，用以存放集群所使用的默认
Pod、Service 和 Deployment 集合。</p>
<!--
Assuming you have a fresh cluster, you can inspect the available namespaces by doing the following:
-->
<p>假设你有一个新的集群，你可以通过执行以下操作来检查可用的名字空间：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl get namespaces
</code></pre></div><pre tabindex="0"><code>NAME      STATUS    AGE
default   Active    13m
</code></pre><!--
## Create new namespaces

For this exercise, we will create two additional Kubernetes namespaces to hold our content.
-->
<h2 id="创建新的名字空间">创建新的名字空间</h2>
<p>在本练习中，我们将创建两个额外的 Kubernetes 名字空间来保存我们的内容。</p>
<!--
Let's imagine a scenario where an organization is using a shared Kubernetes cluster for development and production use cases.
-->
<p>我们假设一个场景，某组织正在使用共享的 Kubernetes 集群来支持开发和生产：</p>
<!--
The development team would like to maintain a space in the cluster where they can get a view on the list of Pods, Services, and Deployments
they use to build and run their application.  In this space, Kubernetes resources come and go, and the restrictions on who can or cannot modify resources
are relaxed to enable agile development.
-->
<p>开发团队希望在集群中维护一个空间，以便他们可以查看用于构建和运行其应用程序的 Pod、Service
和 Deployment 列表。在这个空间里，Kubernetes 资源被自由地加入或移除，
对谁能够或不能修改资源的限制被放宽，以实现敏捷开发。</p>
<!--
The operations team would like to maintain a space in the cluster where they can enforce strict procedures on who can or cannot manipulate the set of
Pods, Services, and Deployments that run the production site.
-->
<p>运维团队希望在集群中维护一个空间，以便他们可以强制实施一些严格的规程，
对谁可以或谁不可以操作运行生产站点的 Pod、Service 和 Deployment 集合进行控制。</p>
<!--
One pattern this organization could follow is to partition the Kubernetes cluster into two namespaces: `development` and `production`.
-->
<p>该组织可以遵循的一种模式是将 Kubernetes 集群划分为两个名字空间：<code>development</code> 和 <code>production</code>。</p>
<!--
Let's create two new namespaces to hold our work.
-->
<p>让我们创建两个新的名字空间来保存我们的工作。</p>
<!--
Use the file [`namespace-dev.json`](/examples/admin/namespace-dev.json) which describes a `development` namespace:
-->
<p>文件 <a href="/examples/admin/namespace-dev.json"><code>namespace-dev.json</code></a> 描述了 <code>development</code> 名字空间:</p>


 













<div class="highlight">
    <div class="copy-code-icon" style="text-align:right">
    <a href="https://raw.githubusercontent.com/kubernetes/website/main/content/zh/examples/admin/namespace-dev.json" download="admin/namespace-dev.json"><code>admin/namespace-dev.json</code>
    </a>
    <img src="/images/copycode.svg" style="max-height:24px; cursor: pointer" onclick="copyCode('admin-namespace-dev-json')" title="Copy admin/namespace-dev.json to clipboard">
    </img>
    </div>
    <div class="includecode" id="admin-namespace-dev-json">
    <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-json" data-lang="json">{
  <span style="color:#008000;font-weight:bold">&#34;apiVersion&#34;</span>: <span style="color:#b44">&#34;v1&#34;</span>,
  <span style="color:#008000;font-weight:bold">&#34;kind&#34;</span>: <span style="color:#b44">&#34;Namespace&#34;</span>,
  <span style="color:#008000;font-weight:bold">&#34;metadata&#34;</span>: {
    <span style="color:#008000;font-weight:bold">&#34;name&#34;</span>: <span style="color:#b44">&#34;development&#34;</span>,
    <span style="color:#008000;font-weight:bold">&#34;labels&#34;</span>: {
      <span style="color:#008000;font-weight:bold">&#34;name&#34;</span>: <span style="color:#b44">&#34;development&#34;</span>
    }
  }
}
</code></pre></div>
    </div>
</div>


<!--
Create the `development` namespace using kubectl.
-->
<p>使用 kubectl 创建 <code>development</code> 名字空间。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl create -f https://k8s.io/examples/admin/namespace-dev.json
</code></pre></div><!--
Save the following contents into file [`namespace-prod.json`](/examples/admin/namespace-prod.json) which describes a `production` namespace:
-->
<p>将下列的内容保存到文件 <a href="/examples/admin/namespace-prod.json"><code>namespace-prod.json</code></a> 中，
这些内容是对 <code>production</code> 名字空间的描述：</p>


 













<div class="highlight">
    <div class="copy-code-icon" style="text-align:right">
    <a href="https://raw.githubusercontent.com/kubernetes/website/main/content/zh/examples/admin/namespace-prod.json" download="admin/namespace-prod.json"><code>admin/namespace-prod.json</code>
    </a>
    <img src="/images/copycode.svg" style="max-height:24px; cursor: pointer" onclick="copyCode('admin-namespace-prod-json')" title="Copy admin/namespace-prod.json to clipboard">
    </img>
    </div>
    <div class="includecode" id="admin-namespace-prod-json">
    <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-json" data-lang="json">{
  <span style="color:#008000;font-weight:bold">&#34;apiVersion&#34;</span>: <span style="color:#b44">&#34;v1&#34;</span>,
  <span style="color:#008000;font-weight:bold">&#34;kind&#34;</span>: <span style="color:#b44">&#34;Namespace&#34;</span>,
  <span style="color:#008000;font-weight:bold">&#34;metadata&#34;</span>: {
    <span style="color:#008000;font-weight:bold">&#34;name&#34;</span>: <span style="color:#b44">&#34;production&#34;</span>,
    <span style="color:#008000;font-weight:bold">&#34;labels&#34;</span>: {
      <span style="color:#008000;font-weight:bold">&#34;name&#34;</span>: <span style="color:#b44">&#34;production&#34;</span>
    }
  }
}
</code></pre></div>
    </div>
</div>


<!--
And then let's create the `production` namespace using kubectl.
-->
<p>让我们使用 kubectl 创建 <code>production</code> 名字空间。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl create -f https://k8s.io/examples/admin/namespace-prod.json
</code></pre></div><!--
To be sure things are right, let's list all of the namespaces in our cluster.
-->
<p>为了确保一切正常，我们列出集群中的所有名字空间。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl get namespaces --show-labels
</code></pre></div><pre tabindex="0"><code>NAME          STATUS    AGE       LABELS
default       Active    32m       &lt;none&gt;
development   Active    29s       name=development
production    Active    23s       name=production
</code></pre><!--
## Create pods in each namespace

A Kubernetes namespace provides the scope for Pods, Services, and Deployments in the cluster.

Users interacting with one namespace do not see the content in another namespace.

To demonstrate this, let's spin up a simple Deployment and Pods in the `development` namespace.
-->
<h2 id="在每个名字空间中创建-pod">在每个名字空间中创建 pod</h2>
<p>Kubernetes 名字空间为集群中的 Pod、Service 和 Deployment 提供了作用域。</p>
<p>与一个名字空间交互的用户不会看到另一个名字空间中的内容。</p>
<p>为了演示这一点，让我们在 development 名字空间中启动一个简单的 Deployment 和 Pod。</p>
<!--
We first check what is the current context:
-->
<p>我们首先检查一下当前的上下文：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl config view
</code></pre></div><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">clusters</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">cluster</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">certificate-authority-data</span>:<span style="color:#bbb"> </span>REDACTED<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">server</span>:<span style="color:#bbb"> </span>https://130.211.122.180<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>lithe-cocoa-92103_kubernetes<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">contexts</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">context</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">cluster</span>:<span style="color:#bbb"> </span>lithe-cocoa-92103_kubernetes<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">user</span>:<span style="color:#bbb"> </span>lithe-cocoa-92103_kubernetes<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>lithe-cocoa-92103_kubernetes<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">current-context</span>:<span style="color:#bbb"> </span>lithe-cocoa-92103_kubernetes<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>Config<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">preferences</span>:<span style="color:#bbb"> </span>{}<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">users</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>lithe-cocoa-92103_kubernetes<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">user</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">client-certificate-data</span>:<span style="color:#bbb"> </span>REDACTED<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">client-key-data</span>:<span style="color:#bbb"> </span>REDACTED<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">token</span>:<span style="color:#bbb"> </span>65rZW78y8HbwXXtSXuUw9DbP4FLjHi4b<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>lithe-cocoa-92103_kubernetes-basic-auth<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">user</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">password</span>:<span style="color:#bbb"> </span>h5M0FtUUIflBSdI7<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">username</span>:<span style="color:#bbb"> </span>admin<span style="color:#bbb">
</span></code></pre></div><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl config current-context
</code></pre></div><pre tabindex="0"><code>lithe-cocoa-92103_kubernetes
</code></pre><!--
The next step is to define a context for the kubectl client to work in each namespace. The value of "cluster" and "user" fields are copied from the current context.
-->
<p>下一步是为 kubectl 客户端定义一个上下文，以便在每个名字空间中工作。
&quot;cluster&quot; 和 &quot;user&quot; 字段的值将从当前上下文中复制。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl config set-context dev --namespace<span style="color:#666">=</span>development <span style="color:#b62;font-weight:bold">\
</span><span style="color:#b62;font-weight:bold"></span>  --cluster<span style="color:#666">=</span>lithe-cocoa-92103_kubernetes <span style="color:#b62;font-weight:bold">\
</span><span style="color:#b62;font-weight:bold"></span>  --user<span style="color:#666">=</span>lithe-cocoa-92103_kubernetes

kubectl config set-context prod --namespace<span style="color:#666">=</span>production <span style="color:#b62;font-weight:bold">\
</span><span style="color:#b62;font-weight:bold"></span>  --cluster<span style="color:#666">=</span>lithe-cocoa-92103_kubernetes <span style="color:#b62;font-weight:bold">\
</span><span style="color:#b62;font-weight:bold"></span>  --user<span style="color:#666">=</span>lithe-cocoa-92103_kubernetes
</code></pre></div><!--
By default, the above commands adds two contexts that are saved into file
`.kube/config`. You can now view the contexts and alternate against the two
new request contexts depending on which namespace you wish to work against.
-->
<p>默认情况下，上述命令会添加两个上下文到 <code>.kube/config</code> 文件中。
你现在可以查看上下文并根据你希望使用的名字空间并在这两个新的请求上下文之间切换。</p>
<!--
To view the new contexts:
-->
<p>查看新的上下文：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl config view
</code></pre></div><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">clusters</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">cluster</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">certificate-authority-data</span>:<span style="color:#bbb"> </span>REDACTED<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">server</span>:<span style="color:#bbb"> </span>https://130.211.122.180<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>lithe-cocoa-92103_kubernetes<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">contexts</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">context</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">cluster</span>:<span style="color:#bbb"> </span>lithe-cocoa-92103_kubernetes<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">user</span>:<span style="color:#bbb"> </span>lithe-cocoa-92103_kubernetes<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>lithe-cocoa-92103_kubernetes<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">context</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">cluster</span>:<span style="color:#bbb"> </span>lithe-cocoa-92103_kubernetes<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">namespace</span>:<span style="color:#bbb"> </span>development<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">user</span>:<span style="color:#bbb"> </span>lithe-cocoa-92103_kubernetes<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>dev<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">context</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">cluster</span>:<span style="color:#bbb"> </span>lithe-cocoa-92103_kubernetes<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">namespace</span>:<span style="color:#bbb"> </span>production<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">user</span>:<span style="color:#bbb"> </span>lithe-cocoa-92103_kubernetes<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>prod<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">current-context</span>:<span style="color:#bbb"> </span>lithe-cocoa-92103_kubernetes<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>Config<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">preferences</span>:<span style="color:#bbb"> </span>{}<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">users</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>lithe-cocoa-92103_kubernetes<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">user</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">client-certificate-data</span>:<span style="color:#bbb"> </span>REDACTED<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">client-key-data</span>:<span style="color:#bbb"> </span>REDACTED<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">token</span>:<span style="color:#bbb"> </span>65rZW78y8HbwXXtSXuUw9DbP4FLjHi4b<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>lithe-cocoa-92103_kubernetes-basic-auth<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">user</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">password</span>:<span style="color:#bbb"> </span>h5M0FtUUIflBSdI7<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">username</span>:<span style="color:#bbb"> </span>admin<span style="color:#bbb">
</span></code></pre></div><!--
Let's switch to operate in the `development` namespace.
-->
<p>让我们切换到 <code>development</code> 名字空间进行操作。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl config use-context dev
</code></pre></div><!--
You can verify your current context by doing the following:
-->
<p>你可以使用下列命令验证当前上下文：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl config current-context
</code></pre></div><pre tabindex="0"><code>dev
</code></pre><!--
At this point, all requests we make to the Kubernetes cluster from the command line are scoped to the `development` namespace.
-->
<p>此时，我们从命令行向 Kubernetes 集群发出的所有请求都限定在 <code>development</code> 名字空间中。</p>
<!--
Let's create some contents.
-->
<p>让我们创建一些内容。</p>


 













<div class="highlight">
    <div class="copy-code-icon" style="text-align:right">
    <a href="https://raw.githubusercontent.com/kubernetes/website/main/content/zh/examples/admin/snowflake-deployment.yaml" download="admin/snowflake-deployment.yaml"><code>admin/snowflake-deployment.yaml</code>
    </a>
    <img src="/images/copycode.svg" style="max-height:24px; cursor: pointer" onclick="copyCode('admin-snowflake-deployment-yaml')" title="Copy admin/snowflake-deployment.yaml to clipboard">
    </img>
    </div>
    <div class="includecode" id="admin-snowflake-deployment-yaml">
    <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>apps/v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>Deployment<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">labels</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">app</span>:<span style="color:#bbb"> </span>snowflake<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>snowflake<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">spec</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">replicas</span>:<span style="color:#bbb"> </span><span style="color:#666">2</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">selector</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">matchLabels</span>:<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">app</span>:<span style="color:#bbb"> </span>snowflake<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">template</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">labels</span>:<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#008000;font-weight:bold">app</span>:<span style="color:#bbb"> </span>snowflake<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">spec</span>:<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">containers</span>:<span style="color:#bbb">
</span><span style="color:#bbb">      </span>- <span style="color:#008000;font-weight:bold">image</span>:<span style="color:#bbb"> </span>k8s.gcr.io/serve_hostname<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#008000;font-weight:bold">imagePullPolicy</span>:<span style="color:#bbb"> </span>Always<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>snowflake<span style="color:#bbb">
</span></code></pre></div>
    </div>
</div>


<!--
Apply the manifest to create a Deployment 
-->
<p>应用清单文件来创建 Deployment。</p>
<!--
We have just created a deployment whose replica size is 2 that is running the pod called `snowflake` with a basic container that just serves the hostname.
-->
<p>我们刚刚创建了一个副本大小为 2 的 Deployment，该 Deployment 运行名为 <code>snowflake</code> 的 Pod，
其中包含一个仅提供主机名服务的基本容器。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl get deployment
</code></pre></div><pre tabindex="0"><code>NAME        DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE
snowflake   2         2         2            2           2m
</code></pre><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl get pods -l <span style="color:#b8860b">app</span><span style="color:#666">=</span>snowflake
</code></pre></div><pre tabindex="0"><code>NAME                         READY     STATUS    RESTARTS   AGE
snowflake-3968820950-9dgr8   1/1       Running   0          2m
snowflake-3968820950-vgc4n   1/1       Running   0          2m
</code></pre><!--
And this is great, developers are able to do what they want, and they do not have to worry about affecting content in the `production` namespace.
-->
<p>这很棒，开发人员可以做他们想要的事情，而不必担心影响 <code>production</code> 名字空间中的内容。</p>
<!--
Let's switch to the `production` namespace and show how resources in one namespace are hidden from the other.
-->
<p>让我们切换到 <code>production</code> 名字空间，展示一个名字空间中的资源如何对另一个名字空间不可见。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl config use-context prod
</code></pre></div><!--
The `production` namespace should be empty, and the following commands should return nothing.
-->
<p><code>production</code> 名字空间应该是空的，下列命令应该返回的内容为空。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl get deployment
kubectl get pods
</code></pre></div><!--
Production likes to run cattle, so let's create some cattle pods.
-->
<p>生产环境需要以放牛的方式运维，让我们创建一些名为 <code>cattle</code> 的 Pod。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl create deployment cattle --image<span style="color:#666">=</span>k8s.gcr.io/serve_hostname --replicas<span style="color:#666">=</span><span style="color:#666">5</span>
kubectl get deployment
</code></pre></div><pre tabindex="0"><code>NAME      DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE
cattle    5         5         5            5           10s
</code></pre><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl get pods -l <span style="color:#b8860b">run</span><span style="color:#666">=</span>cattle
</code></pre></div><pre tabindex="0"><code>NAME                      READY     STATUS    RESTARTS   AGE
cattle-2263376956-41xy6   1/1       Running   0          34s
cattle-2263376956-kw466   1/1       Running   0          34s
cattle-2263376956-n4v97   1/1       Running   0          34s
cattle-2263376956-p5p3i   1/1       Running   0          34s
cattle-2263376956-sxpth   1/1       Running   0          34s
</code></pre><!--
At this point, it should be clear that the resources users create in one namespace are hidden from the other namespace.
-->
<p>此时，应该很清楚的展示了用户在一个名字空间中创建的资源对另一个名字空间是不可见的。</p>
<!--
As the policy support in Kubernetes evolves, we will extend this scenario to show how you can provide different
authorization rules for each namespace.
-->
<p>随着 Kubernetes 中的策略支持的发展，我们将扩展此场景，以展示如何为每个名字空间提供不同的授权规则。</p>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-09cc2cf3e0f23a3996e6cb31dc4d867c">18 - 启用/禁用 Kubernetes API</h1>
    
	<!-- 
---
title: Enable Or Disable A Kubernetes API
content_type: task
---
-->
<!-- overview -->
<!-- 
This page shows how to enable or disable an API version from your cluster's
<a class='glossary-tooltip' title='控制平面是指容器编排层，它暴露 API 和接口来定义、部署容器和管理容器的生命周期。' data-toggle='tooltip' data-placement='top' href='/zh/docs/reference/glossary/?all=true#term-control-plane' target='_blank' aria-label='control plane'>control plane</a>.
-->
<p>本页展示怎么用集群的
<a class='glossary-tooltip' title='控制平面是指容器编排层，它暴露 API 和接口来定义、部署容器和管理容器的生命周期。' data-toggle='tooltip' data-placement='top' href='/zh/docs/reference/glossary/?all=true#term-control-plane' target='_blank' aria-label='控制平面'>控制平面</a>.
启用/禁用 API 版本。</p>
<!-- steps -->
<!-- 
Specific API versions can be turned on or off by passing `--runtime-config=api/<version>` as a
command line argument to the API server. The values for this argument are a comma-separated
list of API versions. Later values override earlier values.

The `runtime-config` command line argument also supports 2 special keys:
-->
<p>通过 API 服务器的命令行参数 <code>--runtime-config=api/&lt;version&gt;</code> ，
可以开启/关闭某个指定的 API 版本。
此参数的值是一个逗号分隔的 API 版本列表。
此列表中，后面的值可以覆盖前面的值。</p>
<p>命令行参数 <code>runtime-config</code> 支持两个特殊的值（keys）：</p>
<!-- 
- `api/all`, representing all known APIs
- `api/legacy`, representing only legacy APIs. Legacy APIs are any APIs that have been
   explicitly [deprecated](/zh/docs/reference/using-api/deprecation-policy/).

For example, to turning off all API versions except v1, pass `--runtime-config=api/all=false,api/v1=true`
to the `kube-apiserver`.
-->
<ul>
<li><code>api/all</code>：指所有已知的 API</li>
<li><code>api/legacy</code>：指过时的 API。过时的 API 就是明确地
<a href="/zh/docs/reference/using-api/deprecation-policy/">弃用</a>
的 API。</li>
</ul>
<p>例如：为了停用除去 v1 版本之外的全部其他 API 版本，
就用参数 <code>--runtime-config=api/all=false,api/v1=true</code> 启动 <code>kube-apiserver</code>。</p>
<h2 id="接下来">接下来</h2>
<!-- 
Read the [full documentation](/docs/reference/command-line-tools-reference/kube-apiserver/)
for the `kube-apiserver` component.
-->
<p>阅读<a href="/zh/docs/reference/command-line-tools-reference/kube-apiserver/">完整的文档</a>,
以了解 <code>kube-apiserver</code> 组件。</p>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-c2f73ef872a65be44f4ab1e6511b8eb9">19 - 启用拓扑感知提示</h1>
    
	<!-- 
---
reviewers:
- robscott
title: Enabling Topology Aware Hints
content_type: task
min-kubernetes-server-version: 1.21
---
-->
<!-- overview -->





<div style="margin-top: 10px; margin-bottom: 10px;">
<b>FEATURE STATE:</b> <code>Kubernetes v1.21 [alpha]</code>
</div>

<!-- 
_Topology Aware Hints_ enable topology aware routing with topology hints
included in <a class='glossary-tooltip' title='一种将网络端点与 Kubernetes 资源组合在一起的方法。' data-toggle='tooltip' data-placement='top' href='/zh/docs/concepts/services-networking/endpoint-slices/' target='_blank' aria-label='EndpointSlices'>EndpointSlices</a>.
This approach tries to keep traffic close to where it originated from;
you might do this to reduce costs, or to improve network performance.
-->
<p><em>拓扑感知提示</em> 启用具有拓扑感知能力的路由，其中拓扑感知信息包含在
<a class='glossary-tooltip' title='一种将网络端点与 Kubernetes 资源组合在一起的方法。' data-toggle='tooltip' data-placement='top' href='/zh/docs/concepts/services-networking/endpoint-slices/' target='_blank' aria-label='EndpointSlices'>EndpointSlices</a> 中。
此功能尽量将流量限制在它的发起区域附近；
可以降低成本，或者提高网络性能。</p>
<h2 id="准备开始">准备开始</h2>
<p><p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
如果你还没有集群，你可以通过 <a href="/zh/docs/tasks/tools/#minikube">Minikube</a> 构建一
个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p>
<!--
You need to have a Kubernetes cluster, and the kubectl command-line tool must
be configured to communicate with your cluster. If you do not already have a
cluster, you can create one by using
[minikube](/docs/tasks/tools/#minikube)
or you can use one of these Kubernetes playgrounds:
-->
<ul>
<li><a href="https://www.katacoda.com/courses/kubernetes/playground">Katacoda</a></li>
<li><a href="http://labs.play-with-k8s.com/">玩转 Kubernetes</a></li>
</ul>
 

您的 Kubernetes 服务器版本必须不低于版本 1.21.
 要获知版本信息，请输入 <code>kubectl version</code>.
</p>
<!-- 
The following prerequisite is needed in order to enable topology aware hints:

* Configure the <a class='glossary-tooltip' title='kube-proxy 是集群中每个节点上运行的网络代理。' data-toggle='tooltip' data-placement='top' href='/zh/docs/reference/command-line-tools-reference/kube-proxy/' target='_blank' aria-label='kube-proxy'>kube-proxy</a> to run in
  iptables mode or IPVS mode
* Ensure that you have not disabled EndpointSlices
-->
<p>为了启用拓扑感知提示，先要满足以下先决条件：</p>
<ul>
<li>配置 <a class='glossary-tooltip' title='kube-proxy 是集群中每个节点上运行的网络代理。' data-toggle='tooltip' data-placement='top' href='/zh/docs/reference/command-line-tools-reference/kube-proxy/' target='_blank' aria-label='kube-proxy'>kube-proxy</a>
以 iptables 或 IPVS 模式运行</li>
<li>确保未禁用 EndpointSlices</li>
</ul>
<!-- 
## Enable Topology Aware Hints
-->
<h2 id="enable-topology-aware-hints">启动拓扑感知提示</h2>
<!-- 
To enable service topology hints, enable the `TopologyAwareHints` [feature
gate](/docs/reference/command-line-tools-reference/feature-gates/) for the
kube-apiserver, kube-controller-manager, and kube-proxy:
-->
<p>要启用服务拓扑感知，请启用 kube-apiserver、kube-controller-manager、和 kube-proxy 的
<a href="/zh/docs/reference/command-line-tools-reference/feature-gates/">特性门控</a>
<code>TopologyAwareHints</code>。</p>
<pre tabindex="0"><code>--feature-gates=&quot;TopologyAwareHints=true&quot;
</code></pre><h2 id="接下来">接下来</h2>
<!-- 
* Read about [Topology Aware Hints](/docs/concepts/services-networking/topology-aware-hints) for Services
* Read [Connecting Applications with Services](/docs/concepts/services-networking/connect-applications-service/)
-->
<ul>
<li>参阅面向服务的<a href="/zh/docs/concepts/services-networking/topology-aware-hints">拓扑感知提示</a></li>
<li>参阅<a href="/zh/docs/concepts/services-networking/connect-applications-service/">用服务连通应用</a></li>
</ul>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-9ceed97f912df7289ed8872e290cfbad">20 - 在 Kubernetes 集群中使用 NodeLocal DNSCache</h1>
    
	<!--
---
reviewers:
- bowei
- zihongz
title: Using NodeLocal DNSCache in Kubernetes clusters
content_type: task
---
-->
<!-- overview -->





<div style="margin-top: 10px; margin-bottom: 10px;">
<b>FEATURE STATE:</b> <code>Kubernetes v1.18 [stable]</code>
</div>

<!--
This page provides an overview of NodeLocal DNSCache feature in Kubernetes.
-->
<p>本页概述了 Kubernetes 中的 NodeLocal DNSCache 功能。</p>
<h2 id="准备开始">准备开始</h2>
<p><p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
如果你还没有集群，你可以通过 <a href="/zh/docs/tasks/tools/#minikube">Minikube</a> 构建一
个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p>
<!--
You need to have a Kubernetes cluster, and the kubectl command-line tool must
be configured to communicate with your cluster. If you do not already have a
cluster, you can create one by using
[minikube](/docs/tasks/tools/#minikube)
or you can use one of these Kubernetes playgrounds:
-->
<ul>
<li><a href="https://www.katacoda.com/courses/kubernetes/playground">Katacoda</a></li>
<li><a href="http://labs.play-with-k8s.com/">玩转 Kubernetes</a></li>
</ul>
 
 要获知版本信息，请输入 <code>kubectl version</code>.
</p>
 <!-- steps -->
<!--
## Introduction
-->
<h2 id="引言">引言</h2>
<!--
NodeLocal DNSCache improves Cluster DNS performance by running a dns caching agent on cluster nodes as a DaemonSet. In today's architecture, Pods in ClusterFirst DNS mode reach out to a kube-dns serviceIP for DNS queries. This is translated to a kube-dns/CoreDNS endpoint via iptables rules added by kube-proxy. With this new architecture, Pods will reach out to the dns caching agent running on the same node, thereby avoiding iptables DNAT rules and connection tracking. The local caching agent will query kube-dns service for cache misses of cluster hostnames(cluster.local suffix by default).
-->
<p>NodeLocal DNSCache 通过在集群节点上作为 DaemonSet 运行 dns 缓存代理来提高集群 DNS 性能。
在当今的体系结构中，处于 ClusterFirst DNS 模式的 Pod 可以连接到 kube-dns serviceIP 进行 DNS 查询。
通过 kube-proxy 添加的 iptables 规则将其转换为 kube-dns/CoreDNS 端点。
借助这种新架构，Pods 将可以访问在同一节点上运行的 dns 缓存代理，从而避免了 iptables DNAT 规则和连接跟踪。
本地缓存代理将查询 kube-dns 服务以获取集群主机名的缓存缺失（默认为 cluster.local 后缀）。</p>
<!--
## Motivation
-->
<h2 id="动机">动机</h2>
<!--
* With the current DNS architecture, it is possible that Pods with the highest DNS QPS have to reach out to a different node, if there is no local kube-dns/CoreDNS instance.
Having a local cache will help improve the latency in such scenarios.
-->
<ul>
<li>使用当前的 DNS 体系结构，如果没有本地 kube-dns/CoreDNS 实例，则具有最高 DNS QPS 的 Pod 可能必须延伸到另一个节点。
在这种脚本下，拥有本地缓存将有助于改善延迟。</li>
</ul>
<!--
* Skipping iptables DNAT and connection tracking will help reduce [conntrack races](https://github.com/kubernetes/kubernetes/issues/56903) and avoid UDP DNS entries filling up conntrack table.
-->
<ul>
<li>跳过 iptables DNAT 和连接跟踪将有助于减少 <a href="https://github.com/kubernetes/kubernetes/issues/56903">conntrack 竞争</a>并避免 UDP DNS 条目填满 conntrack 表。</li>
</ul>
<!--
* Connections from local caching agent to kube-dns servie can be upgraded to TCP. TCP conntrack entries will be removed on connection close in contrast with UDP entries that have to timeout ([default](https://www.kernel.org/doc/Documentation/networking/nf_conntrack-sysctl.txt) `nf_conntrack_udp_timeout` is 30 seconds)
-->
<ul>
<li>从本地缓存代理到 kube-dns 服务的连接可以升级到 TCP 。
TCP conntrack 条目将在连接关闭时被删除，相反 UDP 条目必须超时(<a href="https://www.kernel.org/doc/Documentation/networking/nf_conntrack-sysctl.txt">默认</a> <code>nf_conntrack_udp_timeout</code> 是 30 秒)</li>
</ul>
<!--
* Upgrading DNS queries from UDP to TCP would reduce tail latency attributed to dropped UDP packets and DNS timeouts usually up to 30s (3 retries + 10s timeout). Since the nodelocal cache listens for UDP DNS queries, applications don't need to be changed.
-->
<ul>
<li>将 DNS 查询从 UDP 升级到 TCP 将减少归因于丢弃的 UDP 数据包和 DNS 超时的尾部等待时间，通常长达 30 秒（3 次重试+ 10 秒超时）。</li>
</ul>
<!--
* Metrics & visibility into dns requests at a node level.
-->
<ul>
<li>在节点级别对 dns 请求的度量和可见性。</li>
</ul>
<!--
* Negative caching can be re-enabled, thereby reducing number of queries to kube-dns service.
-->
<ul>
<li>可以重新启用负缓存，从而减少对 kube-dns 服务的查询数量。</li>
</ul>
<!--
## Architecture Diagram
-->
<h2 id="架构图">架构图</h2>
<!--
This is the path followed by DNS Queries after NodeLocal DNSCache is enabled:
-->
<p>启用 NodeLocal DNSCache 之后，这是 DNS 查询所遵循的路径：</p>
<!--

<figure>
    <img src="/images/docs/nodelocaldns.svg"
         alt="NodeLocal DNSCache flow"/> <figcaption>
            <h4>Nodelocal DNSCache flow</h4><p>This image shows how NodeLocal DNSCache handles DNS queries.</p>
        </figcaption>
</figure>

-->

<figure>
    <img src="/images/docs/nodelocaldns.svg"
         alt="NodeLocal DNSCache 流"/> <figcaption>
            <h4>Nodelocal DNSCache 流</h4><p>此图显示了 NodeLocal DNSCache 如何处理 DNS 查询。</p>
        </figcaption>
</figure>

<!--
## Configuration
-->
<h2 id="配置">配置</h2>
<!--
<blockquote class="note callout">
  <div><strong>说明：</strong> The local listen IP address for NodeLocal DNSCache can be any address that can be guaranteed to not collide with any existing IP in your cluster. It's recommended to use an address with a local scope, per example, from the link-local range 169.254.0.0/16 for IPv4 or from the Unique Local Address range in IPv6 fd00::/8.</div>
</blockquote>
-->
<blockquote class="note callout">
  <div><strong>说明：</strong> NodeLocal DNSCache 的本地侦听 IP 地址可以是任何地址，只要该地址不和你的集群里现有的 IP 地址发生冲突。
推荐使用本地范围内的地址，例如，IPv4 链路本地区段 169.254.0.0/16 内的地址，
或者 IPv6 唯一本地地址区段 fd00::/8 内的地址。</div>
</blockquote>
<!--
This feature can be enabled using the following steps:
-->
<p>可以使用以下步骤启动此功能：</p>
<!--
* Prepare a manifest similar to the sample [`nodelocaldns.yaml`](https://github.com/kubernetes/kubernetes/blob/master/cluster/addons/dns/nodelocaldns/nodelocaldns.yaml) and save it as `nodelocaldns.yaml.`
-->
<ul>
<li>根据示例 <a href="https://github.com/kubernetes/kubernetes/blob/master/cluster/addons/dns/nodelocaldns/nodelocaldns.yaml"><code>nodelocaldns.yaml</code></a>
准备一个清单，把它保存为 <code>nodelocaldns.yaml</code>。</li>
</ul>
<!--
* If using IPv6, the CoreDNS configuration file need to enclose all the IPv6 addresses into square brackets if used in IP:Port format. 
If you are using the sample manifest from the previous point, this will require to modify [the configuration line L70](https://github.com/kubernetes/kubernetes/blob/b2ecd1b3a3192fbbe2b9e348e095326f51dc43dd/cluster/addons/dns/nodelocaldns/nodelocaldns.yaml#L70) like this `health [__PILLAR__LOCAL__DNS__]:8080`
-->
<ul>
<li>如果使用 IPv6，在使用 IP:Port 格式的时候需要把 CoreDNS 配置文件里的所有 IPv6 地址用方括号包起来。
如果你使用上述的示例清单，需要把 <a href="https://github.com/kubernetes/kubernetes/blob/b2ecd1b3a3192fbbe2b9e348e095326f51dc43dd/cluster/addons/dns/nodelocaldns/nodelocaldns.yaml#L70">配置行 L70</a>
修改为 <code>health [__PILLAR__LOCAL__DNS__]:8080</code>。</li>
</ul>
<!--
* Substitute the variables in the manifest with the right values:

     * kubedns=`kubectl get svc kube-dns -n kube-system -o jsonpath={.spec.clusterIP}`

     * domain=`<cluster-domain>`

     * localdns=`<node-local-address>`

     `<cluster-domain>` is "cluster.local" by default. `<node-local-address>` is the local listen IP address chosen for NodeLocal DNSCache.
-->
<ul>
<li>
<p>把清单里的变量更改为正确的值：</p>
<ul>
<li>
<p>kubedns=<code>kubectl get svc kube-dns -n kube-system -o jsonpath={.spec.clusterIP}</code></p>
</li>
<li>
<p>domain=<code>&lt;cluster-domain&gt;</code></p>
</li>
<li>
<p>localdns=<code>&lt;node-local-address&gt;</code></p>
</li>
</ul>
<p><code>&lt;cluster-domain&gt;</code> 的默认值是 &quot;cluster.local&quot;。 <code>&lt;node-local-address&gt;</code> 是 NodeLocal DNSCache 选择的本地侦听 IP 地址。</p>
</li>
</ul>
<!--
   * If kube-proxy is running in IPTABLES mode:

     ``` bash
     sed -i "s/__PILLAR__LOCAL__DNS__/$localdns/g; s/__PILLAR__DNS__DOMAIN__/$domain/g; s/__PILLAR__DNS__SERVER__/$kubedns/g" nodelocaldns.yaml
     ```

     `__PILLAR__CLUSTER__DNS__` and `__PILLAR__UPSTREAM__SERVERS__` will be populated by the node-local-dns pods.
     In this mode, node-local-dns pods listen on both the kube-dns service IP as well as `<node-local-address>`, so pods can lookup DNS records using either IP address.
-->   
<ul>
<li>
<p>如果 kube-proxy 运行在 IPTABLES 模式：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">sed -i <span style="color:#b44">&#34;s/__PILLAR__LOCAL__DNS__/</span><span style="color:#b8860b">$localdns</span><span style="color:#b44">/g; s/__PILLAR__DNS__DOMAIN__/</span><span style="color:#b8860b">$domain</span><span style="color:#b44">/g; s/__PILLAR__DNS__SERVER__/</span><span style="color:#b8860b">$kubedns</span><span style="color:#b44">/g&#34;</span> nodelocaldns.yaml
</code></pre></div><p>node-local-dns Pods 会设置 <code>__PILLAR__CLUSTER__DNS__</code> 和 <code>__PILLAR__UPSTREAM__SERVERS__</code>。
在此模式下, node-local-dns Pods 会同时侦听 kube-dns 服务的 IP 地址和 <code>&lt;node-local-address&gt;</code> 的地址，
以便 Pods 可以使用其中任何一个 IP 地址来查询 DNS 记录。</p>
</li>
</ul>
<!--
  * If kube-proxy is running in IPVS mode:

    ``` bash
     sed -i "s/__PILLAR__LOCAL__DNS__/$localdns/g; s/__PILLAR__DNS__DOMAIN__/$domain/g; s/,__PILLAR__DNS__SERVER__//g; s/__PILLAR__CLUSTER__DNS__/$kubedns/g" nodelocaldns.yaml
    ```
     In this mode, node-local-dns pods listen only on `<node-local-address>`. The node-local-dns interface cannot bind the kube-dns cluster IP since the interface used for IPVS loadbalancing already uses this address.
     `__PILLAR__UPSTREAM__SERVERS__` will be populated by the node-local-dns pods.
-->
<ul>
<li>
<p>如果 kube-proxy 运行在 IPVS 模式：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">sed -i <span style="color:#b44">&#34;s/__PILLAR__LOCAL__DNS__/</span><span style="color:#b8860b">$localdns</span><span style="color:#b44">/g; s/__PILLAR__DNS__DOMAIN__/</span><span style="color:#b8860b">$domain</span><span style="color:#b44">/g; s/__PILLAR__DNS__SERVER__//g; s/__PILLAR__CLUSTER__DNS__/</span><span style="color:#b8860b">$kubedns</span><span style="color:#b44">/g&#34;</span> nodelocaldns.yaml
</code></pre></div><p>在此模式下，node-local-dns Pods 只会侦听 <code>&lt;node-local-address&gt;</code> 的地址。
node-local-dns 接口不能绑定 kube-dns 的集群 IP 地址，因为 IPVS 负载均衡
使用的接口已经占用了该地址。
node-local-dns Pods 会设置 <code>__PILLAR__UPSTREAM__SERVERS__</code>。</p>
</li>
</ul>
<!--
* Run `kubectl create -f nodelocaldns.yaml`
* If using kube-proxy in IPVS mode, `--cluster-dns` flag to kubelet needs to be modified to use `<node-local-address>` that NodeLocal DNSCache is listening on.
  Otherwise, there is no need to modify the value of the `--cluster-dns` flag, since NodeLocal DNSCache listens on both the kube-dns service IP as well as `<node-local-address>`.
-->
<ul>
<li>运行 <code>kubectl create -f nodelocaldns.yaml</code></li>
<li>如果 kube-proxy 运行在 IPVS 模式，需要修改 kubelet 的 <code>--cluster-dns</code> 参数为 NodeLocal DNSCache 正在侦听的 <code>&lt;node-local-address&gt;</code> 地址。
否则，不需要修改 <code>--cluster-dns</code> 参数，因为 NodeLocal DNSCache 会同时侦听 kube-dns 服务的 IP 地址和 <code>&lt;node-local-address&gt;</code> 的地址。</li>
</ul>
<!--
Once enabled, node-local-dns Pods will run in the kube-system namespace on each of the cluster nodes. This Pod runs [CoreDNS](https://github.com/coredns/coredns) in cache mode, so all CoreDNS metrics exposed by the different plugins will be available on a per-node basis.

You can disable this feature by removing the DaemonSet, using `kubectl delete -f <manifest>` . You should also revert any changes you made to the kubelet configuration.
-->
<p>启用后，node-local-dns Pods 将在每个集群节点上的 kube-system 名字空间中运行。
此 Pod 在缓存模式下运行 <a href="https://github.com/coredns/coredns">CoreDNS</a> ，因此每个节点都可以使用不同插件公开的所有 CoreDNS 指标。</p>
<p>如果要禁用该功能，你可以使用 <code>kubectl delete -f &lt;manifest&gt;</code> 来删除 DaemonSet。你还应该恢复你对 kubelet 配置所做的所有改动。</p>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-fe5ad73163d38596340536ec03a205f0">21 - 在 Kubernetes 集群中使用 sysctl</h1>
    
	<!--
title: Using sysctls in a Kubernetes Cluster
reviewers:
- sttts
content_type: task
--->
<!-- overview -->
<!--
This document describes how to configure and use kernel parameters within a
Kubernetes cluster using the <a class='glossary-tooltip' title='用于获取和设置 Unix 内核参数的接口' data-toggle='tooltip' data-placement='top' href='/zh/docs/tasks/administer-cluster/sysctl-cluster/' target='_blank' aria-label='sysctl'>sysctl</a>
interface.
-->
<p>本文档介绍如何通过 <a class='glossary-tooltip' title='用于获取和设置 Unix 内核参数的接口' data-toggle='tooltip' data-placement='top' href='/zh/docs/tasks/administer-cluster/sysctl-cluster/' target='_blank' aria-label='sysctl'>sysctl</a>
接口在 Kubernetes 集群中配置和使用内核参数。</p>
<h2 id="准备开始">准备开始</h2>
<p><p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
如果你还没有集群，你可以通过 <a href="/zh/docs/tasks/tools/#minikube">Minikube</a> 构建一
个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p>
<!--
You need to have a Kubernetes cluster, and the kubectl command-line tool must
be configured to communicate with your cluster. If you do not already have a
cluster, you can create one by using
[minikube](/docs/tasks/tools/#minikube)
or you can use one of these Kubernetes playgrounds:
-->
<ul>
<li><a href="https://www.katacoda.com/courses/kubernetes/playground">Katacoda</a></li>
<li><a href="http://labs.play-with-k8s.com/">玩转 Kubernetes</a></li>
</ul>
 
 要获知版本信息，请输入 <code>kubectl version</code>.
</p>
<!-- steps -->
<!--
## Listing all Sysctl Parameters
-->
<h2 id="获取-sysctl-的参数列表">获取 Sysctl 的参数列表</h2>
<!--
In Linux, the sysctl interface allows an administrator to modify kernel
parameters at runtime. Parameters are available via the `/proc/sys/` virtual
process file system. The parameters cover various subsystems such as:
-->
<p>在 Linux 中，管理员可以通过 sysctl 接口修改内核运行时的参数。在 <code>/proc/sys/</code>
虚拟文件系统下存放许多内核参数。这些参数涉及了多个内核子系统，如：</p>
<!--
- kernel (common prefix: `kernel.`)
- networking (common prefix: `net.`)
- virtual memory (common prefix: `vm.`)
- MDADM (common prefix: `dev.`)
- More subsystems are described in [Kernel docs](https://www.kernel.org/doc/Documentation/sysctl/README).
-->
<ul>
<li>内核子系统（通常前缀为: <code>kernel.</code>）</li>
<li>网络子系统（通常前缀为: <code>net.</code>）</li>
<li>虚拟内存子系统（通常前缀为: <code>vm.</code>）</li>
<li>MDADM 子系统（通常前缀为: <code>dev.</code>）</li>
<li>更多子系统请参见<a href="https://www.kernel.org/doc/Documentation/sysctl/README">内核文档</a>。</li>
</ul>
<!--
To get a list of all parameters, you can run
--->
<p>若要获取完整的参数列表，请执行以下命令</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">sudo sysctl -a
</code></pre></div><!--
## Enabling Unsafe Sysctls

Sysctls are grouped into _safe_  and _unsafe_ sysctls. In addition to proper
namespacing a _safe_ sysctl must be properly _isolated_ between pods on the same
node. This means that setting a _safe_ sysctl for one pod
-->
<h2 id="启用非安全的-sysctl-参数">启用非安全的 Sysctl 参数</h2>
<p>sysctl 参数分为 <em>安全</em> 和 <em>非安全的</em>。
<em>安全</em> sysctl 参数除了需要设置恰当的命名空间外，在同一 node 上的不同 Pod
之间也必须是 <em>相互隔离的</em>。这意味着在 Pod 上设置 <em>安全</em> sysctl 参数</p>
<!--
- must not have any influence on any other pod on the node
- must not allow to harm the node's health
- must not allow to gain CPU or memory resources outside of the resource limits
  of a pod.
-->
<ul>
<li>必须不能影响到节点上的其他 Pod</li>
<li>必须不能损害节点的健康</li>
<li>必须不允许使用超出 Pod 的资源限制的 CPU 或内存资源。</li>
</ul>
<!--
By far, most of the _namespaced_ sysctls are not necessarily considered _safe_.
The following sysctls are supported in the _safe_ set:
-->
<p>至今为止，大多数 <em>有命名空间的</em> sysctl 参数不一定被认为是 <em>安全</em> 的。
以下几种 sysctl 参数是 <em>安全的</em>：</p>
<ul>
<li><code>kernel.shm_rmid_forced</code></li>
<li><code>net.ipv4.ip_local_port_range</code></li>
<li><code>net.ipv4.tcp_syncookies</code></li>
<li><code>net.ipv4.ping_group_range</code> （从 Kubernetes 1.18 开始）</li>
</ul>
<!--
The example `net.ipv4.tcp_syncookies` is not namespaced on Linux kernel version 4.4 or lower.
-->
<blockquote class="note callout">
  <div><strong>说明：</strong> 示例中的 <code>net.ipv4.tcp_syncookies</code> 在Linux 内核 4.4 或更低的版本中是无命名空间的。</div>
</blockquote>
<!--
This list will be extended in future Kubernetes versions when the kubelet
supports better isolation mechanisms.
-->
<p>在未来的 Kubernetes 版本中，若 kubelet 支持更好的隔离机制，则上述列表中将会
列出更多 <em>安全的</em> sysctl 参数。</p>
<!--
All _safe_ sysctls are enabled by default.
-->
<p>所有 <em>安全的</em> sysctl 参数都默认启用。</p>
<!--
All _unsafe_ sysctls are disabled by default and must be allowed manually by the
cluster admin on a per-node basis. Pods with disabled unsafe sysctls will be
scheduled, but will fail to launch.
-->
<p>所有 <em>非安全的</em> sysctl 参数都默认禁用，且必须由集群管理员在每个节点上手动开启。
那些设置了不安全 sysctl 参数的 Pod 仍会被调度，但无法正常启动。</p>
<!--
With the warning above in mind, the cluster admin can allow certain _unsafe_
sysctls for very special situations like e.g. high-performance or real-time
application tuning. _Unsafe_ sysctls are enabled on a node-by-node basis with a
flag of the kubelet, e.g.:
-->
<p>参考上述警告，集群管理员只有在一些非常特殊的情况下（如：高可用或实时应用调整），
才可以启用特定的 <em>非安全的</em> sysctl 参数。
如需启用 <em>非安全的</em> sysctl 参数，请你在每个节点上分别设置 kubelet 命令行参数，例如：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubelet --allowed-unsafe-sysctls <span style="color:#b62;font-weight:bold">\
</span><span style="color:#b62;font-weight:bold"></span>  <span style="color:#b44">&#39;kernel.msg*,net.core.somaxconn&#39;</span> ...
</code></pre></div><!--
For <a class='glossary-tooltip' title='Minikube 是用来在本地运行 Kubernetes 的一种工具。' data-toggle='tooltip' data-placement='top' href='/docs/getting-started-guides/minikube/' target='_blank' aria-label='Minikube'>Minikube</a>, this can be done via the `extra-config` flag:
-->
<p>如果你使用 <a class='glossary-tooltip' title='Minikube 是用来在本地运行 Kubernetes 的一种工具。' data-toggle='tooltip' data-placement='top' href='/docs/getting-started-guides/minikube/' target='_blank' aria-label='Minikube'>Minikube</a>，可以通过 <code>extra-config</code> 参数来配置：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">minikube start --extra-config<span style="color:#666">=</span><span style="color:#b44">&#34;kubelet.allowed-unsafe-sysctls=kernel.msg*,net.core.somaxconn&#34;</span>...
</code></pre></div><!--
Only _namespaced_ sysctls can be enabled this way.
-->
<p>只有 <em>有命名空间的</em> sysctl 参数可以通过该方式启用。</p>
<!--
## Setting Sysctls for a Pod

A number of sysctls are _namespaced_ in today's Linux kernels. This means that
they can be set independently for each pod on a node. Only namespaced sysctls
are configurable via the pod securityContext within Kubernetes.
-->
<h2 id="设置-pod-的-sysctl-参数">设置 Pod 的 Sysctl 参数</h2>
<p>目前，在 Linux 内核中，有许多的 sysctl 参数都是 <em>有命名空间的</em> 。
这就意味着可以为节点上的每个 Pod 分别去设置它们的 sysctl 参数。
在 Kubernetes 中，只有那些有命名空间的 sysctl 参数可以通过 Pod 的 securityContext 对其进行配置。</p>
<!--
The following sysctls are known to be namespaced. This list could change
in future versions of the Linux kernel.
-->
<p>以下列出有命名空间的 sysctl 参数，在未来的 Linux 内核版本中，此列表可能会发生变化。</p>
<ul>
<li><code>kernel.shm*</code>,</li>
<li><code>kernel.msg*</code>,</li>
<li><code>kernel.sem</code>,</li>
<li><code>fs.mqueue.*</code>,</li>
<li><code>net.*</code>（内核中可以在容器命名空间里被更改的网络配置项相关参数）。然而也有一些特例
（例如，<code>net.netfilter.nf_conntrack_max</code> 和 <code>net.netfilter.nf_conntrack_expect_max</code>
可以在容器命名空间里被更改，但它们是非命名空间的）。</li>
</ul>
<!--
Sysctls with no namespace are called _node-level_ sysctls. If you need to set
them, you must manually configure them on each node's operating system, or by
using a DaemonSet with privileged containers.
-->
<p>没有命名空间的 sysctl 参数称为 <em>节点级别的</em> sysctl 参数。
如果需要对其进行设置，则必须在每个节点的操作系统上手动地去配置它们，
或者通过在 DaemonSet 中运行特权模式容器来配置。</p>
<!--
Use the pod securityContext to configure namespaced sysctls. The securityContext
applies to all containers in the same pod.
-->
<p>可使用 Pod 的 securityContext 来配置有命名空间的 sysctl 参数，
securityContext 应用于同一个 Pod 中的所有容器。</p>
<!--
This example uses the pod securityContext to set a safe sysctl
`kernel.shm_rmid_forced` and two unsafe sysctls `net.core.somaxconn` and
`kernel.msgmax` There is no distinction between _safe_ and _unsafe_ sysctls in
the specification.
-->
<p>此示例中，使用 Pod SecurityContext 来对一个安全的 sysctl 参数
<code>kernel.shm_rmid_forced</code> 以及两个非安全的 sysctl 参数
<code>net.core.somaxconn</code> 和 <code>kernel.msgmax</code> 进行设置。
在 Pod 规约中对 <em>安全的</em> 和 <em>非安全的</em> sysctl 参数不做区分。</p>
<!--
Only modify sysctl parameters after you understand their effects, to avoid
destabilizing your operating system.
-->
<blockquote class="warning callout">
  <div><strong>警告：</strong> 为了避免破坏操作系统的稳定性，请你在了解变更后果之后再修改 sysctl 参数。</div>
</blockquote>

<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>Pod<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>sysctl-example<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">spec</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">securityContext</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">sysctls</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>kernel.shm_rmid_forced<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">value</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;0&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>net.core.somaxconn<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">value</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;1024&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>kernel.msgmax<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">value</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;65536&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span>...<span style="color:#bbb">
</span></code></pre></div><!-- discussion -->
<!--
Due to their nature of being _unsafe_, the use of _unsafe_ sysctls
is at-your-own-risk and can lead to severe problems like wrong behavior of
containers, resource shortage or complete breakage of a node.
-->
<blockquote class="warning callout">
  <div><strong>警告：</strong> 由于 <em>非安全的</em> sysctl 参数其本身具有不稳定性，在使用 <em>非安全的</em> sysctl 参数
时可能会导致一些严重问题，如容器的错误行为、机器资源不足或节点被完全破坏，
用户需自行承担风险。</div>
</blockquote>

<!--
It is good practice to consider nodes with special sysctl settings as
_tainted_ within a cluster, and only schedule pods onto them which need those
sysctl settings. It is suggested to use the Kubernetes [_taints and toleration_
feature](/docs/reference/generated/kubectl/kubectl-commands/#taint) to implement this.
-->
<p>最佳实践方案是将集群中具有特殊 sysctl 设置的节点视为 <em>有污点的</em>，并且只调度
需要使用到特殊 sysctl 设置的 Pod 到这些节点上。
建议使用 Kubernetes 的
<a href="/docs/reference/generated/kubectl/kubectl-commands/#taint">污点和容忍度特性</a> 来实现它。</p>
<!--
A pod with the _unsafe_ sysctls will fail to launch on any node which has not
enabled those two _unsafe_ sysctls explicitly. As with _node-level_ sysctls it
is recommended to use
[_taints and toleration_ feature](/docs/reference/generated/kubectl/kubectl-commands/#taint) or
[taints on nodes](/docs/concepts/configuration/taint-and-toleration/)
to schedule those pods onto the right nodes.
-->
<p>设置了 <em>非安全的</em> sysctl 参数的 Pod 在禁用了这两种 <em>非安全的</em> sysctl 参数配置
的节点上启动都会失败。与 <em>节点级别的</em> sysctl 一样，建议开启
<a href="/docs/reference/generated/kubectl/kubectl-commands/#taint">污点和容忍度特性</a> 或
<a href="/zh/docs/concepts/scheduling-eviction/taint-and-toleration/">为节点配置污点</a>
以便将 Pod 调度到正确的节点之上。</p>
<h2 id="podsecuritypolicy">PodSecurityPolicy</h2>
<!--
You can further control which sysctls can be set in pods by specifying lists of
sysctls or sysctl patterns in the `forbiddenSysctls` and/or
`allowedUnsafeSysctls` fields of the PodSecurityPolicy. A sysctl pattern ends
with a `*` character, such as `kernel.*`. A `*` character on its own matches
all sysctls.
-->
<p>你可以通过在 PodSecurityPolicy 的 <code>forbiddenSysctls</code> 和/或 <code>allowedUnsafeSysctls</code>
字段中，指定 sysctl 或填写 sysctl 匹配模式来进一步为 Pod 设置 sysctl 参数。
sysctl 参数匹配模式以 <code>*</code> 字符结尾，如 <code>kernel.*</code>。
单独的 <code>*</code>  字符匹配所有 sysctl 参数。</p>
<!--
By default, all safe sysctls are allowed.
-->
<p>所有 <em>安全的</em> sysctl 参数都默认启用。</p>
<!--
Both `forbiddenSysctls` and `allowedUnsafeSysctls` are lists of plain sysctl names
or sysctl patterns (which end with `*`). The string `*` matches all sysctls.
-->
<p><code>forbiddenSysctls</code> 和 <code>allowedUnsafeSysctls</code> 的值都是字符串列表类型，
可以添加 sysctl 参数名称，也可以添加 sysctl 参数匹配模式（以<code>*</code>结尾）。
只填写 <code>*</code> 则匹配所有的 sysctl 参数。</p>
<!--
The `forbiddenSysctls` field excludes specific sysctls. You can forbid a
combination of safe and unsafe sysctls in the list. To forbid setting any
sysctls, use `*` on its own.
-->
<p><code>forbiddenSysctls</code> 字段用于禁用特定的 sysctl 参数。
你可以在列表中禁用安全和非安全的 sysctl 参数的组合。
要禁用所有的 sysctl 参数，请设置为 <code>*</code>。</p>
<!--
If you specify any unsafe sysctl in the `allowedUnsafeSysctls` field and it is
not present in the `forbiddenSysctls` field, that sysctl can be used in Pods
using this PodSecurityPolicy. To allow all unsafe sysctls in the
PodSecurityPolicy to be set, use `*` on its own.
-->
<p>如果要在 <code>allowedUnsafeSysctls</code> 字段中指定一个非安全的 sysctl 参数，
并且它在 <code>forbiddenSysctls</code> 字段中未被禁用，则可以在 Pod 中通过
PodSecurityPolicy 启用该 sysctl 参数。
若要在 PodSecurityPolicy 中开启所有非安全的 sysctl 参数，
请设 <code>allowedUnsafeSysctls</code> 字段值为 <code>*</code>。</p>
<!--
Do not configure these two fields such that there is overlap, meaning that a
given sysctl is both allowed and forbidden.
-->
<p><code>allowedUnsafeSysctls</code> 与 <code>forbiddenSysctls</code> 两字段的配置不能重叠，
否则这就意味着存在某个 sysctl 参数既被启用又被禁用。</p>
<!--
If you whitelist unsafe sysctls via the `allowedUnsafeSysctls` field
in a PodSecurityPolicy, any pod using such a sysctl will fail to start
if the sysctl is not whitelisted via the `--allowed-unsafe-sysctls` kubelet
flag as well on that node.
--->
<blockquote class="warning callout">
  <div><strong>警告：</strong> 如果你通过 PodSecurityPolicy 中的 <code>allowedUnsafeSysctls</code> 字段将非安全的 sysctl
参数列入白名单，但该 sysctl 参数未通过 kubelet 命令行参数
<code>--allowed-unsafe-sysctls</code> 在节点上将其列入白名单，则设置了这个 sysctl
参数的 Pod 将会启动失败。</div>
</blockquote>

<!--
This example allows unsafe sysctls prefixed with `kernel.msg` to be set and
disallows setting of the `kernel.shm_rmid_forced` sysctl.
-->
<p>以下示例设置启用了以 <code>kernel.msg</code> 为前缀的非安全的 sysctl 参数，同时禁用了
sysctl 参数 <code>kernel.shm_rmid_forced</code>。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>policy/v1beta1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>PodSecurityPolicy<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>sysctl-psp<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">spec</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">allowedUnsafeSysctls</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- kernel.msg*<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">forbiddenSysctls</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- kernel.shm_rmid_forced<span style="color:#bbb">
</span><span style="color:#bbb"> </span>...<span style="color:#bbb">
</span></code></pre></div>
</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-eec61e72c300dbfbf7302400ca966432">22 - 在运行中的集群上重新配置节点的 kubelet</h1>
    
	<!--
reviewers:
- mtaufen
- dawnchen
title: Reconfigure a Node's Kubelet in a Live Cluster
content_type: task
-->
<!-- overview -->





<div style="margin-top: 10px; margin-bottom: 10px;">
<b>FEATURE STATE:</b> <code>Kubernetes v1.22 [deprecated]</code>
</div>

<!--
Caution: Dynamic Kubelet Configuration feature is deprecated and should not be used. Please switch to alternative means distributing configuration to the Nodes of your cluster.
-->
<blockquote class="caution callout">
  <div><strong>注意：</strong> <a href="https://github.com/kubernetes/enhancements/issues/281">动态 kubelet 配置</a>
已经废弃不建议使用。请选择其他方法将配置分发到集群中的节点。</div>
</blockquote>

<!--
[Dynamic Kubelet Configuration](https://github.com/kubernetes/enhancements/issues/281)
allows you to change the configuration of each Kubelet in a live Kubernetes
cluster by deploying a ConfigMap and configuring each Node to use it.
-->
<p><a href="https://github.com/kubernetes/enhancements/issues/281">动态 kubelet 配置</a>
允许你通过部署一个所有节点都会使用的 ConfigMap
达到在运行中的 Kubernetes 集群中更改 kubelet 配置的目的。</p>
<!--
All kubelet configuration parameters can be changed dynamically,
but this is unsafe for some parameters. Before deciding to change a parameter
dynamically, you need a strong understanding of how that change will affect your
cluster's behavior. Always carefully test configuration changes on a small set
of nodes before rolling them out cluster-wide. Advice on configuring specific
fields is available in the inline
[`KubeletConfiguration`](/docs/reference/config-api/kubelet-config.v1beta1/).
-->
<blockquote class="warning callout">
  <div><strong>警告：</strong> 所有 kubelet 配置参数都可以被动态更改，但对某些参数来说这类更改是不安全的。
在决定动态更改参数之前，你需要深刻理解这个改动将会如何影响集群的行为。
在将变更扩散到整个集群之前，你需要先在小规模的节点集合上仔细地测试这些配置变动。
特定字段相关的配置建议可以在文档
<a href="/docs/reference/config-api/kubelet-config.v1beta1/"><code>KubeletConfiguration</code></a>中找到。</div>
</blockquote>

<h2 id="准备开始">准备开始</h2>
<!--
You need to have a Kubernetes cluster.
You also need kubectl v1.11 or higher, configured to communicate with your cluster.

 要获知版本信息，请输入 <code>kubectl version</code>.

Your cluster API server version (eg v1.12) must be no more than one minor
version away from the version of kubectl that you are using. For example,
if your cluster is running v1.16 then you can use kubectl v1.15, v1.16
or v1.17; other combinations
[aren't supported](/docs/setup/release/version-skew-policy/#kubectl).
-->
<p>你需要一个 Kubernetes 集群。
你需要 v1.11 或更高版本的 kubectl，并配置好与集群的通信。

 要获知版本信息，请输入 <code>kubectl version</code>.

你的集群 API 服务器版本（如 v1.12）不能和你的 kubectl
版本相差超过一个小版本号。
例如，如果你的集群在运行 v1.16，那么你可以使用 v1.15、v1.16、v1.17 的 kubectl，
所有其他的组合都是
<a href="/zh/docs/setup/release/version-skew-policy/#kubectl">不支持的</a>。</p>
<!--
Some of the examples use the command line tool
[jq](https://stedolan.github.io/jq/). You do not need `jq` to complete the task,
because there are manual alternatives.

For each node that you're reconfiguring, you must set the kubelet
`-dynamic-config-dir` flag to a writable directory.
-->
<p>在某些例子中使用了命令行工具 <a href="https://stedolan.github.io/jq/">jq</a>。
你并不一定需要 <code>jq</code> 才能完成这些任务，因为总是有一些手工替代的方式。</p>
<p>针对你重新配置的每个节点，你必须设置 kubelet 的标志
<code>-dynamic-config-dir</code>，使之指向一个可写的目录。</p>
<!-- steps -->
<!--
## Reconfiguring the kubelet on a running node in your cluster

### Basic Workflow Overview
-->
<h2 id="重配置-集群中运行节点上的-kubelet">重配置 集群中运行节点上的 kubelet</h2>
<h3 id="基本工作流程概览">基本工作流程概览</h3>
<!--
The basic workflow for configuring a Kubelet in a live cluster is as follows:

1. Write a YAML or JSON configuration file containing the
   kubelet's configuration.
2. Wrap this file in a ConfigMap and save it to the Kubernetes control plane.
3. Update the Kubelet's corresponding Node object to use this ConfigMap.
-->
<p>在运行中的集群中配置 kubelet 的基本工作流程如下：</p>
<ol>
<li>编写一个包含 kubelet 配置的 YAML 或 JSON 文件。</li>
<li>将此文件包装在 ConfigMap 中并将其保存到 Kubernetes 控制平面。</li>
<li>更新 kubelet 所在节点对象以使用此 ConfigMap。</li>
</ol>
<!--
Each kubelet watches a configuration reference on its respective Node object.
When this reference changes, the Kubelet downloads the new configuration,
updates a local reference to refer to the file, and exits.
For the feature to work correctly, you must be running an OS-level service
manager (such as systemd), which will restart the Kubelet if it exits. When the
Kubelet is restarted, it will begin using the new configuration.
-->
<p>每个 kubelet 都会在其各自的节点对象上监测（Watch）配置引用。当引用更改时，kubelet 将下载新的配置文件，
更新本地引用指向该文件，然后退出。
为了使该功能正常地工作，你必须运行操作系统级别的服务管理器（如 systemd），
它将会在 kubelet 退出后将其重启。
kubelet 重新启动时，将开始使用新配置。</p>
<!--
The new configuration completely overrides configuration provided by `--config`,
and is overridden by command-line flags. Unspecified values in the new configuration
will receive default values appropriate to the configuration version
(e.g. `kubelet.config.k8s.io/v1beta1`), unless overridden by flags.
-->
<p>新配置将会完全地覆盖 <code>--config</code> 所提供的配置，并被命令行标志覆盖。
新配置中未指定的值将收到适合配置版本的默认值
(e.g. <code>kubelet.config.k8s.io/v1beta1</code>)，除非被命令行标志覆盖。</p>
<!--
The status of the Node's Kubelet configuration is reported via
`Node.Spec.Status.Config`. Once you have updated a Node to use the new
ConfigMap, you can observe this status to confirm that the Node is using the
intended configuration.
-->
<p>节点 kubelet 配置状态可通过 <code>node.spec.status.config</code> 获取。
一旦你更新了一个节点去使用新的 ConfigMap，
就可以通过观察此状态来确认该节点是否正在使用预期配置。</p>
<!--
This document describes editing Nodes using `kubectl edit`.
There are other ways to modify a Node's spec, including `kubectl patch`, for
example, which facilitate scripted workflows.
-->
<p>本文中使用命令 <code>kubectl edit</code> 来编辑节点，还有其他的方式可以修改节点的规约，
比如更利于脚本化工作流程的 <code>kubectl patch</code>。</p>
<!--
This document only describes a single Node consuming each ConfigMap. Keep in
mind that it is also valid for multiple Nodes to consume the same ConfigMap.
-->
<p>本文仅仅讲述在单节点上使用每个 ConfigMap。请注意对于多个节点使用相同的 ConfigMap
也是合法的。</p>
<!--
While it is *possible* to change the configuration by
updating the ConfigMap in-place, this causes all Kubelets configured with
that ConfigMap to update simultaneously. It is much safer to treat ConfigMaps
as immutable by convention, aided by `kubectl`'s `-append-hash` option,
and incrementally roll out updates to `Node.Spec.ConfigSource`.
-->
<blockquote class="warning callout">
  <div><strong>警告：</strong> 尽管通过就地更新 ConfigMap 来更改配置是 <em>可能的</em>。
但是这样做会导致所有使用该 ConfigMap 配置的 kubelet 同时更新。
更安全的做法是按惯例将 ConfigMap 视为不可变更的，借助于
<code>kubectl</code> 的 <code>--append-hash</code> 选项逐步把更新推广到 <code>node.spec.configSource</code>。</div>
</blockquote>

<!--
### Automatic RBAC rules for Node Authorizer

Previously, you were required to manually create RBAC rules
to allow Nodes to access their assigned ConfigMaps. The Node Authorizer now
automatically configures these rules.
-->
<h3 id="节点鉴权器的自动-rbac-规则">节点鉴权器的自动 RBAC 规则</h3>
<p>以前，你需要手动创建 RBAC 规则以允许节点访问其分配的 ConfigMap。节点鉴权器现在
能够自动配置这些规则。</p>
<!--
### Generating a file that contains the current configuration

The Dynamic Kubelet Configuration feature allows you to provide an override for
the entire configuration object, rather than a per-field overlay. This is a
simpler model that makes it easier to trace the source of configuration values
and debug issues. The compromise, however, is that you must start with knowledge
of the existing configuration to ensure that you only change the fields you
intend to change.
-->
<h3 id="生成包含当前配置的文件">生成包含当前配置的文件</h3>
<p>动态 kubelet 配置特性允许你为整个配置对象提供一个重载配置，而不是靠单个字段的叠加。
这是一个更简单的模型，可以更轻松地跟踪配置值的来源，更便于调试问题。
然而，相应的代价是你必须首先了解现有配置，以确保你只更改你打算修改的字段。</p>
<!--
The kubelet loads settings from its configuration file, but you can set command
line flags to override the configuration in the file. This means that if you
only know the contents of the configuration file, and you don't know the
command line overrides, then you do not know the running configuration either.
-->
<p>组件 kubelet 从其配置文件中加载配置数据，不过你可以通过设置命令行标志
来重载文件中的一些配置。这意味着，如果你仅知道配置文件的内容，而你不知道
命令行重载了哪些配置，你就无法知道 kubelet 的运行时配置是什么。</p>
<!--
Because you need to know the running configuration in order to override it,
you can fetch the running configuration from the kubelet. You can generate a
config file containing a Node's current configuration by accessing the kubelet's
`configz` endpoint, through `kubectl proxy`. The next section explains how to
do this.
-->
<p>因为你需要知道运行时所使用的配置才能重载之，你可以从 kubelet 取回其运行时配置。
你可以通过访问 kubelet 的 <code>configz</code> 末端来生成包含节点当前配置的配置文件；
这一操作可以通过 <code>kubectl proxy</code> 来完成。
下一节解释如何完成这一操作。</p>
<!--
The kubelet's `configz` endpoint is there to help with debugging, and is not
a stable part of kubelet behavior.
Do not rely on the behavior of this endpoint for production scenarios or for
use with automated tools.
-->
<blockquote class="caution callout">
  <div><strong>注意：</strong> 组件 <code>kubelet</code> 上的 <code>configz</code> 末端是用来协助调试的，并非 kubelet 稳定行为的一部分。
请不要在产品环境下依赖此末端的行为，也不要在自动化工具中使用此末端。</div>
</blockquote>

<!--
For more information on configuring the kubelet via a configuration file, see
[Set kubelet parameters via a config file](/docs/tasks/administer-cluster/kubelet-config-file)).
-->
<p>关于如何使用配置文件来配置 kubelet 行为的更多信息可参见
<a href="/zh/docs/tasks/administer-cluster/kubelet-config-file">通过配置文件设置 kubelet 参数</a>
文档。</p>
<!-- #### Generate the configuration file -->
<h4 id="生成配置文件">生成配置文件</h4>
<!--
The steps below use the `jq` command to streamline working with JSON.
To follow the tasks as written, you need to have `jq` installed. You can
adapt the steps if you prefer to extract the `kubeletconfig` subobject manually.
-->
<blockquote class="note callout">
  <div><strong>说明：</strong> 下面的任务步骤中使用了 <code>jq</code> 命令以方便处理 JSON 数据。为了完成这里讲述的任务，
你需要安装 <code>jq</code>。如果你更希望手动提取 <code>kubeletconfig</code> 子对象，也可以对这里
的对应步骤做一些调整。</div>
</blockquote>
<!--
1. Choose a Node to reconfigure. In this example, the name of this Node is
   referred to as `NODE_NAME`.
2. Start the kubectl proxy in the background using the following command:
-->
<ol>
<li>
<p>选择要重新配置的节点。在本例中，此节点的名称为 <code>NODE_NAME</code>。</p>
</li>
<li>
<p>使用以下命令在后台启动 kubectl 代理：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl proxy --port<span style="color:#666">=</span><span style="color:#666">8001</span> &amp;
</code></pre></div></li>
</ol>
<!--
3. Run the following command to download and unpack the configuration from the
   `configz` endpoint. The command is long, so be careful when copying and
   pasting. **If you use zsh**, note that common zsh configurations add backslashes
   to escape the opening and closing curly braces around the variable name in the URL.
   For example: `${NODE_NAME}` will be rewritten as `$\{NODE_NAME\}` during the paste.
   You must remove the backslashes before running the command, or the command will fail.
-->
<ol start="3">
<li>
<p>运行以下命令从 <code>configz</code> 端点中下载并解压配置。这个命令很长，因此在复制粘贴时要小心。
<strong>如果你使用 zsh</strong>，请注意常见的 zsh 配置要添加反斜杠转义 URL 中变量名称周围的大括号。
例如：在粘贴时，<code>${NODE_NAME}</code> 将被重写为 <code>$\{NODE_NAME\}</code>。
你必须在运行命令之前删除反斜杠，否则命令将失败。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#b8860b">NODE_NAME</span><span style="color:#666">=</span><span style="color:#b44">&#34;the-name-of-the-node-you-are-reconfiguring&#34;</span>; curl -sSL <span style="color:#b44">&#34;http://localhost:8001/api/v1/nodes/</span><span style="color:#b68;font-weight:bold">${</span><span style="color:#b8860b">NODE_NAME</span><span style="color:#b68;font-weight:bold">}</span><span style="color:#b44">/proxy/configz&#34;</span> | jq <span style="color:#b44">&#39;.kubeletconfig|.kind=&#34;KubeletConfiguration&#34;|.apiVersion=&#34;kubelet.config.k8s.io/v1beta1&#34;&#39;</span> &gt; kubelet_configz_<span style="color:#b68;font-weight:bold">${</span><span style="color:#b8860b">NODE_NAME</span><span style="color:#b68;font-weight:bold">}</span>
</code></pre></div></li>
</ol>
<!--
You need to manually add the `kind` and `apiVersion` to the downloaded
object，because they are not reported by the `configz` endpoint。
-->
<blockquote class="note callout">
  <div><strong>说明：</strong> 你需要手动将 <code>kind</code> 和 <code>apiVersion</code> 添加到下载对象中，因为它们不是由 <code>configz</code> 末端
返回的。</div>
</blockquote>
<!--
#### Edit the configuration file

Using a text editor, change one of the parameters in the
file generated by the previous procedure. For example, you
might edit the QPS parameter `eventRecordQPS`.
-->
<h4 id="修改配置文件">修改配置文件</h4>
<p>使用文本编辑器，改变上述操作生成的文件中一个参数。
例如，你或许会修改 QPS 参数 <code>eventRecordQPS</code>。</p>
<!--
#### Push the configuration file to the control plane

Push the edited configuration file to the control plane with the
following command:
-->
<h4 id="把配置文件推送到控制平面">把配置文件推送到控制平面</h4>
<p>用以下命令把编辑后的配置文件推送到控制平面：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">kubectl -n kube-system create configmap my-node-config <span style="color:#b62;font-weight:bold">\
</span><span style="color:#b62;font-weight:bold"></span>  --from-file<span style="color:#666">=</span><span style="color:#b8860b">kubelet</span><span style="color:#666">=</span>kubelet_configz_<span style="color:#b68;font-weight:bold">${</span><span style="color:#b8860b">NODE_NAME</span><span style="color:#b68;font-weight:bold">}</span> <span style="color:#b62;font-weight:bold">\
</span><span style="color:#b62;font-weight:bold"></span>  --append-hash -o yaml
</code></pre></div><!--
This is an example of a valid response:
-->
<p>下面是合法响应的一个例子：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>ConfigMap<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">creationTimestamp</span>:<span style="color:#bbb"> </span>2017-09-14T20:23:33Z<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>my-node-config-gkt4c2m4b2<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">namespace</span>:<span style="color:#bbb"> </span>kube-system<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">resourceVersion</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;119980&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">selfLink</span>:<span style="color:#bbb"> </span>/api/v1/namespaces/kube-system/configmaps/my-node-config-gkt4c2m4b2<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">uid</span>:<span style="color:#bbb"> </span>946d785e-998a-11e7-a8dd-42010a800006<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">data</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">kubelet</span>:<span style="color:#bbb"> </span>|<span style="color:#b44;font-style:italic">
</span><span style="color:#b44;font-style:italic">    </span><span style="color:#bbb">    </span>{...}<span style="color:#bbb">
</span></code></pre></div><!--
You created that ConfigMap inside the `kube-system` namespace because the kubelet
is a Kubernetes system component.
-->
<p>你会在 <code>kube-system</code> 命名空间中创建 ConfigMap，因为 kubelet 是 Kubernetes 的系统组件。</p>
<!--
The `-append-hash` option appends a short checksum of the ConfigMap contents
to the name. This is convenient for an edit-then-push workflow, because it
automatically, yet deterministically, generates new names for new ConfigMaps.
The name that includes this generated hash is referred to as `CONFIG_MAP_NAME`
in the following examples.
-->
<p><code>--append-hash</code> 选项给 ConfigMap 内容附加了一个简短校验和。
这对于先编辑后推送的工作流程很方便，
因为它自动并确定地为新 ConfigMap 生成新的名称。
在以下示例中，包含生成的哈希字符串的对象名被称为 <code>CONFIG_MAP_NAME</code>。</p>
<!--
#### Set the Node to use the new configuration


Edit the Node's reference to point to the new ConfigMap with the
following command:
-->
<h4 id="配置节点使用新的配置">配置节点使用新的配置</h4>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">kubectl edit node <span style="color:#b68;font-weight:bold">${</span><span style="color:#b8860b">NODE_NAME</span><span style="color:#b68;font-weight:bold">}</span>
</code></pre></div><!--
In your text editor, add the following YAML under `spec`:
-->
<p>在你的文本编辑器中，在 <code>spec</code> 下增添以下 YAML：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">configSource</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">configMap</span>:<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>CONFIG_MAP_NAME<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#008000;font-weight:bold">namespace</span>:<span style="color:#bbb"> </span>kube-system<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#008000;font-weight:bold">kubeletConfigKey</span>:<span style="color:#bbb"> </span>kubelet<span style="color:#bbb">
</span></code></pre></div><!--
You must specify all three of `name`, `namespace`, and `kubeletConfigKey`.
The `kubeletConfigKey` parameter shows the Kubelet which key of the ConfigMap
contains its config.
-->
<p>你必须同时指定 <code>name</code>、<code>namespace</code> 和 <code>kubeletConfigKey</code> 这三个属性。
<code>kubeletConfigKey</code> 这个参数通知 kubelet ConfigMap 中的哪个键下面包含所要的配置。</p>
<!--
#### Observe that the Node begins using the new configuration

Retrieve the Node using the `kubectl get node ${NODE_NAME} -o yaml` command and inspect
`Node.Status.Config`. The config sources corresponding to the `active`,
`assigned`, and `lastKnownGood` configurations are reported in the status.

- The `active` configuration is the version the Kubelet is currently running with.
- The `assigned` configuration is the latest version the Kubelet has resolved based on
  `Node.Spec.ConfigSource`.
- The `lastKnownGood` configuration is the version the
  Kubelet will fall back to if an invalid config is assigned in `Node.Spec.ConfigSource`.
-->
<h4 id="观察节点开始使用新配置">观察节点开始使用新配置</h4>
<p>用 <code>kubectl get node ${NODE_NAME} -o yaml</code> 命令读取节点并检查 <code>node.status.config</code> 内容。
状态部分报告了对应 <code>active</code>（使用中的）配置、<code>assigned</code>（被赋予的）配置和
<code>lastKnownGood</code>（最近已知可用的）配置的配置源。</p>
<ul>
<li><code>active</code> 是 kubelet 当前运行时所使用的版本。</li>
<li><code>assigned</code> 参数是 kubelet 基于 <code>node.spec.configSource</code> 所解析出来的最新版本。</li>
<li><code>lastKnownGood</code> 参数是 kubelet 的回退版本；如果在 <code>node.spec.configSource</code> 中
包含了无效的配置值，kubelet 可以回退到这个版本。</li>
</ul>
<!--
The`lastKnownGood` configuration might not be present if it is set to its default value,
the local config deployed with the node. The status will update `lastKnownGood` to
match a valid `assigned` config after the Kubelet becomes comfortable with the config.
The details of how the Kubelet determines a config should become the `lastKnownGood` are
not guaranteed by the API, but is currently implemented as a 10-minute grace period.
-->
<p>如果用本地配置部署节点，使其设置成默认值，这个 <code>lastKnownGood</code> 配置可能不存在。
在 kubelet 配置好后，将更新 <code>lastKnownGood</code> 为一个有效的 <code>assigned</code> 配置。
决定如何确定某配置成为 <code>lastKnownGood</code> 配置的细节并不在 API 保障范畴，
不过目前实现中采用了 10 分钟的宽限期。</p>
<!--
You can use the following command (using `jq`) to filter down
to the config status:
-->
<p>你可以使用以下命令（使用 <code>jq</code>）过滤出配置状态：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">kubectl get no <span style="color:#b68;font-weight:bold">${</span><span style="color:#b8860b">NODE_NAME</span><span style="color:#b68;font-weight:bold">}</span> -o json | jq <span style="color:#b44">&#39;.status.config&#39;</span>
</code></pre></div><!--
The following is an example response:
-->
<p>以下是一个响应示例：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-json" data-lang="json">{
  <span style="color:#008000;font-weight:bold">&#34;active&#34;</span>: {
    <span style="color:#008000;font-weight:bold">&#34;configMap&#34;</span>: {
      <span style="color:#008000;font-weight:bold">&#34;kubeletConfigKey&#34;</span>: <span style="color:#b44">&#34;kubelet&#34;</span>,
      <span style="color:#008000;font-weight:bold">&#34;name&#34;</span>: <span style="color:#b44">&#34;my-node-config-9mbkccg2cc&#34;</span>,
      <span style="color:#008000;font-weight:bold">&#34;namespace&#34;</span>: <span style="color:#b44">&#34;kube-system&#34;</span>,
      <span style="color:#008000;font-weight:bold">&#34;resourceVersion&#34;</span>: <span style="color:#b44">&#34;1326&#34;</span>,
      <span style="color:#008000;font-weight:bold">&#34;uid&#34;</span>: <span style="color:#b44">&#34;705ab4f5-6393-11e8-b7cc-42010a800002&#34;</span>
    }
  },
  <span style="color:#008000;font-weight:bold">&#34;assigned&#34;</span>: {
    <span style="color:#008000;font-weight:bold">&#34;configMap&#34;</span>: {
      <span style="color:#008000;font-weight:bold">&#34;kubeletConfigKey&#34;</span>: <span style="color:#b44">&#34;kubelet&#34;</span>,
      <span style="color:#008000;font-weight:bold">&#34;name&#34;</span>: <span style="color:#b44">&#34;my-node-config-9mbkccg2cc&#34;</span>,
      <span style="color:#008000;font-weight:bold">&#34;namespace&#34;</span>: <span style="color:#b44">&#34;kube-system&#34;</span>,
      <span style="color:#008000;font-weight:bold">&#34;resourceVersion&#34;</span>: <span style="color:#b44">&#34;1326&#34;</span>,
      <span style="color:#008000;font-weight:bold">&#34;uid&#34;</span>: <span style="color:#b44">&#34;705ab4f5-6393-11e8-b7cc-42010a800002&#34;</span>
    }
  },
  <span style="color:#008000;font-weight:bold">&#34;lastKnownGood&#34;</span>: {
    <span style="color:#008000;font-weight:bold">&#34;configMap&#34;</span>: {
      <span style="color:#008000;font-weight:bold">&#34;kubeletConfigKey&#34;</span>: <span style="color:#b44">&#34;kubelet&#34;</span>,
      <span style="color:#008000;font-weight:bold">&#34;name&#34;</span>: <span style="color:#b44">&#34;my-node-config-9mbkccg2cc&#34;</span>,
      <span style="color:#008000;font-weight:bold">&#34;namespace&#34;</span>: <span style="color:#b44">&#34;kube-system&#34;</span>,
      <span style="color:#008000;font-weight:bold">&#34;resourceVersion&#34;</span>: <span style="color:#b44">&#34;1326&#34;</span>,
      <span style="color:#008000;font-weight:bold">&#34;uid&#34;</span>: <span style="color:#b44">&#34;705ab4f5-6393-11e8-b7cc-42010a800002&#34;</span>
    }
  }
}
</code></pre></div><!--
If you do not have `jq`, you can look at the whole response and find `Node.Status.Config`
by eye.
-->
<p>如果你没有安装 <code>jq</code>，你可以查看整个响应对象，查找其中的 <code>node.status.config</code>
部分。</p>
<!--
If an error occurs, the Kubelet reports it in the `Node.Status.Config.Error`
structure. Possible errors are listed in
[Understanding Node.Status.Config.Error messages](#understanding-node-config-status-errors).
You can search for the identical text in the Kubelet log for additional details
and context about the error.
-->
<p>如果发生错误，kubelet 会在 <code>Node.Status.Config.Error</code> 中显示出错误信息的结构体。
错误可能出现在列表<a href="#understanding-node-config-status-errors">理解节点状态配置错误信息</a>中。
你可以在 kubelet 日志中搜索相同的文本以获取更多详细信息和有关错误的上下文。</p>
<!--
#### Make more changes

Follow the workflow above to make more changes and push them again. Each time
you push a ConfigMap with new contents, the -append-hash kubectl option creates
the ConfigMap with a new name. The safest rollout strategy is to first create a
new ConfigMap, and then update the Node to use the new ConfigMap.
-->
<h4 id="make-more-changes">做出更多的改变  </h4>
<p>按照下面的工作流程做出更多的改变并再次推送它们。
你每次推送一个 ConfigMap 的新内容时，kubeclt 的 <code>--append-hash</code> 选项都会给
ConfigMap 创建一个新的名称。
最安全的上线策略是首先创建一个新的 ConfigMap，然后更新节点以使用新的 ConfigMap。</p>
<!--
#### Reset the Node to use its local default configuration

To reset the Node to use the configuration it was provisioned with, edit the
Node using `kubectl edit node ${NODE_NAME}` and remove the
`Node.Spec.ConfigSource` field.
-->
<h4 id="重置节点以使用其本地默认配置">重置节点以使用其本地默认配置</h4>
<p>要重置节点，使其使用节点创建时使用的配置，可以用
<code>kubectl edit node $ {NODE_NAME}</code> 命令编辑节点，并删除 <code>node.spec.configSource</code>
字段。</p>
<!-- 
#### Observe that the Node is using its local default configuration

After removing this subfield, `Node.Status.Config` eventually becomes
empty, since all config sources have been reset to `nil`, which indicates that
the local default config is `assigned`, `active`, and `lastKnownGood`, and no
error is reported.
-->
<h4 id="观察节点正在使用本地默认配置">观察节点正在使用本地默认配置</h4>
<p>在删除此字段后，<code>node.status.config</code> 最终变成空，所有配置源都已重置为 <code>nil</code>。
这表示本地默认配置成为了 <code>assigned</code>、<code>active</code> 和 <code>lastKnownGood</code> 配置，
并且没有报告错误。</p>
<!-- discussion -->
<!--
## `kubectl patch` example

You can change a Node's configSource using several different mechanisms.
This example uses `kubectl patch`:
-->
<h2 id="kubectl-patch-示例"><code>kubectl patch</code> 示例</h2>
<p>你可以使用几种不同的机制来更改节点的 configSource。</p>
<p>本例使用<code>kubectl patch</code>：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">kubectl patch node <span style="color:#b68;font-weight:bold">${</span><span style="color:#b8860b">NODE_NAME</span><span style="color:#b68;font-weight:bold">}</span> -p <span style="color:#b44">&#34;{\&#34;spec\&#34;:{\&#34;configSource\&#34;:{\&#34;configMap\&#34;:{\&#34;name\&#34;:\&#34;</span><span style="color:#b68;font-weight:bold">${</span><span style="color:#b8860b">CONFIG_MAP_NAME</span><span style="color:#b68;font-weight:bold">}</span><span style="color:#b44">\&#34;,\&#34;namespace\&#34;:\&#34;kube-system\&#34;,\&#34;kubeletConfigKey\&#34;:\&#34;kubelet\&#34;}}}}&#34;</span>
</code></pre></div><!--
## Understanding how the Kubelet checkpoints config

When a new config is assigned to the Node, the Kubelet downloads and unpacks the
config payload as a set of files on the local disk. The Kubelet also records metadata
that locally tracks the assigned and last-known-good config sources, so that the
Kubelet knows which config to use across restarts, even if the API server becomes
unavailable. After checkpointing a config and the relevant metadata, the Kubelet
exits if it detects that the assigned config has changed. When the Kubelet is
restarted by the OS-level service manager (such as `systemd`), it reads the new
metadata and uses the new config.
-->
<h2 id="了解-kubelet-如何为配置生成检查点">了解 Kubelet 如何为配置生成检查点</h2>
<p>当为节点赋予新配置时，kubelet 会下载并解压配置负载为本地磁盘上的一组文件。
kubelet 还记录一些元数据，用以在本地跟踪已赋予的和最近已知良好的配置源，以便
kubelet 在重新启动时知道使用哪个配置，即使 API 服务器变为不可用。
在为配置信息和相关元数据生成检查点之后，如果检测到已赋予的配置发生改变，则 kubelet 退出。
当 kubelet 被 OS 级服务管理器（例如 <code>systemd</code>）重新启动时，它会读取新的元数据并使用新配置。</p>
<!--
The recorded metadata is fully resolved, meaning that it contains all necessary
information to choose a specific config version - typically a `UID` and `ResourceVersion`.
This is in contrast to `Node.Spec.ConfigSource`, where the intended config is declared
via the idempotent `namespace/name` that identifies the target ConfigMap; the Kubelet
tries to use the latest version of this ConfigMap.
-->
<p>当记录的元数据已被完全解析时，意味着它包含选择一个指定的配置版本所需的所有信息
-- 通常是 <code>UID</code> 和 <code>ResourceVersion</code>。
这与 <code>node.spec.configSource</code> 形成对比，后者通过幂等的 <code>namespace/name</code> 声明来标识
目标 ConfigMap；kubelet 尝试使用此 ConfigMap 的最新版本。</p>
<!--
When you are debugging problems on a node, you can inspect the Kubelet's config
metadata and checkpoints. The structure of the Kubelet's checkpointing directory is:
-->
<p>当你在调试节点上问题时，可以检查 kubelet 的配置元数据和检查点。kubelet 的检查点目录结构是：</p>
<!--
```none
- -dynamic-config-dir (root for managing dynamic config)
| - meta
  | - assigned (encoded kubeletconfig/v1beta1.SerializedNodeConfigSource object, indicating the assigned config)
  | - last-known-good (encoded kubeletconfig/v1beta1.SerializedNodeConfigSource object, indicating the last-known-good config)
| - checkpoints
  | - uid1 (dir for versions of object identified by uid1)
    | - resourceVersion1 (dir for unpacked files from resourceVersion1 of object with uid1)
    | - ...
  | - ...
```
-->
<pre tabindex="0"><code class="language-none" data-lang="none">- --dynamic-config-dir （用于管理动态配置的根目录）
|-- meta
  | - assigned （编码后的 kubeletconfig/v1beta1.SerializedNodeConfigSource 对象，对应赋予的配置）
  | - last-known-good （编码后的 kubeletconfig/v1beta1.SerializedNodeConfigSource 对象，对应最近已知可用配置）
| - checkpoints
  | - uid1 （用 uid1 来标识的对象版本目录)
    | - resourceVersion1 （uid1 对象 resourceVersion1 版本下所有解压文件的目录）
    | - ...
  | - ...
</code></pre><!-- 
## Understanding `Node.Status.Config.Error` messages {#understanding-node-config-status-errors}

The following table describes error messages that can occur
when using Dynamic Kubelet Config. You can search for the identical text
in the Kubelet log for additional details and context about the error.
-->
<h2 id="understanding-node-config-status-errors">理解 <code>Node.Status.Config.Error</code> 消息</h2>
<p>下表描述了使用动态 kubelet 配置时可能发生的错误消息。
你可以在 kubelet 日志中搜索相同的文本来获取有关错误的其他详细信息和上下文。</p>
<!--
Error Message    | Possible Causes
:----------------| :----------------
failed to load config, see Kubelet log for details | The kubelet likely could not parse the downloaded config payload, or encountered a filesystem error attempting to load the payload from disk.
failed to validate config, see Kubelet log for details | The configuration in the payload, combined with any command-line flag overrides, and the sum of feature gates from flags, the config file, and the remote payload, was determined to be invalid by the kubelet.
invalid NodeConfigSource, exactly one subfield must be non-nil, but all were nil | Since Node.Spec.ConfigSource is validated by the API server to contain at least one non-nil subfield, this likely means that the kubelet is older than the API server and does not recognize a newer source type.
failed to sync: failed to download config, see Kubelet log for details | The kubelet could not download the config. It is possible that Node.Spec.ConfigSource could not be resolved to a concrete API object, or that network errors disrupted the download attempt. The kubelet will retry the download when in this error state.
failed to sync: internal failure, see Kubelet log for details | The kubelet encountered some internal problem and failed to update its config as a result. Examples include filesystem errors and reading objects from the internal informer cache.
internal failure, see Kubelet log for details | The kubelet encountered some internal problem while manipulating config, outside of the configuration sync loop.
-->





<table><caption style="display: none;">理解 node.status.config.error 消息</caption>
<thead>
<tr>
<th style="text-align:left">错误信息</th>
<th style="text-align:left">可能的原因</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">failed to load config, see Kubelet log for details</td>
<td style="text-align:left">kubelet 可能无法解析下载配置的有效负载，或者当尝试从磁盘中加载有效负载时，遇到文件系统错误。</td>
</tr>
<tr>
<td style="text-align:left">failed to validate config, see Kubelet log for details</td>
<td style="text-align:left">有效负载中的配置，与命令行标志所产生的覆盖配置以及特行门控的组合、配置文件本身、远程负载被 kubelet 判定为无效。</td>
</tr>
<tr>
<td style="text-align:left">invalid NodeConfigSource, exactly one subfield must be non-nil, but all were nil</td>
<td style="text-align:left">由于 API 服务器负责对 node.spec.configSource 执行验证，检查其中是否包含至少一个非空子字段，这个消息可能意味着 kubelet 比 API 服务器版本低，因而无法识别更新的源类型。</td>
</tr>
<tr>
<td style="text-align:left">failed to sync: failed to download config, see Kubelet log for details</td>
<td style="text-align:left">kubelet 无法下载配置数据。可能是 node.spec.configSource 无法解析为具体的 API 对象，或者网络错误破坏了下载。处于此错误状态时，kubelet 将重新尝试下载。</td>
</tr>
<tr>
<td style="text-align:left">failed to sync: internal failure, see Kubelet log for details</td>
<td style="text-align:left">kubelet 遇到了一些内部问题，因此无法更新其配置。 例如：发生文件系统错误或无法从内部缓存中读取对象。</td>
</tr>
<tr>
<td style="text-align:left">internal failure, see Kubelet log for details</td>
<td style="text-align:left">在对配置进行同步的循环之外操作配置时，kubelet 遇到了一些内部问题。</td>
</tr>
</tbody>
</table>

<h2 id="接下来">接下来</h2>
<!--
- For more information on configuring the kubelet via a configuration file, see
[Set kubelet parameters via a config file](/docs/tasks/administer-cluster/kubelet-config-file).
- See the reference documentation for [`NodeConfigSource`](/docs/reference/generated/kubernetes-api/v1.22/#nodeconfigsource-v1-core)
- Learn more about kubelet configuration by checking the
  [`KubeletConfiguration`](/docs/reference/config-api/kubelet-config.v1beta1/)
  reference.
-->
<ul>
<li>关于如何通过配置文件来配置 kubelet 的更多细节信息，可参阅
<a href="/zh/docs/tasks/administer-cluster/kubelet-config-file">使用配置文件设置 kubelet 参数</a>.</li>
<li>阅读 API 文档中 <a href="/docs/reference/generated/kubernetes-api/v1.22/#nodeconfigsource-v1-core"><code>NodeConfigSource</code></a> 说明</li>
<li>查阅<a href="/docs/reference/config-api/kubelet-config.v1beta1/"><code>KubeletConfiguration</code></a>文献进一步了解 kubelet
配置信息。</li>
</ul>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-a3790dfb57271d13517e549dffa805b9">23 - 声明网络策略</h1>
    
	<!--
reviewers:
- caseydavenport
- danwinship
title: Declare Network Policy
min-kubernetes-server-version: v1.8
content_type: task
-->
<!-- overview -->
<!--
This document helps you get started using the Kubernetes [NetworkPolicy API](/docs/concepts/services-networking/network-policies/) to declare network policies that govern how pods communicate with each other.
-->
<p>本文可以帮助你开始使用 Kubernetes 的
<a href="/zh/docs/concepts/services-networking/network-policies/">NetworkPolicy API</a>
声明网络策略去管理 Pod 之间的通信</p>
<blockquote class="callout caution" role="alert">
  <strong>注意：</strong>
  本部分链接到提供 Kubernetes 所需功能的第三方项目。Kubernetes 项目作者不负责这些项目。此页面遵循<a href="https://github.com/cncf/foundation/blob/master/website-guidelines.md" target="_blank">CNCF 网站指南</a>，按字母顺序列出项目。要将项目添加到此列表中，请在提交更改之前阅读<a href="/docs/contribute/style/content-guide/#third-party-content">内容指南</a>。
</blockquote>
<h2 id="准备开始">准备开始</h2>
<p><p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
如果你还没有集群，你可以通过 <a href="/zh/docs/tasks/tools/#minikube">Minikube</a> 构建一
个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p>
<!--
You need to have a Kubernetes cluster, and the kubectl command-line tool must
be configured to communicate with your cluster. If you do not already have a
cluster, you can create one by using
[minikube](/docs/tasks/tools/#minikube)
or you can use one of these Kubernetes playgrounds:
-->
<ul>
<li><a href="https://www.katacoda.com/courses/kubernetes/playground">Katacoda</a></li>
<li><a href="http://labs.play-with-k8s.com/">玩转 Kubernetes</a></li>
</ul>
 

您的 Kubernetes 服务器版本必须不低于版本 v1.8.
 要获知版本信息，请输入 <code>kubectl version</code>.
</p>
<!--
Make sure you've configured a network provider with network policy support. There are a number of network providers that support NetworkPolicy, including:

* [Calico](/docs/tasks/administer-cluster/network-policy-provider/calico-network-policy/)
* [Cilium](/docs/tasks/administer-cluster/network-policy-provider/cilium-network-policy/)
* [Kube-router](/docs/tasks/administer-cluster/network-policy-provider/kube-router-network-policy/)
* [Romana](/docs/tasks/administer-cluster/network-policy-provider/romana-network-policy/)
* [Weave Net](/docs/tasks/administer-cluster/network-policy-provider/weave-network-policy/)
-->
<p>你首先需要有一个支持网络策略的 Kubernetes 集群。已经有许多支持 NetworkPolicy 的网络提供商，包括：</p>
<ul>
<li><a href="/zh/docs/tasks/administer-cluster/network-policy-provider/calico-network-policy/">Calico</a></li>
<li><a href="/zh/docs/tasks/administer-cluster/network-policy-provider/cilium-network-policy/">Cilium</a></li>
<li><a href="/zh/docs/tasks/administer-cluster/network-policy-provider/kube-router-network-policy/">Kube-router</a></li>
<li><a href="/zh/docs/tasks/administer-cluster/network-policy-provider/romana-network-policy/">Romana</a></li>
<li><a href="/zh/docs/tasks/administer-cluster/network-policy-provider/weave-network-policy/">Weave 网络</a></li>
</ul>
<!-- steps -->
<!--
## Create an `nginx` deployment and expose it via a service

To see how Kubernetes network policy works, start off by creating an `nginx` Deployment.
-->
<h2 id="创建一个-nginx-deployment-并且通过服务将其暴露">创建一个<code>nginx</code> Deployment 并且通过服务将其暴露</h2>
<p>为了查看 Kubernetes 网络策略是怎样工作的，可以从创建一个<code>nginx</code> Deployment 并且通过服务将其暴露开始</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl create deployment nginx --image<span style="color:#666">=</span>nginx
</code></pre></div><pre tabindex="0"><code class="language-none" data-lang="none">deployment.apps/nginx created
</code></pre><!--
Expose the Deployment through a Service called `nginx`.
-->
<p>将此 Deployment 以名为 <code>nginx</code> 的 Service 暴露出来：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl expose deployment nginx --port<span style="color:#666">=</span><span style="color:#666">80</span>
</code></pre></div><pre tabindex="0"><code class="language-none" data-lang="none">service/nginx exposed
</code></pre><!--
The above commands create a Deployment with an nginx Pod and expose the Deployment through a Service named `nginx`. The `nginx` Pod and Deployment are found in the `default` namespace.
-->
<p>上述命令创建了一个带有一个 nginx 的 Deployment，并将之通过名为 <code>nginx</code> 的
Service 暴露出来。名为 <code>nginx</code> 的 Pod 和 Deployment 都位于 <code>default</code>
名字空间内。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl get svc,pod
</code></pre></div><pre tabindex="0"><code class="language-none" data-lang="none">NAME                        CLUSTER-IP    EXTERNAL-IP   PORT(S)    AGE
svc/kubernetes              10.100.0.1    &lt;none&gt;        443/TCP    46m
svc/nginx                   10.100.0.16   &lt;none&gt;        80/TCP     33s

NAME                        READY         STATUS        RESTARTS   AGE
po/nginx-701339712-e0qfq    1/1           Running       0          35s
</code></pre><!--
## Test the service by accessing it from another Pod

You should be able to access the new `nginx` service from other Pods. To access the `nginx` Service from another Pod in the `default` namespace, start a busybox container:
-->
<h2 id="通过从-pod-访问服务对其进行测试">通过从 Pod 访问服务对其进行测试</h2>
<p>你应该可以从其它的 Pod 访问这个新的 <code>nginx</code> 服务。
要从 default 命名空间中的其它s Pod 来访问该服务。可以启动一个 busybox 容器：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl run busybox --rm -ti --image<span style="color:#666">=</span>busybox /bin/sh
</code></pre></div><!--
In your shell, run the following command:
-->
<p>在你的 Shell 中，运行下面的命令：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">wget --spider --timeout<span style="color:#666">=</span><span style="color:#666">1</span> nginx
</code></pre></div><pre tabindex="0"><code class="language-none" data-lang="none">Connecting to nginx (10.100.0.16:80)
remote file exists
</code></pre><!--
## Limit access to the `nginx` service

To limit the access to the `nginx` service so that only Pods with the label `access: true` can query it, create a NetworkPolicy object as follows:
-->
<h2 id="限制-nginx-服务的访问">限制 <code>nginx</code> 服务的访问</h2>
<p>如果想限制对 <code>nginx</code> 服务的访问，只让那些拥有标签 <code>access: true</code> 的 Pod 访问它，
那么可以创建一个如下所示的 NetworkPolicy 对象：</p>


 













<div class="highlight">
    <div class="copy-code-icon" style="text-align:right">
    <a href="https://raw.githubusercontent.com/kubernetes/website/main/content/zh/examples/service/networking/nginx-policy.yaml" download="service/networking/nginx-policy.yaml"><code>service/networking/nginx-policy.yaml</code>
    </a>
    <img src="/images/copycode.svg" style="max-height:24px; cursor: pointer" onclick="copyCode('service-networking-nginx-policy-yaml')" title="Copy service/networking/nginx-policy.yaml to clipboard">
    </img>
    </div>
    <div class="includecode" id="service-networking-nginx-policy-yaml">
    <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>networking.k8s.io/v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>NetworkPolicy<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>access-nginx<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">spec</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">podSelector</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">matchLabels</span>:<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">app</span>:<span style="color:#bbb"> </span>nginx<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">ingress</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- <span style="color:#008000;font-weight:bold">from</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span>- <span style="color:#008000;font-weight:bold">podSelector</span>:<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#008000;font-weight:bold">matchLabels</span>:<span style="color:#bbb">
</span><span style="color:#bbb">          </span><span style="color:#008000;font-weight:bold">access</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;true&#34;</span><span style="color:#bbb">
</span></code></pre></div>
    </div>
</div>


<!--
The name of a NetworkPolicy object must be a valid
[DNS subdomain name](/docs/concepts/overview/working-with-objects/names#dns-subdomain-names).
-->
<p>NetworkPolicy 对象的名称必须是一个合法的
<a href="/zh/docs/concepts/overview/working-with-objects/names#dns-subdomain-names">DNS 子域名</a>.</p>
<!--
NetworkPolicy includes a `podSelector` which selects the grouping of Pods to which the policy applies. You can see this policy selects Pods with the label `app=nginx`. The label was automatically added to the Pod in the `nginx` Deployment. An empty `podSelector` selects all pods in the namespace.
-->
<blockquote class="note callout">
  <div><strong>说明：</strong> NetworkPolicy 中包含选择策略所适用的 Pods 集合的 <code>podSelector</code>。
你可以看到上面的策略选择的是带有标签 <code>app=nginx</code> 的 Pods。
此标签是被自动添加到 <code>nginx</code> Deployment 中的 Pod 上的。
如果 <code>podSelector</code> 为空，则意味着选择的是名字空间中的所有 Pods。</div>
</blockquote>
<!--
## Assign the policy to the service

Use kubectl to create a NetworkPolicy from the above `nginx-policy.yaml` file:
-->
<h2 id="为服务指定策略">为服务指定策略</h2>
<p>使用 kubectl 根据上面的 <code>nginx-policy.yaml</code> 文件创建一个 NetworkPolicy：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl apply -f https://k8s.io/examples/service/networking/nginx-policy.yaml
</code></pre></div><pre tabindex="0"><code class="language-none" data-lang="none">networkpolicy.networking.k8s.io/access-nginx created
</code></pre><!--
## Test access to the service when access label is not defined

When you attempt to access the `nginx` Service from a Pod without the correct labels, the request times out:
-->
<h2 id="测试没有定义访问标签时访问服务">测试没有定义访问标签时访问服务</h2>
<p>如果你尝试从没有设定正确标签的 Pod 中去访问 <code>nginx</code> 服务，请求将会超时：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl run busybox --rm -ti --image<span style="color:#666">=</span>busybox -- /bin/sh
</code></pre></div><!--
In your shell, run the command:
-->
<p>在 Shell 中运行命令：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">wget --spider --timeout<span style="color:#666">=</span><span style="color:#666">1</span> nginx
</code></pre></div><pre tabindex="0"><code class="language-none" data-lang="none">Connecting to nginx (10.100.0.16:80)
wget: download timed out
</code></pre><!--
## Define access label and test again

You can create a Pod with the correct labels to see that the request is allowed:
-->
<h2 id="定义访问标签后再次测试">定义访问标签后再次测试</h2>
<p>创建一个拥有正确标签的 Pod，你将看到请求是被允许的：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl run busybox --rm -ti --labels<span style="color:#666">=</span><span style="color:#b44">&#34;access=true&#34;</span> --image<span style="color:#666">=</span>busybox -- /bin/sh
</code></pre></div><!--
In your shell, run the command:
-->
<p>在 Shell 中运行命令：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">wget --spider --timeout<span style="color:#666">=</span><span style="color:#666">1</span> nginx
</code></pre></div><pre tabindex="0"><code class="language-none" data-lang="none">Connecting to nginx (10.100.0.16:80)
remote file exists
</code></pre>
</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-b35b8ddb9bbc15620ce9636f4346c05c">24 - 安全地清空一个节点</h1>
    
	<!--
reviewers:
- davidopp
- mml
- foxish
- kow3ns
title: Safely Drain a Node
content_type: task
min-kubernetes-server-version: 1.5
-->
<!-- overview -->
<!-- 
This page shows how to safely drain a node, respecting the PodDisruptionBudget you have defined.
 -->
<p>本页展示了如何在确保 PodDisruptionBudget 的前提下，安全地清空一个<a class='glossary-tooltip' title='Kubernetes 中的工作机器称作节点。' data-toggle='tooltip' data-placement='top' href='/zh/docs/concepts/architecture/nodes/' target='_blank' aria-label='节点'>节点</a>。</p>
<h2 id="准备开始">准备开始</h2>
<p>您的 Kubernetes 服务器版本必须不低于版本 1.5.
要获知版本信息，请输入 <code>kubectl version</code>.</p>
<!-- 
This task assumes that you have met the following prerequisites:

* You are using Kubernetes release >= 1.5.
* Either:
  1. You do not require your applications to be highly available during the
     node drain, or
  2. You have read about the [PodDisruptionBudget concept](/docs/concepts/workloads/pods/disruptions/)
     and [Configured PodDisruptionBudgets](/docs/tasks/run-application/configure-pdb/) for
     applications that need them.
-->
<p>此任务假定你已经满足了以下先决条件：</p>
<ul>
<li>使用的 Kubernetes 版本 &gt;= 1.5。</li>
<li>以下两项，具备其一：
<ol>
<li>在节点清空期间，不要求应用程序具有高可用性</li>
<li>你已经了解了 <a href="/zh/docs/concepts/workloads/pods/disruptions/">PodDisruptionBudget 的概念</a>，
并为需要它的应用程序<a href="/zh/docs/tasks/run-application/configure-pdb/">配置了 PodDisruptionBudget</a>。</li>
</ol>
</li>
</ul>
<!-- steps -->
<!--
## (Optional) Configure a disruption budget {#configure-poddisruptionbudget}

To endure that your workloads remain available during maintenance, you can
configure a [PodDisruptionBudget](/docs/concepts/workloads/pods/disruptions/).

If availability is important for any applications that run or could run on the node(s)
that you are draining, [configure a PodDisruptionBudgets](/docs/tasks/run-application/configure-pdb/)
first and the continue following this guide.
-->
<h2 id="configure-poddisruptionbudget">（可选） 配置干扰预算</h2>
<p>为了确保你的负载在维护期间仍然可用，你可以配置一个 <a href="/zh/docs/concepts/workloads/pods/disruptions/">PodDisruptionBudget</a>。
如果可用性对于正在清空的该节点上运行或可能在该节点上运行的任何应用程序很重要，
首先 <a href="/zh/docs/tasks/run-application/configure-pdb/">配置一个 PodDisruptionBudgets</a> 并继续遵循本指南。</p>
<!-- 
## Use `kubectl drain` to remove a node from service

You can use `kubectl drain` to safely evict all of your pods from a
node before you perform maintenance on the node (e.g. kernel upgrade,
hardware maintenance, etc.). Safe evictions allow the pod's containers
to [gracefully terminate](/docs/concepts/workloads/pods/pod-lifecycle/#pod-termination)
and will respect the `PodDisruptionBudgets` you have specified.
-->
<h2 id="use-kubectl-drain-to-remove-a-node-from-service">使用 <code>kubectl drain</code> 从服务中删除一个节点</h2>
<p>在对节点执行维护（例如内核升级、硬件维护等）之前，
可以使用 <code>kubectl drain</code> 从节点安全地逐出所有 Pods。
安全的驱逐过程允许 Pod 的容器
<a href="/zh/docs/concepts/workloads/pods/pod-lifecycle/#pod-termination">体面地终止</a>，
并确保满足指定的 PodDisruptionBudgets。</p>
<!-- 
By default `kubectl drain` will ignore certain system pods on the node
that cannot be killed; see
the [kubectl drain](/docs/reference/generated/kubectl/kubectl-commands/#drain)
documentation for more details.
-->
<blockquote class="note callout">
  <div><strong>说明：</strong> 默认情况下， <code>kubectl drain</code> 将忽略节点上不能杀死的特定系统 Pod；
有关更多细节，请参阅
<a href="/docs/reference/generated/kubectl/kubectl-commands/#drain">kubectl drain</a> 文档。</div>
</blockquote>
<!-- 
When `kubectl drain` returns successfully, that indicates that all of
the pods (except the ones excluded as described in the previous paragraph)
have been safely evicted (respecting the desired graceful termination period,
and respecting the PodDisruptionBudget you have defined). It is then safe to
bring down the node by powering down its physical machine or, if running on a
cloud platform, deleting its virtual machine.

First, identify the name of the node you wish to drain. You can list all of the nodes in your cluster with
-->
<p><code>kubectl drain</code> 的成功返回，表明所有的 Pods（除了上一段中描述的被排除的那些），
已经被安全地逐出（考虑到期望的终止宽限期和你定义的 PodDisruptionBudget）。
然后就可以安全地关闭节点，
比如关闭物理机器的电源，如果它运行在云平台上，则删除它的虚拟机。</p>
<p>首先，确定想要清空的节点的名称。可以用以下命令列出集群中的所有节点:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl get nodes
</code></pre></div><!-- 
Next, tell Kubernetes to drain the node:
-->
<p>接下来，告诉 Kubernetes 清空节点：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl drain &lt;node name&gt;
</code></pre></div><!-- 
Once it returns (without giving an error), you can power down the node
(or equivalently, if on a cloud platform, delete the virtual machine backing the node).
If you leave the node in the cluster during the maintenance operation, you need to run
-->
<p>一旦它返回（没有报错），
你就可以下线此节点（或者等价地，如果在云平台上，删除支持该节点的虚拟机）。
如果要在维护操作期间将节点留在集群中，则需要运行：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl uncordon &lt;node name&gt;
</code></pre></div><!-- 
afterwards to tell Kubernetes that it can resume scheduling new pods onto the node.
-->
<p>然后告诉 Kubernetes，它可以继续在此节点上调度新的 Pods。</p>
<!-- 
## Draining multiple nodes in parallel

The `kubectl drain` command should only be issued to a single node at a
time. However, you can run multiple `kubectl drain` commands for
different nodes in parallel, in different terminals or in the
background. Multiple drain commands running concurrently will still
respect the `PodDisruptionBudget` you specify.
-->
<h2 id="draining-multiple-nodes-in-parallel">并行清空多个节点 </h2>
<p><code>kubectl drain</code> 命令一次只能发送给一个节点。
但是，你可以在不同的终端或后台为不同的节点并行地运行多个 <code>kubectl drain</code> 命令。
同时运行的多个 drain 命令仍然遵循你指定的 PodDisruptionBudget 。</p>
<!-- 
For example, if you have a StatefulSet with three replicas and have
set a PodDisruptionBudget for that set specifying `minAvailable: 2`,
`kubectl drain` only evicts a pod from the StatefulSet if all three
replicas pods are ready; if then you issue multiple drain commands in
parallel, Kubernetes respects the PodDisruptionBudget and ensure
that only 1 (calculated as `replicas - minAvailable`) Pod is unavailable
at any given time. Any drains that would cause the number of ready
replicas to fall below the specified budget are blocked.
-->
<p>例如，如果你有一个三副本的 StatefulSet，
并设置了一个 <code>PodDisruptionBudget</code>，指定 <code>minAvailable: 2</code>。
如果所有的三个 Pod 均就绪，并且你并行地发出多个 drain 命令，
那么 <code>kubectl drain</code> 只会从 StatefulSet 中逐出一个 Pod，
因为 Kubernetes 会遵守 PodDisruptionBudget 并确保在任何时候只有一个 Pod 不可用
（最多不可用 Pod 个数的计算方法：<code>replicas - minAvailable</code>）。
任何会导致就绪副本数量低于指定预算的清空操作都将被阻止。</p>
<!-- 
## The Eviction API

If you prefer not to use [kubectl drain](/docs/reference/generated/kubectl/kubectl-commands/#drain) (such as
to avoid calling to an external command, or to get finer control over the pod
eviction process), you can also programmatically cause evictions using the eviction API.
-->
<h2 id="the-eviction-api">驱逐 API</h2>
<p>如果你不喜欢使用
<a href="/docs/reference/generated/kubectl/kubectl-commands/#drain">kubectl drain</a>
（比如避免调用外部命令，或者更细化地控制 pod 驱逐过程），
你也可以用驱逐 API 通过编程的方式达到驱逐的效果。</p>
<!-- 
You should first be familiar with using [Kubernetes language clients](/docs/tasks/administer-cluster/access-cluster-api/#programmatic-access-to-the-api).

The eviction subresource of a
pod can be thought of as a kind of policy-controlled DELETE operation on the pod
itself. To attempt an eviction (perhaps more REST-precisely, to attempt to
*create* an eviction), you POST an attempted operation. Here's an example:
-->
<p>首先应该熟悉使用
<a href="/zh/docs/tasks/administer-cluster/access-cluster-api/#programmatic-access-to-the-api">Kubernetes 语言客户端</a>。</p>
<p>Pod 的 Eviction 子资源可以看作是一种策略控制的 DELETE 操作，作用于 Pod 本身。
要尝试驱逐（更准确地说，尝试 <em>创建</em> 一个 Eviction），需要用 POST 发出所尝试的操作。这里有一个例子：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-json" data-lang="json">{
  <span style="color:#008000;font-weight:bold">&#34;apiVersion&#34;</span>: <span style="color:#b44">&#34;policy/v1beta1&#34;</span>,
  <span style="color:#008000;font-weight:bold">&#34;kind&#34;</span>: <span style="color:#b44">&#34;Eviction&#34;</span>,
  <span style="color:#008000;font-weight:bold">&#34;metadata&#34;</span>: {
    <span style="color:#008000;font-weight:bold">&#34;name&#34;</span>: <span style="color:#b44">&#34;quux&#34;</span>,
    <span style="color:#008000;font-weight:bold">&#34;namespace&#34;</span>: <span style="color:#b44">&#34;default&#34;</span>
  }
}
</code></pre></div><!-- 
You can attempt an eviction using `curl`:
-->
<p>你可以使用 <code>curl</code> 尝试驱逐：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">curl -v -H <span style="color:#b44">&#39;Content-type: application/json&#39;</span> http://127.0.0.1:8080/api/v1/namespaces/default/pods/quux/eviction -d @eviction.json
</code></pre></div><!-- 
The API can respond in one of three ways:

- If the eviction is granted, then the pod is deleted just as if you had sent
  a `DELETE` request to the pod's URL and you get back `200 OK`.
- If the current state of affairs wouldn't allow an eviction by the rules set
  forth in the budget, you get back `429 Too Many Requests`. This is
  typically used for generic rate limiting of *any* requests, but here we mean
  that this request isn't allowed *right now* but it may be allowed later.
  Currently, callers do not get any `Retry-After` advice, but they may in
  future versions.
- If there is some kind of misconfiguration, like multiple budgets pointing at
  the same pod, you will get `500 Internal Server Error`.
-->
<p>API 可以通过以下三种方式之一进行响应：</p>
<ul>
<li>如果驱逐被授权，那么 Pod 将被删掉，并且你会收到 <code>200 OK</code>，
就像你向 Pod 的 URL 发送了 <code>DELETE</code> 请求一样。</li>
<li>如果按照预算中规定，目前的情况不允许的驱逐，你会收到 <code>429 Too Many Requests</code>。
这通常用于对 <em>一些</em> 请求进行通用速率限制，
但这里我们的意思是：此请求 <em>现在</em> 不允许，但以后可能会允许。
目前，调用者不会得到任何 <code>Retry-After</code> 的提示，但在将来的版本中可能会得到。</li>
<li>如果有一些错误的配置，比如多个预算指向同一个 Pod，你将得到 <code>500 Internal Server Error</code>。</li>
</ul>
<!-- 
For a given eviction request, there are two cases:

- There is no budget that matches this pod. In this case, the server always
  returns `200 OK`.
- There is at least one budget. In this case, any of the three above responses may
   apply.
-->
<p>对于一个给定的驱逐请求，有两种情况：</p>
<ul>
<li>没有匹配这个 Pod 的预算。这种情况，服务器总是返回 <code>200 OK</code>。</li>
<li>至少匹配一个预算。在这种情况下，上述三种回答中的任何一种都可能适用。</li>
</ul>
<!-- 
## Stuck evictions

In some cases, an application may reach a broken state, one where unless you intervene the
eviction API will never return anything other than 429 or 500.

For example: this can happen if ReplicaSet is creating Pods for your application but
the replacement Pods do not become `Ready`. You can also see similar symptoms if the
last Pod evicted has a very long termination grace period.
-->
<h2 id="驱逐阻塞">驱逐阻塞</h2>
<p>在某些情况下，应用程序可能会到达一个中断状态，除了 429 或 500 之外，它将永远不会返回任何内容。
例如 ReplicaSet 创建的替换 Pod 没有变成就绪状态，或者被驱逐的最后一个
Pod 有很长的终止宽限期，就会发生这种情况。</p>
<!--
In this case, there are two potential solutions:

- Abort or pause the automated operation. Investigate the reason for the stuck application,
  and restart the automation.
- After a suitably long wait, `DELETE` the Pod from your cluster's control plane, instead
  of using the eviction API.

Kubernetes does not specify what the behavior should be in this case; it is up to the
application owners and cluster owners to establish an agreement on behavior in these cases.
-->
<p>在这种情况下，有两种可能的解决方案：</p>
<ul>
<li>中止或暂停自动操作。调查应用程序卡住的原因，并重新启动自动化。</li>
<li>经过适当的长时间等待后，从集群中删除 Pod 而不是使用驱逐 API。</li>
</ul>
<p>Kubernetes 并没有具体说明在这种情况下应该采取什么行为，
这应该由应用程序所有者和集群所有者紧密沟通，并达成对行动一致意见。</p>
<h2 id="接下来">接下来</h2>
<!-- 
* Follow steps to protect your application by [configuring a Pod Disruption Budget](/docs/tasks/run-application/configure-pdb/).
-->
<ul>
<li>执行<a href="/zh/docs/tasks/run-application/configure-pdb/">配置 PDB</a>中的各个步骤，
保护你的应用</li>
</ul>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-a24171610b6ea75a142cb9c8c7882390">25 - 将重复的控制平面迁至云控制器管理器</h1>
    
	<!--
---
reviewers:
- jpbetz
- cheftako
title: "Migrate Replicated Control Plane To Use Cloud Controller Manager"
linkTitle: "Migrate Replicated Control Plane To Use Cloud Controller Manager"
content_type: task
---
-->
<!-- overview -->





<div style="margin-top: 10px; margin-bottom: 10px;">
<b>FEATURE STATE:</b> <code>Kubernetes v1.22 [beta]</code>
</div>

<!--
title: Cloud Controller Manager
id: cloud-controller-manager
date: 2018-04-12
full_link: /docs/concepts/architecture/cloud-controller/
short_description: >
  Control plane component that integrates Kubernetes with third-party cloud providers.

aka: 
tags:
- core-object
- architecture
- operation
-->
<!--
 A Kubernetes <a class='glossary-tooltip' title='控制平面是指容器编排层，它暴露 API 和接口来定义、部署容器和管理容器的生命周期。' data-toggle='tooltip' data-placement='top' href='/zh/docs/reference/glossary/?all=true#term-control-plane' target='_blank' aria-label='control plane'>control plane</a> component
that embeds cloud-specific control logic. The cloud controller manager lets you link your
cluster into your cloud provider's API, and separates out the components that interact
with that cloud platform from components that only interact with your cluster.
-->
<p><p>云管理控制器是 云控制器管理器是指嵌入特定云的控制逻辑的
<a class='glossary-tooltip' title='控制平面是指容器编排层，它暴露 API 和接口来定义、部署容器和管理容器的生命周期。' data-toggle='tooltip' data-placement='top' href='/zh/docs/reference/glossary/?all=true#term-control-plane' target='_blank' aria-label='控制平面'>控制平面</a>组件。
云控制器管理器使得你可以将你的集群连接到云提供商的 API 之上，
并将与该云平台交互的组件同与你的集群交互的组件分离开来。</p></p>
<!--
By decoupling the interoperability logic between Kubernetes and the underlying cloud
infrastructure, the cloud-controller-manager component enables cloud providers to release
features at a different pace compared to the main Kubernetes project.
-->
<p>通过分离 Kubernetes 和底层云基础设置之间的互操作性逻辑，
云控制器管理器组件使云提供商能够以不同于 Kubernetes 主项目的
步调发布新特征。</p>
<!--
## Background

As part of the [cloud provider extraction effort](https://kubernetes.io/blog/2019/04/17/the-future-of-cloud-providers-in-kubernetes/),
all cloud specific controllers must be moved out of the `kube-controller-manager`. 
All existing clusters that run cloud controllers in the `kube-controller-manager` must migrate to instead run the controllers in a cloud provider specific `cloud-controller-manager`.

Leader Migration provides a mechanism in which HA clusters can safely migrate "cloud specific" controllers between 
the `kube-controller-manager` and the `cloud-controller-manager` via a shared resource lock between the two components while upgrading the replicated control plane. 
For a single-node control plane, or if unavailability of controller managers can be tolerated during the upgrade, Leader Migration is not needed and this guide can be ignored.
-->
<h2 id="背景">背景</h2>
<p>作为<a href="https://kubernetes.io/blog/2019/04/17/the-future-of-cloud-providers-in-kubernetes/">云驱动提取工作</a>
的一部分，所有特定于云的控制器都必须移出 <code>kube-controller-manager</code>。
所有在 <code>kube-controller-manager</code> 中运行云控制器的现有集群必须迁移到云驱动特定的 <code>cloud-controller-manager</code> 中运行控制器。</p>
<p>领导者迁移提供了一种机制，使得 HA 集群可以通过两个组件之间的共享资源锁定，
安全地将“特定于云”的控制器从 <code>kube-controller-manager</code> 和迁移到<code>cloud-controller-manager</code>，
同时升级复制的控制平面。
对于单节点控制平面，或者在升级过程中可以容忍控制器管理器不可用的情况，则不需要领导者迁移，并且可以忽略本指南。</p>
<!--
Leader Migration can be enabled by setting `--enable-leader-migration` on `kube-controller-manager` or `cloud-controller-manager`.
Leader Migration only applies during the upgrade and can be safely disabled or left enabled after the upgrade is complete.

This guide walks you through the manual process of upgrading the control plane from `kube-controller-manager` with 
built-in cloud provider to running both `kube-controller-manager` and `cloud-controller-manager`. 
If you use a tool to administrator the cluster, please refer to the documentation of the tool and the cloud provider for more details.
-->
<p>领导者迁移可以通过在 <code>kube-controller-manager</code> 或 <code>cloud-controller-manager</code> 上设置 <code>--enable-leader-migration</code> 来启用。
领导者迁移仅在升级期间适用，并且可以安全地禁用，也可以在升级完成后保持启用状态。</p>
<p>本指南将引导你手动将控制平面从内置的云驱动的 <code>kube-controller-manager</code> 升级为
同时运行 <code>kube-controller-manager</code> 和 <code>cloud-controller-manager</code>。
如果使用工具来管理群集，请参阅对应工具和云驱动的文档以获取更多详细信息。</p>
<h2 id="准备开始">准备开始</h2>
<!--
It is assumed that the control plane is running Kubernetes version N and to be upgraded to version N + 1. 
Although it is possible to migrate within the same version, ideally the migration should be performed as part of a upgrade so that changes of configuration can be aligned to each release. 
The exact versions of N and N + 1 depend on each cloud provider. For example, if a cloud provider builds a `cloud-controller-manager` to work with Kubernetes 1.22, then N can be 1.21 and N + 1 can be 1.22.

The control plane nodes should run `kube-controller-manager` with Leader Election enabled through `--leader-elect=true`. 
As of version N, an in-tree cloud privider must be set with `--cloud-provider` flag and `cloud-controller-manager` should not yet be deployed.
-->
<p>假定控制平面正在运行 Kubernetes N 版本，并且要升级到 N+1 版本。
尽管可以在同一版本中进行迁移，但理想情况下，迁移应作为升级的一部分执行，以便可以更改配置与每个发布版本保持一致。
N 和 N+1的确切版本取决于各个云驱动。例如，如果云驱动构建了一个可与 Kubernetes 1.22 配合使用的 <code>cloud-controller-manager</code>，
则 N 可以为 1.21，N+1 可以为 1.22。</p>
<p>控制平面节点应运行 <code>kube-controller-manager</code>，并通过 <code>--leader-elect=true</code> 启用领导者选举。
从版本 N 开始，树内云驱动必须设置 <code>--cloud-provider</code> 标志，而且 <code>cloud-controller-manager</code> 尚未部署。</p>
<!--
The out-of-tree cloud provider must have built a `cloud-controller-manager` with Leader Migration implementation. 
If the cloud provider imports `k8s.io/cloud-provider` and `k8s.io/controller-manager` of version v0.21.0 or later, Leader Migration will be available.
However, for version before v0.22.0, Leader Migration is alpha and requires feature gate `ControllerManagerLeaderMigration` to be enabled.

This guide assumes that kubelet of each control plane node starts `kube-controller-manager` 
and `cloud-controller-manager` as static pods defined by their manifests. 
If the components run in a different setting, please adjust the steps accordingly.

For authorization, this guide assumes that the cluster uses RBAC. 
If another authorization mode grants permissions to `kube-controller-manager` and `cloud-controller-manager` components, 
please grant the needed access in a way that matches the mode.
-->
<p>树外云驱动必须已经构建了一个实现领导者迁移的 <code>cloud-controller-manager</code>。
如果云驱动导入了 v0.21.0 或更高版本的 <code>k8s.io/cloud-provider</code> 和 <code>k8s.io/controller-manager</code>，
则可以进行领导者迁移。
但是，对 v0.22.0 以下的版本，领导者迁移是一项 Alpha 阶段功能，它需要启用特性门控 <code>ControllerManagerLeaderMigration</code>。</p>
<p>本指南假定每个控制平面节点的 kubelet 以静态 pod 的形式启动 <code>kube-controller-manager</code>
和 <code>cloud-controller-manager</code>，静态 pod 的定义在清单文件中。
如果组件以其他设置运行，请相应地调整步骤。</p>
<p>为了获得授权，本指南假定集群使用 RBAC。
如果其他授权模式授予 <code>kube-controller-manager</code> 和 <code>cloud-controller-manager</code> 组件权限，
请以与该模式匹配的方式授予所需的访问权限。</p>
<!-- steps -->
<!--
### Grant access to Migration Lease

The default permissions of the controller manager allow only accesses to their main Lease.
In order for the migration to work, accesses to another Lease are required.

You can grant `kube-controller-manager` full access to the leases API by modifying 
the `system::leader-locking-kube-controller-manager` role. 
This task guide assumes that the name of the migration lease is `cloud-provider-extraction-migration`.

`kubectl patch -n kube-system role 'system::leader-locking-kube-controller-manager' -p '{"rules": [ {"apiGroups":[ "coordination.k8s.io"], "resources": ["leases"], "resourceNames": ["cloud-provider-extraction-migration"], "verbs": ["create", "list", "get", "update"] } ]}' --type=merge`

Do the same to the `system::leader-locking-cloud-controller-manager` role.

`kubectl patch -n kube-system role 'system::leader-locking-cloud-controller-manager' -p '{"rules": [ {"apiGroups":[ "coordination.k8s.io"], "resources": ["leases"], "resourceNames": ["cloud-provider-extraction-migration"], "verbs": ["create", "list", "get", "update"] } ]}' --type=merge`
-->
<h3 id="授予访问迁移-lease-的权限">授予访问迁移 Lease 的权限</h3>
<p>控制器管理器的默认权限仅允许访问其主 Lease 对象。为了使迁移正常进行，需要访问其他 Lease 对象。</p>
<p>你可以通过修改 <code>system::leader-locking-kube-controller-manager</code> 角色来授予
<code>kube-controller-manager</code> 对 Lease API 的完全访问权限。
本任务指南假定迁移 Lease 的名称为 <code>cloud-provider-extraction-migration</code>。</p>
<p><code>kubectl patch -n kube-system role 'system::leader-locking-kube-controller-manager' -p '{&quot;rules&quot;: [ {&quot;apiGroups&quot;:[ &quot;coordination.k8s.io&quot;], &quot;resources&quot;: [&quot;leases&quot;], &quot;resourceNames&quot;: [&quot;cloud-provider-extraction-migration&quot;], &quot;verbs&quot;: [&quot;create&quot;, &quot;list&quot;, &quot;get&quot;, &quot;update&quot;] } ]}' --type=merge</code></p>
<p>对 <code>system::leader-locking-cloud-controller-manager</code> 角色执行相同的操作。</p>
<p><code>kubectl patch -n kube-system role 'system::leader-locking-cloud-controller-manager' -p '{&quot;rules&quot;: [ {&quot;apiGroups&quot;:[ &quot;coordination.k8s.io&quot;], &quot;resources&quot;: [&quot;leases&quot;], &quot;resourceNames&quot;: [&quot;cloud-provider-extraction-migration&quot;], &quot;verbs&quot;: [&quot;create&quot;, &quot;list&quot;, &quot;get&quot;, &quot;update&quot;] } ]}' --type=merge</code></p>
<!--
### Initial Leader Migration configuration

Leader Migration optionally takes a configuration file representing the state of controller-to-manager assignment. At this moment, with in-tree cloud provider, `kube-controller-manager` runs `route`, `service`, and `cloud-node-lifecycle`. The following example configuration shows the assignment.

Leader Migration can be enabled without a configuration. Please see [Default Configuration](#default-configuration) for details.
-->
<h3 id="初始领导者迁移配置">初始领导者迁移配置</h3>
<p>领导者迁移可以选择使用一个表示控制器到管理器分配状态的配置文件。
目前，对于树内云驱动，<code>kube-controller-manager</code> 运行 <code>route</code>、<code>service</code> 和 <code>cloud-node-lifecycle</code>。
以下示例配置显示了分配。</p>
<p>领导者迁移可以不指定配置来启用。请参阅 <a href="#default-configuration">默认配置</a> 以获取更多详细信息。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>LeaderMigrationConfiguration<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>controllermanager.config.k8s.io/v1beta1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">leaderName</span>:<span style="color:#bbb"> </span>cloud-provider-extraction-migration<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">resourceLock</span>:<span style="color:#bbb"> </span>leases<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">controllerLeaders</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>route<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">component</span>:<span style="color:#bbb"> </span>kube-controller-manager<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>service<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">component</span>:<span style="color:#bbb"> </span>kube-controller-manager<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>cloud-node-lifecycle<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">component</span>:<span style="color:#bbb"> </span>kube-controller-manager<span style="color:#bbb">
</span></code></pre></div><!--
On each control plane node, save the content to `/etc/leadermigration.conf`, 
and update the manifest of `kube-controller-manager` so that the file is mounted inside the container at the same location. 
Also, update the same manifest to add the following arguments:

- `--enable-leader-migration` to enable Leader Migration on the controller manager
- `--leader-migration-config=/etc/leadermigration.conf` to set configuration file

Restart `kube-controller-manager` on each node. At this moment, `kube-controller-manager` has leader migration enabled and is ready for the migration.
-->
<p>在每个控制平面节点上，将内容保存到 <code>/etc/leadermigration.conf</code> 中，
并更新 <code>kube-controller-manager</code> 清单，以便将文件安装在容器内的同一位置。
另外，更新相同的清单，添加以下参数：</p>
<ul>
<li><code>--enable-leader-migration</code> 在控制器管理器上启用领导者迁移</li>
<li><code>--leader-migration-config=/etc/leadermigration.conf</code> 设置配置文件</li>
</ul>
<p>在每个节点上重新启动 <code>kube-controller-manager</code>。这时，<code>kube-controller-manager</code>
已启用领导者迁移，并准备进行迁移。</p>
<!--
### Deploy Cloud Controller Manager

In version N + 1, the desired state of controller-to-manager assignment can be represented by a new configuration file, shown as follows. 
Please note `component` field of each `controllerLeaders` changing from `kube-controller-manager` to `cloud-controller-manager`.
-->
<h3 id="部署云控制器管理器">部署云控制器管理器</h3>
<p>在 N+1 版本中，控制器到管理器分配的期望状态可以由新的配置文件表示，如下所示。
请注意，每个 <code>controllerLeaders</code> 的 <code>component</code> 字段从 <code>kube-controller-manager</code> 更改为 <code>cloud-controller-manager</code>。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>LeaderMigrationConfiguration<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>controllermanager.config.k8s.io/v1beta1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">leaderName</span>:<span style="color:#bbb"> </span>cloud-provider-extraction-migration<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">resourceLock</span>:<span style="color:#bbb"> </span>leases<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">controllerLeaders</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>route<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">component</span>:<span style="color:#bbb"> </span>cloud-controller-manager<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>service<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">component</span>:<span style="color:#bbb"> </span>cloud-controller-manager<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>cloud-node-lifecycle<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">component</span>:<span style="color:#bbb"> </span>cloud-controller-manager<span style="color:#bbb">
</span></code></pre></div><!--
When creating control plane nodes of version N + 1, the content should be deploy to `/etc/leadermigration.conf`. 
The manifest of `cloud-controller-manager` should be updated to mount the configuration file in 
the same manner as `kube-controller-manager` of version N. Similarly, add `--feature-gates=ControllerManagerLeaderMigration=true`,
`--enable-leader-migration`, and `--leader-migration-config=/etc/leadermigration.conf` to the arguments of `cloud-controller-manager`.

Create a new control plane node of version N + 1 with the updated `cloud-controller-manager` manifest, 
and with the `--cloud-provider` flag unset for `kube-controller-manager`.
`kube-controller-manager` of version N + 1 MUST NOT have Leader Migration enabled because, 
with an external cloud provider, it does not run the migrated controllers anymore and thus it is not involved in the migration.

Please refer to [Cloud Controller Manager Administration](/docs/tasks/administer-cluster/running-cloud-controller/)
for more detail on how to deploy `cloud-controller-manager`.
-->
<p>当创建 N+1 版本的控制平面节点时，应将内容部署到 <code>/etc/leadermigration.conf</code>。
应该更新 <code>cloud-controller-manager</code> 清单，以与 N 版本的 <code>kube-controller-manager</code> 相同的方式挂载配置文件。
类似地，添加 <code>--feature-gates=ControllerManagerLeaderMigration=true</code>、<code>--enable-leader-migration</code>
和 <code>--leader-migration-config=/etc/leadermigration.conf</code> 到 <code>cloud-controller-manager</code> 的参数中。</p>
<p>使用已更新的 <code>cloud-controller-manager</code> 清单创建一个新的 N+1 版本的控制平面节点。
并且没有设置 <code>kube-controller-manager</code> 的 <code>--cloud-provider</code> 标志。
N+1 版本的 <code>kube-controller-manager</code> 不能启用领导者迁移，
因为在使用外部云驱动的情况下，它不再运行已迁移的控制器，因此不参与迁移。</p>
<p>请参阅<a href="/zh/docs/tasks/administer-cluster/running-cloud-controller/">云控制器管理器管理</a>
了解有关如何部署 <code>cloud-controller-manager</code> 的更多细节。</p>
<!--
### Upgrade Control Plane

The control plane now contains nodes of both version N and N + 1. 
The nodes of version N run `kube-controller-manager` only, 
and these of version N + 1 run both `kube-controller-manager` and `cloud-controller-manager`. 
The migrated controllers, as specified in the configuration, are running under either `kube-controller-manager` of 
version N or `cloud-controller-manager` of version N + 1 depending on which controller manager holds the migration lease.
No controller will ever be running under both controller managers at any time.

In a rolling manner, create a new control plane node of version N + 1 and bring down one of version N + 1 until the control plane contains only nodes of version N + 1.
If a rollback from version N + 1 to N is required, add nodes of version N with Leader Migration enabled for `kube-controller-manager` back to the control plane, replacing one of version N + 1 each time until there are only nodes of version N.
-->
<h3 id="升级控制平面">升级控制平面</h3>
<p>现在，控制平面包含 N 和 N+1 版本的节点。
N 版本的节点仅运行 <code>kube-controller-manager</code>，而 N+1 版本的节点同时运行
<code>kube-controller-manager</code> 和 <code>cloud-controller-manager</code>。
根据配置所指定，已迁移的控制器在 N 版本的 <code>kube-controller-manager</code> 或 N+1 版本的
<code>cloud-controller-manager</code> 下运行，
具体取决于哪个控制器管理器拥有迁移  Lease 对象。任何时候都不存在一个控制器在两个控制器管理器下运行。</p>
<p>以滚动的方式创建一个新的版本为 N+1 的控制平面节点，并将 N+1 版本中的一个关闭，
直到控制平面仅包含版本为 N+1 的节点。
如果需要从 N+1 版本回滚到 N 版本，则将启用了领导者迁移的 <code>kube-controller-manager</code>
且版本为 N 的节点添加回控制平面，每次替换 N+1 版本的一个，直到只有 N 版本的节点为止。</p>
<!--
### (Optional) Disable Leader Migration {#disable-leader-migration}

Now that the control plane has been upgraded to run both `kube-controller-manager` and `cloud-controller-manager` of version N + 1, 
Leader Migration has finished its job and can be safely disabled to save one Lease resource. 
It is safe to re-enable Leader Migration for the rollback in the future.

In a rolling manager, update manifest of `cloud-controller-manager` to unset both 
`--enable-leader-migration` and `--leader-migration-config=` flag, 
also remove the mount of `/etc/leadermigration.conf`, and finally remove `/etc/leadermigration.conf`. 
To re-enable Leader Migration, recreate the configuration file and add its mount and the flags that enable Leader Migration back to `cloud-controller-manager`.
-->
<h3 id="disable-leader-migration">（可选）禁用领导者迁移</h3>
<p>现在，控制平面已经升级，可以同时运行 N+1 版本的 <code>kube-controller-manager</code> 和 <code>cloud-controller-manager</code> 了。
领导者迁移已经完成工作，可以安全地禁用以节省一个 Lease 资源。
在将来可以安全地重新启用领导者迁移以完成回滚。</p>
<p>在滚动管理器中，更新 <code>cloud-controller-manager</code> 的清单以同时取消设置 <code>--enable-leader-migration</code>
和 <code>--leader-migration-config=</code> 标志，并删除 <code>/etc/leadermigration.conf</code> 的挂载。
最后删除 <code>/etc/leadermigration.conf</code>。
要重新启用领导者迁移，请重新创建配置文件，并将其挂载和启用领导者迁移的标志添加回到 <code>cloud-controller-manager</code>。</p>
<!--
### Default Configuration

Starting Kubernetes 1.22, Leader Migration provides a default configuration suitable for the default controller-to-manager assignment.
The default configuration can be enabled by setting `--enable-leader-migration` but without `--leader-migration-config=`.

For `kube-controller-manager` and `cloud-controller-manager`, if there are no flags that enable any in-tree cloud provider or change ownership of controllers, the default configuration can be used to avoid manual creation of the configuration file.
-->
<h3 id="default-configuration">默认配置</h3>
<p>从 Kubernetes 1.22 开始，领导者迁移提供了一个默认配置，它适用于默认的控制器到管理器分配。
可以通过设置 <code>--enable-leader-migration</code>，但不设置 <code>--leader-migration-config=</code> 来启用默认配置。</p>
<p>对于 <code>kube-controller-manager</code> 和 <code>cloud-controller-manager</code>，如果没有用参数来启用树内云驱动或者改变控制器属主，
则可以使用默认配置来避免手动创建配置文件。</p>
<h2 id="接下来">接下来</h2>
<!--
- Read the [Controller Manager Leader Migration](https://github.com/kubernetes/enhancements/tree/master/keps/sig-cloud-provider/2436-controller-manager-leader-migration) enhancement proposal
-->
<ul>
<li>阅读<a href="https://github.com/kubernetes/enhancements/tree/master/keps/sig-cloud-provider/2436-controller-manager-leader-migration">领导者迁移控制器管理器</a>改进建议</li>
</ul>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-9585dc0efb0450fd68728e7511754717">26 - 开发云控制器管理器</h1>
    
	<!--
reviewers:
- luxas
- thockin
- wlan0
title: Developing Cloud Controller Manager
content_type: concept
-->
<!-- overview -->





<div style="margin-top: 10px; margin-bottom: 10px;">
<b>FEATURE STATE:</b> <code>Kubernetes v1.11 [beta]</code>
</div>

<!--
title: Cloud Controller Manager
id: cloud-controller-manager
date: 2018-04-12
full_link: /docs/concepts/architecture/cloud-controller/
short_description: >
  Control plane component that integrates Kubernetes with third-party cloud providers.

aka: 
tags:
- core-object
- architecture
- operation
-->
<!--
 A Kubernetes <a class='glossary-tooltip' title='控制平面是指容器编排层，它暴露 API 和接口来定义、部署容器和管理容器的生命周期。' data-toggle='tooltip' data-placement='top' href='/zh/docs/reference/glossary/?all=true#term-control-plane' target='_blank' aria-label='control plane'>control plane</a> component
that embeds cloud-specific control logic. The cloud controller manager lets you link your
cluster into your cloud provider's API, and separates out the components that interact
with that cloud platform from components that only interact with your cluster.
-->
<p><p>组件 cloud-controller-manager 是 云控制器管理器是指嵌入特定云的控制逻辑的
<a class='glossary-tooltip' title='控制平面是指容器编排层，它暴露 API 和接口来定义、部署容器和管理容器的生命周期。' data-toggle='tooltip' data-placement='top' href='/zh/docs/reference/glossary/?all=true#term-control-plane' target='_blank' aria-label='控制平面'>控制平面</a>组件。
云控制器管理器使得你可以将你的集群连接到云提供商的 API 之上，
并将与该云平台交互的组件同与你的集群交互的组件分离开来。</p></p>
<!--
By decoupling the interoperability logic between Kubernetes and the underlying cloud
infrastructure, the cloud-controller-manager component enables cloud providers to release
features at a different pace compared to the main Kubernetes project.
-->
<p>通过分离 Kubernetes 和底层云基础设置之间的互操作性逻辑，
云控制器管理器组件使云提供商能够以不同于 Kubernetes 主项目的
步调发布新特征。</p>
<!-- body -->
<!--
## Background

Since cloud providers develop and release at a different pace compared to the Kubernetes project, abstracting the provider-specific code to the `cloud-controller-manager` binary allows cloud vendors to evolve independently from the core Kubernetes code.
-->
<h2 id="背景">背景</h2>
<p>由于云驱动的开发和发布与 Kubernetes 项目本身步调不同，将特定于云环境
的代码抽象到 <code>cloud-controller-manager</code> 二进制组件有助于云厂商独立于
Kubernetes 核心代码推进其驱动开发。</p>
<!--
The Kubernetes project provides skeleton cloud-controller-manager code with Go interfaces to allow you (or your cloud provider) to plug in your own implementations. This means that a cloud provider can implement a cloud-controller-manager by importing packages from Kubernetes core; each cloudprovider will register their own code by calling `cloudprovider.RegisterCloudProvider` to update a global variable of available cloud providers.
-->
<p>Kubernetes 项目提供 cloud-controller-manager 的框架代码，其中包含 Go
语言的接口，便于你（或者你的云驱动提供者）接驳你自己的实现。
这意味着每个云驱动可以通过从 Kubernetes 核心代码导入软件包来实现一个
cloud-controller-manager；每个云驱动会通过调用
<code>cloudprovider.RegisterCloudProvider</code> 接口来注册其自身实现代码，从而更新
记录可用云驱动的全局变量。</p>
<!--
## Developing
-->
<h2 id="开发">开发</h2>
<h3 id="out-of-tree">Out of Tree</h3>
<!--
To build an out-of-tree cloud-controller-manager for your cloud, follow these steps:
-->
<p>要为你的云环境构建一个 out-of-tree 云控制器管理器：</p>
<!--
1. Create a go package with an implementation that satisfies [cloudprovider.Interface](https://git.k8s.io/kubernetes/pkg/cloudprovider/cloud.go).
2. Use [main.go in cloud-controller-manager](https://github.com/kubernetes/kubernetes/blob/master/cmd/cloud-controller-manager/main.go) from Kubernetes core as a template for your main.go. As mentioned above, the only difference should be the cloud package that will be imported.
3. Import your cloud package in `main.go`, ensure your package has an `init` block to run [cloudprovider.RegisterCloudProvider](https://github.com/kubernetes/kubernetes/blob/master/pkg/cloudprovider/plugins.go#L42-L52).
-->
<ol>
<li>使用满足 <a href="https://git.k8s.io/kubernetes/pkg/cloudprovider/cloud.go">cloudprovider.Interface</a>
的实现创建一个 Go 语言包。</li>
<li>使用来自 Kubernetes 核心代码库的
<a href="https://github.com/kubernetes/kubernetes/blob/master/cmd/cloud-controller-manager/main.go">cloud-controller-manager 中的 main.go</a>
作为 main.go 的模板。如上所述，唯一的区别应该是将导入的云包。</li>
<li>在 <code>main.go</code> 中导入你的云包，确保你的包有一个 <code>init</code> 块来运行
<a href="https://github.com/kubernetes/kubernetes/blob/master/pkg/cloudprovider/plugins.go#L42-L52">cloudprovider.RegisterCloudProvider</a>。</li>
</ol>
<!--
Many cloud providers publish their controller manager code as open source. If you are creating
a new cloud-controller-manager from scratch, you could take an existing out-of-tree cloud
controller manager as your starting point.
-->
<p>很多云驱动都将其控制器管理器代码以开源代码的形式公开。
如果你在开发一个新的 cloud-controller-manager，你可以选择某个 out-of-tree
云控制器管理器作为出发点。</p>
<h3 id="in-tree">In Tree</h3>
<!--
For in-tree cloud providers, you can run the in-tree cloud controller manager as a <a class='glossary-tooltip' title='确保 Pod 的副本在集群中的一组节点上运行。' data-toggle='tooltip' data-placement='top' href='/zh/docs/concepts/workloads/controllers/daemonset/' target='_blank' aria-label='DaemonSet'>DaemonSet</a> in your cluster. See [Cloud Controller Manager Administration](/docs/tasks/administer-cluster/running-cloud-controller/) for more details.
-->
<p>对于 in-tree 驱动，你可以将 in-tree 云控制器管理器作为群集中的
<a class='glossary-tooltip' title='确保 Pod 的副本在集群中的一组节点上运行。' data-toggle='tooltip' data-placement='top' href='/zh/docs/concepts/workloads/controllers/daemonset/' target='_blank' aria-label='Daemonset'>Daemonset</a> 来运行。
有关详细信息，请参阅<a href="/zh/docs/tasks/administer-cluster/running-cloud-controller/">云控制器管理器管理</a>。</p>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-00733cc3747eb3f5fe1c9e0439262967">27 - 开启服务拓扑</h1>
    
	<!-- overview -->
<!--
This page provides an overview of enabling Service Topology in Kubernetes.
-->
<p>本页面提供了在 Kubernetes 中启用服务拓扑的概述。</p>
<h2 id="准备开始">准备开始</h2>
<p><p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
如果你还没有集群，你可以通过 <a href="/zh/docs/tasks/tools/#minikube">Minikube</a> 构建一
个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p>
<!--
You need to have a Kubernetes cluster, and the kubectl command-line tool must
be configured to communicate with your cluster. If you do not already have a
cluster, you can create one by using
[minikube](/docs/tasks/tools/#minikube)
or you can use one of these Kubernetes playgrounds:
-->
<ul>
<li><a href="https://www.katacoda.com/courses/kubernetes/playground">Katacoda</a></li>
<li><a href="http://labs.play-with-k8s.com/">玩转 Kubernetes</a></li>
</ul>
 
 要获知版本信息，请输入 <code>kubectl version</code>.
</p>
<!-- steps -->
<!--
## Introduction

_Service Topology_ enables a service to route traffic based upon the Node
topology of the cluster. For example, a service can specify that traffic be
preferentially routed to endpoints that are on the same Node as the client, or
in the same availability zone.
-->
<h2 id="介绍">介绍</h2>
<p><em>服务拓扑（Service Topology）</em> 使服务能够根据集群中的 Node 拓扑来路由流量。
比如，服务可以指定将流量优先路由到与客户端位于同一节点或者同一可用区域的端点上。</p>
<!--
## Prerequisites

The following prerequisites are needed in order to enable topology aware service
routing:

   * Kubernetes 1.17 or later
   * <a class='glossary-tooltip' title='kube-proxy 是集群中每个节点上运行的网络代理。' data-toggle='tooltip' data-placement='top' href='/zh/docs/reference/command-line-tools-reference/kube-proxy/' target='_blank' aria-label='Kube-proxy'>Kube-proxy</a> running in iptables mode or IPVS mode
   * Enable [Endpoint Slices](/docs/concepts/services-networking/endpoint-slices/)
-->
<h2 id="先决条件">先决条件</h2>
<p>需要下面列的先决条件，才能启用拓扑感知的服务路由：</p>
<ul>
<li>Kubernetes 1.17 或更新版本</li>
<li><a class='glossary-tooltip' title='kube-proxy 是集群中每个节点上运行的网络代理。' data-toggle='tooltip' data-placement='top' href='/zh/docs/reference/command-line-tools-reference/kube-proxy/' target='_blank' aria-label='Kube-proxy'>Kube-proxy</a> 以 iptables 或者 IPVS 模式运行</li>
<li>启用<a href="/zh/docs/concepts/services-networking/endpoint-slices/">端点切片</a></li>
</ul>
<!--
## Enable Service Topology






<div style="margin-top: 10px; margin-bottom: 10px;">
<b>FEATURE STATE:</b> <code>Kubernetes v1.17 [alpha]</code>
</div>


To enable service topology, enable the `ServiceTopology` and `EndpointSlice` feature gate for all Kubernetes components:
-->
<h2 id="启用服务拓扑">启用服务拓扑</h2>





<div style="margin-top: 10px; margin-bottom: 10px;">
<b>FEATURE STATE:</b> <code>Kubernetes v1.17 [alpha]</code>
</div>

<p>要启用服务拓扑功能，需要为所有 Kubernetes 组件启用 <code>ServiceTopology</code> 和 <code>EndpointSlice</code> 特性门控：</p>
<pre tabindex="0"><code>--feature-gates=&quot;ServiceTopology=true,EndpointSlice=true&quot;
</code></pre><h2 id="接下来">接下来</h2>
<!--
* Read about the [Service Topology](/docs/concepts/services-networking/service-topology) concept
* Read about [Endpoint Slices](/docs/concepts/services-networking/endpoint-slices)
* Read [Connecting Applications with Services](/docs/concepts/services-networking/connect-applications-service/)
-->
<ul>
<li>阅读<a href="/zh/docs/concepts/services-networking/service-topology">服务拓扑</a>概念</li>
<li>阅读<a href="/zh/docs/concepts/services-networking/endpoint-slices">端点切片</a></li>
<li>阅读<a href="/zh/docs/concepts/services-networking/connect-applications-service/">通过服务来连接应用</a></li>
</ul>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-7127e6b7344b315b30b1ce8c4d8bfc55">28 - 控制节点上的 CPU 管理策略</h1>
    
	<!--
title: Control CPU Management Policies on the Node
reviewers:
- sjenning
- ConnorDoyle
- balajismaniam
content_type: task
-->
<!-- overview -->





<div style="margin-top: 10px; margin-bottom: 10px;">
<b>FEATURE STATE:</b> <code>Kubernetes v1.12 [beta]</code>
</div>

<!--
Kubernetes keeps many aspects of how pods execute on nodes abstracted
from the user. This is by design.  However, some workloads require
stronger guarantees in terms of latency and/or performance in order to operate
acceptably. The kubelet provides methods to enable more complex workload
placement policies while keeping the abstraction free from explicit placement
directives.
-->
<p>按照设计，Kubernetes 对 pod 执行相关的很多方面进行了抽象，使得用户不必关心。
然而，为了正常运行，有些工作负载要求在延迟和/或性能方面有更强的保证。
为此，kubelet 提供方法来实现更复杂的负载放置策略，同时保持抽象，避免显式的放置指令。</p>
<h2 id="准备开始">准备开始</h2>
<p><p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
如果你还没有集群，你可以通过 <a href="/zh/docs/tasks/tools/#minikube">Minikube</a> 构建一
个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p>
<!--
You need to have a Kubernetes cluster, and the kubectl command-line tool must
be configured to communicate with your cluster. If you do not already have a
cluster, you can create one by using
[minikube](/docs/tasks/tools/#minikube)
or you can use one of these Kubernetes playgrounds:
-->
<ul>
<li><a href="https://www.katacoda.com/courses/kubernetes/playground">Katacoda</a></li>
<li><a href="http://labs.play-with-k8s.com/">玩转 Kubernetes</a></li>
</ul>
 
 要获知版本信息，请输入 <code>kubectl version</code>.
</p>
<!-- steps -->
<!--
## CPU Management Policies

By default, the kubelet uses [CFS quota](https://en.wikipedia.org/wiki/Completely_Fair_Scheduler)
to enforce pod CPU limits.  When the node runs many CPU-bound pods,
the workload can move to different CPU cores depending on
whether the pod is throttled and which CPU cores are available at
scheduling time.  Many workloads are not sensitive to this migration and thus
work fine without any intervention.
-->
<h2 id="cpu-管理策略">CPU 管理策略</h2>
<p>默认情况下，kubelet 使用 <a href="https://en.wikipedia.org/wiki/Completely_Fair_Scheduler">CFS 配额</a>
来执行 Pod 的 CPU 约束。
当节点上运行了很多 CPU 密集的 Pod 时，工作负载可能会迁移到不同的 CPU 核，
这取决于调度时 Pod 是否被扼制，以及哪些 CPU 核是可用的。
许多工作负载对这种迁移不敏感，因此无需任何干预即可正常工作。</p>
<!--
However, in workloads where CPU cache affinity and scheduling latency
significantly affect workload performance, the kubelet allows alternative CPU
management policies to determine some placement preferences on the node.
-->
<p>然而，有些工作负载的性能明显地受到 CPU 缓存亲和性以及调度延迟的影响。
对此，kubelet 提供了可选的 CPU 管理策略，来确定节点上的一些分配偏好。</p>
<!--
### Configuration

The CPU Manager policy is set with the `-cpu-manager-policy` kubelet
option. There are two supported policies:
-->
<h3 id="配置">配置</h3>
<p>CPU 管理策略通过 kubelet 参数 <code>--cpu-manager-policy</code> 来指定。支持两种策略：</p>
<!--
* `none`: the default, which represents the existing scheduling behavior.
* `static`: allows pods with certain resource characteristics to be
  granted increased CPU affinity and exclusivity on the node.
-->
<ul>
<li><code>none</code>: 默认策略，表示现有的调度行为。</li>
<li><code>static</code>: 允许为节点上具有某些资源特征的 pod 赋予增强的 CPU 亲和性和独占性。</li>
</ul>
<!--
The CPU manager periodically writes resource updates through the CRI in
order to reconcile in-memory CPU assignments with cgroupfs. The reconcile
frequency is set through a new Kubelet configuration value
`-cpu-manager-reconcile-period`. If not specified, it defaults to the same
duration as `-node-status-update-frequency`.
-->
<p>CPU 管理器定期通过 CRI 写入资源更新，以保证内存中 CPU 分配与 cgroupfs 一致。
同步频率通过新增的 Kubelet 配置参数 <code>--cpu-manager-reconcile-period</code> 来设置。
如果不指定，默认与 <code>--node-status-update-frequency</code> 的周期相同。</p>
<!--
The behavior of the static policy can be fine-tuned using the `--cpu-manager-policy-options` flag.
The flag takes a comma-separated list of `key=value` policy options.
-->
<p>Static 策略的行为可以使用 <code>--cpu-manager-policy-options</code> 参数来微调。
该参数采用一个逗号分隔的 <code>key=value</code> 策略选项列表。</p>
<!--
### None policy

The `none` policy explicitly enables the existing default CPU
affinity scheme, providing no affinity beyond what the OS scheduler does
automatically.  Limits on CPU usage for
[Guaranteed pods](/docs/tasks/configure-pod-container/quality-service-pod/) and
[Burstable pods](/docs/tasks/configure-pod-container/quality-service-pod/)
are enforced using CFS quota.
-->
<h3 id="none-策略">none 策略</h3>
<p><code>none</code> 策略显式地启用现有的默认 CPU 亲和方案，不提供操作系统调度器默认行为之外的亲和性策略。
通过 CFS 配额来实现 <a href="/zh/docs/tasks/configure-pod-container/quality-service-pod/">Guaranteed pods</a>
和 <a href="/zh/docs/tasks/configure-pod-container/quality-service-pod/">Burstable pods</a>
的 CPU 使用限制。</p>
<!--
### Static policy

The `static` policy allows containers in `Guaranteed` pods with integer CPU
`requests` access to exclusive CPUs on the node. This exclusivity is enforced
using the [cpuset cgroup controller](https://www.kernel.org/doc/Documentation/cgroup-v1/cpusets.txt).
-->
<h3 id="static-策略">static 策略</h3>
<p><code>static</code> 策略针对具有整数型 CPU <code>requests</code> 的 <code>Guaranteed</code> Pod ，它允许该类 Pod
中的容器访问节点上的独占 CPU 资源。这种独占性是使用
<a href="https://www.kernel.org/doc/Documentation/cgroup-v1/cpusets.txt">cpuset cgroup 控制器</a> 来实现的。</p>
<!--
System services such as the container runtime and the kubelet itself can continue to run on these exclusive CPUs.  The exclusivity only extends to other pods.
-->
<blockquote class="note callout">
  <div><strong>说明：</strong> 诸如容器运行时和 kubelet 本身的系统服务可以继续在这些独占 CPU 上运行。独占性仅针对其他 Pod。</div>
</blockquote>
<!--
CPU Manager doesn't support offlining and onlining of
CPUs at runtime. Also, if the set of online CPUs changes on the node,
the node must be drained and CPU manager manually reset by deleting the
state file `cpu_manager_state` in the kubelet root directory.
-->
<blockquote class="note callout">
  <div><strong>说明：</strong> CPU 管理器不支持运行时下线和上线 CPUs。此外，如果节点上的在线 CPUs 集合发生变化，
则必须驱逐节点上的 Pod，并通过删除 kubelet 根目录中的状态文件 <code>cpu_manager_state</code>
来手动重置 CPU 管理器。</div>
</blockquote>
<!--
This policy manages a shared pool of CPUs that initially contains all CPUs in the
node. The amount of exclusively allocatable CPUs is equal to the total
number of CPUs in the node minus any CPU reservations by the kubelet `--kube-reserved` or
`--system-reserved` options. From 1.17, the CPU reservation list can be specified
explicitly by kubelet `--reserved-cpus` option. The explicit CPU list specified by
`--reserved-cpus` takes precedence over the CPU reservation specified by
`--kube-reserved` and `--system-reserved`. CPUs reserved by these options are taken, in
integer quantity, from the initial shared pool in ascending order by physical
core ID.  This shared pool is the set of CPUs on which any containers in
`BestEffort` and `Burstable` pods run. Containers in `Guaranteed` pods with fractional
CPU `requests` also run on CPUs in the shared pool. Only containers that are
both part of a `Guaranteed` pod and have integer CPU `requests` are assigned
exclusive CPUs.
--->
<p>该策略管理一个共享 CPU 资源池，最初，该资源池包含节点上所有的 CPU 资源。可用
的独占性 CPU 资源数量等于节点的 CPU 总量减去通过 <code>--kube-reserved</code> 或 <code>--system-reserved</code> 参数保留的 CPU 。从1.17版本开始，CPU保留列表可以通过 kublet 的 '--reserved-cpus' 参数显式地设置。
通过 '--reserved-cpus' 指定的显式CPU列表优先于使用 '--kube-reserved' 和 '--system-reserved' 参数指定的保留CPU。 通过这些参数预留的 CPU 是以整数方式，按物理内
核 ID 升序从初始共享池获取的。 共享池是 <code>BestEffort</code> 和 <code>Burstable</code> pod 运行
的 CPU 集合。<code>Guaranteed</code> pod 中的容器，如果声明了非整数值的 CPU <code>requests</code> ，也将运行在共享池的 CPU 上。只有 <code>Guaranteed</code> pod 中，指定了整数型 CPU <code>requests</code> 的容器，才会被分配独占 CPU 资源。</p>
<!--
The kubelet requires a CPU reservation greater than zero be made
using either `--kube-reserved` and/or `--system-reserved`  or `--reserved-cpus` when the static
policy is enabled. This is because zero CPU reservation would allow the shared
pool to become empty.
--->
<blockquote class="note callout">
  <div><strong>说明：</strong> 当启用 static 策略时，要求使用 <code>--kube-reserved</code> 和/或 <code>--system-reserved</code> 或
<code>--reserved-cpus</code> 来保证预留的 CPU 值大于零。
这是因为零预留 CPU 值可能使得共享池变空。</div>
</blockquote>
<!--
As `Guaranteed` pods whose containers fit the requirements for being statically
assigned are scheduled to the node, CPUs are removed from the shared pool and
placed in the cpuset for the container. CFS quota is not used to bound
the CPU usage of these containers as their usage is bound by the scheduling domain
itself. In others words, the number of CPUs in the container cpuset is equal to the integer
CPU `limit` specified in the pod spec. This static assignment increases CPU
affinity and decreases context switches due to throttling for the CPU-bound
workload.

Consider the containers in the following pod specs:
-->
<p>当 <code>Guaranteed</code> Pod 调度到节点上时，如果其容器符合静态分配要求，
相应的 CPU 会被从共享池中移除，并放置到容器的 cpuset 中。
因为这些容器所使用的 CPU 受到调度域本身的限制，所以不需要使用 CFS 配额来进行 CPU 的绑定。
换言之，容器 cpuset  中的 CPU 数量与 Pod 规约中指定的整数型 CPU <code>limit</code> 相等。
这种静态分配增强了 CPU 亲和性，减少了 CPU 密集的工作负载在节流时引起的上下文切换。</p>
<p>考虑以下 Pod 规格的容器：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">spec</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">containers</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>nginx<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">image</span>:<span style="color:#bbb"> </span>nginx<span style="color:#bbb">
</span></code></pre></div><!--
This pod runs in the `BestEffort` QoS class because no resource `requests` or
`limits` are specified. It runs in the shared pool.
-->
<p>该 Pod 属于 <code>BestEffort</code> QoS 类型，因为其未指定 <code>requests</code> 或 <code>limits</code> 值。
所以该容器运行在共享 CPU 池中。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">spec</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">containers</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>nginx<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">image</span>:<span style="color:#bbb"> </span>nginx<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">resources</span>:<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">limits</span>:<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#008000;font-weight:bold">memory</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;200Mi&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">requests</span>:<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#008000;font-weight:bold">memory</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;100Mi&#34;</span><span style="color:#bbb">
</span></code></pre></div><!--
This pod runs in the `Burstable` QoS class because resource `requests` do not
equal `limits` and the `cpu` quantity is not specified. It runs in the shared
pool.
-->
<p>该 Pod 属于 <code>Burstable</code> QoS 类型，因为其资源 <code>requests</code> 不等于 <code>limits</code>，且未指定 <code>cpu</code> 数量。
所以该容器运行在共享 CPU 池中。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">spec</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">containers</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>nginx<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">image</span>:<span style="color:#bbb"> </span>nginx<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">resources</span>:<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">limits</span>:<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#008000;font-weight:bold">memory</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;200Mi&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#008000;font-weight:bold">cpu</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;2&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">requests</span>:<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#008000;font-weight:bold">memory</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;100Mi&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#008000;font-weight:bold">cpu</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;1&#34;</span><span style="color:#bbb">
</span></code></pre></div><!--
This pod runs in the `Burstable` QoS class because resource `requests` do not
equal `limits`. It runs in the shared pool.
-->
<p>该 pod 属于 <code>Burstable</code> QoS 类型，因为其资源 <code>requests</code> 不等于 <code>limits</code>。
所以该容器运行在共享 CPU 池中。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">spec</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">containers</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>nginx<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">image</span>:<span style="color:#bbb"> </span>nginx<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">resources</span>:<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">limits</span>:<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#008000;font-weight:bold">memory</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;200Mi&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#008000;font-weight:bold">cpu</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;2&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">requests</span>:<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#008000;font-weight:bold">memory</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;200Mi&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#008000;font-weight:bold">cpu</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;2&#34;</span><span style="color:#bbb">
</span></code></pre></div><!--
This pod runs in the `Guaranteed` QoS class because `requests` are equal to `limits`.
And the container's resource limit for the CPU resource is an integer greater than
or equal to one. The `nginx` container is granted 2 exclusive CPUs.
-->
<p>该 Pod 属于 <code>Guaranteed</code> QoS 类型，因为其 <code>requests</code> 值与 <code>limits</code>相等。
同时，容器对 CPU 资源的限制值是一个大于或等于 1 的整数值。
所以，该 <code>nginx</code> 容器被赋予 2 个独占 CPU。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">spec</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">containers</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>nginx<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">image</span>:<span style="color:#bbb"> </span>nginx<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">resources</span>:<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">limits</span>:<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#008000;font-weight:bold">memory</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;200Mi&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#008000;font-weight:bold">cpu</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;1.5&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">requests</span>:<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#008000;font-weight:bold">memory</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;200Mi&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#008000;font-weight:bold">cpu</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;1.5&#34;</span><span style="color:#bbb">
</span></code></pre></div><!--
This pod runs in the `Guaranteed` QoS class because `requests` are equal to `limits`.
But the container's resource limit for the CPU resource is a fraction. It runs in
the shared pool.
-->
<p>该 Pod 属于 <code>Guaranteed</code> QoS 类型，因为其 <code>requests</code> 值与 <code>limits</code>相等。
但是容器对 CPU 资源的限制值是一个小数。所以该容器运行在共享 CPU 池中。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">spec</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">containers</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>nginx<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">image</span>:<span style="color:#bbb"> </span>nginx<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">resources</span>:<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">limits</span>:<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#008000;font-weight:bold">memory</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;200Mi&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#008000;font-weight:bold">cpu</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;2&#34;</span><span style="color:#bbb">
</span></code></pre></div><!--
This pod runs in the `Guaranteed` QoS class because only `limits` are specified
and `requests` are set equal to `limits` when not explicitly specified. And the
container's resource limit for the CPU resource is an integer greater than or
equal to one. The `nginx` container is granted 2 exclusive CPUs.
-->
<p>该 Pod 属于 <code>Guaranteed</code> QoS 类型，因其指定了 <code>limits</code> 值，同时当未显式指定时，
<code>requests</code> 值被设置为与 <code>limits</code> 值相等。
同时，容器对 CPU 资源的限制值是一个大于或等于 1 的整数值。
所以，该 <code>nginx</code> 容器被赋予 2 个独占 CPU。</p>
<!--
#### Static policy options

If the `full-pcpus-only` policy option is specified, the static policy will always allocate full physical cores.
You can enable this option by adding `full-pcups-only=true` to the CPUManager policy options.
-->
<h4 id="static-策略选项">Static 策略选项</h4>
<p>如果使用 <code>full-pcpus-only</code> 策略选项，static 策略总是会分配完整的物理核心。
你可以通过在 CPUManager 策略选项里加上 <code>full-pcups-only=true</code> 来启用该选项。</p>
<!--
By default, without this option, the static policy allocates CPUs using a topology-aware best-fit allocation.
On SMT enabled systems, the policy can allocate individual virtual cores, which correspond to hardware threads.
This can lead to different containers sharing the same physical cores; this behaviour in turn contributes
to the [noisy neighbours problem](https://en.wikipedia.org/wiki/Cloud_computing_issues#Performance_interference_and_noisy_neighbors).
-->
<p>默认情况下，如果不使用该选项，static 策略会使用拓扑感知最适合的分配方法来分配 CPU。
在启用了 SMT 的系统上，此策略所分配是与硬件线程对应的、独立的虚拟核。
这会导致不同的容器共享相同的物理核心，该行为进而会导致
<a href="https://en.wikipedia.org/wiki/Cloud_computing_issues#Performance_interference_and_noisy_neighbors">吵闹的邻居问题</a>。</p>
<!--
With the option enabled, the pod will be admitted by the kubelet only if the CPU request of all its containers
can be fulfilled by allocating full physical cores.
If the pod does not pass the admission, it will be put in Failed state with the message `SMTAlignmentError`.
-->
<p>启用该选项之后，只有当一个 Pod 里所有容器的 CPU 请求都能够分配到完整的物理核心时，kubelet 才会接受该 Pod。
如果 Pod 没有被准入，它会被置于 Failed 状态，错误消息是 <code>SMTAlignmentError</code>。</p>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-8060aed5bf1172fa62199a4c306a4cd1">29 - 控制节点上的拓扑管理策略</h1>
    
	<!--
title: Control Topology Management Policies on a node
reviewers:
- ConnorDoyle
- klueska
- lmdaly
- nolancon
- bg-chun
content_type: task
min-kubernetes-server-version: v1.18
-->
<!-- overview -->





<div style="margin-top: 10px; margin-bottom: 10px;">
<b>FEATURE STATE:</b> <code>Kubernetes v1.18 [beta]</code>
</div>

<!--
An increasing number of systems leverage a combination of CPUs and hardware accelerators to support latency-critical execution and high-throughput parallel computation. These include workloads in fields such as telecommunications, scientific computing, machine learning, financial services and data analytics. Such hybrid systems comprise a high performance environment.
-->
<p>越来越多的系统利用 CPU 和硬件加速器的组合来支持对延迟要求较高的任务和高吞吐量的并行计算。
这类负载包括电信、科学计算、机器学习、金融服务和数据分析等。
此类混合系统即用于构造这些高性能环境。</p>
<!--
In order to extract the best performance, optimizations related to CPU isolation, memory and device locality are required. However, in Kubernetes, these optimizations are handled by a disjoint set of components.
-->
<p>为了获得最佳性能，需要进行与 CPU 隔离、内存和设备局部性有关的优化。
但是，在 Kubernetes 中，这些优化由各自独立的组件集合来处理。</p>
<!--
_Topology Manager_ is a Kubelet component that aims to co-ordinate the set of components that are responsible for these optimizations.
-->
<p><em>拓扑管理器（Topology Manager）</em> 是一个 kubelet 的一部分，旨在协调负责这些优化的一组组件。</p>
<h2 id="准备开始">准备开始</h2>
<p><p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
如果你还没有集群，你可以通过 <a href="/zh/docs/tasks/tools/#minikube">Minikube</a> 构建一
个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p>
<!--
You need to have a Kubernetes cluster, and the kubectl command-line tool must
be configured to communicate with your cluster. If you do not already have a
cluster, you can create one by using
[minikube](/docs/tasks/tools/#minikube)
or you can use one of these Kubernetes playgrounds:
-->
<ul>
<li><a href="https://www.katacoda.com/courses/kubernetes/playground">Katacoda</a></li>
<li><a href="http://labs.play-with-k8s.com/">玩转 Kubernetes</a></li>
</ul>
 

您的 Kubernetes 服务器版本必须不低于版本 v1.18.
 要获知版本信息，请输入 <code>kubectl version</code>.
</p>
<!-- steps -->
<!--
## How Topology Manager Works
-->
<h2 id="拓扑管理器如何工作">拓扑管理器如何工作</h2>
<!--
Prior to the introduction of Topology Manager, the CPU and Device Manager in Kubernetes make resource allocation decisions independently of each other.
This can result in undesirable allocations on multiple-socketed systems, performance/latency sensitive applications will suffer due to these undesirable allocations. 
 Undesirable in this case meaning for example, CPUs and devices being allocated from different NUMA Nodes thus, incurring additional latency.
-->
<p>在引入拓扑管理器之前， Kubernetes 中的 CPU 和设备管理器相互独立地做出资源分配决策。
这可能会导致在多处理系统上出现并非期望的资源分配；由于这些与期望相左的分配，对性能或延迟敏感的应用将受到影响。
这里的不符合期望意指，例如， CPU 和设备是从不同的 NUMA 节点分配的，因此会导致额外的延迟。</p>
<!--
The Topology Manager is a Kubelet component, which acts as a source of truth so that other Kubelet components can make topology aligned resource allocation choices.
-->
<p>拓扑管理器是一个 Kubelet 组件，扮演信息源的角色，以便其他 Kubelet 组件可以做出与拓扑结构相对应的资源分配决定。</p>
<!--
The Topology Manager provides an interface for components, called *Hint Providers*, to send and receive topology information. Topology Manager has a set of node level policies which are explained below.
-->
<p>拓扑管理器为组件提供了一个称为 <em>建议供应者（Hint Providers）</em> 的接口，以发送和接收拓扑信息。
拓扑管理器具有一组节点级策略，具体说明如下。</p>
<!--
The Topology manager receives Topology information from the *Hint Providers* as a bitmask denoting NUMA Nodes available and a preferred allocation indication. The Topology Manager policies perform a set of operations on the hints provided and converge on the hint determined by the policy to give the optimal result, if an undesirable hint is stored the preferred field for the hint will be set to false. In the current policies preferred is the narrowest preferred mask.
The selected hint is stored as part of the Topology Manager. Depending on the policy configured the pod can be accepted or rejected from the node based on the selected hint.
The hint is then stored in the Topology Manager for use by the *Hint Providers* when making the resource allocation decisions.
-->
<p>拓扑管理器从 <em>建议提供者</em> 接收拓扑信息，作为表示可用的 NUMA 节点和首选分配指示的位掩码。
拓扑管理器策略对所提供的建议执行一组操作，并根据策略对提示进行约减以得到最优解；如果存储了与预期不符的建议，则该建议的优选字段将被设置为 false。
在当前策略中，首选的是最窄的优选掩码。
所选建议将被存储为拓扑管理器的一部分。
取决于所配置的策略，所选建议可用来决定节点接受或拒绝 Pod 。
之后，建议会被存储在拓扑管理器中，供 <em>建议提供者</em> 进行资源分配决策时使用。</p>
<!--
### Enable the Topology Manager feature

Support for the Topology Manager requires `TopologyManager` [feature gate](/docs/reference/command-line-tools-reference/feature-gates/) to be enabled. It is enabled by default starting with Kubernetes 1.18.
-->
<h3 id="启用拓扑管理器功能特性">启用拓扑管理器功能特性</h3>
<p>对拓扑管理器的支持要求启用 <code>TopologyManager</code>
<a href="/zh/docs/reference/command-line-tools-reference/feature-gates/">特性门控</a>。
从 Kubernetes 1.18 版本开始，这一特性默认是启用的。</p>
<!--
### Topology Manager Scopes and Policies

The Topology Manager currently:
 - Aligns Pods of all QoS classes.
 - Aligns the requested resources that Hint Provider provides topology hints for.
-->
<h3 id="拓扑管理器作用域和策略">拓扑管理器作用域和策略</h3>
<p>拓扑管理器目前：</p>
<ul>
<li>对所有 QoS 类的 Pod 执行对齐操作</li>
<li>针对建议提供者所提供的拓扑建议，对请求的资源进行对齐</li>
</ul>
<!--
If these conditions are met, the Topology Manager will align the requested resources.

In order to customise how this alignment is carried out, the Topology Manager provides two distinct knobs: `scope` and `policy`.
-->
<p>如果满足这些条件，则拓扑管理器将对齐请求的资源。</p>
<p>为了定制如何进行对齐，拓扑管理器提供了两种不同的方式：<code>scope</code> 和 <code>policy</code>。</p>
<!--
The `scope` defines the granularity at which you would like resource alignment to be performed (e.g. at the `pod` or `container` level). And the `policy` defines the actual strategy used to carry out the alignment (e.g. `best-effort`, `restricted`, `single-numa-node`, etc.).

Details on the various `scopes` and `policies` available today can be found below.
-->
<p><code>scope</code> 定义了资源对齐时你所希望使用的粒度（例如，是在 <code>pod</code> 还是 <code>container</code> 级别）。
<code>policy</code> 定义了对齐时实际使用的策略（例如，<code>best-effort</code>、<code>restricted</code>、<code>single-numa-node</code> 等等）。</p>
<p>可以在下文找到现今可用的各种 <code>scopes</code> 和 <code>policies</code> 的具体信息。</p>
<!--
To align CPU resources with other requested resources in a Pod Spec, the CPU Manager should be enabled and proper CPU Manager policy should be configured on a Node. See [control CPU Management Policies](/docs/tasks/administer-cluster/cpu-management-policies/).
-->
<blockquote class="note callout">
  <div><strong>说明：</strong> 为了将 Pod 规约中的 CPU 资源与其他请求资源对齐，CPU 管理器需要被启用并且
节点上应配置了适当的 CPU 管理器策略。
参看<a href="/zh/docs/tasks/administer-cluster/cpu-management-policies/">控制 CPU 管理策略</a>.</div>
</blockquote>
<!--
### Topology Manager Scopes

The Topology Manager can deal with the alignment of resources in a couple of distinct scopes:

* `container` (default)
* `pod`

Either option can be selected at a time of the kubelet startup, with `--topology-manager-scope` flag.
-->
<h3 id="拓扑管理器作用域">拓扑管理器作用域</h3>
<p>拓扑管理器可以在以下不同的作用域内进行资源对齐：</p>
<ul>
<li><code>container</code> （默认）</li>
<li><code>pod</code></li>
</ul>
<p>在 kubelet 启动时，可以使用 <code>--topology-manager-scope</code> 标志来选择其中任一选项。</p>
<!--
### container scope

The `container` scope is used by default.
-->
<h3 id="容器作用域">容器作用域</h3>
<p>默认使用的是 <code>container</code> 作用域。</p>
<!--
Within this scope, the Topology Manager performs a number of sequential resource alignments, i.e., for each container (in a pod) a separate alignment is computed. In other words, there is no notion of grouping the containers to a specific set of NUMA nodes, for this particular scope. In effect, the Topology Manager performs an arbitrary alignment of individual containers to NUMA nodes.
-->
<p>在该作用域内，拓扑管理器依次进行一系列的资源对齐，
也就是，对每一个容器（包含在一个 Pod 里）计算单独的对齐。
换句话说，在该特定的作用域内，没有根据特定的 NUMA 节点集来把容器分组的概念。
实际上，拓扑管理器会把单个容器任意地对齐到 NUMA 节点上。</p>
<!--
The notion of grouping the containers was endorsed and implemented on purpose in the following scope, for example the `pod` scope.
-->
<p>容器分组的概念是在以下的作用域内特别实现的，也就是 <code>pod</code> 作用域。</p>
<!--
### pod scope

To select the `pod` scope, start the kubelet with the command line option `--topology-manager-scope=pod`.
-->
<h3 id="pod-作用域">Pod 作用域</h3>
<p>使用命令行选项 <code>--topology-manager-scope=pod</code> 来启动 kubelet，就可以选择 <code>pod</code> 作用域。</p>
<!--
This scope allows for grouping all containers in a pod to a common set of NUMA nodes. That is, the Topology Manager treats a pod as a whole and attempts to allocate the entire pod (all containers) to either a single NUMA node or a common set of NUMA nodes. The following examples illustrate the alignments produced by the Topology Manager on different occasions:
-->
<p>该作用域允许把一个 Pod 里的所有容器作为一个分组，分配到一个共同的 NUMA 节点集。
也就是，拓扑管理器会把一个 Pod 当成一个整体，
并且试图把整个 Pod（所有容器）分配到一个单个的 NUMA 节点或者一个共同的 NUMA 节点集。
以下的例子说明了拓扑管理器在不同的场景下使用的对齐方式：</p>
<!--
* all containers can be and are allocated to a single NUMA node;
* all containers can be and are allocated to a shared set of NUMA nodes.
-->
<ul>
<li>所有容器可以被分配到一个单一的 NUMA 节点；</li>
<li>所有容器可以被分配到一个共享的 NUMA 节点集。</li>
</ul>
<!--
The total amount of particular resource demanded for the entire pod is calculated according to [effective requests/limits](/docs/concepts/workloads/pods/init-containers/#resources) formula, and thus, this total value is equal to the maximum of:
* the sum of all app container requests,
* the maximum of init container requests,
for a resource.
-->
<p>整个 Pod 所请求的某种资源总量是根据
<a href="/zh/docs/concepts/workloads/pods/init-containers/#resources">有效 request/limit</a>
公式来计算的，
因此，对某一种资源而言，该总量等于以下数值中的最大值：</p>
<ul>
<li>所有应用容器请求之和；</li>
<li>初始容器请求的最大值。</li>
</ul>
<!--
Using the `pod` scope in tandem with `single-numa-node` Topology Manager policy is specifically valuable for workloads that are latency sensitive or for high-throughput applications that perform IPC. By combining both options, you are able to place all containers in a pod onto a single NUMA node; hence, the inter-NUMA communication overhead can be eliminated for that pod.
-->
<p><code>pod</code> 作用域与 <code>single-numa-node</code> 拓扑管理器策略一起使用，
对于延时敏感的工作负载，或者对于进行 IPC 的高吞吐量应用程序，都是特别有价值的。
把这两个选项组合起来，你可以把一个 Pod 里的所有容器都放到一个单个的 NUMA 节点，
使得该 Pod 消除了 NUMA 之间的通信开销。</p>
<!--
In the case of `single-numa-node` policy, a pod is accepted only if a suitable set of NUMA nodes is present among possible allocations. Reconsider the example above:
-->
<p>在 <code>single-numa-node</code> 策略下，只有当可能的分配方案中存在合适的 NUMA 节点集时，Pod 才会被接受。
重新考虑上述的例子：</p>
<!--
* a set containing only a single NUMA node - it leads to pod being admitted,
* whereas a set containing more NUMA nodes - it results in pod rejection (because instead of one NUMA node, two or more NUMA nodes are required to satisfy the allocation).
-->
<ul>
<li>节点集只包含单个 NUMA 节点时，Pod 就会被接受，</li>
<li>然而，节点集包含多个 NUMA 节点时，Pod 就会被拒绝
（因为满足该分配方案需要两个或以上的 NUMA 节点，而不是单个 NUMA 节点）。</li>
</ul>
<!--
To recap, Topology Manager first computes a set of NUMA nodes and then tests it against Topology Manager policy, which either leads to the rejection or admission of the pod.
-->
<p>简要地说，拓扑管理器首先计算出 NUMA 节点集，然后使用拓扑管理器策略来测试该集合，
从而决定拒绝或者接受 Pod。</p>
<!--
### Topology Manager Policies
-->
<h3 id="拓扑管理器策略">拓扑管理器策略</h3>
<!--
Topology Manager supports four allocation policies. You can set a policy via a Kubelet flag, `--topology-manager-policy`.
There are four supported policies:

* `none` (default)
* `best-effort`
* `restricted`
* `single-numa-node`
-->
<p>拓扑管理器支持四种分配策略。
你可以通过 Kubelet 标志 <code>--topology-manager-policy</code> 设置策略。
所支持的策略有四种：</p>
<ul>
<li><code>none</code> (默认)</li>
<li><code>best-effort</code></li>
<li><code>restricted</code></li>
<li><code>single-numa-node</code></li>
</ul>
<!--
<blockquote class="note callout">
  <div><strong>说明：</strong> If Topology Manager is configured with the <strong>pod</strong> scope, the container, which is considered by the policy, is reflecting requirements of the entire pod, and thus each container from the pod will result with <strong>the same</strong> topology alignment decision.</div>
</blockquote>
-->
<blockquote class="note callout">
  <div><strong>说明：</strong> 如果拓扑管理器配置使用 <strong>Pod</strong> 作用域，
那么在策略考量一个容器时，该容器反映的是整个 Pod 的要求，
于是该 Pod 里的每个容器都会得到 <strong>相同的</strong> 拓扑对齐决定。</div>
</blockquote>
<!--
### none policy {#policy-none}

This is the default policy and does not perform any topology alignment.
-->
<h3 id="policy-none">none 策略</h3>
<p>这是默认策略，不执行任何拓扑对齐。</p>
<!--
### best-effort policy {#policy-best-effort}

For each container in a Guaranteed Pod, kubelet, with `best-effort` topology 
management policy, calls each Hint Provider to discover their resource availability.
Using this information, the Topology Manager stores the 
preferred NUMA Node affinity for that container. If the affinity is not preferred, 
Topology Manager will store this and admit the pod to the node anyway.
-->
<h3 id="policy-best-effort">best-effort 策略</h3>
<p>对于 Guaranteed 类的 Pod 中的每个容器，具有 <code>best-effort</code> 拓扑管理策略的
kubelet 将调用每个建议提供者以确定资源可用性。
使用此信息，拓扑管理器存储该容器的首选 NUMA 节点亲和性。
如果亲和性不是首选，则拓扑管理器将存储该亲和性，并且无论如何都将  pod 接纳到该节点。</p>
<!--
The *Hint Providers* can then use this information when making the 
resource allocation decision.
-->
<p>之后 <em>建议提供者</em> 可以在进行资源分配决策时使用这个信息。</p>
<!--
### restricted policy {#policy-restricted}

For each container in a Guaranteed Pod, kubelet, with `restricted` topology 
management policy, calls each Hint Provider to discover their resource availability.
Using this information, the Topology Manager stores the 
preferred NUMA Node affinity for that container. If the affinity is not preferred, 
Topology Manager will reject this pod from the node. This will result in a pod in a `Terminated` state with a pod admission failure.
-->
<h3 id="policy-restricted">restricted 策略</h3>
<p>对于 Guaranteed 类 Pod 中的每个容器， 配置了 <code>restricted</code> 拓扑管理策略的 kubelet
调用每个建议提供者以确定其资源可用性。。
使用此信息，拓扑管理器存储该容器的首选 NUMA 节点亲和性。
如果亲和性不是首选，则拓扑管理器将从节点中拒绝此 Pod 。
这将导致 Pod 处于 <code>Terminated</code> 状态，且 Pod 无法被节点接纳。</p>
<!--
Once the pod is in a `Terminated` state, the Kubernetes scheduler will **not** attempt to reschedule the pod. It is recommended to use a ReplicaSet or Deployment to trigger a redeploy of the pod.
An external control loop could be also implemented to trigger a redeployment of pods that have the `Topology Affinity` error.
-->
<p>一旦 Pod 处于 <code>Terminated</code> 状态，Kubernetes 调度器将不会尝试重新调度该 Pod。
建议使用 ReplicaSet 或者 Deployment 来重新部署 Pod。
还可以通过实现外部控制环，以启动对具有 <code>Topology Affinity</code> 错误的 Pod 的重新部署。</p>
<!--
If the pod is admitted, the *Hint Providers* can then use this information when making the 
resource allocation decision.
-->
<p>如果 Pod 被允许运行在某节点，则 <em>建议提供者</em> 可以在做出资源分配决定时使用此信息。</p>
<!--
### single-numa-node policy {#policy-single-numa-node}

For each container in a Guaranteed Pod, kubelet, with `single-numa-node` topology 
management policy, calls each Hint Provider to discover their resource availability.
Using this information, the Topology Manager determines if a single NUMA Node affinity is possible.
If it is, Topology Manager will store this and the *Hint Providers* can then use this information when making the 
resource allocation decision.
If, however, this is not possible then the Topology Manager will reject the pod from the node. This will result in a pod in a `Terminated` state with a pod admission failure.
-->
<h3 id="policy-single-numa-node">single-numa-node 策略</h3>
<p>对于 Guaranteed 类 Pod 中的每个容器， 配置了 <code>single-numa-nodde</code> 拓扑管理策略的
kubelet 调用每个建议提供者以确定其资源可用性。
使用此信息，拓扑管理器确定单 NUMA 节点亲和性是否可能。
如果是这样，则拓扑管理器将存储此信息，然后 <em>建议提供者</em> 可以在做出资源分配决定时使用此信息。
如果不可能，则拓扑管理器将拒绝 Pod 运行于该节点。
这将导致 Pod 处于 <code>Terminated</code> 状态，且 Pod 无法被节点接受。</p>
<!--
Once the pod is in a `Terminated` state, the Kubernetes scheduler will **not** attempt to reschedule the pod. It is recommended to use a Deployment with replicas to trigger a redeploy of the Pod.
An external control loop could be also implemented to trigger a redeployment of pods that have the `Topology Affinity` error.
-->
<p>一旦 Pod 处于 <code>Terminated</code> 状态，Kubernetes 调度器将不会尝试重新调度该 Pod。
建议使用 ReplicaSet 或者 Deployment 来重新部署 Pod。
还可以通过实现外部控制环，以触发具有 <code>Topology Affinity</code> 错误的 Pod 的重新部署。</p>
<!--
### Pod Interactions with Topology Manager Policies

Consider the containers in the following pod specs:
-->
<h3 id="pod-与拓扑管理器策略的交互">Pod 与拓扑管理器策略的交互</h3>
<p>考虑以下 pod 规范中的容器：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">spec</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">containers</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>nginx<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">image</span>:<span style="color:#bbb"> </span>nginx<span style="color:#bbb">
</span></code></pre></div><!--
This pod runs in the `BestEffort` QoS class because no resource `requests` or
`limits` are specified.
-->
<p>该 Pod 以 <code>BestEffort</code> QoS 类运行，因为没有指定资源 <code>requests</code> 或 <code>limits</code>。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">spec</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">containers</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>nginx<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">image</span>:<span style="color:#bbb"> </span>nginx<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">resources</span>:<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">limits</span>:<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#008000;font-weight:bold">memory</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;200Mi&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">requests</span>:<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#008000;font-weight:bold">memory</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;100Mi&#34;</span><span style="color:#bbb">
</span></code></pre></div><!--
This pod runs in the `Burstable` QoS class because requests are less than limits.
-->
<p>由于 requests 数少于 limits，因此该 Pod 以 <code>Burstable</code> QoS 类运行。</p>
<!--
If the selected policy is anything other than `none`, Topology Manager would consider these Pod specifications. The Topology Manager would consult the Hint Providers to get topology hints. In the case of the `static`, the CPU Manager policy would return default topology hint, because these Pods do not have explicity request CPU resources.
-->
<p>如果选择的策略是 <code>none</code> 以外的任何其他策略，拓扑管理器都会评估这些 Pod 的规范。
拓扑管理器会咨询建议提供者，获得拓扑建议。
若策略为 <code>static</code>，则 CPU 管理器策略会返回默认的拓扑建议，因为这些 Pod
并没有显式地请求 CPU 资源。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">spec</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">containers</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>nginx<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">image</span>:<span style="color:#bbb"> </span>nginx<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">resources</span>:<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">limits</span>:<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#008000;font-weight:bold">memory</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;200Mi&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#008000;font-weight:bold">cpu</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;2&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#008000;font-weight:bold">example.com/device</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;1&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">requests</span>:<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#008000;font-weight:bold">memory</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;200Mi&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#008000;font-weight:bold">cpu</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;2&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#008000;font-weight:bold">example.com/device</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;1&#34;</span><span style="color:#bbb">
</span></code></pre></div><!--
This pod with integer CPU request runs in the `Guaranteed` QoS class because
`requests` are equal to `limits`.
-->
<p>此 Pod 以 <code>Guaranteed</code> QoS 类运行，因为其 <code>requests</code> 值等于 <code>limits</code> 值。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">spec</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">containers</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>nginx<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">image</span>:<span style="color:#bbb"> </span>nginx<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">resources</span>:<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">limits</span>:<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#008000;font-weight:bold">example.com/deviceA</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;1&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#008000;font-weight:bold">example.com/deviceB</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;1&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">requests</span>:<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#008000;font-weight:bold">example.com/deviceA</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;1&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#008000;font-weight:bold">example.com/deviceB</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;1&#34;</span><span style="color:#bbb">
</span></code></pre></div><!--
This pod runs in the `BestEffort` QoS class because there are no CPU and memory requests.
-->
<p>因为未指定 CPU 和内存请求，所以 Pod 以 <code>BestEffort</code> QoS 类运行。</p>
<!--
The Topology Manager would consider both of the above pods. The Topology Manager would consult the Hint Providers, which are CPU and Device Manager to get topology hints for the pods. 

In the case of the `Guaranteed` pod with integer request, the `static` CPU Manager policy would return hints relating to the CPU request and the Device Manager would send back hints for the requested device.
-->
<p>拓扑管理器将考虑以上两个 Pod。拓扑管理器将咨询建议提供者即 CPU 和设备管理器，以获取 Pod 的拓扑提示。
对于 <code>Guaranteed</code> 类的 CPU 请求数为整数的 Pod，<code>static</code> CPU 管理器策略将返回与 CPU 请求有关的提示，
而设备管理器将返回有关所请求设备的提示。</p>
<!--
In the case of the `Guaranteed` pod with sharing CPU request, the `static` CPU Manager policy would return default topology hint as there is no exclusive CPU request and the Device Manager would send back hints for the requested device.

In the above two cases of the `Guaranteed` pod, the `none` CPU Manager policy would return default topology hint.
-->
<p>对于 <code>Guaranteed</code> 类的 CPU 请求可共享的 Pod，<code>static</code> CPU
管理器策略将返回默认的拓扑提示，因为没有排他性的 CPU 请求；而设备管理器
则针对所请求的设备返回有关提示。</p>
<p>在上述两种 <code>Guaranteed</code> Pod 的情况中，<code>none</code> CPU 管理器策略会返回默认的拓扑提示。</p>
<!--
In the case of the `BestEffort` pod, the `static` CPU Manager policy would send back the default topology hint as there is no CPU request and the Device Manager would send back the hints for each of the requested devices.
-->
<p>对于 <code>BestEffort</code> Pod，由于没有 CPU 请求，<code>static</code> CPU 管理器策略将发送默认提示，
而设备管理器将为每个请求的设备发送提示。</p>
<!--
Using this information the Topology Manager calculates the optimal hint for the pod and stores this information, which will be used by the Hint Providers when they are making their resource assignments.
-->
<p>基于此信息，拓扑管理器将为 Pod 计算最佳提示并存储该信息，并且供
提示提供程序在进行资源分配时使用。</p>
<!--
### Known Limitations

1. The maximum number of NUMA nodes that Topology Manager allows is 8. With more than 8 NUMA nodes there will be a state explosion when trying to enumerate the possible NUMA affinities and generating their hints.

2. The scheduler is not topology-aware, so it is possible to be scheduled on a node and then fail on the node due to the Topology Manager.

3. The Device Manager and the CPU Manager are the only components to adopt the Topology Manager's HintProvider interface. This means that NUMA alignment can only be achieved for resources managed by the CPU Manager and the Device Manager. Memory or Hugepages are not considered by the Topology Manager for NUMA alignment.
-->
<h3 id="已知的局限性">已知的局限性</h3>
<ol>
<li>拓扑管理器所能处理的最大 NUMA 节点个数是 8。若 NUMA 节点数超过 8，
枚举可能的 NUMA 亲和性并为之生成提示时会发生状态爆炸。</li>
<li>调度器不支持拓扑功能，因此可能会由于拓扑管理器的原因而在节点上进行调度，然后在该节点上调度失败。</li>
<li>设备管理器和 CPU 管理器时能够采纳拓扑管理器 HintProvider 接口的唯一两个组件。
这意味着 NUMA 对齐只能针对 CPU 管理器和设备管理器所管理的资源实现。
内存和大页面在拓扑管理器决定 NUMA 对齐时都还不会被考虑在内。</li>
</ol>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-0b17e83b6049e53b8ffa864bdfa07c87">30 - 搭建高可用的 Kubernetes Masters</h1>
    
	<!--
reviewers:
- jszczepkowski
title: Set up High-Availability Kubernetes Masters
content_type: task
-->
<!-- overview -->





<div style="margin-top: 10px; margin-bottom: 10px;">
<b>FEATURE STATE:</b> <code>Kubernetes 1.5 [alpha]</code>
</div>

<!--
You can replicate Kubernetes masters in `kube-up` or `kube-down` scripts for Google Compute Engine.
This document describes how to use kube-up/down scripts to manage highly available (HA) masters and how HA masters are implemented for use with GCE.
-->
<p>你可以在谷歌计算引擎（GCE）的 <code>kubeup</code> 或 <code>kube-down</code> 脚本中复制 Kubernetes Master。
本文描述了如何使用 kube-up/down 脚本来管理高可用（HA）的 Master，
以及如何使用 GCE 实现高可用控制节点。</p>
<h2 id="准备开始">准备开始</h2>
<p><p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
如果你还没有集群，你可以通过 <a href="/zh/docs/tasks/tools/#minikube">Minikube</a> 构建一
个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p>
<!--
You need to have a Kubernetes cluster, and the kubectl command-line tool must
be configured to communicate with your cluster. If you do not already have a
cluster, you can create one by using
[minikube](/docs/tasks/tools/#minikube)
or you can use one of these Kubernetes playgrounds:
-->
<ul>
<li><a href="https://www.katacoda.com/courses/kubernetes/playground">Katacoda</a></li>
<li><a href="http://labs.play-with-k8s.com/">玩转 Kubernetes</a></li>
</ul>
 
 要获知版本信息，请输入 <code>kubectl version</code>.
</p>
<!-- steps -->
<!--
## Starting an HA-compatible cluster

To create a new HA-compatible cluster, you must set the following flags in your `kube-up` script:
-->
<h2 id="启动一个兼容高可用的集群">启动一个兼容高可用的集群</h2>
<p>要创建一个新的兼容高可用的集群，你必须在 <code>kubeup</code> 脚本中设置以下标志:</p>
<!--
* `MULTIZONE=true` - to prevent removal of master replicas kubelets from zones different than server's default zone.
Required if you want to run master replicas in different zones, which is recommended.

* `ENABLE_ETCD_QUORUM_READ=true` - to ensure that reads from all API servers will return most up-to-date data.
If true, reads will be directed to leader etcd replica.
Setting this value to true is optional: reads will be more reliable but will also be slower.

Optionally, you can specify a GCE zone where the first master replica is to be created.
Set the following flag:

* `KUBE_GCE_ZONE=zone` - zone where the first master replica will run.

The following sample command sets up a HA-compatible cluster in the GCE zone europe-west1-b:

```shell
MULTIZONE=true KUBE_GCE_ZONE=europe-west1-b  ENABLE_ETCD_QUORUM_READS=true ./cluster/kube-up.sh
```

Note that the commands above create a cluster with one master;
however, you can add new master replicas to the cluster with subsequent commands.
-->
<ul>
<li>
<p><code>MULTIZONE=true</code> - 为了防止从不同于服务器的默认区域的区域中删除 kubelets 副本。
如果你希望在不同的区域运行副本，那么这一项是必需并且推荐的。</p>
</li>
<li>
<p><code>ENABLE_ETCD_QUORUM_READ=true</code> - 确保从所有 API 服务器读取数据时将返回最新的数据。
如果为 true，读操作将被定向到主 etcd 副本。可以选择将这个值设置为 true，
那么读取将更可靠，但也会更慢。</p>
</li>
</ul>
<p>你还可以指定一个 GCE 区域，在这里创建第一个主节点副本。设置以下标志:</p>
<ul>
<li><code>KUBE_GCE_ZONE=zone</code> - 将运行第一个主节点副本的区域。</li>
</ul>
<p>下面的命令演示在 GCE  europe-west1-b 区域中设置一个兼容高可用的集群:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="color:#b8860b">MULTIZONE</span><span style="color:#666">=</span><span style="color:#a2f">true</span> <span style="color:#b8860b">KUBE_GCE_ZONE</span><span style="color:#666">=</span>europe-west1-b  <span style="color:#b8860b">ENABLE_ETCD_QUORUM_READS</span><span style="color:#666">=</span><span style="color:#a2f">true</span> ./cluster/kube-up.sh
</code></pre></div><p>注意，上面的命令创建一个只有单一主节点的集群;
但是，你可以使用后续命令将新的主节点副本添加到集群中。</p>
<!--
## Adding a new master replica

After you have created an HA-compatible cluster, you can add master replicas to it.
You add master replicas by using a `kube-up` script with the following flags:

* `KUBE_REPLICATE_EXISTING_MASTER=true` - to create a replica of an existing
master.

* `KUBE_GCE_ZONE=zone` - zone where the master replica will run.
Must be in the same region as other replicas' zones.

You don't need to set the `MULTIZONE` or `ENABLE_ETCD_QUORUM_READS` flags,
as those are inherited from when you started your HA-compatible cluster.

The following sample command replicates the master on an existing HA-compatible cluster:

```shell
KUBE_GCE_ZONE=europe-west1-c KUBE_REPLICATE_EXISTING_MASTER=true ./cluster/kube-up.sh
```
-->
<h2 id="增加一个新的主节点副本">增加一个新的主节点副本</h2>
<p>在创建了兼容高可用的集群之后，可以向其中添加主节点副本。
你可以使用带有如下标记的 <code>kubeup</code> 脚本添加主节点副本:</p>
<ul>
<li>
<p><code>KUBE_REPLICATE_EXISTING_MASTER=true</code> - 创建一个已经存在的主节点的副本。</p>
</li>
<li>
<p><code>KUBE_GCE_ZONE=zone</code> -主节点副本将运行的区域。必须与其他副本位于同一区域。</p>
</li>
</ul>
<p>你无需设置 <code>MULTIZONE</code> 或 <code>ENABLE_ETCD_QUORUM_READS</code> 标志，因为他们可以从兼容高可用的集群中继承。</p>
<p>使用下面的命令可以复制现有兼容高可用的集群上的 Master:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="color:#b8860b">KUBE_GCE_ZONE</span><span style="color:#666">=</span>europe-west1-c <span style="color:#b8860b">KUBE_REPLICATE_EXISTING_MASTER</span><span style="color:#666">=</span><span style="color:#a2f">true</span> ./cluster/kube-up.sh
</code></pre></div><!--
## Removing a master replica

You can remove a master replica from an HA cluster by using a `kube-down` script with the following flags:

* `KUBE_DELETE_NODES=false` - to restrain deletion of kubelets.

* `KUBE_GCE_ZONE=zone` - the zone from where master replica will be removed.

* `KUBE_REPLICA_NAME=replica_name` - (optional) the name of master replica to remove.
If empty: any replica from the given zone will be removed.

The following sample command removes a master replica from an existing HA cluster:

```shell
KUBE_DELETE_NODES=false KUBE_GCE_ZONE=europe-west1-c ./cluster/kube-down.sh
```
-->
<h2 id="删除主节点副本">删除主节点副本</h2>
<p>你可以使用一个 <code>kube-down</code> 脚本从高可用集群中删除一个主节点副本，并可以使用以下标记:</p>
<ul>
<li>
<p><code>KUBE_DELETE_NODES=false</code> - 限制删除 kubelets。</p>
</li>
<li>
<p><code>KUBE_GCE_ZONE=zone</code> - 将移除主节点副本的区域。</p>
</li>
<li>
<p><code>KUBE_REPLICA_NAME=replica_name</code> - （可选）要删除的主节点副本的名称。
如果为空：将删除给定区域中的所有副本。</p>
</li>
</ul>
<p>使用下面的命令可以从一个现有的高可用集群中删除一个 Master副本:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="color:#b8860b">KUBE_DELETE_NODES</span><span style="color:#666">=</span><span style="color:#a2f">false</span> <span style="color:#b8860b">KUBE_GCE_ZONE</span><span style="color:#666">=</span>europe-west1-c ./cluster/kube-down.sh
</code></pre></div><!--
## Handling master replica failures

If one of the master replicas in your HA cluster fails,
the best practice is to remove the replica from your cluster and add a new replica in the same zone.
The following sample commands demonstrate this process:

1. Remove the broken replica:

```shell
KUBE_DELETE_NODES=false KUBE_GCE_ZONE=replica_zone KUBE_REPLICA_NAME=replica_name ./cluster/kube-down.sh
```

<ol start="2"><li>Add a new replica in place of the old one:</li></ol>

```shell
KUBE_GCE_ZONE=replica-zone KUBE_REPLICATE_EXISTING_MASTER=true ./cluster/kube-up.sh
```
-->
<h2 id="处理主节点副本失败">处理主节点副本失败</h2>
<p>如果高可用集群中的一个主节点副本失败，最佳实践是从集群中删除副本，
并在相同的区域中添加一个新副本。
下面的命令演示了这个过程:</p>
<ol>
<li>删除失败的副本:</li>
</ol>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="color:#b8860b">KUBE_DELETE_NODES</span><span style="color:#666">=</span><span style="color:#a2f">false</span> <span style="color:#b8860b">KUBE_GCE_ZONE</span><span style="color:#666">=</span>replica_zone <span style="color:#b8860b">KUBE_REPLICA_NAME</span><span style="color:#666">=</span>replica_name ./cluster/kube-down.sh
</code></pre></div><ol start="2"><li>在原有位置增加一个新副本：</li></ol>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="color:#b8860b">KUBE_GCE_ZONE</span><span style="color:#666">=</span>replica-zone <span style="color:#b8860b">KUBE_REPLICATE_EXISTING_MASTER</span><span style="color:#666">=</span><span style="color:#a2f">true</span> ./cluster/kube-up.sh
</code></pre></div><!--
## Best practices for replicating masters for HA clusters

* Try to place master replicas in different zones. During a zone failure, all masters placed inside the zone will fail.
To survive zone failure, also place nodes in multiple zones
(see [multiple-zones](/docs/setup/best-practices/multiple-zones/) for details).

* Do not use a cluster with two master replicas. Consensus on a two-replica cluster requires both replicas running when changing persistent state.
As a result, both replicas are needed and a failure of any replica turns cluster into majority failure state.
A two-replica cluster is thus inferior, in terms of HA, to a single replica cluster.

* When you add a master replica, cluster state (etcd) is copied to a new instance.
If the cluster is large, it may take a long time to duplicate its state.
This operation may be sped up by migrating etcd data directory, as described [here](https://coreos.com/etcd/docs/latest/admin_guide.html#member-migration)
(we are considering adding support for etcd data dir migration in future).
-->
<h2 id="高可用集群复制主节点的最佳实践">高可用集群复制主节点的最佳实践</h2>
<ul>
<li>
<p>尝试将主节点副本放置在不同的区域。在某区域故障时，放置在该区域内的所有主机都将失败。
为了在区域故障中幸免，请同样将工作节点放置在多区域中
（详情请见<a href="/zh/docs/setup/best-practices/multiple-zones/">多区域</a>）。</p>
</li>
<li>
<p>不要使用具有两个主节点副本的集群。在双副本集群上达成一致需要在更改持久状态时
两个副本都处于运行状态。
因此，两个副本都是需要的，任一副本的失败都会将集群带入多数失败状态。
因此，就高可用而言，双副本集群不如单个副本集群。</p>
</li>
<li>
<p>添加主节点副本时，集群状态（etcd）会被复制到一个新实例。如果集群很大，
可能需要很长时间才能复制它的状态。
这个操作可以通过迁移 etcd 数据存储来加速, 详情参见
<a href="https://coreos.com/etcd/docs/latest/admin_guide.html#member-migration">这里</a>
（我们正在考虑在未来添加对迁移 etcd 数据存储的支持）。</p>
</li>
</ul>
<!-- discussion -->
<!--
## Implementation notes

![ha-master-gce](/images/docs/ha-master-gce.png)
-->
<h2 id="实现说明">实现说明</h2>
<p><img src="/images/docs/ha-master-gce.png" alt="ha-master-gce"></p>
<!--
### Overview

Each of master replicas will run the following components in the following mode:

* etcd instance: all instances will be clustered together using consensus;

* API server: each server will talk to local etcd - all API servers in the cluster will be available;

* controllers, scheduler, and cluster auto-scaler: will use lease mechanism - only one instance of each of them will be active in the cluster;

* add-on manager: each manager will work independently trying to keep add-ons in sync.

In addition, there will be a load balancer in front of API servers that will route external and internal traffic to them.
-->
<h3 id="概述">概述</h3>
<p>每个主节点副本将以以下模式运行以下组件:</p>
<ul>
<li>
<p>etcd 实例： 所有实例将会以共识方式组建集群；</p>
</li>
<li>
<p>API 服务器： 每个服务器将与本地 etcd 通信——集群中的所有 API 服务器都可用;</p>
</li>
<li>
<p>控制器、调度器和集群自动扩缩器：将使用租约机制 —— 每个集群中只有一个实例是可用的；</p>
</li>
<li>
<p>插件管理器：每个管理器将独立工作，试图保持插件同步。</p>
</li>
</ul>
<p>此外，在 API 服务器前面将有一个负载均衡器，用于将外部和内部通信路由到他们。</p>
<!--
### Load balancing

When starting the second master replica, a load balancer containing the two replicas will be created
and the IP address of the first replica will be promoted to IP address of load balancer.
Similarly, after removal of the penultimate master replica, the load balancer will be removed and its IP address will be assigned to the last remaining replica.
Please note that creation and removal of load balancer are complex operations and it may take some time (~20 minutes) for them to propagate.
-->
<h3 id="负载均衡">负载均衡</h3>
<p>启动第二个主节点副本时，将创建一个包含两个副本的负载均衡器，
并将第一个副本的 IP 地址提升为负载均衡器的 IP 地址。
类似地，在删除倒数第二个主节点副本之后，将删除负载均衡器，
并将其 IP 地址分配给最后一个剩余的副本。
请注意，创建和删除负载均衡器是复杂的操作，可能需要一些时间（约20分钟）来同步。</p>
<!--
###主节点service & kubelets

Instead of trying to keep an up-to-date list of Kubernetes apiserver in the Kubernetes service,
the system directs all traffic to the external IP:

* in one master cluster the IP points to the single master,

* in multi-master cluster the IP points to the load balancer in-front of the masters.

Similarly, the external IP will be used by kubelets to communicate with master.
-->
<h3 id="主节点服务-kubelets">主节点服务 &amp; kubelets</h3>
<p>Kubernetes 并不试图在其服务中保持 apiserver 的列表为最新，
相反，它将将所有访问请求指向外部 IP：</p>
<ul>
<li>在拥有一个主节点的集群中，IP 指向单一的主节点，</li>
<li>在拥有多个主节点的集群中，IP 指向主节点前面的负载均衡器。</li>
</ul>
<p>类似地，kubelets 将使用外部 IP 与主节点通信。</p>
<!--
### Master certificates

Kubernetes generates主节点TLS certificates for the external public IP and local IP for each replica.
There are no certificates for the ephemeral public IP for replicas;
to access a replica via its ephemeral public IP, you must skip TLS verification.
-->
<h3 id="主节点证书">主节点证书</h3>
<p>Kubernetes 为每个副本的外部公共 IP 和本地 IP 生成主节点 TLS 证书。
副本的临时公共 IP 没有证书；
要通过其临时公共 IP 访问副本，必须跳过 TLS 检查。</p>
<!--
### Clustering etcd

To allow etcd clustering, ports needed to communicate between etcd instances will be opened (for inside cluster communication).
To make such deployment secure, communication between etcd instances is authorized using SSL.
-->
<h3 id="etcd-集群">etcd 集群</h3>
<p>为了允许 etcd 组建集群，需开放 etcd 实例之间通信所需的端口（用于集群内部通信）。
为了使这种部署安全，etcd 实例之间的通信使用 SSL 进行鉴权。</p>
<!--
### API server identity
-->
<h3 id="api-服务器标识">API 服务器标识</h3>





<div style="margin-top: 10px; margin-bottom: 10px;">
<b>FEATURE STATE:</b> <code>Kubernetes v1.20 [alpha]</code>
</div>

<!--
The API Server Identity feature is controlled by a
[feature gate](/docs/reference/command-line-tools-reference/feature-gates/)
and is not enabled by default. You can activate API Server Identity by enabling
the feature gate named `APIServerIdentity` when you start the
<a class='glossary-tooltip' title='提供 Kubernetes API 服务的控制面组件。' data-toggle='tooltip' data-placement='top' href='/zh/docs/reference/command-line-tools-reference/kube-apiserver/' target='_blank' aria-label='API Server'>API Server</a>:
-->
<p>使用 API 服务器标识功能需要启用<a href="/zh/docs/reference/command-line-tools-reference/feature-gates/">特性门控</a>，
该功能默认不启用。
你可以在启动 <a class='glossary-tooltip' title='提供 Kubernetes API 服务的控制面组件。' data-toggle='tooltip' data-placement='top' href='/zh/docs/reference/command-line-tools-reference/kube-apiserver/' target='_blank' aria-label='API 服务器'>API 服务器</a> 的时候启用特性门控 <code>APIServerIdentity</code> 来激活 API 服务器标识：</p>
<!--
```shell
kube-apiserver \
--feature-gates=APIServerIdentity=true \
 # …and other flags as usual
```
-->
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kube-apiserver <span style="color:#b62;font-weight:bold">\
</span><span style="color:#b62;font-weight:bold"></span>--feature-gates<span style="color:#666">=</span><span style="color:#b8860b">APIServerIdentity</span><span style="color:#666">=</span><span style="color:#a2f">true</span> <span style="color:#b62;font-weight:bold">\
</span><span style="color:#b62;font-weight:bold"></span> <span style="color:#080;font-style:italic"># …其他标记照常</span>
</code></pre></div><!--
During bootstrap, each kube-apiserver assigns a unique ID to itself. The ID is
in the format of `kube-apiserver-{UUID}`. Each kube-apiserver creates a
[Lease](/docs/reference/generated/kubernetes-api/v1.22//#lease-v1-coordination-k8s-io)
in the _kube-system_ <a class='glossary-tooltip' title='名字空间是 Kubernetes 为了在同一物理集群上支持多个虚拟集群而使用的一种抽象。' data-toggle='tooltip' data-placement='top' href='/zh/docs/concepts/overview/working-with-objects/namespaces/' target='_blank' aria-label='namespaces'>namespaces</a>.
-->
<p>在启动引导过程中，每个 kube-apiserver 会给自己分配一个唯一 ID。
该 ID 的格式是 <code>kube-apiserver-{UUID}</code>。
每个 kube-apiserver 会在 <em>kube-system</em> <a class='glossary-tooltip' title='名字空间是 Kubernetes 为了在同一物理集群上支持多个虚拟集群而使用的一种抽象。' data-toggle='tooltip' data-placement='top' href='/zh/docs/concepts/overview/working-with-objects/namespaces/' target='_blank' aria-label='名字空间'>名字空间</a> 里创建一个 <a href="/docs/reference/generated/kubernetes-api/v1.22//#lease-v1-coordination-k8s-io"><code>Lease</code> 对象</a>。</p>
<!--
The Lease name is the unique ID for the kube-apiserver. The Lease contains a
label `k8s.io/component=kube-apiserver`. Each kube-apiserver refreshes its
Lease every `IdentityLeaseRenewIntervalSeconds` (defaults to 10s). Each
kube-apiserver also checks all the kube-apiserver identity Leases every
`IdentityLeaseDurationSeconds` (defaults to 3600s), and deletes Leases that
hasn't got refreshed for more than `IdentityLeaseDurationSeconds`.
`IdentityLeaseRenewIntervalSeconds` and `IdentityLeaseDurationSeconds` can be
configured by kube-apiserver flags `identity-lease-renew-interval-seconds`
and `identity-lease-duration-seconds`.
-->
<p><code>Lease</code> 对象的名字是 kube-apiserver 的唯一 ID。
<code>Lease</code> 对象包含一个标签 <code>k8s.io/component=kube-apiserver</code>。
每个 kube-apiserver 每过 <code>IdentityLeaseRenewIntervalSeconds</code>（默认是 10 秒）就会刷新它的 <code>Lease</code> 对象。
每个 kube-apiserver 每过 <code>IdentityLeaseDurationSeconds</code>（默认是 3600 秒）也会检查所有 kube-apiserver 的标识 <code>Lease</code> 对象，
并且会删除超过 <code>IdentityLeaseDurationSeconds</code> 时间还没被刷新的 <code>Lease</code> 对象。
可以在 kube-apiserver 的 <code>identity-lease-renew-interval-seconds</code>
和 <code>identity-lease-duration-seconds</code> 标记里配置 <code>IdentityLeaseRenewIntervalSeconds</code> 和 <code>IdentityLeaseDurationSeconds</code>。</p>
<!--
Enabling this feature is a prerequisite for using features that involve HA API
server coordination (for example, the `StorageVersionAPI` feature gate).
-->
<p>启用该功能是使用 HA API 服务器协调相关功能（例如，<code>StorageVersionAPI</code> 特性门控）的前提条件。</p>
<!--
## Additional reading

[Automated HA master deployment - design doc](https://git.k8s.io/community/contributors/design-proposals/cluster-lifecycle/ha_master.md)
-->
<h2 id="拓展阅读">拓展阅读</h2>
<p><a href="https://git.k8s.io/community/contributors/design-proposals/cluster-lifecycle/ha_master.md">自动化高可用集群部署 - 设计文档</a></p>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-2bffd7f3571cdd609bd97fb2e1bdb2fe">31 - 改变默认 StorageClass</h1>
    
	<!-- overview -->
<!--
This page shows how to change the default Storage Class that is used to
provision volumes for PersistentVolumeClaims that have no special requirements.
-->
<p>本文展示了如何改变默认的 Storage Class，它用于为没有特殊需求的 PersistentVolumeClaims 配置 volumes。</p>
<h2 id="准备开始">准备开始</h2>
<p><p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
如果你还没有集群，你可以通过 <a href="/zh/docs/tasks/tools/#minikube">Minikube</a> 构建一
个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p>
<!--
You need to have a Kubernetes cluster, and the kubectl command-line tool must
be configured to communicate with your cluster. If you do not already have a
cluster, you can create one by using
[minikube](/docs/tasks/tools/#minikube)
or you can use one of these Kubernetes playgrounds:
-->
<ul>
<li><a href="https://www.katacoda.com/courses/kubernetes/playground">Katacoda</a></li>
<li><a href="http://labs.play-with-k8s.com/">玩转 Kubernetes</a></li>
</ul>
 
 要获知版本信息，请输入 <code>kubectl version</code>.
</p>
<!-- steps -->
<!--
## Why change the default storage class?

Depending on the installation method, your Kubernetes cluster may be deployed with
an existing StorageClass that is marked as default. This default StorageClass
is then used to dynamically provision storage for PersistentVolumeClaims
that do not require any specific storage class. See
[PersistentVolumeClaim documentation](/docs/concepts/storage/persistent-volumes/#persistentvolumeclaims)
for details.
-->
<h2 id="为什么要改变默认存储类">为什么要改变默认存储类？</h2>
<p>取决于安装模式，你的 Kubernetes 集群可能和一个被标记为默认的已有 StorageClass 一起部署。
这个默认的 StorageClass 以后将被用于动态的为没有特定存储类需求的 PersistentVolumeClaims
配置存储。更多细节请查看
<a href="/zh/docs/concepts/storage/persistent-volumes/#perspersistentvolumeclaims">PersistentVolumeClaim 文档</a>。</p>
<!--
The pre-installed default StorageClass may not fit well with your expected workload;
for example, it might provision storage that is too expensive. If this is the case,
you can either change the default StorageClass or disable it completely to avoid
dynamic provisioning of storage.
-->
<p>预先安装的默认 StorageClass 可能不能很好的适应你期望的工作负载；例如，它配置的存储可能太过昂贵。
如果是这样的话，你可以改变默认 StorageClass，或者完全禁用它以防止动态配置存储。</p>
<!--
Deleting the default StorageClass may not work, as it may be re-created
automatically by the addon manager running in your cluster. Please consult the docs for your installation
for details about addon manager and how to disable individual addons.
-->
<p>删除默认 StorageClass 可能行不通，因为它可能会被你集群中的扩展管理器自动重建。
请查阅你的安装文档中关于扩展管理器的细节，以及如何禁用单个扩展。</p>
<!--
## Changing the default StorageClass
-->
<h2 id="改变默认-storageclass">改变默认 StorageClass</h2>
<!--
1. List the StorageClasses in your cluster: 
-->
<ol>
<li>
<p>列出你的集群中的 StorageClasses：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl get storageclass
</code></pre></div><p>输出类似这样：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">NAME                 PROVISIONER               AGE
standard <span style="color:#666">(</span>default<span style="color:#666">)</span>   kubernetes.io/gce-pd      1d
gold                 kubernetes.io/gce-pd      1d
</code></pre></div><p>默认 StorageClass 以 <code>(default)</code> 标记。</p>
</li>
</ol>
<!--
1. Mark the default StorageClass as non-default:
-->
<ol start="2">
<li>
<p>标记默认 StorageClass  非默认：</p>
<!--
The default StorageClass has an annotation
`storageclass.kubernetes.io/is-default-class` set to `true`. Any other value
or absence of the annotation is interpreted as `false`.

To mark a StorageClass as non-default, you need to change its value to `false`:
-->
<p>默认 StorageClass 的注解 <code>storageclass.kubernetes.io/is-default-class</code> 设置为 <code>true</code>。
注解的其它任意值或者缺省值将被解释为 <code>false</code>。</p>
<p>要标记一个 StorageClass 为非默认的，你需要改变它的值为 <code>false</code>：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">kubectl patch storageclass standard -p <span style="color:#b44">&#39;{&#34;metadata&#34;: {&#34;annotations&#34;:{&#34;storageclass.kubernetes.io/is-default-class&#34;:&#34;false&#34;}}}&#39;</span>
</code></pre></div><!--
where `standard` is the name of your chosen StorageClass.
-->
<p>这里的 <code>standard</code> 是你选择的 StorageClass 的名字。</p>
</li>
</ol>
<!--
1. Mark a StorageClass as default:
-->
<ol start="3">
<li>
<p>标记一个 StorageClass 为默认的：</p>
<!--
Similar to the previous step, you need to add/set the annotation
`storageclass.kubernetes.io/is-default-class=true`.
-->
<p>和前面的步骤类似，你需要添加/设置注解 <code>storageclass.kubernetes.io/is-default-class=true</code>。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">kubectl patch storageclass &lt;your-class-name&gt; -p <span style="color:#b44">&#39;{&#34;metadata&#34;: {&#34;annotations&#34;:{&#34;storageclass.kubernetes.io/is-default-class&#34;:&#34;true&#34;}}}&#39;</span>
</code></pre></div><!--
Please note that at most one StorageClass can be marked as default. If two
or more of them are marked as default, a `PersistentVolumeClaim` without
`storageClassName` explicitly specified cannot be created.
-->
<p>请注意，最多只能有一个 StorageClass 能够被标记为默认。
如果它们中有两个或多个被标记为默认，Kubernetes 将忽略这个注解，
也就是它将表现为没有默认 StorageClass。</p>
</li>
</ol>
<!--
1. Verify that your chosen StorageClass is default:
-->
<ol start="4">
<li>
<p>验证你选用的 StorageClass 为默认的：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">kubectl get storageclass
</code></pre></div><!--
The output is similar to this:
-->
<p>输出类似这样：</p>
<pre tabindex="0"><code>NAME             PROVISIONER               AGE
standard         kubernetes.io/gce-pd      1d
gold (default)   kubernetes.io/gce-pd      1d
</code></pre></li>
</ol>
<h2 id="接下来">接下来</h2>
<!--
* Learn more about [PersistentVolumes](/docs/concepts/storage/persistent-volumes/).
-->
<ul>
<li>进一步了解 <a href="/zh/docs/concepts/storage/persistent-volumes/">PersistentVolumes</a></li>
</ul>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-fbc9136f53eccd6eb8c80f4bbea3b8f4">32 - 更改 PersistentVolume 的回收策略</h1>
    
	<!-- overview -->
<!--
This page shows how to change the reclaim policy of a Kubernetes
PersistentVolume.
-->
<p>本文展示了如何更改 Kubernetes PersistentVolume 的回收策略。</p>
<h2 id="准备开始">准备开始</h2>
<p><p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
如果你还没有集群，你可以通过 <a href="/zh/docs/tasks/tools/#minikube">Minikube</a> 构建一
个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p>
<!--
You need to have a Kubernetes cluster, and the kubectl command-line tool must
be configured to communicate with your cluster. If you do not already have a
cluster, you can create one by using
[minikube](/docs/tasks/tools/#minikube)
or you can use one of these Kubernetes playgrounds:
-->
<ul>
<li><a href="https://www.katacoda.com/courses/kubernetes/playground">Katacoda</a></li>
<li><a href="http://labs.play-with-k8s.com/">玩转 Kubernetes</a></li>
</ul>
 
 要获知版本信息，请输入 <code>kubectl version</code>.
</p>
<!-- steps -->
<!--
## Why change reclaim policy of a PersistentVolume

PersistentVolumes can have various reclaim policies, including "Retain",
"Recycle", and "Delete". For dynamically provisioned PersistentVolumes,
the default reclaim policy is "Delete". This means that a dynamically provisioned
volume is automatically deleted when a user deletes the corresponding
PersistentVolumeClaim. This automatic behavior might be inappropriate if the volume
contains precious data. In that case, it is more appropriate to use the "Retain"
policy. With the "Retain" policy, if a user deletes a PersistentVolumeClaim,
the corresponding PersistentVolume will not be deleted. Instead, it is moved to the
Released phase, where all of its data can be manually recovered.
-->
<h2 id="为什么要更改-persistentvolume-的回收策略">为什么要更改 PersistentVolume 的回收策略</h2>
<p>PersistentVolumes 可以有多种回收策略，包括 &quot;Retain&quot;、&quot;Recycle&quot; 和  &quot;Delete&quot;。
对于动态配置的 PersistentVolumes 来说，默认回收策略为 &quot;Delete&quot;。
这表示当用户删除对应的 PersistentVolumeClaim 时，动态配置的 volume 将被自动删除。
如果 volume 包含重要数据时，这种自动行为可能是不合适的。
那种情况下，更适合使用 &quot;Retain&quot; 策略。
使用 &quot;Retain&quot; 时，如果用户删除 PersistentVolumeClaim，对应的 PersistentVolume 不会被删除。
相反，它将变为 Released 状态，表示所有的数据可以被手动恢复。</p>
<!--
## Changing the reclaim policy of a PersistentVolume
-->
<h2 id="更改-persistentvolume-的回收策略">更改 PersistentVolume 的回收策略</h2>
<!--
1. List the PersistentVolumes in your cluster:
-->
<ol>
<li>
<p>列出你集群中的 PersistentVolumes</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl get pv
</code></pre></div><p>输出类似于这样：</p>
<pre tabindex="0"><code>NAME                                       CAPACITY   ACCESSMODES   RECLAIMPOLICY   STATUS    CLAIM                  REASON    AGE
pvc-b6efd8da-b7b5-11e6-9d58-0ed433a7dd94   4Gi        RWO           Delete          Bound     default/claim1                   10s
pvc-b95650f8-b7b5-11e6-9d58-0ed433a7dd94   4Gi        RWO           Delete          Bound     default/claim2                   6s
pvc-bb3ca71d-b7b5-11e6-9d58-0ed433a7dd94   4Gi        RWO           Delete          Bound     default/claim3                   3s
</code></pre><!--
This list also includes the name of the claims that are bound to each volume
for easier identification of dynamically provisioned volumes.
-->
<p>这个列表同样包含了绑定到每个卷的 claims 名称，以便更容易的识别动态配置的卷。</p>
</li>
</ol>
<!--
1. Choose one of your PersistentVolumes and change its reclaim policy:
-->
<ol start="2">
<li>
<p>选择你的 PersistentVolumes 中的一个并更改它的回收策略：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl patch pv &lt;your-pv-name&gt; -p <span style="color:#b44">&#39;{&#34;spec&#34;:{&#34;persistentVolumeReclaimPolicy&#34;:&#34;Retain&#34;}}&#39;</span>
</code></pre></div><!--
where `<your-pv-name>` is the name of your chosen PersistentVolume.
-->
<p>这里的 <code>&lt;your-pv-name&gt;</code> 是你选择的 PersistentVolume 的名字。</p>
<!--
On Windows, you must _double_ quote any JSONPath template that contains spaces
(not single quote as shown above for bash). This in turn means that you must
use a single quote or escaped double quote around any literals in the template. For example:
-->
<blockquote class="note callout">
  <div><strong>说明：</strong> <p>在 Windows 系统上，你必须对包含空格的 JSONPath 模板加双引号（而不是像上面
一样为 Bash 环境使用的单引号）。这也意味着你必须使用单引号或者转义的双引号
来处理模板中的字面值。例如：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cmd" data-lang="cmd">kubectl patch pv &lt;your-pv-name&gt; -p <span style="color:#b44">&#34;{\&#34;</span>spec\<span style="color:#b44">&#34;:{\&#34;</span>persistentVolumeReclaimPolicy\<span style="color:#b44">&#34;:\&#34;</span>Retain\<span style="color:#b44">&#34;}}&#34;</span>
</code></pre></div></div>
</blockquote>
</li>
</ol>
<!--
1. Verify that your chosen PersistentVolume has the right policy:
-->
<ol start="3">
<li>
<p>验证你选择的 PersistentVolume 拥有正确的策略：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl get pv
</code></pre></div><!--
The output is similar to this:
-->
<p>输出类似于这样：</p>
<pre tabindex="0"><code>NAME                                       CAPACITY   ACCESSMODES   RECLAIMPOLICY   STATUS    CLAIM                  REASON    AGE
pvc-b6efd8da-b7b5-11e6-9d58-0ed433a7dd94   4Gi        RWO           Delete          Bound     default/claim1                   40s
pvc-b95650f8-b7b5-11e6-9d58-0ed433a7dd94   4Gi        RWO           Delete          Bound     default/claim2                   36s
pvc-bb3ca71d-b7b5-11e6-9d58-0ed433a7dd94   4Gi        RWO           Retain          Bound     default/claim3                   33s
</code></pre><!--
In the preceding output, you can see that the volume bound to claim
`default/claim3` has reclaim policy `Retain`. It will not be automatically
deleted when a user deletes claim `default/claim3`.
-->
<p>在前面的输出中，你可以看到绑定到申领 <code>default/claim3</code> 的卷的回收策略为 <code>Retain</code>。
当用户删除申领 <code>default/claim3</code> 时，它不会被自动删除。</p>
</li>
</ol>
<h2 id="接下来">接下来</h2>
<!--
* Learn more about [PersistentVolumes](/docs/concepts/storage/persistent-volumes/).
* Learn more about [PersistentVolumeClaims](/docs/concepts/storage/persistent-volumes/#persistentvolumeclaims).
-->
<ul>
<li>进一步了解 <a href="/zh/docs/concepts/storage/persistent-volumes/">PersistentVolumes</a></li>
<li>进一步了解 <a href="/zh/docs/concepts/storage/persistent-volumes/#persistentvolumeclaims">PersistentVolumeClaims</a></li>
</ul>
<h3 id="参考">参考</h3>
<ul>
<li><a href="/docs/api-reference/v1.22/#persistentvolume-v1-core">PersistentVolume</a></li>
<li><a href="/docs/api-reference/v1.22/#persistentvolumeclaim-v1-core">PersistentVolumeClaim</a></li>
<li>参阅 <a href="/docs/api-reference/v1.22/#persistentvolumeclaim-v1-core">PersistentVolumeSpec</a> 的 <code>persistentVolumeReclaimPolicy</code> 字段</li>
</ul>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-966cd1cc69c69410d8698b3ac74abce2">33 - 自动扩缩集群 DNS 服务</h1>
    
	<!--
title: Autoscale the DNS Service in a Cluster
content_type: task
-->
<!-- overview -->
<!--
This page shows how to enable and configure autoscaling of the DNS service in a
Kubernetes cluster.
-->
<p>本页展示了如何在集群中启用和配置 DNS 服务的自动扩缩功能。</p>
<h2 id="准备开始">准备开始</h2>
<ul>
<li><p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
如果你还没有集群，你可以通过 <a href="/zh/docs/tasks/tools/#minikube">Minikube</a> 构建一
个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p>
<!--
You need to have a Kubernetes cluster, and the kubectl command-line tool must
be configured to communicate with your cluster. If you do not already have a
cluster, you can create one by using
[minikube](/docs/tasks/tools/#minikube)
or you can use one of these Kubernetes playgrounds:
-->
<ul>
<li><a href="https://www.katacoda.com/courses/kubernetes/playground">Katacoda</a></li>
<li><a href="http://labs.play-with-k8s.com/">玩转 Kubernetes</a></li>
</ul>
 
 要获知版本信息，请输入 <code>kubectl version</code>.
</li>
</ul>
<!--
* This guide assumes your nodes use the AMD64 or Intel 64 CPU architecture

* Make sure the [DNS feature](/docs/concepts/services-networking/dns-pod-service/) itself is enabled.

* Kubernetes version 1.4.0 or later is recommended.
-->
<ul>
<li>
<p>本指南假设你的节点使用 AMD64 或 Intel 64 CPU 架构</p>
</li>
<li>
<p>确保已启用 <a href="/zh/docs/concepts/services-networking/dns-pod-service/">DNS 功能</a>本身。</p>
</li>
<li>
<p>建议使用 Kubernetes 1.4.0 或更高版本。</p>
</li>
</ul>
<!-- steps -->
<!--
## Determining whether DNS horizontal autoscaling is already enabled

List the <a class='glossary-tooltip' title='Deployment 是管理应用副本的 API 对象。' data-toggle='tooltip' data-placement='top' href='/zh/docs/concepts/workloads/controllers/deployment/' target='_blank' aria-label='Deployments'>Deployments</a>
in your cluster in the kube-system namespace:

```shell
kubectl get deployment --namespace=kube-system
```

The output is similar to this:

    NAME                  DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE
    ...
    dns-autoscaler        1         1         1            1           ...
    ...

If you see "dns-autoscaler" in the output, DNS horizontal autoscaling is
already enabled, and you can skip to
[Tuning autoscaling parameters](#tuning-autoscaling-parameters).
-->
<h2 id="determining-whether-dns-horizontal-autoscaling-is-already-enabled">确定是否 DNS 水平 水平自动扩缩特性已经启用</h2>
<p>在 kube-system 命名空间中列出集群中的 <a class='glossary-tooltip' title='Deployment 是管理应用副本的 API 对象。' data-toggle='tooltip' data-placement='top' href='/zh/docs/concepts/workloads/controllers/deployment/' target='_blank' aria-label='Deployments'>Deployments</a> ：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl get deployment --namespace<span style="color:#666">=</span>kube-system
</code></pre></div><p>输出类似如下这样：</p>
<pre tabindex="0"><code>NAME                  DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE
...
dns-autoscaler        1         1         1            1           ...
...
</code></pre><p>如果在输出中看到 “dns-autoscaler”，说明 DNS 水平自动扩缩已经启用，可以跳到
<a href="#tuning-autoscaling-parameters">调优自动扩缩参数</a>。</p>
<!--
## Getting the name of your DNS Deployment {#find-scaling-target}

List the Deployments in your cluster in the kube-system namespace:

```shell
kubectl get deployment --namespace=kube-system
```

The output is similar to this:
-->
<h2 id="find-scaling-target">获取 DNS Deployment 的名称</h2>
<p>列出集群内 kube-system 名字空间中的 DNS Deployment：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl get deployment -l k8s-app<span style="color:#666">=</span>kube-dns --namespace<span style="color:#666">=</span>kube-system
</code></pre></div><p>输出类似如下这样：</p>
<pre tabindex="0"><code>NAME      READY   UP-TO-DATE   AVAILABLE   AGE
...
coredns   2/2     2            2           ...
...
</code></pre><!--
If you don't see a Deployment for DNS services, you can also look for it by name:
-->
<p>如果看不到 DNS 服务的 Deployment，你也可以通过名字来查找：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl get deployment --namespace<span style="color:#666">=</span>kube-system
</code></pre></div><!--
and look for a deployment named `coredns` or `kube-dns`.
-->
<p>并在输出中寻找名称为 <code>coredns</code> 或 <code>kube-dns</code> 的 Deployment。</p>
<!--
Your scale target is:
-->
<p>你的扩缩目标为：</p>
<pre tabindex="0"><code>Deployment/&lt;your-deployment-name&gt;
</code></pre><!--
where `<your-deployment-name>` is the name of your DNS Deployment. For example, if
your DNS Deployment name is coredns, your scale target is Deployment/coredns.
-->
<p>其中 <code>&lt;your-deployment-name&gt;</code> 是 DNS Deployment 的名称。
例如，如果你的 DNS Deployment 名称是 <code>coredns</code>，则你的扩展目标是 Deployment/coredns。</p>
<!--
CoreDNS is the default DNS service for Kubernetes. CoreDNS sets the label
`k8s-app=kube-dns` so that it can work in clusters that originally used
kube-dns.
-->
<blockquote class="note callout">
  <div><strong>说明：</strong> CoreDNS 是 Kubernetes 的默认 DNS 服务。CoreDNS 设置标签 <code>k8s-app=kube-dns</code>，
以便能够在原来使用 <code>kube-dns</code> 的集群中工作。</div>
</blockquote>
<!--
## Enabling DNS horizontal autoscaling      {#enablng-dns-horizontal-autoscaling}

In this section, you create a Deployment. The Pods in the Deployment run a
container based on the `cluster-proportional-autoscaler-amd64` image.

Create a file named `dns-horizontal-autoscaler.yaml` with this content:
-->
<h2 id="enablng-dns-horizontal-autoscaling">启用 DNS 水平自动扩缩  </h2>
<p>在本节，我们创建一个 Deployment。Deployment 中的 Pod 运行一个基于
<code>cluster-proportional-autoscaler-amd64</code> 镜像的容器。</p>
<p>创建文件 <code>dns-horizontal-autoscaler.yaml</code>，内容如下所示：</p>


 













<div class="highlight">
    <div class="copy-code-icon" style="text-align:right">
    <a href="https://raw.githubusercontent.com/kubernetes/website/main/content/zh/examples/admin/dns/dns-horizontal-autoscaler.yaml" download="admin/dns/dns-horizontal-autoscaler.yaml"><code>admin/dns/dns-horizontal-autoscaler.yaml</code>
    </a>
    <img src="/images/copycode.svg" style="max-height:24px; cursor: pointer" onclick="copyCode('admin-dns-dns-horizontal-autoscaler-yaml')" title="Copy admin/dns/dns-horizontal-autoscaler.yaml to clipboard">
    </img>
    </div>
    <div class="includecode" id="admin-dns-dns-horizontal-autoscaler-yaml">
    <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>apps/v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>Deployment<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>dns-autoscaler<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">namespace</span>:<span style="color:#bbb"> </span>kube-system<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">labels</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">k8s-app</span>:<span style="color:#bbb"> </span>dns-autoscaler<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">spec</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">selector</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">matchLabels</span>:<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">k8s-app</span>:<span style="color:#bbb"> </span>dns-autoscaler<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">template</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">labels</span>:<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#008000;font-weight:bold">k8s-app</span>:<span style="color:#bbb"> </span>dns-autoscaler<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">spec</span>:<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">containers</span>:<span style="color:#bbb">
</span><span style="color:#bbb">      </span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>autoscaler<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#008000;font-weight:bold">image</span>:<span style="color:#bbb"> </span>k8s.gcr.io/cluster-proportional-autoscaler-amd64:1.6.0<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#008000;font-weight:bold">resources</span>:<span style="color:#bbb">
</span><span style="color:#bbb">          </span><span style="color:#008000;font-weight:bold">requests</span>:<span style="color:#bbb">
</span><span style="color:#bbb">            </span><span style="color:#008000;font-weight:bold">cpu</span>:<span style="color:#bbb"> </span>20m<span style="color:#bbb">
</span><span style="color:#bbb">            </span><span style="color:#008000;font-weight:bold">memory</span>:<span style="color:#bbb"> </span>10Mi<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#008000;font-weight:bold">command</span>:<span style="color:#bbb">
</span><span style="color:#bbb">        </span>- /cluster-proportional-autoscaler<span style="color:#bbb">
</span><span style="color:#bbb">        </span>- --namespace=kube-system<span style="color:#bbb">
</span><span style="color:#bbb">        </span>- --configmap=dns-autoscaler<span style="color:#bbb">
</span><span style="color:#bbb">        </span>- --target=&lt;SCALE_TARGET&gt;<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#080;font-style:italic"># When cluster is using large nodes(with more cores), &#34;coresPerReplica&#34; should dominate.</span><span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#080;font-style:italic"># If using small nodes, &#34;nodesPerReplica&#34; should dominate.</span><span style="color:#bbb">
</span><span style="color:#bbb">        </span>- --default-params={&#34;linear&#34;:{&#34;coresPerReplica&#34;:256,&#34;nodesPerReplica&#34;:16,&#34;min&#34;:1}}<span style="color:#bbb">
</span><span style="color:#bbb">        </span>- --logtostderr=true<span style="color:#bbb">
</span><span style="color:#bbb">        </span>- --v=2<span style="color:#bbb">
</span></code></pre></div>
    </div>
</div>


<!--
In the file, replace `<SCALE_TARGET>` with your scale target.

Go to the directory that contains your configuration file, and enter this
command to create the Deployment:
-->
<p>在文件中，将 <code>&lt;SCALE_TARGET&gt;</code> 替换成扩缩目标。</p>
<p>进入到包含配置文件的目录中，输入如下命令创建 Deployment：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl apply -f dns-horizontal-autoscaler.yaml
</code></pre></div><!--
The output of a successful command is:
-->
<p>一个成功的命令输出是：</p>
<pre tabindex="0"><code>deployment.apps/dns-autoscaler created
</code></pre><!--
DNS horizontal autoscaling is now enabled.
-->
<p>DNS 水平自动扩缩在已经启用了。</p>
<!--
## Tuning autoscaling parameters  {#tuning-autoscaling-parameters}

Verify that the dns-autoscaler <a class='glossary-tooltip' title='ConfigMap 是一种 API 对象，用来将非机密性的数据保存到键值对中。使用时可以用作环境变量、命令行参数或者存储卷中的配置文件。' data-toggle='tooltip' data-placement='top' href='/zh/docs/tasks/configure-pod-container/configure-pod-configmap/' target='_blank' aria-label='ConfigMap'>ConfigMap</a> exists:
-->
<h2 id="tuning-autoscaling-parameters">调优自动扩缩参数  </h2>
<p>验证 dns-autoscaler <a class='glossary-tooltip' title='ConfigMap 是一种 API 对象，用来将非机密性的数据保存到键值对中。使用时可以用作环境变量、命令行参数或者存储卷中的配置文件。' data-toggle='tooltip' data-placement='top' href='/zh/docs/tasks/configure-pod-container/configure-pod-configmap/' target='_blank' aria-label='ConfigMap'>ConfigMap</a> 是否存在：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl get configmap --namespace<span style="color:#666">=</span>kube-system
</code></pre></div><!--
The output is similar to this:
-->
<p>输出类似于：</p>
<pre tabindex="0"><code>NAME                  DATA      AGE
...
dns-autoscaler        1         ...
...
</code></pre><!--
Modify the data in the ConfigMap:
-->
<p>修改该 ConfigMap 中的数据：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl edit configmap dns-autoscaler --namespace<span style="color:#666">=</span>kube-system
</code></pre></div><!--
Look for this line:
-->
<p>找到如下这行内容：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">linear</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#39;{&#34;coresPerReplica&#34;:256,&#34;min&#34;:1,&#34;nodesPerReplica&#34;:16}&#39;</span><span style="color:#bbb">
</span></code></pre></div><!--
Modify the fields according to your needs. The "min" field indicates the
minimal number of DNS backends. The actual number of backends number is
calculated using this equation:
-->
<p>根据需要修改对应的字段。“min” 字段表明 DNS 后端的最小数量。
实际后端的数量通过使用如下公式来计算：</p>
<pre tabindex="0"><code>replicas = max( ceil( cores * 1/coresPerReplica ) , ceil( nodes * 1/nodesPerReplica ) )
</code></pre><!--
Note that the values of both `coresPerReplica` and `nodesPerReplica` are
integers.

The idea is that when a cluster is using nodes that have many cores,
`coresPerReplica` dominates. When a cluster is using nodes that have fewer
cores, `nodesPerReplica` dominates.

There are other supported scaling patterns. For details, see
[cluster-proportional-autoscaler](https://github.com/kubernetes-sigs/cluster-proportional-autoscaler).
-->
<p>注意 <code>coresPerReplica</code> 和 <code>nodesPerReplica</code> 的值都是整数。</p>
<p>背后的思想是，当一个集群使用具有很多核心的节点时，由 <code>coresPerReplica</code> 来控制。
当一个集群使用具有较少核心的节点时，由 <code>nodesPerReplica</code> 来控制。</p>
<p>其它的扩缩模式也是支持的，详情查看
<a href="https://github.com/kubernetes-sigs/cluster-proportional-autoscaler">cluster-proportional-autoscaler</a>。</p>
<!--
## Disable DNS horizontal autoscaling

There are a few options for tuning DNS horizontal autoscaling. Which option to
use depends on different conditions.
-->
<h2 id="禁用-dns-水平自动扩缩">禁用 DNS 水平自动扩缩</h2>
<p>有几个可供调优的 DNS 水平自动扩缩选项。具体使用哪个选项因环境而异。</p>
<!--
### Option 1: Scale down the dns-autoscaler deployment to 0 replicas

This option works for all situations. Enter this command:
-->
<h3 id="选项-1-缩容-dns-autoscaler-deployment-至-0-个副本">选项 1：缩容 dns-autoscaler Deployment 至 0 个副本</h3>
<p>该选项适用于所有场景。运行如下命令：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl scale deployment --replicas<span style="color:#666">=</span><span style="color:#666">0</span> dns-autoscaler --namespace<span style="color:#666">=</span>kube-system
</code></pre></div><!-- The output is: -->
<p>输出如下所示：</p>
<pre tabindex="0"><code>deployment.apps/dns-autoscaler scaled
</code></pre><!--
Verify that the replica count is zero:
-->
<p>验证当前副本数为 0：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl get rs --namespace<span style="color:#666">=</span>kube-system
</code></pre></div><!--
The output displays 0 in the DESIRED and CURRENT columns:
-->
<p>输出内容中，在 DESIRED 和 CURRENT 列显示为 0：</p>
<pre tabindex="0"><code>NAME                                 DESIRED   CURRENT   READY   AGE
...
dns-autoscaler-6b59789fc8            0         0         0       ...
...
</code></pre><!--
### Option 2: Delete the dns-autoscaler deployment

This option works if dns-autoscaler is under your own control, which means
no one will re-create it:
-->
<h3 id="选项-2-删除-dns-autoscaler-deployment">选项 2：删除 dns-autoscaler Deployment</h3>
<p>如果 dns-autoscaler 为你所控制，也就说没有人会去重新创建它，可以选择此选项：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl delete deployment dns-autoscaler --namespace<span style="color:#666">=</span>kube-system
</code></pre></div><!-- The output is:-->
<p>输出内容如下所示：</p>
<pre tabindex="0"><code>deployment.apps &quot;dns-autoscaler&quot; deleted
</code></pre><!--
### Option 3: Delete the dns-autoscaler manifest file from the master node

This option works if dns-autoscaler is under control of the (deprecated)
[Addon Manager](https://git.k8s.io/kubernetes/cluster/addons/README.md),
and you have write access to the master node.
-->
<h3 id="选项-3-从主控节点删除-dns-autoscaler-清单文件">选项 3：从主控节点删除 dns-autoscaler 清单文件</h3>
<p>如果 dns-autoscaler 在<a href="https://git.k8s.io/kubernetes/cluster/addons/README.md">插件管理器</a>
的控制之下，并且具有操作 master 节点的写权限，可以使用此选项。</p>
<!--
Sign in to the master node and delete the corresponding manifest file.
The common path for this dns-autoscaler is:
-->
<p>登录到主控节点，删除对应的清单文件。
dns-autoscaler 对应的路径一般为：</p>
<pre tabindex="0"><code>/etc/kubernetes/addons/dns-horizontal-autoscaler/dns-horizontal-autoscaler.yaml
</code></pre><!--
After the manifest file is deleted, the Addon Manager will delete the
dns-autoscaler Deployment.
-->
<p>当清单文件被删除后，插件管理器将删除 dns-autoscaler Deployment。</p>
<!-- discussion -->
<!--
## Understanding how DNS horizontal autoscaling works

* The cluster-proportional-autoscaler application is deployed separately from
the DNS service.

* An autoscaler Pod runs a client that polls the Kubernetes API server for the
number of nodes and cores in the cluster.
-->
<h2 id="理解-dns-水平自动扩缩工作原理">理解 DNS 水平自动扩缩工作原理</h2>
<ul>
<li>
<p>cluster-proportional-autoscaler 应用独立于 DNS 服务部署。</p>
</li>
<li>
<p>autoscaler Pod 运行一个客户端，它通过轮询 Kubernetes API 服务器获取集群中节点和核心的数量。</p>
</li>
</ul>
<!--
* A desired replica count is calculated and applied to the DNS backends based on
the current schedulable nodes and cores and the given scaling parameters.

* The scaling parameters and data points are provided via a ConfigMap to the
autoscaler, and it refreshes its parameters table every poll interval to be up
to date with the latest desired scaling parameters.
-->
<ul>
<li>
<p>系统会基于当前可调度的节点个数、核心数以及所给的扩缩参数，计算期望的副本数并应用到 DNS 后端。</p>
</li>
<li>
<p>扩缩参数和数据点会基于一个 ConfigMap 来提供给 autoscaler，它会在每次轮询时刷新它的参数表，
以与最近期望的扩缩参数保持一致。</p>
</li>
</ul>
<!--
* Changes to the scaling parameters are allowed without rebuilding or restarting
the autoscaler Pod.

* The autoscaler provides a controller interface to support two control
patterns: *linear* and *ladder*.
-->
<ul>
<li>
<p>扩缩参数是可以被修改的，而且不需要重建或重启 autoscaler Pod。</p>
</li>
<li>
<p>autoscaler 提供了一个控制器接口来支持两种控制模式：<em>linear</em> 和 <em>ladder</em>。</p>
</li>
</ul>
<h2 id="接下来">接下来</h2>
<!--
* Read about [Guaranteed Scheduling For Critical Add-On Pods](/docs/tasks/administer-cluster/guaranteed-scheduling-critical-addon-pods/).
* Learn more about the
[implementation of cluster-proportional-autoscaler](https://github.com/kubernetes-sigs/cluster-proportional-autoscaler).

-->
<ul>
<li>阅读<a href="/zh/docs/tasks/administer-cluster/guaranteed-scheduling-critical-addon-pods/">为关键插件 Pod 提供的调度保障</a></li>
<li>进一步了解 <a href="https://github.com/kubernetes-sigs/cluster-proportional-autoscaler">cluster-proportional-autoscaler 实现</a></li>
</ul>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-3d0cd7d2f13d4759094f281504cf57b8">34 - 自定义 DNS 服务</h1>
    
	<!-- 
reviewers:
- bowei
- zihongz
title: Customizing DNS Service
content_type: task
min-kubernetes-server-version: v1.12
-->
<!-- overview -->
<!-- 
This page explains how to configure your DNS
<a class='glossary-tooltip' title='Pod 表示您的集群上一组正在运行的容器。' data-toggle='tooltip' data-placement='top' href='/docs/concepts/workloads/pods/pod-overview/' target='_blank' aria-label='Pod(s)'>Pod(s)</a> and customize the
DNS resolution process in your cluster.
-->
<p>本页说明如何配置 DNS <a class='glossary-tooltip' title='Pod 表示您的集群上一组正在运行的容器。' data-toggle='tooltip' data-placement='top' href='/docs/concepts/workloads/pods/pod-overview/' target='_blank' aria-label='Pod(s)'>Pod(s)</a>，以及定制集群中 DNS 解析过程。</p>
<h2 id="准备开始">准备开始</h2>
<p><p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
如果你还没有集群，你可以通过 <a href="/zh/docs/tasks/tools/#minikube">Minikube</a> 构建一
个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p>
<!--
You need to have a Kubernetes cluster, and the kubectl command-line tool must
be configured to communicate with your cluster. If you do not already have a
cluster, you can create one by using
[minikube](/docs/tasks/tools/#minikube)
or you can use one of these Kubernetes playgrounds:
-->
<ul>
<li><a href="https://www.katacoda.com/courses/kubernetes/playground">Katacoda</a></li>
<li><a href="http://labs.play-with-k8s.com/">玩转 Kubernetes</a></li>
</ul>
 

您的 Kubernetes 服务器版本必须不低于版本 v1.12.
 要获知版本信息，请输入 <code>kubectl version</code>.
</p>
<!-- 
Your cluster must be running the CoreDNS add-on.
[Migrating to CoreDNS](/docs/tasks/administer-cluster/coredns/#migrating-to-coredns)
explains how to use `kubeadm` to migrate from `kube-dns`.
-->
<p>你的集群必须运行 CoreDNS 插件。
文档<a href="/zh/docs/tasks/administer-cluster/coredns/#migrating-to-coredns">迁移到 CoreDNS</a>
解释了如何使用 <code>kubeadm</code> 从 <code>kube-dns</code> 迁移到 CoreDNS。</p>
<!-- steps -->
<!-- 
## Introduction 

DNS is a built-in Kubernetes service launched automatically
using the addon manager
[cluster add-on](https://releases.k8s.io/main/cluster/addons/README.md). 
-->
<h2 id="介绍">介绍</h2>
<p>DNS 是使用<a href="https://releases.k8s.io/main/cluster/addons/README.md">集群插件</a>
管理器自动启动的内置的 Kubernetes 服务。</p>
<!-- 
As of Kubernetes v1.12, CoreDNS is the recommended DNS Server, replacing kube-dns.  If your cluster
originally used kube-dns, you may still have `kube-dns` deployed rather than CoreDNS.
-->
<p>从 Kubernetes v1.12 开始，CoreDNS 是推荐的 DNS 服务器，取代了 kube-dns。 如果
你的集群原来使用 kube-dns，你可能部署的仍然是 <code>kube-dns</code> 而不是 CoreDNS。</p>
<!--
Both the CoreDNS and kube-dns Service are named `kube-dns` in the `metadata.name` field.  
This is so that there is greater interoperability with workloads that relied on the legacy `kube-dns` Service name to resolve addresses internal to the cluster. Using a Service named `kube-dns` abstracts away the implementation detail of which DNS provider is running behind that common name.
-->
<blockquote class="note callout">
  <div><strong>说明：</strong> CoreDNS 和 kube-dns 的 Service 都在其 <code>metadata.name</code> 字段使用名字 <code>kube-dns</code>。
这是为了能够与依靠传统 <code>kube-dns</code> 服务名称来解析集群内部地址的工作负载具有更好的互操作性。
使用 <code>kube-dns</code> 作为服务名称可以抽离共有名称之后运行的是哪个 DNS 提供程序这一实现细节。</div>
</blockquote>
<!--
If you are running CoreDNS as a Deployment, it will typically be exposed as a Kubernetes Service with a static IP address.
The kubelet passes DNS resolver information to each container with the `-cluster-dns=<dns-service-ip>` flag.
-->
<p>如果你在使用 Deployment 运行 CoreDNS，则该 Deployment 通常会向外暴露为一个具有
静态 IP 地址 Kubernetes 服务。
kubelet 使用 <code>--cluster-dns=&lt;DNS 服务 IP&gt;</code> 标志将 DNS 解析器的信息传递给每个容器。</p>
<!-- 
DNS names also need domains. You configure the local domain in the kubelet
with the flag `-cluster-domain=<default-local-domain>`. 
-->
<p>DNS 名称也需要域名。 你可在 kubelet 中使用 <code>--cluster-domain=&lt;默认本地域名&gt;</code>
标志配置本地域名。</p>
<!-- 
The DNS server supports forward lookups (A and AAAA records), port lookups (SRV records), reverse IP address lookups (PTR records),
and more. For more information, see [DNS for Services and Pods](/docs/concepts/services-networking/dns-pod-service/).
-->
<p>DNS 服务器支持正向查找（A 和 AAAA 记录）、端口发现（SRV 记录）、反向 IP 地址发现（PTR 记录）等。
更多信息，请参见<a href="/zh/docs/concepts/services-networking/dns-pod-service/">Pod 和 服务的 DNS</a>。</p>
<!-- 
If a Pod's `dnsPolicy` is set to "`default`", it inherits the name resolution
configuration from the node that the Pod runs on. The Pod's DNS resolution
should behave the same as the node.
But see [Known issues](/docs/tasks/administer-cluster/dns-debugging-resolution/#known-issues). 
-->
<p>如果 Pod 的 <code>dnsPolicy</code> 设置为 &quot;<code>default</code>&quot;，则它将从 Pod 运行所在节点继承名称解析配置。
Pod 的 DNS 解析行为应该与节点相同。
但请参阅<a href="/zh/docs/tasks/administer-cluster/dns-debugging-resolution/#known-issues">已知问题</a>。</p>
<!-- 
If you don't want this, or if you want a different DNS config for pods, you can
use the kubelet's `-resolv-conf` flag.  Set this flag to "" to prevent Pods from
inheriting DNS. Set it to a valid file path to specify a file other than
`/etc/resolv.conf` for DNS inheritance. 
-->
<p>如果你不想这样做，或者想要为 Pod 使用其他 DNS 配置，则可以
使用 kubelet 的 <code>--resolv-conf</code> 标志。 将此标志设置为 &quot;&quot; 可以避免 Pod 继承 DNS。
将其设置为有别于 <code>/etc/resolv.conf</code> 的有效文件路径可以设定 DNS 继承不同的配置。</p>
<h2 id="coredns">CoreDNS</h2>
<!-- 
CoreDNS is a general-purpose authoritative DNS server that can serve as cluster DNS, complying with the [dns specifications]
(https://github.com/kubernetes/dns/blob/master/docs/specification.md). 
-->
<p>CoreDNS 是通用的权威 DNS 服务器，可以用作集群 DNS，符合
<a href="https://github.com/kubernetes/dns/blob/master/docs/specification.md">DNS 规范</a>。</p>
<!-- 
### CoreDNS ConfigMap options 

CoreDNS is a DNS server that is modular and pluggable, and each plugin adds new functionality to CoreDNS. 
This can be configured by maintaining a [Corefile](https://coredns.io/2017/07/23/corefile-explained/), which is the CoreDNS
configuration file. A cluster administrator can modify the ConfigMap for the CoreDNS Corefile to change how service discovery works.  
-->
<h3 id="coredns-configmap-options">CoreDNS ConfigMap 选项 </h3>
<p>CoreDNS 是模块化且可插拔的 DNS 服务器，每个插件都为 CoreDNS 添加了新功能。
可以通过维护 <a href="https://coredns.io/2017/07/23/corefile-explained/">Corefile</a>，即 CoreDNS 配置文件，
来定制其行为。 集群管理员可以修改 CoreDNS Corefile 的 ConfigMap，以更改服务发现的工作方式。</p>
<!-- 
In Kubernetes, CoreDNS is installed with the following default Corefile configuration. 
-->
<p>在 Kubernetes 中，CoreDNS 安装时使用如下默认 Corefile 配置。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>ConfigMap<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>coredns<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">namespace</span>:<span style="color:#bbb"> </span>kube-system<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">data</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">Corefile</span>:<span style="color:#bbb"> </span>|<span style="color:#b44;font-style:italic">
</span><span style="color:#b44;font-style:italic">    .:53 {
</span><span style="color:#b44;font-style:italic">        errors
</span><span style="color:#b44;font-style:italic">        health {
</span><span style="color:#b44;font-style:italic">            lameduck 5s
</span><span style="color:#b44;font-style:italic">        }
</span><span style="color:#b44;font-style:italic">        ready
</span><span style="color:#b44;font-style:italic">        kubernetes cluster.local in-addr.arpa ip6.arpa {
</span><span style="color:#b44;font-style:italic">           pods insecure
</span><span style="color:#b44;font-style:italic">           fallthrough in-addr.arpa ip6.arpa
</span><span style="color:#b44;font-style:italic">           ttl 30
</span><span style="color:#b44;font-style:italic">        }
</span><span style="color:#b44;font-style:italic">        prometheus :9153
</span><span style="color:#b44;font-style:italic">        forward . /etc/resolv.conf
</span><span style="color:#b44;font-style:italic">        cache 30
</span><span style="color:#b44;font-style:italic">        loop
</span><span style="color:#b44;font-style:italic">        reload
</span><span style="color:#b44;font-style:italic">        loadbalance
</span><span style="color:#b44;font-style:italic">    }</span><span style="color:#bbb">    
</span></code></pre></div><!-- 
The Corefile configuration includes the following [plugins](https://coredns.io/plugins/) of CoreDNS: 
-->
<p>Corefile 配置包括以下 CoreDNS <a href="https://coredns.io/plugins/">插件</a>：</p>
<!-- 
* [errors](https://coredns.io/plugins/errors/): Errors are logged to stdout.
* [health](https://coredns.io/plugins/health/): Health of CoreDNS is reported to http://localhost:8080/health.
* [kubernetes](https://coredns.io/plugins/kubernetes/): CoreDNS will reply to DNS queries based on IP of the services and pods of Kubernetes. You can find more details [here](https://coredns.io/plugins/kubernetes/).  
-->
<ul>
<li>
<p><a href="https://coredns.io/plugins/errors/">errors</a>：错误记录到标准输出。</p>
</li>
<li>
<p><a href="https://coredns.io/plugins/health/">health</a>：在 http://localhost:8080/health 处提供 CoreDNS 的健康报告。</p>
</li>
<li>
<p><a href="https://coredns.io/plugins/ready/">ready</a>：在端口 8181 上提供的一个 HTTP 末端，当所有能够
表达自身就绪的插件都已就绪时，在此末端返回 200 OK。</p>
</li>
<li>
<p><a href="https://coredns.io/plugins/kubernetes/">kubernetes</a>：CoreDNS 将基于 Kubernetes 的服务和 Pod 的
IP 答复 DNS 查询。你可以在 CoreDNS 网站阅读<a href="https://coredns.io/plugins/kubernetes/">更多细节</a>。
你可以使用 <code>ttl</code> 来定制响应的 TTL。默认值是 5 秒钟。TTL 的最小值可以是 0 秒钟，
最大值为 3600 秒。将 TTL 设置为 0 可以禁止对 DNS 记录进行缓存。</p>
<!-- 
The `pods insecure` option is provided for backward compatibility with kube-dns. You can use the
`pods verified` option, which returns an A record only if there exists a pod in same namespace
with matching IP. The `pods disabled` option can be used if you don't use pod records. 
-->
<p><code>pods insecure</code> 选项是为了与 kube-dns 向后兼容。你可以使用 <code>pods verified</code> 选项，该选项使得
仅在相同名称空间中存在具有匹配 IP 的 Pod 时才返回 A 记录。如果你不使用 Pod 记录，则可以使用
<code>pods disabled</code> 选项。</p>
</li>
</ul>
<!-- 
* [prometheus](https://coredns.io/plugins/prometheus/): Metrics of CoreDNS are available at http://localhost:9153/metrics in [Prometheus](https://prometheus.io/) format.
* [forward](https://coredns.io/plugins/forward/): Any queries that are not within the cluster domain of Kubernetes will be forwarded to predefined resolvers (/etc/resolv.conf).
* [cache](https://coredns.io/plugins/cache/): This enables a frontend cache.
* [loop](https://coredns.io/plugins/loop/): Detects simple forwarding loops and halts the CoreDNS process if a loop is found.
* [reload](https://coredns.io/plugins/reload): Allows automatic reload of a changed Corefile. After you edit the ConfigMap configuration, allow two minutes for your changes to take effect.
* [loadbalance](https://coredns.io/plugins/loadbalance): This is a round-robin DNS loadbalancer that randomizes the order of A, AAAA, and MX records in the answer. 
-->
<ul>
<li><a href="https://coredns.io/plugins/prometheus/">prometheus</a>：CoreDNS 的度量指标值以
<a href="https://prometheus.io/">Prometheus</a> 格式在 http://localhost:9153/metrics 上提供。</li>
<li><a href="https://coredns.io/plugins/forward/">forward</a>: 不在 Kubernetes 集群域内的任何查询都将转发到
预定义的解析器 (/etc/resolv.conf).</li>
<li><a href="https://coredns.io/plugins/cache/">cache</a>：启用前端缓存。</li>
<li><a href="https://coredns.io/plugins/loop/">loop</a>：检测到简单的转发环，如果发现死循环，则中止 CoreDNS 进程。</li>
<li><a href="https://coredns.io/plugins/reload">reload</a>：允许自动重新加载已更改的 Corefile。
编辑 ConfigMap 配置后，请等待两分钟，以使更改生效。</li>
<li><a href="https://coredns.io/plugins/loadbalance">loadbalance</a>：这是一个轮转式 DNS 负载均衡器，
它在应答中随机分配 A、AAAA 和 MX 记录的顺序。</li>
</ul>
<!-- 
You can modify the default CoreDNS behavior by modifying the ConfigMap. 
-->
<p>你可以通过修改 ConfigMap 来更改默认的 CoreDNS 行为。</p>
<!-- 
### Configuration of Stub-domain and upstream nameserver using CoreDNS 

CoreDNS has the ability to configure stubdomains and upstream nameservers using the [forward plugin](https://coredns.io/plugins/forward/).
-->
<h3 id="使用-coredns-配置存根域和上游域名服务器">使用 CoreDNS 配置存根域和上游域名服务器</h3>
<p>CoreDNS 能够使用 <a href="https://coredns.io/plugins/forward/">forward 插件</a>配置存根域和上游域名服务器。</p>
<!-- 
#### Example

If a cluster operator has a [Consul](https://www.consul.io/) domain server located at 10.150.0.1, and all Consul names have the suffix .consul.local. To configure it in CoreDNS, the cluster administrator creates the following stanza in the CoreDNS ConfigMap. 
-->
<h4 id="示例">示例</h4>
<p>如果集群操作员在 10.150.0.1 处运行了 <a href="https://www.consul.io/">Consul</a> 域服务器，
且所有 Consul 名称都带有后缀 <code>.consul.local</code>。要在 CoreDNS 中对其进行配置，
集群管理员可以在 CoreDNS 的 ConfigMap 中创建加入以下字段。</p>
<pre tabindex="0"><code>consul.local:53 {
        errors
        cache 30
        forward . 10.150.0.1
    }
</code></pre><!-- 
To explicitly force all non-cluster DNS lookups to go through a specific nameserver at 172.16.0.1, point the  `forward` to the nameserver instead of `/etc/resolv.conf` 
-->
<p>要显式强制所有非集群 DNS 查找通过特定的域名服务器（位于 172.16.0.1），可将 <code>forward</code>
指向该域名服务器，而不是 <code>/etc/resolv.conf</code>。</p>
<pre tabindex="0"><code>forward .  172.16.0.1
</code></pre><!-- 
The final ConfigMap along with the default `Corefile` configuration looks like: 
-->
<p>最终的包含默认的 <code>Corefile</code> 配置的 ConfigMap 如下所示：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>ConfigMap<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>coredns<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">namespace</span>:<span style="color:#bbb"> </span>kube-system<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">data</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">Corefile</span>:<span style="color:#bbb"> </span>|<span style="color:#b44;font-style:italic">
</span><span style="color:#b44;font-style:italic">    .:53 {
</span><span style="color:#b44;font-style:italic">        errors
</span><span style="color:#b44;font-style:italic">        health
</span><span style="color:#b44;font-style:italic">        kubernetes cluster.local in-addr.arpa ip6.arpa {
</span><span style="color:#b44;font-style:italic">           pods insecure
</span><span style="color:#b44;font-style:italic">           fallthrough in-addr.arpa ip6.arpa
</span><span style="color:#b44;font-style:italic">        }
</span><span style="color:#b44;font-style:italic">        prometheus :9153
</span><span style="color:#b44;font-style:italic">        forward . 172.16.0.1
</span><span style="color:#b44;font-style:italic">        cache 30
</span><span style="color:#b44;font-style:italic">        loop
</span><span style="color:#b44;font-style:italic">        reload
</span><span style="color:#b44;font-style:italic">        loadbalance
</span><span style="color:#b44;font-style:italic">    }
</span><span style="color:#b44;font-style:italic">    consul.local:53 {
</span><span style="color:#b44;font-style:italic">        errors
</span><span style="color:#b44;font-style:italic">        cache 30
</span><span style="color:#b44;font-style:italic">        forward . 10.150.0.1
</span><span style="color:#b44;font-style:italic">    }</span><span style="color:#bbb">    
</span></code></pre></div><!-- 
The `kubeadm` supports automatic translation of the CoreDNS ConfigMap from the kube-dns ConfigMap.
-->
<p>工具 <code>kubeadm</code> 支持将 kube-dns ConfigMap 自动转换为 CoreDNS ConfigMap。</p>
<!--
While kube-dns accepts an FQDN for stubdomain and nameserver (eg: ns.foo.com), CoreDNS does not support this feature. 
During translation, all FQDN nameservers will be omitted from the CoreDNS config.*** 
-->
<blockquote class="note callout">
  <div><strong>说明：</strong> 尽管 kube-dns 接受 FQDN（例如：ns.foo.com）作为存根域和名字服务器，CoreDNS 不支持此功能。
转换期间，CoreDNS 配置中将忽略所有的 FQDN 域名服务器。</div>
</blockquote>
<!-- 
## CoreDNS configuration equivalent to kube-dns

CoreDNS supports the features of kube-dns and more.
A ConfigMap created for kube-dns to support `StubDomains`and `upstreamNameservers` translates to the `proxy` plugin in CoreDNS.
Similarly, the `Federations` plugin in kube-dns translates to the `federation` plugin in CoreDNS.

### Example

This example ConfigMap for kubedns specifies federations, stubdomains and upstreamnameservers: 
-->
<h2 id="coredns-配置等同于-kube-dns">CoreDNS 配置等同于 kube-dns</h2>
<p>CoreDNS 不仅仅提供 kube-dns 的功能。
为 kube-dns 创建的 ConfigMap 支持 <code>StubDomains</code> 和 <code>upstreamNameservers</code> 转换为 CoreDNS 中的 <code>forward</code> 插件。
同样，kube-dns 中的 <code>Federations</code> 插件会转换为 CoreDNS 中的 <code>federation</code> 插件。</p>
<h3 id="示例-1">示例</h3>
<p>用于 kubedns 的此示例 ConfigMap 描述了 federations、stubdomains and upstreamnameservers：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">data</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">federations</span>:<span style="color:#bbb"> </span>|<span style="color:#b44;font-style:italic">
</span><span style="color:#b44;font-style:italic">    </span><span style="color:#bbb">    </span>{<span style="color:#b44">&#34;foo&#34;</span><span style="color:#bbb"> </span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;foo.feddomain.com&#34;</span>}<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">stubDomains</span>:<span style="color:#bbb"> </span>|<span style="color:#b44;font-style:italic">
</span><span style="color:#b44;font-style:italic">    </span><span style="color:#bbb">    </span>{<span style="color:#b44">&#34;abc.com&#34;</span><span style="color:#bbb"> </span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;1.2.3.4&#34;</span>],<span style="color:#bbb"> </span><span style="color:#b44">&#34;my.cluster.local&#34;</span><span style="color:#bbb"> </span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;2.3.4.5&#34;</span>]}<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">upstreamNameservers</span>:<span style="color:#bbb"> </span>|<span style="color:#b44;font-style:italic">
</span><span style="color:#b44;font-style:italic">    </span><span style="color:#bbb">    </span>[<span style="color:#b44">&#34;8.8.8.8&#34;</span>,<span style="color:#bbb"> </span><span style="color:#b44">&#34;8.8.4.4&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>ConfigMap<span style="color:#bbb">
</span></code></pre></div><!-- 
The equivalent configuration in CoreDNS creates a Corefile: 
-->
<p>CoreDNS 中的等效配置将创建一个 Corefile：</p>
<ul>
<li>
<p>针对 federations:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml">federation cluster.local {<span style="color:#bbb">
</span><span style="color:#bbb">    </span>foo foo.feddomain.com<span style="color:#bbb">
</span><span style="color:#bbb"></span>}<span style="color:#bbb">
</span></code></pre></div></li>
<li>
<p>针对 stubDomains:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml">abc.com:53 {<span style="color:#bbb">
</span><span style="color:#bbb">     </span>errors<span style="color:#bbb">
</span><span style="color:#bbb">     </span>cache 30<span style="color:#bbb">
</span><span style="color:#bbb">     </span>proxy . 1.2.3.4<span style="color:#bbb">
</span><span style="color:#bbb"> </span>}<span style="color:#bbb">
</span><span style="color:#bbb"> </span>my.cluster.local:53 {<span style="color:#bbb">
</span><span style="color:#bbb">     </span>errors<span style="color:#bbb">
</span><span style="color:#bbb">     </span>cache 30<span style="color:#bbb">
</span><span style="color:#bbb">     </span>proxy . 2.3.4.5<span style="color:#bbb">
</span><span style="color:#bbb"> </span>}<span style="color:#bbb">
</span></code></pre></div></li>
</ul>
<!-- 
The complete Corefile with the default plugins: 
-->
<p>带有默认插件的完整 Corefile：</p>
<pre tabindex="0"><code>.:53 {
    errors
    health
    kubernetes cluster.local in-addr.arpa ip6.arpa {
       pods insecure
       fallthrough in-addr.arpa ip6.arpa
    }
    federation cluster.local {
       foo foo.feddomain.com
    }
    prometheus :9153
    forward .  8.8.8.8 8.8.4.4
    cache 30
}
abc.com:53 {
    errors
    cache 30
    forward . 1.2.3.4
}
my.cluster.local:53 {
    errors
    cache 30
    forward . 2.3.4.5
}
</code></pre><!-- 
## Migration to CoreDNS

To migrate from kube-dns to CoreDNS, [a detailed blog](https://coredns.io/2018/05/21/migration-from-kube-dns-to-coredns/) is available to help users adapt CoreDNS in place of kube-dns.
A cluster administrator can also migrate using [the deploy script](https://github.com/coredns/deployment/blob/master/kubernetes/deploy.sh).

-->
<h2 id="迁移到-coredns">迁移到 CoreDNS</h2>
<p>要从 kube-dns 迁移到 CoreDNS，<a href="https://coredns.io/2018/05/21/migration-from-kube-dns-to-coredns/">此博客</a>
提供了帮助用户将 kube-dns 替换为 CoreDNS。
集群管理员还可以使用<a href="https://github.com/coredns/deployment/blob/master/kubernetes/deploy.sh">部署脚本</a>
进行迁移。</p>
<h2 id="接下来">接下来</h2>
<!--
- Read [Debugging DNS Resolution](/docs/tasks/administer-cluster/dns-debugging-resolution/).
-->
<ul>
<li>阅读<a href="/zh/docs/tasks/administer-cluster/dns-debugging-resolution/">调试 DNS 解析</a></li>
</ul>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-bc6e50c405a620aab43b40d41d6375df">35 - 访问集群上运行的服务</h1>
    
	<!-- overview -->
<!--
This page shows how to connect to services running on the Kubernetes cluster.
-->
<p>本文展示了如何连接 Kubernetes 集群上运行的服务。</p>
<h2 id="准备开始">准备开始</h2>
<p><p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
如果你还没有集群，你可以通过 <a href="/zh/docs/tasks/tools/#minikube">Minikube</a> 构建一
个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p>
<!--
You need to have a Kubernetes cluster, and the kubectl command-line tool must
be configured to communicate with your cluster. If you do not already have a
cluster, you can create one by using
[minikube](/docs/tasks/tools/#minikube)
or you can use one of these Kubernetes playgrounds:
-->
<ul>
<li><a href="https://www.katacoda.com/courses/kubernetes/playground">Katacoda</a></li>
<li><a href="http://labs.play-with-k8s.com/">玩转 Kubernetes</a></li>
</ul>
 
 要获知版本信息，请输入 <code>kubectl version</code>.
</p>
<!-- steps -->
<!--
## Accessing services running on the cluster

In Kubernetes, [nodes](/docs/concepts/architecture/nodes/),
[pods](/docs/concepts/workloads/pods/) and [services](/docs/concepts/services-networking/service/) all have
their own IPs.  In many cases, the node IPs, pod IPs, and some service IPs on a cluster will not be
routable, so they will not be reachable from a machine outside the cluster,
such as your desktop machine.
-->
<h2 id="访问集群上运行的服务">访问集群上运行的服务</h2>
<p>在 Kubernetes 里，<a href="/zh/docs/concepts/architecture/nodes/">节点</a>、
<a href="/zh/docs/concepts/workloads/pods/">Pod</a> 和
<a href="/zh/docs/concepts/services-networking/service/">服务</a> 都有自己的 IP。
许多情况下，集群上的节点 IP、Pod IP 和某些服务 IP 是路由不可达的，
所以不能从集群之外访问它们，例如从你自己的台式机。</p>
<!--
### Ways to connect

You have several options for connecting to nodes, pods and services from outside the cluster:
-->
<h3 id="ways-to-connect">连接方式  </h3>
<p>你有多种可选方式从集群外连接节点、Pod 和服务：</p>
<!--
  - Access services through public IPs.
    - Use a service with type `NodePort` or `LoadBalancer` to make the service reachable outside
      the cluster.  See the [services](/docs/concepts/services-networking/service/) and
      [kubectl expose](/docs/reference/generated/kubectl/kubectl-commands/#expose) documentation.
    - Depending on your cluster environment, this may just expose the service to your corporate network,
      or it may expose it to the internet.  Think about whether the service being exposed is secure.
      Does it do its own authentication?
    - Place pods behind services.  To access one specific pod from a set of replicas, such as for debugging,
      place a unique label on the pod and create a new service which selects this label.
    - In most cases, it should not be necessary for application developer to directly access
      nodes via their nodeIPs.
-->
<ul>
<li>通过公网 IP 访问服务
<ul>
<li>使用类型为 <code>NodePort</code> 或 <code>LoadBalancer</code> 的服务，可以从外部访问它们。
请查阅<a href="/zh/docs/concepts/services-networking/service/">服务</a> 和
<a href="/docs/reference/generated/kubectl/kubectl-commands/#expose">kubectl expose</a> 文档。</li>
<li>取决于你的集群环境，你可以仅把服务暴露在你的企业网络环境中，也可以将其暴露在
因特网上。需要考虑暴露的服务是否安全，它是否有自己的用户认证？</li>
<li>将 Pod 放置于服务背后。如果要访问一个副本集合中特定的 Pod，例如用于调试目的，
请给 Pod 指定一个独特的标签并创建一个新服务选择该标签。</li>
<li>大部分情况下，都不需要应用开发者通过节点 IP 直接访问节点。</li>
</ul>
</li>
</ul>
<!--
  - Access services, nodes, or pods using the Proxy Verb.
    - Does apiserver authentication and authorization prior to accessing the remote service.
      Use this if the services are not secure enough to expose to the internet, or to gain
      access to ports on the node IP, or for debugging.
    - Proxies may cause problems for some web applications.
    - Only works for HTTP/HTTPS.
    - Described [here](#manually-constructing-apiserver-proxy-urls).
-->
<ul>
<li>通过 Proxy 动词访问服务、节点或者 Pod
<ul>
<li>在访问远程服务之前，利用 API 服务器执行身份认证和鉴权。
如果你的服务不够安全，无法暴露到因特网中，或者需要访问节点 IP 上的端口，
又或者出于调试目的，可使用这种方式。</li>
<li>代理可能给某些应用带来麻烦</li>
<li>此方式仅适用于 HTTP/HTTPS</li>
<li>进一步的描述在<a href="#manually-constructing-apiserver-proxy-urls">这里</a></li>
<li>从集群中的 node 或者 pod 访问。</li>
</ul>
</li>
</ul>
<!--
  - Access from a node or pod in the cluster.
    - Run a pod, and then connect to a shell in it using [kubectl exec](/docs/reference/generated/kubectl/kubectl-commands/#exec).
      Connect to other nodes, pods, and services from that shell.
    - Some clusters may allow you to ssh to a node in the cluster. From there you may be able to
      access cluster services. This is a non-standard method, and will work on some clusters but
      not others. Browsers and other tools may or may not be installed. Cluster DNS may not work.
-->
<ul>
<li>从集群中的一个节点或 Pod 访问
<ul>
<li>运行一个 Pod，然后使用
<a href="/docs/reference/generated/kubectl/kubectl-commands/#exec">kubectl exec</a>
连接到它的 Shell。从那个 Shell 连接其他的节点、Pod 和 服务</li>
<li>某些集群可能允许你 SSH 到集群中的节点。你可能可以从那儿访问集群服务。
这是一个非标准的方式，可能在一些集群上能工作，但在另一些上却不能。
浏览器和其他工具可能已经安装也可能没有安装。集群 DNS 可能不会正常工作。</li>
</ul>
</li>
</ul>
<!--
### Discovering builtin services

Typically, there are several services which are started on a cluster by kube-system. Get a list of these
with the `kubectl cluster-info` command:
-->
<h3 id="discovering-builtin-services">发现内置服务  </h3>
<p>典型情况下，kube-system 名字空间中会启动集群的几个服务。
使用 <code>kubectl cluster-info</code> 命令获取这些服务的列表：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl cluster-info
</code></pre></div><!--
The output is similar to this:
-->
<p>输出类似于：</p>
<pre tabindex="0"><code>Kubernetes master is running at https://104.197.5.247
elasticsearch-logging is running at https://104.197.5.247/api/v1/namespaces/kube-system/services/elasticsearch-logging/proxy
kibana-logging is running at https://104.197.5.247/api/v1/namespaces/kube-system/services/kibana-logging/proxy
kube-dns is running at https://104.197.5.247/api/v1/namespaces/kube-system/services/kube-dns/proxy
grafana is running at https://104.197.5.247/api/v1/namespaces/kube-system/services/monitoring-grafana/proxy
heapster is running at https://104.197.5.247/api/v1/namespaces/kube-system/services/monitoring-heapster/proxy
</code></pre><!--
This shows the proxy-verb URL for accessing each service.
For example, this cluster has cluster-level logging enabled (using Elasticsearch), which can be reached
at `https://104.197.5.247/api/v1/namespaces/kube-system/services/elasticsearch-logging/proxy/` if suitable credentials are passed, or through a kubectl proxy at, for example:
`http://localhost:8080/api/v1/namespaces/kube-system/services/elasticsearch-logging/proxy/`.
-->
<p>这一输出显示了用 proxy 动词访问每个服务时可用的 URL。例如，此集群
（使用 Elasticsearch）启用了集群层面的日志。如果提供合适的凭据，可以通过
<code>https://104.197.5.247/api/v1/namespaces/kube-system/services/elasticsearch-logging/proxy/</code>
访问，或通过一个 <code>kubectl proxy</code> 来访问：
<code>http://localhost:8080/api/v1/namespaces/kube-system/services/elasticsearch-logging/proxy/</code>。</p>
<!--
See [Access Clusters Using the Kubernetes API](/docs/tasks/administer-cluster/access-cluster-api/#accessing-the-cluster-api) for how to pass credentials or use kubectl proxy.
-->
<blockquote class="note callout">
  <div><strong>说明：</strong> 请参阅<a href="/zh/docs/tasks/administer-cluster/access-cluster-api/#accessing-the-cluster-api">使用 Kubernets API 访问集群</a>
了解如何传递凭据或如何使用 <code>kubectl proxy</code>。</div>
</blockquote>
<!--
#### Manually constructing apiserver proxy URLs

As mentioned above, you use the `kubectl cluster-info` command to retrieve the service's proxy URL. To create proxy URLs that include service endpoints, suffixes, and parameters, you simply append to the service's proxy URL:
`http://`*`kubernetes_master_address`*`/api/v1/namespaces/`*`namespace_name`*`/services/`*`[https:]service_name[:port_name]`*`/proxy`

If you haven't specified a name for your port, you don't have to specify *port_name* in the URL.
-->
<h4 id="manually-constructing-apiserver-proxy-urls">手动构建 API 服务器代理 URLs  </h4>
<p>如前所述，你可以使用 <code>kubectl cluster-info</code> 命令取得服务的代理 URL。
为了创建包含服务末端、后缀和参数的代理 URLs，你可以简单地在服务的代理 URL 中添加：
<code>http://</code><em><code>kubernetes_master_address</code></em><code>/api/v1/namespaces/</code><em><code>namespace_name</code></em><code>/services/</code><em><code>service_name[:port_name]</code></em><code>/proxy</code></p>
<p>如果还没有为你的端口指定名称，你可以不用在 URL 中指定 <em>port_name</em>。</p>
<!--
##### Examples

* To access the Elasticsearch service endpoint `_search?q=user:kimchy`, you would use:
-->
<h5 id="示例">示例</h5>
<ul>
<li>
<p>如要访问 Elasticsearch 服务末端 <code>_search?q=user:kimchy</code>，你可以使用：</p>
<pre tabindex="0"><code>http://104.197.5.247/api/v1/namespaces/kube-system/services/elasticsearch-logging/proxy/_search?q=user:kimchy
</code></pre></li>
</ul>
<!--
* To access the Elasticsearch cluster health information `_cluster/health?pretty=true`, you would use:
-->
<ul>
<li>
<p>如要访问 Elasticsearch 集群健康信息<code>_cluster/health?pretty=true</code>，你会使用：</p>
<pre tabindex="0"><code>https://104.197.5.247/api/v1/namespaces/kube-system/services/elasticsearch-logging/proxy/_cluster/health?pretty=true` 
</code></pre><!--
The health information is similar to this:
-->
<p>健康信息与下面的例子类似：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-json" data-lang="json">{
  <span style="color:#008000;font-weight:bold">&#34;cluster_name&#34;</span> : <span style="color:#b44">&#34;kubernetes_logging&#34;</span>,
  <span style="color:#008000;font-weight:bold">&#34;status&#34;</span> : <span style="color:#b44">&#34;yellow&#34;</span>,
  <span style="color:#008000;font-weight:bold">&#34;timed_out&#34;</span> : <span style="color:#a2f;font-weight:bold">false</span>,
  <span style="color:#008000;font-weight:bold">&#34;number_of_nodes&#34;</span> : <span style="color:#666">1</span>,
  <span style="color:#008000;font-weight:bold">&#34;number_of_data_nodes&#34;</span> : <span style="color:#666">1</span>,
  <span style="color:#008000;font-weight:bold">&#34;active_primary_shards&#34;</span> : <span style="color:#666">5</span>,
  <span style="color:#008000;font-weight:bold">&#34;active_shards&#34;</span> : <span style="color:#666">5</span>,
  <span style="color:#008000;font-weight:bold">&#34;relocating_shards&#34;</span> : <span style="color:#666">0</span>,
  <span style="color:#008000;font-weight:bold">&#34;initializing_shards&#34;</span> : <span style="color:#666">0</span>,
  <span style="color:#008000;font-weight:bold">&#34;unassigned_shards&#34;</span> : <span style="color:#666">5</span>
}
</code></pre></div></li>
</ul>
<!--
* To access the *https* Elasticsearch service health information `_cluster/health?pretty=true`, you would use:
-->
<ul>
<li>
<p>要访问 <em>https</em> Elasticsearch 服务健康信息 <code>_cluster/health?pretty=true</code>，你会使用：</p>
<pre tabindex="0"><code>https://104.197.5.247/api/v1/namespaces/kube-system/services/https:elasticsearch-logging/proxy/_cluster/health?pretty=true
</code></pre></li>
</ul>
<!--
#### Using web browsers to access services running on the cluster

You may be able to put an apiserver proxy URL into the address bar of a browser. However:
-->
<h4 id="通过-web-浏览器访问集群中运行的服务">通过 Web 浏览器访问集群中运行的服务</h4>
<p>你或许能够将 API 服务器代理的 URL 放入浏览器的地址栏，然而：</p>
<!--
- Web browsers cannot usually pass tokens, so you may need to use basic (password) auth. Apiserver can be configured to accept basic auth,
    but your cluster may not be configured to accept basic auth.
- Some web apps may not work, particularly those with client side javascript that construct URLs in a
    way that is unaware of the proxy path prefix.
-->
<ul>
<li>Web 服务器通常不能传递令牌，所以你可能需要使用基本（密码）认证。
API 服务器可以配置为接受基本认证，但你的集群可能并没有这样配置。</li>
<li>某些 Web 应用可能无法工作，特别是那些使用客户端 Javascript 构造 URL 的
应用，所构造的 URL 可能并不支持代理路径前缀。</li>
</ul>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-8bcf4aeb5bbb6d6969a146e5ab97557b">36 - 调试 DNS 问题</h1>
    
	<!-- overview -->
<!--
This page provides hints on diagnosing DNS problems.
-->
<p>这篇文章提供了一些关于 DNS 问题诊断的方法。</p>
<!-- steps -->
<h2 id="准备开始">准备开始</h2>
<p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
如果你还没有集群，你可以通过 <a href="/zh/docs/tasks/tools/#minikube">Minikube</a> 构建一
个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p>
<!--
You need to have a Kubernetes cluster, and the kubectl command-line tool must
be configured to communicate with your cluster. If you do not already have a
cluster, you can create one by using
[minikube](/docs/tasks/tools/#minikube)
or you can use one of these Kubernetes playgrounds:
-->
<ul>
<li><a href="https://www.katacoda.com/courses/kubernetes/playground">Katacoda</a></li>
<li><a href="http://labs.play-with-k8s.com/">玩转 Kubernetes</a></li>
</ul>

<!-- 
Your cluster must be configured to use the CoreDNS
<a class='glossary-tooltip' title='扩展 Kubernetes 功能的资源。' data-toggle='tooltip' data-placement='top' href='/zh/docs/concepts/cluster-administration/addons/' target='_blank' aria-label='addon'>addon</a> or its precursor,
kube-dns.  
-->
<p>你的集群必须使用了 CoreDNS <a class='glossary-tooltip' title='扩展 Kubernetes 功能的资源。' data-toggle='tooltip' data-placement='top' href='/zh/docs/concepts/cluster-administration/addons/' target='_blank' aria-label='插件'>插件</a>
或者其前身，<code>kube-dns</code>。</p>


您的 Kubernetes 服务器版本必须不低于版本 v1.6.
 要获知版本信息，请输入 <code>kubectl version</code>.

<!--
### Create a simple Pod to use as a test environment



 













<div class="highlight">
    <div class="copy-code-icon" style="text-align:right">
    <a href="https://raw.githubusercontent.com/kubernetes/website/main/content/zh/examples/admin/dns/dnsutils.yaml" download="admin/dns/dnsutils.yaml"><code>admin/dns/dnsutils.yaml</code>
    </a>
    <img src="/images/copycode.svg" style="max-height:24px; cursor: pointer" onclick="copyCode('admin-dns-dnsutils-yaml')" title="Copy admin/dns/dnsutils.yaml to clipboard">
    </img>
    </div>
    <div class="includecode" id="admin-dns-dnsutils-yaml">
    <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>Pod<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>dnsutils<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">namespace</span>:<span style="color:#bbb"> </span>default<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">spec</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">containers</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>dnsutils<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">image</span>:<span style="color:#bbb"> </span>gcr.io/kubernetes-e2e-test-images/dnsutils:1.3<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">command</span>:<span style="color:#bbb">
</span><span style="color:#bbb">      </span>- sleep<span style="color:#bbb">
</span><span style="color:#bbb">      </span>- <span style="color:#b44">&#34;3600&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">imagePullPolicy</span>:<span style="color:#bbb"> </span>IfNotPresent<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">restartPolicy</span>:<span style="color:#bbb"> </span>Always<span style="color:#bbb">
</span></code></pre></div>
    </div>
</div>



<blockquote class="note callout">
  <div><strong>说明：</strong> This example creates a pod in the <code>default</code> namespace. DNS name resolution for
services depends on the namespace of the pod. For more information, review
<a href="/docs/concepts/services-networking/dns-pod-service/#what-things-get-dns-names">DNS for Services and Pods</a>.</div>
</blockquote>

Use that manifest to create a Pod:

```shell
kubectl create -f https://k8s.io/examples/admin/dns/busybox.yaml
pod/busybox created

kubectl get pods busybox
NAME      READY     STATUS    RESTARTS   AGE
busybox   1/1       Running   0          <some-time>
```
-->
<h3 id="创建一个简单的-pod-作为测试环境">创建一个简单的 Pod 作为测试环境</h3>


 













<div class="highlight">
    <div class="copy-code-icon" style="text-align:right">
    <a href="https://raw.githubusercontent.com/kubernetes/website/main/content/zh/examples/admin/dns/dnsutils.yaml" download="admin/dns/dnsutils.yaml"><code>admin/dns/dnsutils.yaml</code>
    </a>
    <img src="/images/copycode.svg" style="max-height:24px; cursor: pointer" onclick="copyCode('admin-dns-dnsutils-yaml')" title="Copy admin/dns/dnsutils.yaml to clipboard">
    </img>
    </div>
    <div class="includecode" id="admin-dns-dnsutils-yaml">
    <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>Pod<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>dnsutils<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">namespace</span>:<span style="color:#bbb"> </span>default<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">spec</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">containers</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>dnsutils<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">image</span>:<span style="color:#bbb"> </span>gcr.io/kubernetes-e2e-test-images/dnsutils:1.3<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">command</span>:<span style="color:#bbb">
</span><span style="color:#bbb">      </span>- sleep<span style="color:#bbb">
</span><span style="color:#bbb">      </span>- <span style="color:#b44">&#34;3600&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">imagePullPolicy</span>:<span style="color:#bbb"> </span>IfNotPresent<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">restartPolicy</span>:<span style="color:#bbb"> </span>Always<span style="color:#bbb">
</span></code></pre></div>
    </div>
</div>


<blockquote class="note callout">
  <div><strong>说明：</strong> 此示例在 <code>default</code> 命名空间创建 pod。 服务的 DNS 名字解析取决于 pod 的命名空间。 详细信息请查阅
<a href="/zh/docs/concepts/services-networking/dns-pod-service/#what-things-get-dns-names">服务和 Pod 的 DNS</a>。</div>
</blockquote>
<p>使用上面的清单来创建一个 Pod：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl apply -f https://k8s.io/examples/admin/dns/dnsutils.yaml
</code></pre></div><pre tabindex="0"><code>pod/dnsutils created
</code></pre><!--
…and verify its status:
-->
<p>验证其状态：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl get pods dnsutils
</code></pre></div><pre tabindex="0"><code>NAME      READY     STATUS    RESTARTS   AGE
dnsutils   1/1       Running   0          &lt;some-time&gt;
</code></pre><!--
Once that pod is running, you can exec `nslookup` in that environment.
If you see something like the following, DNS is working correctly.
-->
<p>一旦 Pod 处于运行状态，你就可以在该环境里执行 <code>nslookup</code>。
如果你看到类似下列的内容，则表示 DNS 是正常运行的。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl <span style="color:#a2f">exec</span> -i -t dnsutils -- nslookup kubernetes.default
</code></pre></div><pre tabindex="0"><code>Server:    10.0.0.10
Address 1: 10.0.0.10

Name:      kubernetes.default
Address 1: 10.0.0.1
</code></pre><!--
If the `nslookup` command fails, check the following:
-->
<p>如果 <code>nslookup</code> 命令执行失败，请检查下列内容：</p>
<!--
### Check the local DNS configuration first

Take a look inside the resolv.conf file.
(See [Inheriting DNS from the node](/docs/tasks/administer-cluster/dns-custom-nameservers/#inheriting-dns-from-the-node) and
[Known issues](#known-issues) below for more information)
-->
<h3 id="先检查本地的-dns-配置">先检查本地的 DNS 配置</h3>
<p>查看 resolv.conf 文件的内容
（阅读<a href="/zh/docs/tasks/administer-cluster/dns-custom-nameservers/">从节点继承 DNS 配置</a> 和
后文的<a href="#known-issues">已知问题</a> ，获取更多信息)</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl <span style="color:#a2f">exec</span> -ti dnsutils -- cat /etc/resolv.conf
</code></pre></div><!--
Verify that the search path and name server are set up like the following
(note that search path may vary for different cloud providers):
-->
<p>验证 search 和 nameserver 的配置是否与下面的内容类似
（注意 search 根据不同的云提供商可能会有所不同)：</p>
<pre tabindex="0"><code>search default.svc.cluster.local svc.cluster.local cluster.local google.internal c.gce_project_id.internal
nameserver 10.0.0.10
options ndots:5
</code></pre><!--
Errors such as the following indicate a problem with the CoreDNS (or kube-dns)
add-on or with associated Services:
-->
<p>下列错误表示 CoreDNS （或 kube-dns）插件或者相关服务出现了问题：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl <span style="color:#a2f">exec</span> -i -t dnsutils -- nslookup kubernetes.default
</code></pre></div><p>输出为：</p>
<pre tabindex="0"><code>Server:    10.0.0.10
Address 1: 10.0.0.10

nslookup: can't resolve 'kubernetes.default'
</code></pre><p>或者</p>
<pre tabindex="0"><code>Server:    10.0.0.10
Address 1: 10.0.0.10 kube-dns.kube-system.svc.cluster.local

nslookup: can't resolve 'kubernetes.default'
</code></pre><!--
### Check if the DNS pod is running

Use the `kubectl get pods` command to verify that the DNS pod is running.
-->
<h3 id="check-if-the-dns-pod-is-running">检查 DNS Pod 是否运行  </h3>
<p>使用 <code>kubectl get pods</code> 命令来验证 DNS Pod 是否运行。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl get pods --namespace<span style="color:#666">=</span>kube-system -l k8s-app<span style="color:#666">=</span>kube-dns
</code></pre></div><pre tabindex="0"><code>NAME                       READY     STATUS    RESTARTS   AGE
...
coredns-7b96bf9f76-5hsxb   1/1       Running   0           1h
coredns-7b96bf9f76-mvmmt   1/1       Running   0           1h
...
</code></pre><!--
The value for label `k8s-app` is `kube-dns` for both CoreDNS and kube-dns deployments.
-->
<blockquote class="note callout">
  <div><strong>说明：</strong> 对于 CoreDNS 和 kube-dns 部署而言，标签 <code>k8s-app</code> 的值都应该是 <code>kube-dns</code>。</div>
</blockquote>
<!--
If you see that no CoreDNS pod is running or that the pod has failed/completed,
the DNS add-on may not be deployed by default in your current environment and you
will have to deploy it manually.
-->
<p>如果你发现没有 CoreDNS Pod 在运行，或者该 Pod 的状态是 failed 或者 completed，
那可能这个 DNS 插件在您当前的环境里并没有成功部署，你将需要手动去部署它。</p>
<!--
### Check for Errors in the DNS pod

Use `kubectl logs` command to see logs for the DNS containers.
-->
<h3 id="check-for-errors-in-the-dns-pod">检查 DNS Pod 里的错误   </h3>
<p>使用 <code>kubectl logs</code> 命令来查看 DNS 容器的日志信息。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl logs --namespace<span style="color:#666">=</span>kube-system -l k8s-app<span style="color:#666">=</span>kube-dns
</code></pre></div><!--
Here is an example of a healthy CoreDNS log:
-->
<p>下列是一个正常运行的 CoreDNS 日志信息：</p>
<pre tabindex="0"><code>.:53
2018/08/15 14:37:17 [INFO] CoreDNS-1.2.2
2018/08/15 14:37:17 [INFO] linux/amd64, go1.10.3, 2e322f6
CoreDNS-1.2.2
linux/amd64, go1.10.3, 2e322f6
2018/08/15 14:37:17 [INFO] plugin/reload: Running configuration MD5 = 24e6c59e83ce706f07bcc82c31b1ea1c
</code></pre><!--
See if there are any suspicious or unexpected messages in the logs.
-->
<p>查看是否日志中有一些可疑的或者意外的消息。</p>
<!--
### Is DNS service up?

Verify that the DNS service is up by using the `kubectl get service` command.
-->
<h3 id="is-dns-service-up">检查是否启用了 DNS 服务  </h3>
<p>使用 <code>kubectl get service</code> 命令来检查 DNS 服务是否已经启用。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl get svc --namespace<span style="color:#666">=</span>kube-system
</code></pre></div><pre tabindex="0"><code>NAME         TYPE        CLUSTER-IP     EXTERNAL-IP   PORT(S)             AGE
...
kube-dns     ClusterIP   10.0.0.10      &lt;none&gt;        53/UDP,53/TCP        1h
...
</code></pre><!--
The service name is `kube-dns` for both CoreDNS and kube-dns deployments.
-->
<blockquote class="note callout">
  <div><strong>说明：</strong> 不管是 CoreDNS 还是 kube-dns，这个服务的名字都会是 <code>kube-dns</code> 。</div>
</blockquote>
<!--
If you have created the Service or in the case it should be created by default
but it does not appear, see
[debugging Services](/docs/tasks/debug-application-cluster/debug-service/) for
more information.
-->
<p>如果你已经创建了 DNS 服务，或者该服务应该是默认自动创建的但是它并没有出现，
请阅读<a href="/zh/docs/tasks/debug-application-cluster/debug-service/">调试服务</a>
来获取更多信息。</p>
<!--
### Are DNS endpoints exposed?

You can verify that DNS endpoints are exposed by using the `kubectl get endpoints`
command.
-->
<h3 id="are-dns-endpoints-exposed">DNS 的端点公开了吗？   </h3>
<p>你可以使用 <code>kubectl get endpoints</code> 命令来验证 DNS 的端点是否公开了。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl get ep kube-dns --namespace<span style="color:#666">=</span>kube-system
</code></pre></div><pre tabindex="0"><code>NAME       ENDPOINTS                       AGE
kube-dns   10.180.3.17:53,10.180.3.17:53    1h
</code></pre><!--
If you do not see the endpoints, see endpoints section in the
[debugging services](/docs/tasks/debug-application-cluster/debug-service/) documentation.

For additional Kubernetes DNS examples, see the
[cluster-dns examples](https://github.com/kubernetes/examples/tree/master/staging/cluster-dns)
in the Kubernetes GitHub repository.
-->
<p>如果你没看到对应的端点，请阅读
<a href="/zh/docs/tasks/debug-application-cluster/debug-service/">调试服务</a>的端点部分。</p>
<p>若需要了解更多的 Kubernetes DNS 例子，请在 Kubernetes GitHub 仓库里查看
<a href="https://github.com/kubernetes/examples/tree/master/staging/cluster-dns">cluster-dns 示例</a>。</p>
<!--
### Are DNS queries being received/processed?

You can verify if queries are being received by CoreDNS by adding the `log` plugin to the CoreDNS configuration (aka Corefile).
The CoreDNS Corefile is held in a ConfigMap named `coredns`. To edit it, use the command ...
-->
<h3 id="are-dns-queries-bing-received-processed">DNS 查询有被接收或者执行吗？  </h3>
<p>你可以通过给 CoreDNS 的配置文件（也叫 Corefile）添加 <code>log</code> 插件来检查查询是否被正确接收。
CoreDNS 的 Corefile 被保存在一个叫 <code>coredns</code> 的 ConfigMap 里，使用下列命令来编辑它：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl -n kube-system edit configmap coredns
</code></pre></div><!--
Then add `log` in the Corefile section per the example below.
-->
<p>然后按下面的例子给 Corefile 添加 <code>log</code>。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>ConfigMap<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>coredns<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">namespace</span>:<span style="color:#bbb"> </span>kube-system<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">data</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">Corefile</span>:<span style="color:#bbb"> </span>|<span style="color:#b44;font-style:italic">
</span><span style="color:#b44;font-style:italic">    .:53 {
</span><span style="color:#b44;font-style:italic">        log
</span><span style="color:#b44;font-style:italic">        errors
</span><span style="color:#b44;font-style:italic">        health
</span><span style="color:#b44;font-style:italic">        kubernetes cluster.local in-addr.arpa ip6.arpa {
</span><span style="color:#b44;font-style:italic">          pods insecure
</span><span style="color:#b44;font-style:italic">          upstream
</span><span style="color:#b44;font-style:italic">          fallthrough in-addr.arpa ip6.arpa
</span><span style="color:#b44;font-style:italic">        }
</span><span style="color:#b44;font-style:italic">        prometheus :9153
</span><span style="color:#b44;font-style:italic">        forward . /etc/resolv.conf
</span><span style="color:#b44;font-style:italic">        cache 30
</span><span style="color:#b44;font-style:italic">        loop
</span><span style="color:#b44;font-style:italic">        reload
</span><span style="color:#b44;font-style:italic">        loadbalance
</span><span style="color:#b44;font-style:italic">    }</span><span style="color:#bbb">    
</span></code></pre></div><!--
After saving the changes, it may take up to minute or two for Kubernetes to propagate these changes to the CoreDNS pods.
-->
<p>保存这些更改后，你可能会需要等待一到两分钟让 Kubernetes 把这些更改应用到
CoreDNS 的 Pod 里。</p>
<!--
Next, make some queries and view the logs per the sections above in this document. If CoreDNS pods are receiving the queries, you should see them in the logs.

Here is an example of a query in the log.
-->
<p>接下来，发起一些查询并依照前文所述查看日志信息，如果 CoreDNS 的 Pod 接收到这些查询，
你将可以在日志信息里看到它们。</p>
<p>下面是日志信息里的查询例子：</p>
<pre tabindex="0"><code>.:53
2018/08/15 14:37:15 [INFO] CoreDNS-1.2.0
2018/08/15 14:37:15 [INFO] linux/amd64, go1.10.3, 2e322f6
CoreDNS-1.2.0
linux/amd64, go1.10.3, 2e322f6
2018/09/07 15:29:04 [INFO] plugin/reload: Running configuration MD5 = 162475cdf272d8aa601e6fe67a6ad42f
2018/09/07 15:29:04 [INFO] Reloading complete
172.17.0.18:41675 - [07/Sep/2018:15:29:11 +0000] 59925 &quot;A IN kubernetes.default.svc.cluster.local. udp 54 false 512&quot; NOERROR qr,aa,rd,ra 106 0.000066649s

</code></pre><!--
### Are you in the right namespace for the service?

DNS queries that don't specify a namespace are limited to the pod's 
namespace. 

If the namespace of the pod and service differ, the DNS query must include 
the namespace of the service.

This query is limited to the pod's namespace:
```shell
kubectl exec -i -t dnsutils -- nslookup <service-name>
```
-->
<h3 id="你的服务在正确的命名空间中吗">你的服务在正确的命名空间中吗？</h3>
<p>未指定命名空间的 DNS 查询仅作用于 pod 所在的命名空间。</p>
<p>如果 pod 和服务的命名空间不相同，则 DNS 查询必须指定服务所在的命名空间。</p>
<p>该查询仅限于 pod 所在的名称空间：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl <span style="color:#a2f">exec</span> -i -t dnsutils -- nslookup &lt;service-name&gt;
</code></pre></div><!--
This query specifies the namespace:
```shell
kubectl exec -i -t dnsutils -- nslookup <service-name>.<namespace>
```
-->
<p>指定命名空间的查询：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl <span style="color:#a2f">exec</span> -i -t dnsutils -- nslookup &lt;service-name&gt;.&lt;namespace&gt;
</code></pre></div><!--
To learn more about name resolution, see 
[DNS for Services and Pods](/docs/concepts/services-networking/dns-pod-service/#what-things-get-dns-names). 
-->
<p>要进一步了解名字解析，请查看
<a href="/zh/docs/concepts/services-networking/dns-pod-service/#what-things-get-dns-names">服务和 Pod 的 DNS</a>。</p>
<!--
## Known issues

Some Linux distributions (e.g. Ubuntu), use a local DNS resolver by default (systemd-resolved).
Systemd-resolved moves and replaces `/etc/resolv.conf` with a stub file that can cause a fatal forwarding
loop when resolving names in upstream servers. This can be fixed manually by using kubelet's `-resolv-conf` flag
to point to the correct `resolv.conf` (With `systemd-resolved`, this is `/run/systemd/resolve/resolv.conf`).
kubeadm automatically detects `systemd-resolved`, and adjusts the kubelet flags accordingly.
-->
<h2 id="known-issues">已知问题</h2>
<p>有些 Linux 发行版本（比如 Ubuntu）默认使用一个本地的 DNS 解析器（systemd-resolved）。
<code>systemd-resolved</code> 会用一个存根文件（Stub File）来覆盖 <code>/etc/resolv.conf</code> 内容，
从而可能在上游服务器中解析域名产生转发环（forwarding loop）。 这个问题可以通过手动指定
kubelet 的 <code>--resolv-conf</code> 标志为正确的 <code>resolv.conf</code>（如果是 <code>systemd-resolved</code>，
则这个文件路径为 <code>/run/systemd/resolve/resolv.conf</code>）来解决。
kubeadm 会自动检测 <code>systemd-resolved</code> 并对应的更改 kubelet 的命令行标志。</p>
<!--
Kubernetes installs do not configure the nodes' `resolv.conf` files to use the
cluster DNS by default, because that process is inherently distribution-specific.
This should probably be implemented eventually.
-->
<p>Kubernetes 的安装并不会默认配置节点的 <code>resolv.conf</code> 文件来使用集群的 DNS 服务，因为这个配置对于不同的发行版本是不一样的。这个问题应该迟早会被解决的。</p>
<!--
Linux's libc (a.k.a. glibc) has a limit for the DNS `nameserver` records to 3
by default. What's more, for the glibc versions which are older than
glibc-2.17-222 ([the new versions update see this
issue](https://access.redhat.com/solutions/58028)), the allowed number of DNS
`search` records has been limited to 6 ([see this bug from
2005](https://bugzilla.redhat.com/show_bug.cgi?id=168253)). Kubernetes needs
to consume 1 `nameserver` record and 3 `search` records. This means that if a
local installation already uses 3 `nameserver`s or uses more than 3 `search`es
while your glibc version is in the affected list, some of those settings will
be lost. To work around the DNS `nameserver` records limit, the node can run
`dnsmasq`, which will provide more `nameserver` entries. You can also use
kubelet's `--resolv-conf` flag. To fix the DNS `search` records limit,
consider upgrading your linux distribution or upgrading to an unaffected
version of glibc.
-->
<p>Linux 的 libc 限制 <code>nameserver</code> 只能有三个记录。不仅如此，对于 glibc-2.17-222
之前的版本（<a href="https://access.redhat.com/solutions/58028">参见此 Issue 了解新版本的更新</a>），<code>search</code> 的记录不能超过 6 个
（ <a href="https://bugzilla.redhat.com/show_bug.cgi?id=168253">详情请查阅这个 2005 年的 bug</a>）。
Kubernetes 需要占用一个 <code>nameserver</code> 记录和三个<code>search</code>记录。
这意味着如果一个本地的安装已经使用了三个 <code>nameserver</code> 或者使用了超过三个
<code>search</code> 记录，而你的 glibc 版本也在有问题的版本列表中，那么有些配置很可能会丢失。
为了绕过 DNS <code>nameserver</code> 个数限制，节点可以运行 <code>dnsmasq</code>，以提供更多的
<code>nameserver</code> 记录。你也可以使用kubelet 的 <code>--resolv-conf</code> 标志来解决这个问题。
要想修复 DNS <code>search</code> 记录个数限制问题，可以考虑升级你的 Linux 发行版本，或者
升级 glibc 到一个不再受此困扰的版本。</p>
<!--
If you are using Alpine version 3.3 or earlier as your base image, DNS may not
work properly owing to a known issue with Alpine.
Check [here](https://github.com/kubernetes/kubernetes/issues/30215)
for more information.
-->
<p>如果你使用 Alpine  3.3 或更早版本作为你的基础镜像，DNS 可能会由于 Alpine 中
一个已知的问题导致无法正常工作。
请查看<a href="https://github.com/kubernetes/kubernetes/issues/30215">这里</a>获取更多信息。</p>
<h2 id="接下来">接下来</h2>
<!--
- [Autoscaling the DNS Service in a Cluster](/docs/tasks/administer-cluster/dns-horizontal-autoscaling/).
- [DNS for Services and Pods](/docs/concepts/services-networking/dns-pod-service/)
-->
<ul>
<li>参阅<a href="/zh/docs/tasks/administer-cluster/dns-horizontal-autoscaling/">自动扩缩集群中的 DNS 服务</a>.</li>
<li>阅读<a href="/zh/docs/concepts/services-networking/dns-pod-service/">服务和 Pod 的 DNS</a></li>
</ul>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-1e966f5d0540bbee0876f9d0d08d54dc">37 - 通过名字空间共享集群</h1>
    
	<!--
reviewers:
- derekwaynecarr
- janetkuo
title: Share a Cluster with Namespaces
content_type: task
-->
<!-- overview -->
<!--
This page shows how to view, work in, and delete <a class='glossary-tooltip' title='名字空间是 Kubernetes 为了在同一物理集群上支持多个虚拟集群而使用的一种抽象。' data-toggle='tooltip' data-placement='top' href='/zh/docs/concepts/overview/working-with-objects/namespaces/' target='_blank' aria-label='namespaces'>namespaces</a>. The page also shows how to use Kubernetes namespaces to subdivide your cluster.
-->
<p>本页展示如何查看、使用和删除<a class='glossary-tooltip' title='名字空间是 Kubernetes 为了在同一物理集群上支持多个虚拟集群而使用的一种抽象。' data-toggle='tooltip' data-placement='top' href='/zh/docs/concepts/overview/working-with-objects/namespaces/' target='_blank' aria-label='名字空间'>名字空间</a>。
本页同时展示如何使用 Kubernetes 名字空间来划分集群。</p>
<h2 id="准备开始">准备开始</h2>
<!--
* Have an [existing Kubernetes cluster](/docs/setup/).
* You have a basic understanding of Kubernetes <a class='glossary-tooltip' title='Pod 表示您的集群上一组正在运行的容器。' data-toggle='tooltip' data-placement='top' href='/docs/concepts/workloads/pods/pod-overview/' target='_blank' aria-label='Pods'>Pods</a>, <a class='glossary-tooltip' title='将运行在一组 Pods 上的应用程序公开为网络服务的抽象方法。' data-toggle='tooltip' data-placement='top' href='/zh/docs/concepts/services-networking/service/' target='_blank' aria-label='Services'>Services</a>, and <a class='glossary-tooltip' title='Deployment 是管理应用副本的 API 对象。' data-toggle='tooltip' data-placement='top' href='/zh/docs/concepts/workloads/controllers/deployment/' target='_blank' aria-label='Deployments'>Deployments</a>.
-->
<ul>
<li>你已拥有一个<a href="/zh/docs/setup/">配置好的 Kubernetes 集群</a>。</li>
<li>你已对 Kubernetes 的 <a class='glossary-tooltip' title='Pod 表示您的集群上一组正在运行的容器。' data-toggle='tooltip' data-placement='top' href='/docs/concepts/workloads/pods/pod-overview/' target='_blank' aria-label='Pods'>Pods</a> ,
<a class='glossary-tooltip' title='将运行在一组 Pods 上的应用程序公开为网络服务的抽象方法。' data-toggle='tooltip' data-placement='top' href='/zh/docs/concepts/services-networking/service/' target='_blank' aria-label='Services'>Services</a> , 和
<a class='glossary-tooltip' title='Deployment 是管理应用副本的 API 对象。' data-toggle='tooltip' data-placement='top' href='/zh/docs/concepts/workloads/controllers/deployment/' target='_blank' aria-label='Deployments'>Deployments</a> 有基本理解。</li>
</ul>
<!-- steps -->
<!-- ## Viewing namespaces -->
<h2 id="查看名字空间">查看名字空间</h2>
<!-- 1. List the current namespaces in a cluster using: -->
<ol>
<li>列出集群中现有的名字空间：</li>
</ol>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl get namespaces
</code></pre></div><pre tabindex="0"><code>NAME          STATUS    AGE
default       Active    11d
kube-system   Active    11d
kube-public   Active    11d
</code></pre><!-- Kubernetes starts with three initial namespaces: -->
<p>初始状态下，Kubernetes 具有三个名字空间：</p>
<!--
* `default` The default namespace for objects with no other namespace
* `kube-system` The namespace for objects created by the Kubernetes system
* `kube-public` This namespace is created automatically and is readable by all users (including those not authenticated). This namespace is mostly reserved for cluster usage, in case that some resources should be visible and readable publicly throughout the whole cluster. The public aspect of this namespace is only a convention, not a requirement. -->
<ul>
<li><code>default</code> 无名字空间对象的默认名字空间</li>
<li><code>kube-system</code> 由 Kubernetes 系统创建的对象的名字空间</li>
<li><code>kube-public</code> 自动创建且被所有用户可读的名字空间（包括未经身份认证的）。此名字空间通常在某些资源在整个集群中可见且可公开读取时被集群使用。此名字空间的公共方面只是一个约定，而不是一个必要条件。</li>
</ul>
<!-- You can also get the summary of a specific namespace using: -->
<p>你还可以通过下列命令获取特定名字空间的摘要：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl get namespaces &lt;name&gt;
</code></pre></div><!-- Or you can get detailed information with: -->
<p>或用下面的命令获取详细信息：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl describe namespaces &lt;name&gt;
</code></pre></div><pre tabindex="0"><code>Name:           default
Labels:         &lt;none&gt;
Annotations:    &lt;none&gt;
Status:         Active

No resource quota.

Resource Limits
 Type       Resource    Min Max Default
 ----               --------    --- --- ---
 Container          cpu         -   -   100m
</code></pre><!-- Note that these details show both resource quota (if present) as well as resource limit ranges. -->
<p>请注意，这些详情同时显示了资源配额（如果存在）以及资源限制区间。</p>
<!-- Resource quota tracks aggregate usage of resources in the *Namespace* and allows cluster operators
to define *Hard* resource usage limits that a *Namespace* may consume. -->
<p>资源配额跟踪并聚合 <em>Namespace</em> 中资源的使用情况，并允许集群运营者定义 <em>Namespace</em> 可能消耗的 <em>Hard</em> 资源使用限制。</p>
<!-- A limit range defines min/max constraints on the amount of resources a single entity can consume in
a *Namespace*.

See [Admission control: Limit Range](https://git.k8s.io/community/contributors/design-proposals/resource-management/admission_control_limit_range.md) -->
<p>限制区间定义了单个实体在一个 <em>Namespace</em> 中可使用的最小/最大资源量约束。</p>
<p>参阅 <a href="https://git.k8s.io/community/contributors/design-proposals/resource-management/admission_control_limit_range.md">准入控制: 限制区间</a></p>
<!--
A namespace can be in one of two phases:

* `Active` the namespace is in use
* `Terminating` the namespace is being deleted, and can not be used for new objects

See the [design doc](https://git.k8s.io/community/contributors/design-proposals/architecture/namespaces.md#phases) for more details. -->
<p>名字空间可以处于下列两个阶段中的一个:</p>
<ul>
<li><code>Active</code> 名字空间正在被使用中</li>
<li><code>Terminating</code> 名字空间正在被删除，且不能被用于新对象。</li>
</ul>
<p>参见<a href="https://git.k8s.io/community/contributors/design-proposals/architecture/namespaces.md#phases">设计文档</a> 查看更多细节。</p>
<!-- ## Creating a new namespace -->
<h2 id="创建名字空间">创建名字空间</h2>
<!--
Avoid creating namespace with prefix `kube-`, since it is reserved for Kubernetes system namespaces.
-->
<blockquote class="note callout">
  <div><strong>说明：</strong> 避免使用前缀 <code>kube-</code> 创建名字空间，因为它是为 Kubernetes 系统名字空间保留的。</div>
</blockquote>
<!-- 1. Create a new YAML file called `my-namespace.yaml` with the contents: -->
<ol>
<li>
<p>新建一个名为 <code>my-namespace.yaml</code> 的 YAML 文件，并写入下列内容：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>Namespace<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>&lt;insert-namespace-name-here&gt;<span style="color:#bbb">
</span></code></pre></div><!-- Then run: -->
<p>然后运行：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl create -f ./my-namespace.yaml
</code></pre></div></li>
</ol>
<!--
2. Alternatively, you can create namespace using below command:
-->
<ol start="2">
<li>
<p>或者，你可以使用下面的命令创建名字空间：</p>
<pre tabindex="0"><code>kubectl create namespace &lt;insert-namespace-name-here&gt;
</code></pre></li>
</ol>
<!--
The name of your namespace must be a valid
[DNS label](/docs/concepts/overview/working-with-objects/names#dns-label-names).
-->
<p>请注意，名字空间的名称必须是一个合法的
<a href="/zh/docs/concepts/overview/working-with-objects/names#dns-label-names">DNS 标签</a>。</p>
<!--
There's an optional field `finalizers`, which allows observables to purge resources whenever the namespace is deleted. Keep in mind that if you specify a nonexistent finalizer, the namespace will be created but will get stuck in the `Terminating` state if the user tries to delete it.

More information on `finalizers` can be found in the namespace [design doc](https://git.k8s.io/community/contributors/design-proposals/architecture/namespaces.md#finalizers).
-->
<p>可选字段 <code>finalizers</code> 允许观察者们在名字空间被删除时清除资源。记住如果指定了一个不存在的终结器，名字空间仍会被创建，但如果用户试图删除它，它将陷入 <code>Terminating</code> 状态。</p>
<p>更多有关 <code>finalizers</code> 的信息请查阅 <a href="https://git.k8s.io/community/contributors/design-proposals/architecture/namespaces.md#finalizers">设计文档</a> 中名字空间部分。</p>
<!-- ## Deleting a namespace -->
<h2 id="删除名字空间">删除名字空间</h2>
<!--
Delete a namespace with
-->
<p>删除名字空间使用命令：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl delete namespaces &lt;insert-some-namespace-name&gt;
</code></pre></div><!-- This deletes _everything_ under the namespace! -->
<blockquote class="warning callout">
  <div><strong>警告：</strong> 这会删除名字空间下的 <em>所有内容</em> ！</div>
</blockquote>

<!-- This delete is asynchronous, so for a time you will see the namespace in the `Terminating` state. -->
<p>删除是异步的，所以有一段时间你会看到名字空间处于 <code>Terminating</code> 状态。</p>
<!--
## Subdividing your cluster using Kubernetes namespaces
-->
<h2 id="使用-kubernetes-名字空间细分你的集群">使用 Kubernetes 名字空间细分你的集群</h2>
<!--
1. Understand the default namespace

   By default, a Kubernetes cluster will instantiate a default namespace when provisioning
   the cluster to hold the default set of Pods, Services, and Deployments used by the cluster.
-->
<ol>
<li>
<p>理解 default 名字空间</p>
<p>默认情况下，Kubernetes 集群会在配置集群时实例化一个 default 名字空间，用以存放集群所使用的默认
Pods、Services 和 Deployments 集合。</p>
<!--
Assuming you have a fresh cluster, you can introspect the available namespace's by doing the following:
-->
<p>假设你有一个新的集群，你可以通过执行以下操作来内省可用的名字空间</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl get namespaces
</code></pre></div><pre tabindex="0"><code>NAME      STATUS    AGE
default   Active    13m
</code></pre></li>
</ol>
<!--
2. Create new namespaces
-->
<ol start="2">
<li>
<p>创建新的名字空间</p>
<!--
For this exercise, we will create two additional Kubernetes namespaces to hold our content.
-->
<p>在本练习中，我们将创建两个额外的 Kubernetes 名字空间来保存我们的内容。</p>
<!--
In a scenario where an organization is using a shared Kubernetes cluster for development and
production use cases:
-->
<p>在某组织使用共享的 Kubernetes 集群进行开发和生产的场景中：</p>
<!--
The development team would like to maintain a space in the cluster where they can
get a view on the list of Pods, Services, and Deployments
they use to build and run their application.  In this space, Kubernetes resources come
and go, and the restrictions on who can or cannot modify resources
are relaxed to enable agile development.
-->
<p>开发团队希望在集群中维护一个空间，以便他们可以查看用于构建和运行其应用程序的 Pods、Services
和 Deployments 列表。在这个空间里，Kubernetes 资源被自由地加入或移除，
对谁能够或不能修改资源的限制被放宽，以实现敏捷开发。</p>
<!--
The operations team would like to maintain a space in the cluster where they can enforce
strict procedures on who can or cannot manipulate the set of
Pods, Services, and Deployments that run the production site.
-->
<p>运维团队希望在集群中维护一个空间，以便他们可以强制实施一些严格的规程，
对谁可以或不可以操作运行生产站点的 Pods、Services 和 Deployments 集合进行控制。</p>
<!--
One pattern this organization could follow is to partition the Kubernetes cluster into
two namespaces: `development` and `production`.
-->
<p>该组织可以遵循的一种模式是将 Kubernetes 集群划分为两个名字空间：development 和 production。</p>
<!-- Let's create two new namespaces to hold our work. -->
<p>让我们创建两个新的名字空间来保存我们的工作。</p>
<!-- Create the `development` namespace using kubectl. -->
<p>使用 kubectl 创建 <code>development</code> 名字空间。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl create -f https://k8s.io/examples/admin/namespace-dev.json
</code></pre></div><!-- And then let's create the `production` namespace using kubectl. -->
<p>让我们使用 kubectl 创建 <code>production</code> 名字空间。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl create -f https://k8s.io/examples/admin/namespace-prod.json
</code></pre></div><!-- To be sure things are right, list all of the namespaces in our cluster. -->
<p>为了确保一切正常，列出集群中的所有名字空间。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl get namespaces --show-labels
</code></pre></div><pre tabindex="0"><code>NAME          STATUS    AGE       LABELS
default       Active    32m       &lt;none&gt;
development   Active    29s       name=development
production    Active    23s       name=production
</code></pre></li>
</ol>
<!-- 3. Create pods in each namespace -->
<ol start="3">
<li>
<p>在每个名字空间中创建 pod</p>
<!--
A Kubernetes namespace provides the scope for Pods, Services, and Deployments in the cluster.

Users interacting with one namespace do not see the content in another namespace.
-->
<p>Kubernetes 名字空间为集群中的 Pods、Services 和 Deployments 提供了作用域。</p>
<p>与一个名字空间交互的用户不会看到另一个名字空间中的内容。</p>
<!-- To demonstrate this, let's spin up a simple Deployment and Pods in the `development` namespace. -->
<p>为了演示这一点，让我们在 <code>development</code> 名字空间中启动一个简单的 Deployment 和 Pod。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl create deployment snowflake --image<span style="color:#666">=</span>k8s.gcr.io/serve_hostname -n<span style="color:#666">=</span>development
kubectl scale deployment snowflake --replicas<span style="color:#666">=</span><span style="color:#666">2</span> -n<span style="color:#666">=</span>development
</code></pre></div><!--
We have just created a deployment whose replica size is 2 that is running the pod
called `snowflake` with a basic container that just serves the hostname.
-->
<p>我们刚刚创建了一个副本个数为 2 的 Deployment，运行名为 <code>snowflake</code> 的
Pod，其中包含一个仅负责提供主机名的基本容器。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl get deployment -n<span style="color:#666">=</span>development
</code></pre></div><pre tabindex="0"><code>NAME         READY   UP-TO-DATE   AVAILABLE   AGE
snowflake    2/2     2            2           2m
</code></pre><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl get pods -l <span style="color:#b8860b">app</span><span style="color:#666">=</span>snowflake -n<span style="color:#666">=</span>development
</code></pre></div><pre tabindex="0"><code>NAME                         READY     STATUS    RESTARTS   AGE
snowflake-3968820950-9dgr8   1/1       Running   0          2m
snowflake-3968820950-vgc4n   1/1       Running   0          2m
</code></pre><!--
And this is great, developers are able to do what they want, and they do not have to worry about affecting content in the `production` namespace.

Let's switch to the `production` namespace and show how resources in one namespace are hidden from the other.

The `production` namespace should be empty, and the following commands should return nothing.
-->
<p>看起来还不错，开发人员能够做他们想做的事，而且他们不必担心会影响到
<code>production</code> 名字空间下面的内容。</p>
<p>让我们切换到 <code>production</code> 名字空间，展示一下一个名字空间中的资源是如何对
另一个名字空间隐藏的。</p>
<p>名字空间 <code>production</code> 应该是空的，下面的命令应该不会返回任何东西。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl get deployment -n<span style="color:#666">=</span>production
kubectl get pods -n<span style="color:#666">=</span>production
</code></pre></div><!--
Production likes to run cattle, so let's create some cattle pods.
-->
<p>生产环境下一般以养牛的方式运行负载，所以让我们创建一些 Cattle（牛）Pod。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl create deployment cattle --image<span style="color:#666">=</span>k8s.gcr.io/serve_hostname -n<span style="color:#666">=</span>production
kubectl scale deployment cattle --replicas<span style="color:#666">=</span><span style="color:#666">5</span> -n<span style="color:#666">=</span>production

kubectl get deployment -n<span style="color:#666">=</span>production
</code></pre></div><pre tabindex="0"><code>NAME         READY   UP-TO-DATE   AVAILABLE   AGE
cattle       5/5     5            5           10s
</code></pre><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl get pods -l <span style="color:#b8860b">app</span><span style="color:#666">=</span>cattle -n<span style="color:#666">=</span>production
</code></pre></div><pre tabindex="0"><code>NAME                      READY     STATUS    RESTARTS   AGE
cattle-2263376956-41xy6   1/1       Running   0          34s
cattle-2263376956-kw466   1/1       Running   0          34s
cattle-2263376956-n4v97   1/1       Running   0          34s
cattle-2263376956-p5p3i   1/1       Running   0          34s
cattle-2263376956-sxpth   1/1       Running   0          34s
</code></pre></li>
</ol>
<!--
At this point, it should be clear that the resources users create in one namespace are hidden from the other namespace.
-->
<p>此时，应该很清楚的展示了用户在一个名字空间中创建的资源对另一个名字空间是隐藏的。</p>
<!--
As the policy support in Kubernetes evolves, we will extend this scenario to show how you can provide different
authorization rules for each namespace.
-->
<p>随着 Kubernetes 中的策略支持的发展，我们将扩展此场景，以展示如何为每个名字空间提供不同的授权规则。</p>
<!-- discussion -->
<!--
## Understanding the motivation for using namespaces
-->
<h2 id="理解使用名字空间的动机">理解使用名字空间的动机</h2>
<!--
A single cluster should be able to satisfy the needs of multiple users or groups of users (henceforth a 'user community').
-->
<p>单个集群应该能满足多个用户及用户组的需求（以下称为 “用户社区”）。</p>
<!-- Kubernetes _namespaces_ help different projects, teams, or customers to share a Kubernetes cluster. -->
<p>Kubernetes <em>名字空间</em> 帮助不同的项目、团队或客户去共享 Kubernetes 集群。</p>
<!--
It does this by providing the following:

1. A scope for [Names](/docs/concepts/overview/working-with-objects/names/).
2. A mechanism to attach authorization and policy to a subsection of the cluster.
-->
<p>名字空间通过以下方式实现这点：</p>
<ol>
<li>为<a href="/zh/docs/concepts/overview/working-with-objects/names/">名字</a>设置作用域.</li>
<li>为集群中的部分资源关联鉴权和策略的机制。</li>
</ol>
<!--
Use of multiple namespaces is optional.
-->
<p>使用多个名字空间是可选的。</p>
<!--
Each user community wants to be able to work in isolation from other communities.
-->
<p>每个用户社区都希望能够与其他社区隔离开展工作。</p>
<!--
Each user community has its own:

1. resources (pods, services, replication controllers, etc.)
2. policies (who can or cannot perform actions in their community)
3. constraints (this community is allowed this much quota, etc.)
-->
<p>每个用户社区都有自己的：</p>
<ol>
<li>资源（pods、服务、 副本控制器等等）</li>
<li>策略（谁能或不能在他们的社区里执行操作）</li>
<li>约束（该社区允许多少配额，等等）</li>
</ol>
<!--
A cluster operator may create a Namespace for each unique user community.
-->
<p>集群运营者可以为每个唯一用户社区创建名字空间。</p>
<!--
The Namespace provides a unique scope for:

1. named resources (to avoid basic naming collisions)
2. delegated management authority to trusted users
3. ability to limit community resource consumption
-->
<p>名字空间为下列内容提供唯一的作用域：</p>
<ol>
<li>命名资源（避免基本的命名冲突）</li>
<li>将管理权限委派给可信用户</li>
<li>限制社区资源消耗的能力</li>
</ol>
<!--
Use cases include:

1.  As a cluster operator, I want to support multiple user communities on a single cluster.
2.  As a cluster operator, I want to delegate authority to partitions of the cluster to trusted users
    in those communities.
3.  As a cluster operator, I want to limit the amount of resources each community can consume in order
    to limit the impact to other communities using the cluster.
4.  As a cluster user, I want to interact with resources that are pertinent to my user community in
    isolation of what other user communities are doing on the cluster.
-->
<p>用例包括:</p>
<ol>
<li>作为集群运营者, 我希望能在单个集群上支持多个用户社区。</li>
<li>作为集群运营者，我希望将集群分区的权限委派给这些社区中的受信任用户。</li>
<li>作为集群运营者，我希望能限定每个用户社区可使用的资源量，以限制对使用同一集群的其他用户社区的影响。</li>
<li>作为群集用户，我希望与我的用户社区相关的资源进行交互，而与其他用户社区在该集群上执行的操作无关。</li>
</ol>
<!--
## Understanding namespaces and DNS
-->
<h2 id="理解名字空间和-dns">理解名字空间和 DNS</h2>
<!--
When you create a [Service](/docs/concepts/services-networking/service/), it creates a corresponding [DNS entry](/docs/concepts/services-networking/dns-pod-service/).
This entry is of the form `<service-name>.<namespace-name>.svc.cluster.local`, which means
that if a container just uses `<service-name>` it will resolve to the service which
is local to a namespace.  This is useful for using the same configuration across
multiple namespaces such as Development, Staging and Production.  If you want to reach
across namespaces, you need to use the fully qualified domain name (FQDN).
-->
<p>当你创建<a href="/zh/docs/concepts/services-networking/service/">服务</a>时，Kubernetes
会创建相应的 <a href="/zh/docs/concepts/services-networking/dns-pod-service/">DNS 条目</a>。
此条目的格式为 <code>&lt;服务名称&gt;.&lt;名字空间名称&gt;.svc.cluster.local</code>。
这意味着如果容器只使用 <code>&lt;服务名称&gt;</code>，它将解析为名字空间本地的服务。
这对于在多个名字空间（如开发、暂存和生产）中使用相同的配置非常有用。
如果要跨名字空间访问，则需要使用完全限定的域名（FQDN）。</p>
<h2 id="接下来">接下来</h2>
<!--
* Learn more about [setting the namespace preference](/docs/concepts/overview/working-with-objects/namespaces/#setting-the-namespace-preference).
* Learn more about [setting the namespace for a request](/docs/concepts/overview/working-with-objects/namespaces/#setting-the-namespace-for-a-request)
* See [namespaces design](https://github.com/kubernetes/community/blob/main/contributors/design-proposals/architecture/namespaces.md).
-->
<ul>
<li>进一步了解<a href="/zh/docs/concepts/overview/working-with-objects/namespaces/#setting-the-namespace-preference">设置名字空间偏好</a></li>
<li>进一步了解<a href="/zh/docs/concepts/overview/working-with-objects/namespaces/#setting-the-namespace-for-a-request">设置请求的名字空间</a></li>
<li>参阅<a href="https://github.com/kubernetes/community/blob/main/contributors/design-proposals/architecture/namespaces.md">名字空间的设计文档</a></li>
</ul>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-f58763cc9447491b6c40f939a02d441d">38 - 通过配置文件设置 Kubelet 参数</h1>
    
	<!--
reviewers:
- mtaufen
- dawnchen
title: Set Kubelet parameters via a config file
content_type: task
--->
<!-- overview -->





<div style="margin-top: 10px; margin-bottom: 10px;">
<b>FEATURE STATE:</b> <code>Kubernetes v1.10 [beta]</code>
</div>

<!--
A subset of the Kubelet's configuration parameters may be
set via an on-disk config file, as a substitute for command-line flags.
This functionality is considered beta in v1.10.
--->
<p>通过保存在硬盘的配置文件设置 kubelet 的部分配置参数，这可以作为命令行参数的替代。
此功能在 v1.10 中为 beta 版。</p>
<!--
Providing parameters via a config file is the recommended approach because
it simplifies node deployment and configuration management.
--->
<p>建议通过配置文件的方式提供参数，因为这样可以简化节点部署和配置管理。</p>
<h2 id="准备开始">准备开始</h2>
<!--
- A v1.10 or higher Kubelet binary must be installed for beta functionality.
-->
<ul>
<li>需要安装 1.10 或更高版本的 kubelet 可执行文件，才能使用此 beta 功能。</li>
</ul>
<!-- steps -->
<!--
## Create the config file

The subset of the Kubelet's configuration that can be configured via a file
is defined by the `KubeletConfiguration` struct
[here (v1beta1)](https://github.com/kubernetes/kubernetes/blob/main/staging/src/k8s.io/kubelet/config/v1beta1/types.go).
-->
<h2 id="创建配置文件">创建配置文件</h2>
<p><code>KubeletConfiguration</code> 结构体定义了可以通过文件配置的 Kubelet 配置子集，
该结构体在 <a href="https://github.com/kubernetes/kubernetes/blob/main/staging/src/k8s.io/kubelet/config/v1beta1/types.go">这里（v1beta1）</a>
可以找到。</p>
<!--
The configuration file must be a JSON or YAML representation of the parameters
in this struct. Make sure the Kubelet has read permissions on the file.

Here is an example of what this file might look like:
-->
<p>配置文件必须是这个结构体中参数的 JSON 或 YAML 表现形式。
确保 kubelet 可以读取该文件。</p>
<p>下面是一个 Kubelet 配置文件示例：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>KubeletConfiguration<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>kubelet.config.k8s.io/v1beta1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">evictionHard</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">memory.available</span>:<span style="color:#bbb">  </span><span style="color:#b44">&#34;200Mi&#34;</span><span style="color:#bbb">
</span></code></pre></div><!--
In the example, the Kubelet is configured to evict Pods when available memory drops below 200Mi.
All other Kubelet configuration values are left at their built-in defaults, unless overridden
by flags. Command line flags which target the same value as a config file will override that value.

For a trick to generate a configuration file from a live node, see
[Reconfigure a Node's Kubelet in a Live Cluster](/docs/tasks/administer-cluster/reconfigure-kubelet).
-->
<p>在这个示例中, 当可用内存低于 200Mi 时, kubelet 将会开始驱逐 Pods。
没有声明的其余配置项都将使用默认值，除非使用命令行参数来重载。
命令行中的参数将会覆盖配置文件中的对应值。</p>
<p>作为一个小技巧，你可以从活动节点生成配置文件，相关方法请查看
<a href="/zh/docs/tasks/administer-cluster/reconfigure-kubelet">重新配置活动集群节点的 kubelet</a>。</p>
<!--
## Start a Kubelet process configured via the config file

Start the Kubelet with the `--config` flag set to the path of the Kubelet's config file.
The Kubelet will then load its config from this file.
--->
<h2 id="启动通过配置文件配置的-kubelet-进程">启动通过配置文件配置的 Kubelet 进程</h2>
<p>启动 Kubelet 需要将 <code>--config</code> 参数设置为 Kubelet 配置文件的路径。Kubelet 将从此文件加载其配置。</p>
<!--
Note that command line flags which target the same value as a config file will override that value.
This helps ensure backwards compatibility with the command-line API.
-->
<p>请注意，命令行参数与配置文件有相同的值时，就会覆盖配置文件中的该值。
这有助于确保命令行 API 的向后兼容性。</p>
<!--
Note that relative file paths in the Kubelet config file are resolved relative to the
location of the Kubelet config file, whereas relative paths in command line flags are resolved
relative to the Kubelet's current working directory.
-->
<p>请注意，kubelet 配置文件中的相对文件路径是相对于 kubelet 配置文件的位置解析的，
而命令行参数中的相对路径是相对于 kubelet 的当前工作目录解析的。</p>
<!--
Note that some default values differ between command-line flags and the Kubelet config file.
If `--config` is provided and the values are not specified via the command line, the
defaults for the `KubeletConfiguration` version apply.
In the above example, this version is `kubelet.config.k8s.io/v1beta1`.
--->
<p>请注意，命令行参数和 Kubelet 配置文件的某些默认值不同。
如果设置了 <code>--config</code>，并且没有通过命令行指定值，则 <code>KubeletConfiguration</code>
版本的默认值生效。在上面的例子中，version 是 <code>kubelet.config.k8s.io/v1beta1</code>。</p>
<!-- discussion -->
<!--
## Relationship to Dynamic Kubelet Config

If you are using the [Dynamic Kubelet Configuration](/docs/tasks/administer-cluster/reconfigure-kubelet)
feature, the combination of configuration provided via `--config` and any flags which override these values
is considered the default "last known good" configuration by the automatic rollback mechanism.
--->
<h2 id="与动态-kubelet-配置的关系">与动态 Kubelet 配置的关系</h2>
<p>如果你正在使用<a href="/zh/docs/tasks/administer-cluster/reconfigure-kubelet">动态 kubelet 配置</a>特性，
那么自动回滚机制将认为通过 <code>--config</code> 提供的配置与覆盖这些值的任何参数的组合是
&quot;最后已知正常（last known good）&quot; 的配置。</p>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-5e59f5575dce11fdaed640afdbeedfc1">39 - 配置 API 对象配额</h1>
    
	<!--
title: Configure Quotas for API Objects
content_type: task
-->
<!-- overview -->
<!--
This page shows how to configure quotas for API objects, including
PersistentVolumeClaims and Services. A quota restricts the number of
objects, of a particular type, that can be created in a namespace.
You specify quotas in a
[ResourceQuota](/docs/reference/generated/kubernetes-api/v1.22/#resourcequota-v1-core)
object.
-->
<p>本文讨论如何为 API 对象配置配额，包括 PersistentVolumeClaim 和 Service。
配额限制了可以在命名空间中创建的特定类型对象的数量。
你可以在 <a href="/docs/reference/generated/kubernetes-api/v1.22/#resourcequota-v1-core">ResourceQuota</a> 对象中指定配额。</p>
<h2 id="准备开始">准备开始</h2>
<p><p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
如果你还没有集群，你可以通过 <a href="/zh/docs/tasks/tools/#minikube">Minikube</a> 构建一
个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p>
<!--
You need to have a Kubernetes cluster, and the kubectl command-line tool must
be configured to communicate with your cluster. If you do not already have a
cluster, you can create one by using
[minikube](/docs/tasks/tools/#minikube)
or you can use one of these Kubernetes playgrounds:
-->
<ul>
<li><a href="https://www.katacoda.com/courses/kubernetes/playground">Katacoda</a></li>
<li><a href="http://labs.play-with-k8s.com/">玩转 Kubernetes</a></li>
</ul>
 
 要获知版本信息，请输入 <code>kubectl version</code>.
</p>
<!-- steps -->
<!--
## Create a namespace

Create a namespace so that the resources you create in this exercise are
isolated from the rest of your cluster.
-->
<h2 id="创建命名空间">创建命名空间</h2>
<p>创建一个命名空间以便本例中创建的资源和集群中的其余部分相隔离。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl create namespace quota-object-example
</code></pre></div><!--
## Create a ResourceQuota

Here is the configuration file for a ResourceQuota object:
-->
<h2 id="创建-resourcequota">创建 ResourceQuota</h2>
<p>下面是一个 ResourceQuota 对象的配置文件：</p>


 













<div class="highlight">
    <div class="copy-code-icon" style="text-align:right">
    <a href="https://raw.githubusercontent.com/kubernetes/website/main/content/zh/examples/admin/resource/quota-objects.yaml" download="admin/resource/quota-objects.yaml"><code>admin/resource/quota-objects.yaml</code>
    </a>
    <img src="/images/copycode.svg" style="max-height:24px; cursor: pointer" onclick="copyCode('admin-resource-quota-objects-yaml')" title="Copy admin/resource/quota-objects.yaml to clipboard">
    </img>
    </div>
    <div class="includecode" id="admin-resource-quota-objects-yaml">
    <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>ResourceQuota<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>object-quota-demo<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">spec</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">hard</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">persistentvolumeclaims</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;1&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">services.loadbalancers</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;2&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">services.nodeports</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;0&#34;</span><span style="color:#bbb">
</span></code></pre></div>
    </div>
</div>


<!--
Create the ResourceQuota:
-->
<p>创建 ResourceQuota：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl apply -f https://k8s.io/examples/admin/resource/quota-objects.yaml --namespace<span style="color:#666">=</span>quota-object-example
</code></pre></div><!--
View detailed information about the ResourceQuota:
-->
<p>查看 ResourceQuota 的详细信息：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl get resourcequota object-quota-demo --namespace<span style="color:#666">=</span>quota-object-example --output<span style="color:#666">=</span>yaml
</code></pre></div><!--
The output shows that in the quota-object-example namespace, there can be at most
one PersistentVolumeClaim, at most two Services of type LoadBalancer, and no Services
of type NodePort.
-->
<p>输出结果表明在 quota-object-example 命名空间中，至多只能有一个 PersistentVolumeClaim，
最多两个 LoadBalancer 类型的服务，不能有 NodePort 类型的服务。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">status</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">hard</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">persistentvolumeclaims</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;1&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">services.loadbalancers</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;2&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">services.nodeports</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;0&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">used</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">persistentvolumeclaims</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;0&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">services.loadbalancers</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;0&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">services.nodeports</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;0&#34;</span><span style="color:#bbb">
</span></code></pre></div><!--
## Create a PersistentVolumeClaim

Here is the configuration file for a PersistentVolumeClaim object:
-->
<h2 id="创建-persistentvolumeclaim">创建 PersistentVolumeClaim</h2>
<p>下面是一个 PersistentVolumeClaim 对象的配置文件：</p>


 













<div class="highlight">
    <div class="copy-code-icon" style="text-align:right">
    <a href="https://raw.githubusercontent.com/kubernetes/website/main/content/zh/examples/admin/resource/quota-objects-pvc.yaml" download="admin/resource/quota-objects-pvc.yaml"><code>admin/resource/quota-objects-pvc.yaml</code>
    </a>
    <img src="/images/copycode.svg" style="max-height:24px; cursor: pointer" onclick="copyCode('admin-resource-quota-objects-pvc-yaml')" title="Copy admin/resource/quota-objects-pvc.yaml to clipboard">
    </img>
    </div>
    <div class="includecode" id="admin-resource-quota-objects-pvc-yaml">
    <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>PersistentVolumeClaim<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>pvc-quota-demo<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">spec</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">storageClassName</span>:<span style="color:#bbb"> </span>manual<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">accessModes</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span>- ReadWriteOnce<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">resources</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">requests</span>:<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">storage</span>:<span style="color:#bbb"> </span>3Gi<span style="color:#bbb">
</span></code></pre></div>
    </div>
</div>


<!--
Create the PersistentVolumeClaim:
-->
<p>创建 PersistentVolumeClaim：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl apply -f https://k8s.io/examples/admin/resource/quota-objects-pvc.yaml --namespace<span style="color:#666">=</span>quota-object-example
</code></pre></div><!--
Verify that the PersistentVolumeClaim was created:
-->
<p>确认已创建完 PersistentVolumeClaim：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl get persistentvolumeclaims --namespace<span style="color:#666">=</span>quota-object-example
</code></pre></div><!--
The output shows that the PersistentVolumeClaim exists and has status Pending:
-->
<p>输出信息表明 PersistentVolumeClaim 存在并且处于 Pending 状态：</p>
<pre tabindex="0"><code>NAME             STATUS
pvc-quota-demo   Pending
</code></pre><!--
## Attempt to create a second PersistentVolumeClaim

Here is the configuration file for a second PersistentVolumeClaim:
-->
<h2 id="尝试创建第二个-persistentvolumeclaim">尝试创建第二个 PersistentVolumeClaim</h2>
<p>下面是第二个 PersistentVolumeClaim 的配置文件：</p>


 













<div class="highlight">
    <div class="copy-code-icon" style="text-align:right">
    <a href="https://raw.githubusercontent.com/kubernetes/website/main/content/zh/examples/admin/resource/quota-objects-pvc-2.yaml" download="admin/resource/quota-objects-pvc-2.yaml"><code>admin/resource/quota-objects-pvc-2.yaml</code>
    </a>
    <img src="/images/copycode.svg" style="max-height:24px; cursor: pointer" onclick="copyCode('admin-resource-quota-objects-pvc-2-yaml')" title="Copy admin/resource/quota-objects-pvc-2.yaml to clipboard">
    </img>
    </div>
    <div class="includecode" id="admin-resource-quota-objects-pvc-2-yaml">
    <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>PersistentVolumeClaim<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>pvc-quota-demo-2<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">spec</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">storageClassName</span>:<span style="color:#bbb"> </span>manual<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">accessModes</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span>- ReadWriteOnce<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">resources</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">requests</span>:<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">storage</span>:<span style="color:#bbb"> </span>4Gi<span style="color:#bbb">
</span></code></pre></div>
    </div>
</div>


<!--
Attempt to create the second PersistentVolumeClaim:
-->
<p>尝试创建第二个 PersistentVolumeClaim：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl create -f https://k8s.io/examples/admin/resource/quota-objects-pvc-2.yaml --namespace<span style="color:#666">=</span>quota-object-example
</code></pre></div><!--
The output shows that the second PersistentVolumeClaim was not created,
because it would have exceeded the quota for the namespace.
-->
<p>输出信息表明第二个 PersistentVolumeClaim 没有创建成功，因为这会超出命名空间的配额。</p>
<pre tabindex="0"><code>persistentvolumeclaims &quot;pvc-quota-demo-2&quot; is forbidden:
exceeded quota: object-quota-demo, requested: persistentvolumeclaims=1,
used: persistentvolumeclaims=1, limited: persistentvolumeclaims=1
</code></pre><!--
## Notes

These are the strings used to identify API resources that can be constrained
by quotas:
-->
<h2 id="说明">说明</h2>
<p>下面这些字符串可被用来标识那些能被配额限制的 API 资源：</p>
<table>
<tr><th>String</th><th>API Object</th></tr>
<tr><td>"pods"</td><td>Pod</td></tr>
<tr><td>"services"</td><td>Service</td></tr>
<tr><td>"replicationcontrollers"</td><td>ReplicationController</td></tr>
<tr><td>"resourcequotas"</td><td>ResourceQuota</td></tr>
<tr><td>"secrets"</td><td>Secret</td></tr>
<tr><td>"configmaps"</td><td>ConfigMap</td></tr>
<tr><td>"persistentvolumeclaims"</td><td>PersistentVolumeClaim</td></tr>
<tr><td>"services.nodeports"</td><td>Service of type NodePort</td></tr>
<tr><td>"services.loadbalancers"</td><td>Service of type LoadBalancer</td></tr>
</table>
<!--
## Clean up

Delete your namespace:
-->
<h2 id="清理">清理</h2>
<p>删除你的命名空间：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl delete namespace quota-object-example
</code></pre></div><h2 id="接下来">接下来</h2>
<!--
### For cluster administrators

* [Configure Default Memory Requests and Limits for a Namespace](/docs/tasks/administer-cluster/memory-default-namespace/)

* [Configure Default CPU Requests and Limits for a Namespace](/docs/tasks/administer-cluster/cpu-default-namespace/)

* [Configure Minimum and Maximum Memory Constraints for a Namespace](/docs/tasks/administer-cluster/memory-constraint-namespace/)

* [Configure Minimum and Maximum CPU Constraints for a Namespace](/docs/tasks/administer-cluster/cpu-constraint-namespace/)

* [Configure Memory and CPU Quotas for a Namespace](/docs/tasks/administer-cluster/quota-memory-cpu-namespace/)

* [Configure a Pod Quota for a Namespace](/docs/tasks/administer-cluster/quota-pod-namespace/)
-->
<h3 id="集群管理员参考">集群管理员参考</h3>
<ul>
<li><a href="/zh/docs/tasks/administer-cluster/manage-resources/memory-default-namespace/">为命名空间配置默认的内存请求和限制</a></li>
<li><a href="/zh/docs/tasks/administer-cluster/manage-resources/cpu-default-namespace/">为命名空间配置默认的 CPU 请求和限制</a></li>
<li><a href="/zh/docs/tasks/administer-cluster/manage-resources/memory-constraint-namespace/">为命名空间配置内存的最小和最大限制</a></li>
<li><a href="/zh/docs/tasks/administer-cluster/manage-resources/cpu-constraint-namespace/">为命名空间配置 CPU 的最小和最大限制</a></li>
<li><a href="/zh/docs/tasks/administer-cluster/manage-resources/quota-memory-cpu-namespace/">为命名空间配置 CPU 和内存配额</a></li>
<li><a href="/zh/docs/tasks/administer-cluster/manage-resources/quota-pod-namespace/">为命名空间配置 Pod 配额</a></li>
</ul>
<!--
### For app developers

* [Assign Memory Resources to Containers and Pods](/docs/tasks/configure-pod-container/assign-memory-resource/)

* [Assign CPU Resources to Containers and Pods](/docs/tasks/configure-pod-container/assign-cpu-resource/)

* [Configure Quality of Service for Pods](/docs/tasks/configure-pod-container/quality-service-pod/)
-->
<h3 id="应用开发者参考">应用开发者参考</h3>
<ul>
<li><a href="/zh/docs/tasks/configure-pod-container/assign-memory-resource/">为容器和 Pod 分配内存资源</a></li>
<li><a href="/zh/docs/tasks/configure-pod-container/assign-cpu-resource/">为容器和 Pod 分配 CPU 资源</a></li>
<li><a href="/zh/docs/tasks/configure-pod-container/quality-service-pod/">为 Pod 配置服务质量</a></li>
</ul>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-6f3658d05bf8864be1d96b1d1287cffb">40 - 配置资源不足时的处理方式</h1>
    
	<!--
reviewers:
- derekwaynecarr
- vishh
- timstclair
title: Configure Out Of Resource Handling
content_type: concept
-->
<!-- overview -->
<!--
This page explains how to configure out of resource handling with `kubelet`.

The `kubelet` needs to preserve node stability when available compute resources
are low. This is especially important when dealing with incompressible
compute resources, such as memory or disk space. If such resources are exhausted,
nodes become unstable.
-->
<p>本页介绍如何使用 <code>kubelet</code> 配置资源不足时的处理方式。</p>
<p>当可用计算资源较少时，<code>kubelet</code>需要保证节点稳定性。
这在处理如内存和硬盘之类的不可压缩资源时尤为重要。
如果任意一种资源耗尽，节点将会变得不稳定。</p>
<!-- body -->
<!--
### Eviction Signals

The `kubelet` supports eviction decisions based on the signals described in the following
table. The value of each signal is described in the Description column, which is based on
the `kubelet` summary API.
-->
<h3 id="驱逐信号">驱逐信号</h3>
<p><code>kubelet</code> 支持按照以下表格中描述的信号触发驱逐决定。
每个信号的值在 description 列描述，基于 <code>kubelet</code> 摘要 API。</p>
<!--
| Eviction Signal            | Description                                                         |
|----------------------------|---------------------------------------------------------------------|
| `memory.available` | `memory.available` := `node.status.capacity[memory]` - `node.stats.memory.workingSet` |
| `nodefs.available` | `nodefs.available` := `node.stats.fs.available` |
| `nodefs.inodesFree` | `nodefs.inodesFree` := `node.stats.fs.inodesFree` |
| `imagefs.available` | `imagefs.available` := `node.stats.runtime.imagefs.available` |
| `imagefs.inodesFree` | `imagefs.inodesFree` := `node.stats.runtime.imagefs.inodesFree` |
| `pid.available`      | `pid.available` := `node.stats.rlimit.maxpid` - `node.stats.rlimit.curproc`           |
-->
<table>
<thead>
<tr>
<th>驱逐信号</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>memory.available</code></td>
<td><code>memory.available</code> := <code>node.status.capacity[memory]</code> - <code>node.stats.memory.workingSet</code></td>
</tr>
<tr>
<td><code>nodefs.available</code></td>
<td><code>nodefs.available</code> := <code>node.stats.fs.available</code></td>
</tr>
<tr>
<td><code>nodefs.inodesFree</code></td>
<td><code>nodefs.inodesFree</code> := <code>node.stats.fs.inodesFree</code></td>
</tr>
<tr>
<td><code>imagefs.available</code></td>
<td><code>imagefs.available</code> := <code>node.stats.runtime.imagefs.available</code></td>
</tr>
<tr>
<td><code>imagefs.inodesFree</code></td>
<td><code>imagefs.inodesFree</code> := <code>node.stats.runtime.imagefs.inodesFree</code></td>
</tr>
<tr>
<td><code>pid.available</code></td>
<td><code>pid.available</code> := <code>node.stats.rlimit.maxpid</code> - <code>node.stats.rlimit.curproc</code></td>
</tr>
</tbody>
</table>
<!--
Each of the above signals supports either a literal or percentage based value.
The percentage based value is calculated relative to the total capacity
associated with each signal.
-->
<p>上面的每个信号都支持字面值或百分比的值。基于百分比的值的计算与每个信号对应的总容量相关。</p>
<!--
The value for `memory.available` is derived from the cgroupfs instead of tools
like `free -m`. This is important because `free -m` does not work in a
container, and if users use the [node
allocatable](/docs/tasks/administer-cluster/reserve-compute-resources/#node-allocatable) feature, out of resource decisions
are made local to the end user Pod part of the cgroup hierarchy as well as the
root node. This
[script](/examples/admin/resource/memory-available.sh)
reproduces the same set of steps that the `kubelet` performs to calculate
`memory.available`. The `kubelet` excludes inactive_file (i.e. # of bytes of
file-backed memory on inactive LRU list) from its calculation as it assumes that
memory is reclaimable under pressure.
-->
<p><code>memory.available</code> 的值从 cgroupfs 获取，而不是通过类似 <code>free -m</code> 的工具。
这很重要，因为 <code>free -m</code> 不能在容器中工作，并且如果用户使用了
<a href="/zh/docs/tasks/administer-cluster/reserve-compute-resources/#node-allocatable">节点可分配资源</a>
特性，资源不足的判定将同时在本地 cgroup 层次结构的终端用户 Pod 部分和根节点做出。
这个<a href="/zh/examples/admin/resource/memory-available.sh">脚本</a>
复现了与 <code>kubelet</code> 计算 <code>memory.available</code> 相同的步骤。
<code>kubelet</code> 将 <code>inactive_file</code>（意即活动 LRU 列表上基于文件后端的内存字节数）从计算中排除，
因为它假设内存在出现压力时将被回收。</p>
<!--
`kubelet` supports only two filesystem partitions.

1. The `nodefs` filesystem that kubelet uses for volumes, daemon logs, etc.
2. The `imagefs` filesystem that container runtimes uses for storing images and
   container writable layers.
-->
<p><code>kubelet</code> 只支持两种文件系统分区。</p>
<ol>
<li><code>nodefs</code> 文件系统，kubelet 将其用于卷和守护程序日志等。</li>
<li><code>imagefs</code> 文件系统，容器运行时用于保存镜像和容器可写层。</li>
</ol>
<!--
`imagefs` is optional. `kubelet` auto-discovers these filesystems using
cAdvisor. `kubelet` does not care about any other filesystems. Any other types
of configurations are not currently supported by the kubelet. For example, it is
*not OK* to store volumes and logs in a dedicated `filesystem`.

In future releases, the `kubelet` will deprecate the existing [garbage
collection](/docs/concepts/cluster-administration/kubelet-garbage-collection/)
support in favor of eviction in response to disk pressure.
-->
<p><code>imagefs</code> 可选。<code>kubelet</code> 使用 cAdvisor 自动发现这些文件系统。
<code>kubelet</code> 不关心其它文件系统。当前不支持配置任何其它类型。
例如，在专用 <code>filesytem</code> 中存储卷和日志是 <em>不可以</em> 的。</p>
<p>在将来的发布中，<code>kubelet</code>将废除当前存在的
<a href="/zh/docs/concepts/cluster-administration/kubelet-garbage-collection/">垃圾回收</a>
机制，这种机制目前支持将驱逐操作作为对磁盘压力的响应。</p>
<!--
### Eviction Thresholds

The `kubelet` supports the ability to specify eviction thresholds that trigger the `kubelet` to reclaim resources.

Each threshold has the following form:

`[eviction-signal][operator][quantity]`

where:

* `eviction-signal` is an eviction signal token as defined in the previous table.
* `operator` is the desired relational operator, such as `<` (less than).
* `quantity` is the eviction threshold quantity, such as `1Gi`. These tokens must
match the quantity representation used by Kubernetes. An eviction threshold can also
be expressed as a percentage using the `%` token.

For example, if a node has `10Gi` of total memory and you want trigger eviction if
the available memory falls below `1Gi`, you can define the eviction threshold as
either `memory.available<10%` or `memory.available<1Gi`. You cannot use both.
-->
<h3 id="驱逐阈值">驱逐阈值</h3>
<p><code>kubelet</code>支持指定驱逐阈值，用于触发 <code>kubelet</code> 回收资源。</p>
<p>每个阈值形式如下：</p>
<p><code>[eviction-signal][operator][quantity]</code></p>
<ul>
<li>合法的 <code>eviction-signal</code> 标志如上所示。</li>
<li><code>operator</code> 是所需的关系运算符，例如 <code>&lt;</code>。</li>
<li><code>quantity</code> 是驱逐阈值值标志，例如 <code>1Gi</code>。合法的标志必须匹配 Kubernetes 使用的数量表示。
驱逐阈值也可以使用 <code>%</code> 标记表示百分比。</li>
</ul>
<p>举例说明，如果一个节点有 <code>10Gi</code> 内存，希望在可用内存下降到 <code>1Gi</code> 以下时引起驱逐操作，
则驱逐阈值可以使用下面任意一种方式指定（但不是两者同时）。</p>
<ul>
<li><code>memory.available&lt;10%</code></li>
<li><code>memory.available&lt;1Gi</code></li>
</ul>
<!--
#### Soft Eviction Thresholds

A soft eviction threshold pairs an eviction threshold with a required
administrator-specified grace period. No action is taken by the `kubelet`
to reclaim resources associated with the eviction signal until that grace
period has been exceeded. If no grace period is provided, the `kubelet`
returns an error on startup.
-->
<h4 id="软驱逐阈值">软驱逐阈值</h4>
<p>软驱逐阈值使用一对由驱逐阈值和管理员必须指定的宽限期组成的配置对。在超过宽限期前，<code>kubelet</code>不会采取任何动作回收和驱逐信号关联的资源。如果没有提供宽限期，<code>kubelet</code>启动时将报错。</p>
<!--
In addition, if a soft eviction threshold has been met, an operator can
specify a maximum allowed Pod termination grace period to use when evicting
pods from the node. If specified, the `kubelet` uses the lesser value among
the `pod.Spec.TerminationGracePeriodSeconds` and the max allowed grace period.
If not specified, the `kubelet` kills Pods immediately with no graceful
termination.
-->
<p>此外，如果达到了软驱逐阈值，操作员可以指定从节点驱逐 pod 时，在宽限期内允许结束的 pod 的最大数量。
如果指定了 <code>pod.Spec.TerminationGracePeriodSeconds</code> 值，
<code>kubelet</code> 将使用它和宽限期二者中较小的一个。
如果没有指定，<code>kubelet</code>将立即终止 pod，而不会优雅结束它们。</p>
<!--
To configure soft eviction thresholds, the following flags are supported:

* `eviction-soft` describes a set of eviction thresholds (e.g. `memory.available<1.5Gi`) that if met over a
corresponding grace period would trigger a Pod eviction.
* `eviction-soft-grace-period` describes a set of eviction grace periods (e.g. `memory.available=1m30s`) that
correspond to how long a soft eviction threshold must hold before triggering a Pod eviction.
* `eviction-max-pod-grace-period` describes the maximum allowed grace period (in seconds) to use when terminating
pods in response to a soft eviction threshold being met.
-->
<p>软驱逐阈值的配置支持下列标记：</p>
<ul>
<li><code>eviction-soft</code> 描述了驱逐阈值的集合（例如 <code>memory.available&lt;1.5Gi</code>），如果在宽限期之外满足条件将触发 pod 驱逐。</li>
<li><code>eviction-soft-grace-period</code> 描述了驱逐宽限期的集合（例如 <code>memory.available=1m30s</code>），对应于在驱逐 pod 前软驱逐阈值应该被控制的时长。</li>
<li><code>eviction-max-pod-grace-period</code> 描述了当满足软驱逐阈值并终止 pod 时允许的最大宽限期值（秒数）。</li>
</ul>
<!--
#### Hard Eviction Thresholds

A hard eviction threshold has no grace period, and if observed, the `kubelet`
will take immediate action to reclaim the associated starved resource. If a
hard eviction threshold is met, the `kubelet` kills the Pod immediately
with no graceful termination.

To configure hard eviction thresholds, the following flag is supported:

* `eviction-hard` describes a set of eviction thresholds (e.g. `memory.available<1Gi`) that if met
would trigger a Pod eviction.

The `kubelet` has the following default hard eviction threshold:

* `memory.available<100Mi`
* `nodefs.available<10%`
* `imagefs.available<15%`

On a Linux node, the default value also includes `nodefs.inodesFree<5%`.

-->
<h4 id="硬驱逐阈值">硬驱逐阈值</h4>
<p>硬驱逐阈值没有宽限期，一旦察觉，<code>kubelet</code> 将立即采取行动回收关联的短缺资源。
如果满足硬驱逐阈值，<code>kubelet</code> 将立即结束 Pod 而不是体面地终止它们。</p>
<p>硬驱逐阈值的配置支持下列标记：</p>
<ul>
<li><code>eviction-hard</code> 描述了驱逐阈值的集合（例如 <code>memory.available&lt;1Gi</code>），如果满足条件将触发 Pod 驱逐。</li>
</ul>
<p><code>kubelet</code> 有如下所示的默认硬驱逐阈值：</p>
<ul>
<li><code>memory.available&lt;100Mi</code></li>
<li><code>nodefs.available&lt;10%</code></li>
<li><code>imagefs.available&lt;15%</code></li>
</ul>
<p>在Linux节点上，默认值还包括 <code>nodefs.inodesFree&lt;5％</code>。</p>
<!--
### Eviction Monitoring Interval

The `kubelet` evaluates eviction thresholds per its configured housekeeping interval.

* `housekeeping-interval` is the interval between container housekeepings.
-->
<h3 id="驱逐监控时间间隔">驱逐监控时间间隔</h3>
<p><code>kubelet</code> 根据其配置的整理时间间隔计算驱逐阈值。</p>
<ul>
<li><code>housekeeping-interval</code> 是容器管理时间间隔。</li>
</ul>
<!--
### Node Conditions

The `kubelet` maps one or more eviction signals to a corresponding node condition.

If a hard eviction threshold has been met, or a soft eviction threshold has been met
independent of its associated grace period, the `kubelet` reports a condition that
reflects the node is under pressure.
-->
<h3 id="节点状态">节点状态</h3>
<p><code>kubelet</code> 会将一个或多个驱逐信号映射到对应的节点状态。</p>
<p>如果满足硬驱逐阈值，或者满足独立于其关联宽限期的软驱逐阈值时，<code>kubelet</code>将报告节点处于压力下的状态。</p>
<!--
The following node conditions are defined that correspond to the specified eviction signal.

| Node Condition | Eviction Signal  | Description                                                      |
|-------------------------|-------------------------------|--------------------------------------------|
| `MemoryPressure` | `memory.available` | Available memory on the node has satisfied an eviction threshold |
| `DiskPressure` | `nodefs.available`, `nodefs.inodesFree`, `imagefs.available`, or `imagefs.inodesFree` | Available disk space and inodes on either the node's root filesystem or image filesystem has satisfied an eviction threshold |
| `PIDPressure`     | `pid.available`                                                                       | Available processes identifiers on the (Linux) node has fallen below an eviction threshold                                   |   

The `kubelet` continues to report node status updates at the frequency specified by
`--node-status-update-frequency` which defaults to `10s`.
-->
<p>下列节点状态根据相应的驱逐信号定义。</p>
<table>
<thead>
<tr>
<th>节点状态</th>
<th>驱逐信号</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>MemoryPressure</code></td>
<td><code>memory.available</code></td>
<td>节点上可用内存量达到逐出阈值</td>
</tr>
<tr>
<td><code>DiskPressure</code></td>
<td><code>nodefs.available</code>, <code>nodefs.inodesFree</code>, <code>imagefs.available</code>, 或 <code>imagefs.inodesFree</code></td>
<td>节点或者节点的根文件系统或镜像文件系统上可用磁盘空间和 i 节点个数达到逐出阈值</td>
</tr>
<tr>
<td><code>PIDPressure</code></td>
<td><code>pid.available</code></td>
<td>在（Linux）节点上的可用进程标识符已降至驱逐阈值以下</td>
</tr>
</tbody>
</table>
<p><code>kubelet</code> 将以 <code>--node-status-update-frequency</code> 指定的频率连续报告节点状态更新，其默认值为 <code>10s</code>。</p>
<!--
### Oscillation of node conditions

If a node is oscillating above and below a soft eviction threshold, but not exceeding
its associated grace period, it would cause the corresponding node condition to
constantly oscillate between true and false, and could cause poor scheduling decisions
as a consequence.

To protect against this oscillation, the following flag is defined to control how
long the `kubelet` must wait before transitioning out of a pressure condition.

* `eviction-pressure-transition-period` is the duration for which the `kubelet` has
to wait before transitioning out of an eviction pressure condition.

The `kubelet` would ensure that it has not observed an eviction threshold being met
for the specified pressure condition for the period specified before toggling the
condition back to `false`.
-->
<h3 id="节点状态振荡">节点状态振荡</h3>
<p>如果节点在软驱逐阈值的上下振荡，但没有超过关联的宽限期时，将引起对应节点的状态持续在
true 和 false 间跳变，并导致不好的调度结果。</p>
<p>为了防止这种振荡，可以定义下面的标志，用于控制 <code>kubelet</code> 从压力状态中退出之前必须等待的时间。</p>
<ul>
<li><code>eviction-pressure-transition-period</code> 是 <code>kubelet</code> 从压力状态中退出之前必须等待的时长。</li>
</ul>
<p><code>kubelet</code> 将确保在设定的时间段内没有发现和指定压力条件相对应的驱逐阈值被满足时，才会将状态变回 <code>false</code>。</p>
<!--
### Reclaiming node level resources

If an eviction threshold has been met and the grace period has passed,
the `kubelet` initiates the process of reclaiming the pressured resource
until it has observed the signal has gone below its defined threshold.

The `kubelet` attempts to reclaim node level resources prior to evicting end-user Pods. If
disk pressure is observed, the `kubelet` reclaims node level resources differently if the
machine has a dedicated `imagefs` configured for the container runtime.
-->
<h3 id="回收节点层级资源">回收节点层级资源</h3>
<p>如果满足驱逐阈值并超过了宽限期，<code>kubelet</code>将启动回收压力资源的过程，直到它发现低于设定阈值的信号为止。</p>
<p><code>kubelet</code> 将尝试在驱逐终端用户 pod 前回收节点层级资源。
发现磁盘压力时，如果节点针对容器运行时配置有独占的 <code>imagefs</code>，<code>kubelet</code>回收节点层级资源的方式将会不同。</p>
<!--
#### With `imagefs`

If `nodefs` filesystem has met eviction thresholds, `kubelet` frees up disk space by deleting the dead Pods and their containers.

If `imagefs` filesystem has met eviction thresholds, `kubelet` frees up disk space by deleting all unused images.

#### Without `imagefs`

If `nodefs` filesystem has met eviction thresholds, `kubelet` frees up disk space in the following order:

1. Delete dead Pods and their containers
2. Delete all unused images
-->
<h4 id="使用-imagefs">使用 <code>imagefs</code></h4>
<p>如果 <code>nodefs</code> 文件系统满足驱逐阈值，<code>kubelet</code>通过驱逐 pod 及其容器来释放磁盘空间。</p>
<p>如果 <code>imagefs</code> 文件系统满足驱逐阈值，<code>kubelet</code>通过删除所有未使用的镜像来释放磁盘空间。</p>
<h4 id="未使用-imagefs">未使用 <code>imagefs</code></h4>
<p>如果 <code>nodefs</code> 满足驱逐阈值，<code>kubelet</code>将以下面的顺序释放磁盘空间：</p>
<ol>
<li>删除停止运行的 pod/container</li>
<li>删除全部没有使用的镜像</li>
</ol>
<!--
### Evicting end-user Pods

If the `kubelet` is unable to reclaim sufficient resource on the node, `kubelet` begins evicting Pods.

The `kubelet` ranks Pods for eviction first by whether or not their usage of the starved resource exceeds requests,
then by [Priority](/docs/concepts/configuration/pod-priority-preemption/), and then by the consumption of the starved compute resource relative to the Pods' scheduling requests.

-->
<h3 id="驱逐最终用户的-pod">驱逐最终用户的 pod</h3>
<p>如果 <code>kubelet</code> 在节点上无法回收足够的资源，<code>kubelet</code>将开始驱逐 pod。</p>
<p><code>kubelet</code> 首先根据他们对短缺资源的使用是否超过请求来排除 pod 的驱逐行为，
然后通过<a href="/zh/docs/concepts/configuration/pod-priority-preemption/">优先级</a>，
然后通过相对于 pod 的调度请求消耗急需的计算资源。</p>
<!--
As a result, `kubelet` ranks and evicts Pods in the following order:

* `BestEffort` or `Burstable` Pods whose usage of a starved resource exceeds its request.
Such pods are ranked by Priority, and then usage above request.
* `Guaranteed` pods and `Burstable` pods whose usage is beneath requests are evicted last.
`Guaranteed` Pods are guaranteed only when requests and limits are specified for all
the containers and they are equal. Such pods are guaranteed to never be evicted because
of another Pod's resource consumption. If a system daemon (such as `kubelet`, `docker`,
and `journald`) is consuming more resources than were reserved via `system-reserved` or
`kube-reserved` allocations, and the node only has `Guaranteed` or `Burstable` Pods using
less than requests remaining, then the node must choose to evict such a Pod in order to
preserve node stability and to limit the impact of the unexpected consumption to other Pods.
In this case, it will choose to evict pods of Lowest Priority first.
-->
<p><code>kubelet</code> 按以下顺序对要驱逐的 pod 排名：</p>
<ul>
<li><code>BestEffort</code> 或 <code>Burstable</code>，其对短缺资源的使用超过了其请求，此类 pod 按优先级排序，然后使用高于请求。</li>
<li><code>Guaranteed</code> pod 和 <code>Burstable</code> pod，其使用率低于请求，最后被驱逐。
<code>Guaranteed</code> Pod 只有为所有的容器指定了要求和限制并且它们相等时才能得到保证。
由于另一个 Pod 的资源消耗，这些 Pod 保证永远不会被驱逐。
如果系统守护进程（例如 <code>kubelet</code>、<code>docker</code>、和 <code>journald</code>）消耗的资源多于通过
<code>system-reserved</code> 或 <code>kube-reserved</code> 分配保留的资源，并且该节点只有 <code>Guaranteed</code> 或
<code>Burstable</code> Pod 使用少于剩余的请求，然后节点必须选择驱逐这样的 Pod
以保持节点的稳定性并限制意外消耗对其他 pod 的影响。
在这种情况下，它将首先驱逐优先级最低的 pod。</li>
</ul>
<!--
If necessary, `kubelet` evicts Pods one at a time to reclaim disk when `DiskPressure`
is encountered. If the `kubelet` is responding to `inode` starvation, it reclaims
`inodes` by evicting Pods with the lowest quality of service first. If the `kubelet`
is responding to lack of available disk, it ranks Pods within a quality of service
that consumes the largest amount of disk and kill those first.
-->
<p>必要时，<code>kubelet</code>会在遇到 <code>DiskPressure</code> 时逐个驱逐 Pod 来回收磁盘空间。
如果 <code>kubelet</code> 响应 <code>inode</code> 短缺，它会首先驱逐服务质量最低的 Pod 来回收 <code>inodes</code>。
如果 <code>kubelet</code> 响应缺少可用磁盘，它会将 Pod 排在服务质量范围内，该服务会消耗大量的磁盘并首先结束这些磁盘。</p>
<!--
#### With `imagefs`

If `nodefs` is triggering evictions, `kubelet` sorts Pods based on the usage on `nodefs`
- local volumes + logs of all its containers.

If `imagefs` is triggering evictions, `kubelet` sorts Pods based on the writable layer usage of all its containers.

#### Without `imagefs`

If `nodefs` is triggering evictions, `kubelet` sorts Pods based on their total disk usage
- local volumes + logs & writable layer of all its containers.
-->
<h4 id="使用-imagefs-1">使用 <code>imagefs</code></h4>
<p>如果是 <code>nodefs</code> 触发驱逐，<code>kubelet</code>将按 <code>nodefs</code> 用量 - 本地卷 + pod 的所有容器日志的总和对其排序。</p>
<p>如果是 <code>imagefs</code> 触发驱逐，<code>kubelet</code>将按 pod 所有可写层的用量对其进行排序。</p>
<h4 id="未使用-imagefs-1">未使用 <code>imagefs</code></h4>
<p>如果是 <code>nodefs</code> 触发驱逐，<code>kubelet</code>会根据磁盘的总使用情况对 pod 进行排序 - 本地卷 + 所有容器的日志及其可写层。</p>
<!--
### Minimum eviction reclaim

In certain scenarios, eviction of Pods could result in reclamation of small amount of resources. This can result in
`kubelet` hitting eviction thresholds in repeated successions. In addition to that, eviction of resources like `disk`,
 is time consuming.
-->
<h3 id="最小驱逐回收">最小驱逐回收</h3>
<p>在某些场景，驱逐 pod 会导致回收少量资源。这将导致 <code>kubelet</code> 反复碰到驱逐阈值。除此之外，对如 <code>disk</code> 这类资源的驱逐时比较耗时的。</p>
<!--
To mitigate these issues, `kubelet` can have a per-resource `minimum-reclaim`. Whenever `kubelet` observes
resource pressure, `kubelet` attempts to reclaim at least `minimum-reclaim` amount of resource below
the configured eviction threshold.

For example, with the following configuration:
-->
<p>为了减少这类问题，<code>kubelet</code>可以为每个资源配置一个 <code>minimum-reclaim</code>。
当 <code>kubelet</code> 发现资源压力时，<code>kubelet</code>将尝试至少回收驱逐阈值之下 <code>minimum-reclaim</code> 数量的资源。</p>
<p>例如使用下面的配置：</p>
<pre tabindex="0"><code>--eviction-hard=memory.available&lt;500Mi,nodefs.available&lt;1Gi,imagefs.available&lt;100Gi
--eviction-minimum-reclaim=&quot;memory.available=0Mi,nodefs.available=500Mi,imagefs.available=2Gi&quot;`
</code></pre><!--
If an eviction threshold is triggered for `memory.available`, the `kubelet` works to ensure
that `memory.available` is at least `500Mi`. For `nodefs.available`, the `kubelet` works
to ensure that `nodefs.available` is at least `1.5Gi`, and for `imagefs.available` it
works to ensure that `imagefs.available` is at least `102Gi` before no longer reporting pressure
on their associated resources.

The default `eviction-minimum-reclaim` is `0` for all resources.
-->
<p>如果 <code>memory.available</code> 驱逐阈值被触发，<code>kubelet</code> 将保证 <code>memory.available</code> 至少为 <code>500Mi</code>。
对于 <code>nodefs.available</code>，<code>kubelet</code> 将保证 <code>nodefs.available</code> 至少为 <code>1.5Gi</code>。
对于 <code>imagefs.available</code>，<code>kubelet</code> 将保证 <code>imagefs.available</code> 至少为 <code>102Gi</code>，
直到不再有相关资源报告压力为止。</p>
<p>所有资源的默认 <code>eviction-minimum-reclaim</code> 值为 <code>0</code>。</p>
<!--
### Scheduler

The node reports a condition when a compute resource is under pressure. The
scheduler views that condition as a signal to dissuade placing additional
pods on the node.

| Node Condition    | Scheduler Behavior                               |
| ---------------- | ------------------------------------------------ |
| `MemoryPressure` | No new `BestEffort` Pods are scheduled to the node. |
| `DiskPressure` | No new Pods are scheduled to the node. |
-->
<h3 id="调度器">调度器</h3>
<p>当资源处于压力之下时，节点将报告状态。调度器将那种状态视为一种信号，阻止更多 pod 调度到这个节点上。</p>
<table>
<thead>
<tr>
<th>节点状态</th>
<th>调度器行为</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>MemoryPressure</code></td>
<td>新的 <code>BestEffort</code> Pod 不会被调度到该节点</td>
</tr>
<tr>
<td><code>DiskPressure</code></td>
<td>没有新的 Pod 会被调度到该节点</td>
</tr>
</tbody>
</table>
<!--
## Node OOM Behavior

If the node experiences a system OOM (out of memory) event prior to the `kubelet` is able to reclaim memory,
the node depends on the [oom_killer](https://lwn.net/Articles/391222/) to respond.

The `kubelet` sets a `oom_score_adj` value for each container based on the quality of service for the Pod.
-->
<h2 id="节点-oom-行为">节点 OOM 行为</h2>
<p>如果节点在 <code>kubelet</code> 回收内存之前经历了系统 OOM（内存不足）事件，它将基于
<a href="https://lwn.net/Articles/391222/">oom-killer</a> 做出响应。</p>
<p><code>kubelet</code> 基于 pod 的 service 质量为每个容器设置一个 <code>oom_score_adj</code> 值。</p>
<!--
| Quality of Service | oom_score_adj |
|----------------------------|-----------------------------------------------------------------------|
| `Guaranteed` | -998 |
| `BestEffort` | 1000 |
| `Burstable` | min(max(2, 1000 - (1000 * memoryRequestBytes) / machineMemoryCapacityBytes), 999) |
-->
<table>
<thead>
<tr>
<th>Service 质量</th>
<th>oom_score_adj</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Guaranteed</code></td>
<td>-998</td>
</tr>
<tr>
<td><code>BestEffort</code></td>
<td>1000</td>
</tr>
<tr>
<td><code>Burstable</code></td>
<td>min(max(2, 1000 - (1000 * memoryRequestBytes) / machineMemoryCapacityBytes), 999)</td>
</tr>
</tbody>
</table>
<!--
If the `kubelet` is unable to reclaim memory prior to a node experiencing system OOM, the `oom_killer` calculates
an `oom_score` based on the percentage of memory it's using on the node, and then add the `oom_score_adj` to get an
effective `oom_score` for the container, and then kills the container with the highest score.

The intended behavior should be that containers with the lowest quality of service that
are consuming the largest amount of memory relative to the scheduling request should be killed first in order
to reclaim memory.

Unlike Pod eviction, if a Pod container is OOM killed, it may be restarted by the `kubelet` based on its `RestartPolicy`.
-->
<p>如果 <code>kubelet</code> 在节点经历系统 OOM 之前无法回收内存，<code>oom_killer</code> 将基于它在节点上
使用的内存百分比算出一个 <code>oom_score</code>，并加上 <code>oom_score_adj</code> 得到容器的有效
<code>oom_score</code>，然后结束得分最高的容器。</p>
<p>预期的行为应该是拥有最低服务质量并消耗和调度请求相关内存量最多的容器第一个被结束，以回收内存。</p>
<p>和 pod 驱逐不同，如果一个 Pod 的容器是被 OOM 结束的，基于其 <code>RestartPolicy</code>，
它可能会被 <code>kubelet</code> 重新启动。</p>
<!--
## Best Practices

The following sections describe best practices for out of resource handling.

### Schedulable resources and eviction policies

Consider the following scenario:

* Node memory capacity: `10Gi`
* Operator wants to reserve 10% of memory capacity for system daemons (kernel, `kubelet`, etc.)
* Operator wants to evict Pods at 95% memory utilization to reduce incidence of system OOM.

To facilitate this scenario, the `kubelet` would be launched as follows:
-->
<h2 id="最佳实践">最佳实践</h2>
<p>以下部分描述了资源外处理的最佳实践。</p>
<h3 id="可调度资源和驱逐策略">可调度资源和驱逐策略</h3>
<p>考虑以下场景：</p>
<ul>
<li>节点内存容量：<code>10Gi</code></li>
<li>操作员希望为系统守护进程保留 10% 内存容量（内核、<code>kubelet</code>等）。</li>
<li>操作员希望在内存用量达到 95% 时驱逐 pod，以减少对系统的冲击并防止系统 OOM 的发生。</li>
</ul>
<p>为了促成这个场景，<code>kubelet</code>将像下面这样启动：</p>
<pre tabindex="0"><code>--eviction-hard=memory.available&lt;500Mi
--system-reserved=memory=1.5Gi
</code></pre><!--
Implicit in this configuration is the understanding that "System reserved" should include the amount of memory
covered by the eviction threshold.

To reach that capacity, either some Pod is using more than its request, or the system is using more than `1.5Gi - 500Mi = 1Gi`.

This configuration ensures that the scheduler does not place Pods on a node that immediately induce memory pressure
and trigger eviction assuming those Pods use less than their configured request.
-->
<p>这个配置的暗示是理解系统保留应该包含被驱逐阈值覆盖的内存数量。</p>
<p>要达到这个容量，要么某些 pod 使用了超过它们请求的资源，要么系统使用的内存超过 <code>1.5Gi - 500Mi = 1Gi</code>。</p>
<p>这个配置将保证在 pod 使用量都不超过它们配置的请求值时，如果可能立即引起内存压力并触发驱逐时，调度器不会将 pod 放到这个节点上。</p>
<!--
### DaemonSet

It is never desired for `kubelet` to evict a `DaemonSet` Pod, since the Pod is
immediately recreated and rescheduled back to the same node.

At the moment, the `kubelet` has no ability to distinguish a Pod created
from `DaemonSet` versus any other object. If/when that information is
available, the `kubelet` could pro-actively filter those Pods from the
candidate set of Pods provided to the eviction strategy.

In general, it is strongly recommended that `DaemonSet` not
create `BestEffort` Pods to avoid being identified as a candidate Pod
for eviction. Instead `DaemonSet` should ideally launch `Guaranteed` Pods.
-->
<h3 id="daemonset">DaemonSet</h3>
<p>我们永远都不希望 <code>kubelet</code> 驱逐一个从 <code>DaemonSet</code> 派生的 Pod，因为这个 Pod 将立即被重建并调度回相同的节点。</p>
<p>目前，<code>kubelet</code>没有办法区分一个 Pod 是由 <code>DaemonSet</code> 还是其他对象创建。
如果/当这个信息可用时，<code>kubelet</code> 可能会预先将这些 pod 从提供给驱逐策略的候选集合中过滤掉。</p>
<p>总之，强烈推荐 <code>DaemonSet</code> 不要创建 <code>BestEffort</code> 的 Pod，防止其被识别为驱逐的候选 Pod。
相反，理想情况下 <code>DaemonSet</code> 应该启动 <code>Guaranteed</code> 的 pod。</p>
<!--
## Deprecation of existing feature flags to reclaim disk

`kubelet` has been freeing up disk space on demand to keep the node stable.

As disk based eviction matures, the following `kubelet` flags are marked for deprecation
in favor of the simpler configuration supported around eviction.
-->
<h2 id="现有的回收磁盘特性标签已被弃用">现有的回收磁盘特性标签已被弃用</h2>
<p><code>kubelet</code> 已经按需求清空了磁盘空间以保证节点稳定性。</p>
<p>当磁盘驱逐成熟时，下面的 <code>kubelet</code> 标志将被标记为废弃的，以简化支持驱逐的配置。</p>
<!--
| Existing Flag | New Flag |
| ------------- | -------- |
| `--image-gc-high-threshold` | `--eviction-hard` or `eviction-soft` |
| `--image-gc-low-threshold` | `--eviction-minimum-reclaim` |
| `--maximum-dead-containers` | deprecated |
| `--maximum-dead-containers-per-container` | deprecated |
| `--minimum-container-ttl-duration` | deprecated |
| `--low-diskspace-threshold-mb` | `--eviction-hard` or `eviction-soft` |
| `--outofdisk-transition-frequency` | `--eviction-pressure-transition-period` |
-->
<table>
<thead>
<tr>
<th>现有标签</th>
<th>新标签</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>--image-gc-high-threshold</code></td>
<td><code>--eviction-hard</code> or <code>eviction-soft</code></td>
</tr>
<tr>
<td><code>--image-gc-low-threshold</code></td>
<td><code>--eviction-minimum-reclaim</code></td>
</tr>
<tr>
<td><code>--maximum-dead-containers</code></td>
<td>deprecated</td>
</tr>
<tr>
<td><code>--maximum-dead-containers-per-container</code></td>
<td>deprecated</td>
</tr>
<tr>
<td><code>--minimum-container-ttl-duration</code></td>
<td>deprecated</td>
</tr>
<tr>
<td><code>--low-diskspace-threshold-mb</code></td>
<td><code>--eviction-hard</code> or <code>eviction-soft</code></td>
</tr>
<tr>
<td><code>--outofdisk-transition-frequency</code></td>
<td><code>--eviction-pressure-transition-period</code></td>
</tr>
</tbody>
</table>
<!--
## Known issues

The following sections describe known issues related to out of resource handling.
-->
<h2 id="已知问题">已知问题</h2>
<p>以下部分描述了与资源外处理有关的已知问题。</p>
<!--
### kubelet may not observe memory pressure right away

The `kubelet` currently polls `cAdvisor` to collect memory usage stats at a regular interval. If memory usage
increases within that window rapidly, the `kubelet` may not observe `MemoryPressure` fast enough, and the `OOMKiller`
will still be invoked. We intend to integrate with the `memcg` notification API in a future release to reduce this
latency, and instead have the kernel tell us when a threshold has been crossed immediately.
-->
<h3 id="kubelet-可能无法立即发现内存压力">kubelet 可能无法立即发现内存压力</h3>
<p><code>kubelet</code>当前通过以固定的时间间隔轮询 <code>cAdvisor</code> 来收集内存使用数据。如果内存使用在那个时间窗口内迅速增长，<code>kubelet</code>可能不能足够快的发现 <code>MemoryPressure</code>，<code>OOMKiller</code>将不会被调用。我们准备在将来的发行版本中通过集成 <code>memcg</code> 通知 API 来减小这种延迟。当超过阈值时，内核将立即告诉我们。</p>
<!--
If you are not trying to achieve extreme utilization, but a sensible measure of overcommit, a viable workaround for
this issue is to set eviction thresholds at approximately 75% capacity. This increases the ability of this feature
to prevent system OOMs, and promote eviction of workloads so cluster state can rebalance.
-->
<p>如果您想处理可察觉的超量使用而不要求极端精准，可以设置驱逐阈值为大约 75% 容量作为这个问题的变通手段。这将增强这个特性的能力，防止系统 OOM，并提升负载卸载能力，以再次平衡集群状态。</p>
<!--
### kubelet may evict more Pods than needed

The Pod eviction may evict more Pods than needed due to stats collection timing gap. This can be mitigated by adding
the ability to get root container stats on an on-demand basis [(https://github.com/google/cadvisor/issues/1247)](https://github.com/google/cadvisor/issues/1247) in the future.
-->
<h3 id="kubelet-可能会驱逐超过需求数量的-pod">kubelet 可能会驱逐超过需求数量的 pod</h3>
<p>由于状态采集的时间差，驱逐操作可能驱逐比所需的更多的 pod。将来可通过添加从根容器获取所需状态的能力
<a href="https://github.com/google/cadvisor/issues/1247">https://github.com/google/cadvisor/issues/1247</a>
来减缓这种状况。</p>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-a02f35804917d7a269c38d7e2c475005">41 - 限制存储消耗</h1>
    
	<!--
title: Limit Storage Consumption
content_type: task
-->
<!-- overview -->
<!--
This example demonstrates how to limit the amount of storage consumed in a namespace
-->
<p>此示例演示了如何限制一个名字空间中的存储使用量。</p>
<!--
The following resources are used in the demonstration: [ResourceQuota](/docs/concepts/policy/resource-quotas/),
[LimitRange](/docs/tasks/administer-cluster/memory-default-namespace/),
and [PersistentVolumeClaim](/docs/concepts/storage/persistent-volumes/).
-->
<p>演示中用到了以下资源：<a href="/zh/docs/concepts/policy/resource-quotas/">ResourceQuota</a>，
<a href="/zh/docs/tasks/administer-cluster/manage-resources/memory-default-namespace/">LimitRange</a> 和
<a href="/zh/docs/concepts/storage/persistent-volumes/">PersistentVolumeClaim</a>。</p>
<h2 id="准备开始">准备开始</h2>
<ul>
<li><p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
如果你还没有集群，你可以通过 <a href="/zh/docs/tasks/tools/#minikube">Minikube</a> 构建一
个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p>
<!--
You need to have a Kubernetes cluster, and the kubectl command-line tool must
be configured to communicate with your cluster. If you do not already have a
cluster, you can create one by using
[minikube](/docs/tasks/tools/#minikube)
or you can use one of these Kubernetes playgrounds:
-->
<ul>
<li><a href="https://www.katacoda.com/courses/kubernetes/playground">Katacoda</a></li>
<li><a href="http://labs.play-with-k8s.com/">玩转 Kubernetes</a></li>
</ul>
 
 要获知版本信息，请输入 <code>kubectl version</code>.
</li>
</ul>
<!-- steps -->
<!--
## Scenario: Limiting Storage Consumption
-->
<h2 id="场景-限制存储消耗">场景：限制存储消耗</h2>
<!--
The cluster-admin is operating a cluster on behalf of a user population and the admin wants to control
how much storage a single namespace can consume in order to control cost.
-->
<p>集群管理员代表用户群操作集群，管理员希望控制单个名称空间可以消耗多少存储空间以控制成本。</p>
<!--
The admin would like to limit:
-->
<p>管理员想要限制：</p>
<!--
1. The number of persistent volume claims in a namespace
2. The amount of storage each claim can request
3. The amount of cumulative storage the namespace can have
-->
<ol>
<li>名字空间中持久卷申领（persistent volume claims）的数量</li>
<li>每个申领（claim）可以请求的存储量</li>
<li>名字空间可以具有的累计存储量</li>
</ol>
<!--
## LimitRange to limit requests for storage
-->
<h2 id="使用-limitrange-限制存储请求">使用 LimitRange 限制存储请求</h2>
<!--
Adding a `LimitRange` to a namespace enforces storage request sizes to a minimum and maximum. Storage is requested via `PersistentVolumeClaim`. The admission controller that enforces limit ranges will reject any PVC that is above or below the values set by the admin.
-->
<p>将 <code>LimitRange</code> 添加到名字空间会为存储请求大小强制设置最小值和最大值。
存储是通过 <code>PersistentVolumeClaim</code> 来发起请求的。
执行限制范围控制的准入控制器会拒绝任何高于或低于管理员所设阈值的 PVC。</p>
<!--
In this example, a PVC requesting 10Gi of storage would be rejected because it exceeds the 2Gi max.
-->
<p>在此示例中，请求 10Gi 存储的 PVC 将被拒绝，因为它超过了最大 2Gi。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>LimitRange<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>storagelimits<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">spec</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">limits</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- <span style="color:#008000;font-weight:bold">type</span>:<span style="color:#bbb"> </span>PersistentVolumeClaim<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">max</span>:<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">storage</span>:<span style="color:#bbb"> </span>2Gi<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">min</span>:<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">storage</span>:<span style="color:#bbb"> </span>1Gi<span style="color:#bbb">
</span></code></pre></div><!--
Minimum storage requests are used when the underlying storage provider requires certain minimums. For example,
AWS EBS volumes have a 1Gi minimum requirement.
-->
<p>当底层存储提供程序需要某些最小值时，将会用到所设置最小存储请求值。
例如，AWS EBS volumes 的最低要求为 1Gi。</p>
<!--
## StorageQuota to limit PVC count and cumulative storage capacity
-->
<h2 id="使用-storagequota-限制-pvc-数目和累计存储容量">使用 StorageQuota 限制 PVC 数目和累计存储容量</h2>
<!--
Admins can limit the number of PVCs in a namespace as well as the cumulative capacity of those PVCs. New PVCs that exceed
either maximum value will be rejected.
-->
<p>管理员可以限制某个名字空间中的 PVCs 个数以及这些 PVCs 的累计容量。
新 PVCs 请求如果超过任一上限值将被拒绝。</p>
<!--
In this example, a 6th PVC in the namespace would be rejected because it exceeds the maximum count of 5. Alternatively,
a 5Gi maximum quota when combined with the 2Gi max limit above, cannot have 3 PVCs where each has 2Gi. That would be 6Gi requested
 for a namespace capped at 5Gi.
-->
<p>在此示例中，名字空间中的第 6 个 PVC 将被拒绝，因为它超过了最大计数 5。
或者，当与上面的 2Gi 最大容量限制结合在一起时，意味着 5Gi 的最大配额
不能支持 3 个都是 2Gi 的 PVC。
后者实际上是向名字空间请求 6Gi 容量，而该命令空间已经设置上限为 5Gi。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>ResourceQuota<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>storagequota<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">spec</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">hard</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">persistentvolumeclaims</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;5&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">requests.storage</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;5Gi&#34;</span><span style="color:#bbb">
</span></code></pre></div><!-- discussion -->
<!--
## Summary

A limit range can put a ceiling on how much storage is requested while a resource quota can effectively cap the storage consumed by a namespace through claim counts and cumulative storage capacity. The allows a cluster-admin to plan their
cluster's storage budget without risk of any one project going over their allotment.
-->
<h2 id="小结">小结</h2>
<p>限制范围对象可以用来设置可请求的存储量上限，而资源配额对象则可以通过申领计数和
累计存储容量有效地限制名字空间耗用的存储量。
这两种机制使得集群管理员能够规划其集群存储预算而不会发生任一项目超量分配的风险。</p>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-6b4e7ca6586f448c8533a120c29bdd25">42 - 静态加密 Secret 数据</h1>
    
	<!--
reviewers:
- smarterclayton
title: Encrypting Secret Data at Rest
content_type: task
-->
<!-- overview -->
<!--
This page shows how to enable and configure encryption of secret data at rest.
-->
<p>本文展示如何启用和配置静态 Secret 数据的加密</p>
<h2 id="准备开始">准备开始</h2>
<ul>
<li><p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
如果你还没有集群，你可以通过 <a href="/zh/docs/tasks/tools/#minikube">Minikube</a> 构建一
个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p>
<!--
You need to have a Kubernetes cluster, and the kubectl command-line tool must
be configured to communicate with your cluster. If you do not already have a
cluster, you can create one by using
[minikube](/docs/tasks/tools/#minikube)
or you can use one of these Kubernetes playgrounds:
-->
<ul>
<li><a href="https://www.katacoda.com/courses/kubernetes/playground">Katacoda</a></li>
<li><a href="http://labs.play-with-k8s.com/">玩转 Kubernetes</a></li>
</ul>
 
 要获知版本信息，请输入 <code>kubectl version</code>.
</li>
</ul>
<!--
* etcd v3 or later is required
-->
<ul>
<li>需要 etcd v3 或者更高版本</li>
</ul>
<!-- steps -->
<!--
## Configuration and determining whether encryption at rest is already enabled

The `kube-apiserver` process accepts an argument `-experimental-encryption-provider-config`
that controls how API data is encrypted in etcd. An example configuration
is provided below.

## Understanding the encryption at rest configuration.
-->
<h2 id="配置并确定是否已启用静态数据加密">配置并确定是否已启用静态数据加密</h2>
<p><code>kube-apiserver</code> 的参数 <code>--experimental-encryption-provider-config</code> 控制 API 数据在 etcd 中的加密方式。
下面提供一个配置示例。</p>
<h2 id="理解静态数据加密">理解静态数据加密</h2>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>apiserver.config.k8s.io/v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>EncryptionConfiguration<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">resources</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- <span style="color:#008000;font-weight:bold">resources</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span>- secrets<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">providers</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span>- <span style="color:#008000;font-weight:bold">identity</span>:<span style="color:#bbb"> </span>{}<span style="color:#bbb">
</span><span style="color:#bbb">    </span>- <span style="color:#008000;font-weight:bold">aesgcm</span>:<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#008000;font-weight:bold">keys</span>:<span style="color:#bbb">
</span><span style="color:#bbb">        </span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>key1<span style="color:#bbb">
</span><span style="color:#bbb">          </span><span style="color:#008000;font-weight:bold">secret</span>:<span style="color:#bbb"> </span>c2VjcmV0IGlzIHNlY3VyZQ==<span style="color:#bbb">
</span><span style="color:#bbb">        </span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>key2<span style="color:#bbb">
</span><span style="color:#bbb">          </span><span style="color:#008000;font-weight:bold">secret</span>:<span style="color:#bbb"> </span>dGhpcyBpcyBwYXNzd29yZA==<span style="color:#bbb">
</span><span style="color:#bbb">    </span>- <span style="color:#008000;font-weight:bold">aescbc</span>:<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#008000;font-weight:bold">keys</span>:<span style="color:#bbb">
</span><span style="color:#bbb">        </span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>key1<span style="color:#bbb">
</span><span style="color:#bbb">          </span><span style="color:#008000;font-weight:bold">secret</span>:<span style="color:#bbb"> </span>c2VjcmV0IGlzIHNlY3VyZQ==<span style="color:#bbb">
</span><span style="color:#bbb">        </span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>key2<span style="color:#bbb">
</span><span style="color:#bbb">          </span><span style="color:#008000;font-weight:bold">secret</span>:<span style="color:#bbb"> </span>dGhpcyBpcyBwYXNzd29yZA==<span style="color:#bbb">
</span><span style="color:#bbb">    </span>- <span style="color:#008000;font-weight:bold">secretbox</span>:<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#008000;font-weight:bold">keys</span>:<span style="color:#bbb">
</span><span style="color:#bbb">        </span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>key1<span style="color:#bbb">
</span><span style="color:#bbb">          </span><span style="color:#008000;font-weight:bold">secret</span>:<span style="color:#bbb"> </span>YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTY=<span style="color:#bbb">
</span></code></pre></div><!--
Each `resources` array item is a separate config and contains a complete configuration. The
`resources.resources` field is an array of Kubernetes resource names (`resource` or `resource.group`)
that should be encrypted. The `providers` array is an ordered list of the possible encryption
providers. Only one provider type may be specified per entry (`identity` or `aescbc` may be provided,
but not both in the same item).
-->
<p>每个 <code>resources</code> 数组项目是一个单独的完整的配置。
<code>resources.resources</code> 字段是要加密的 Kubernetes 资源名称（<code>resource</code> 或 <code>resource.group</code>）的数组。
<code>providers</code> 数组是可能的加密 provider 的有序列表。
每个条目只能指定一个 provider 类型（可以是 <code>identity</code> 或 <code>aescbc</code>，但不能在同一个项目中同时指定）。</p>
<!--
The first provider in the list is used to encrypt resources going into storage. When reading
resources from storage each provider that matches the stored data attempts to decrypt the data in
order. If no provider can read the stored data due to a mismatch in format or secret key, an error
is returned which prevents clients from accessing that resource.
-->
<p>列表中的第一个 provider 用于加密进入存储的资源。
当从存储器读取资源时，与存储的数据匹配的所有 provider 将按顺序尝试解密数据。
如果由于格式或密钥不匹配而导致没有 provider 能够读取存储的数据，则会返回一个错误，以防止客户端访问该资源。</p>
<!--
**IMPORTANT:** If any resource is not readable via the encryption config (because keys were changed),
the only recourse is to delete that key from the underlying etcd directly. Calls that attempt to
read that resource will fail until it is deleted or a valid decryption key is provided.
-->
<blockquote class="caution callout">
  <div><strong>注意：</strong> <strong>重要：</strong> 如果通过加密配置无法读取资源（因为密钥已更改），唯一的方法是直接从底层 etcd 中删除该密钥。
任何尝试读取资源的调用将会失败，直到它被删除或提供有效的解密密钥。</div>
</blockquote>

<h3 id="providers">Providers:</h3>
<!--
Name | Encryption | Strength | Speed | Key Length | Other Considerations
-----|------------|----------|-------|------------|---------------------
`identity` | None | N/A | N/A | N/A | Resources written as-is without encryption. When set as the first provider, the resource will be decrypted as new values are written.
`aescbc` | AES-CBC with PKCS#7 padding | Strongest | Fast | 32-byte | The recommended choice for encryption at rest but may be slightly slower than `secretbox`.
`secretbox` | XSalsa20 and Poly1305 | Strong | Faster | 32-byte | A newer standard and may not be considered acceptable in environments that require high levels of review.
`aesgcm` | AES-GCM with random nonce | Must be rotated every 200k writes | Fastest | 16, 24, or 32-byte | Is not recommended for use except when an automated key rotation scheme is implemented.
`kms` | Uses envelope encryption scheme: Data is encrypted by data encryption keys (DEKs) using AES-CBC with PKCS#7 padding, DEKs are encrypted by key encryption keys (KEKs) according to configuration in Key Management Service (KMS) | Strongest | Fast | 32-bytes |  The recommended choice for using a third party tool for key management. Simplifies key rotation, with a new DEK generated for each encryption, and KEK rotation controlled by the user. [Configure the KMS provider](/docs/tasks/administer-cluster/kms-provider/)

Each provider supports multiple keys - the keys are tried in order for decryption, and if the provider
is the first provider, the first key is used for encryption.
-->





<table><caption style="display: none;">Kubernetes 静态数据加密的 Providers</caption>
<thead>
<tr>
<th>名称</th>
<th>加密类型</th>
<th>强度</th>
<th>速度</th>
<th>密钥长度</th>
<th>其它事项</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>identity</code></td>
<td>无</td>
<td>N/A</td>
<td>N/A</td>
<td>N/A</td>
<td>不加密写入的资源。当设置为第一个 provider 时，资源将在新值写入时被解密。</td>
</tr>
<tr>
<td><code>aescbc</code></td>
<td>填充 PKCS#7 的 AES-CBC</td>
<td>最强</td>
<td>快</td>
<td>32字节</td>
<td>建议使用的加密项，但可能比 <code>secretbox</code> 稍微慢一些。</td>
</tr>
<tr>
<td><code>secretbox</code></td>
<td>XSalsa20 和 Poly1305</td>
<td>强</td>
<td>更快</td>
<td>32字节</td>
<td>较新的标准，在需要高度评审的环境中可能不被接受。</td>
</tr>
<tr>
<td><code>aesgcm</code></td>
<td>带有随机数的 AES-GCM</td>
<td>必须每 200k 写入一次</td>
<td>最快</td>
<td>16, 24 或者 32字节</td>
<td>建议不要使用，除非实施了自动密钥循环方案。</td>
</tr>
<tr>
<td><code>kms</code></td>
<td>使用信封加密方案：数据使用带有 PKCS#7 填充的 AES-CBC 通过数据加密密钥（DEK）加密，DEK 根据 Key Management Service（KMS）中的配置通过密钥加密密钥（Key Encryption Keys，KEK）加密</td>
<td>最强</td>
<td>快</td>
<td>32字节</td>
<td>建议使用第三方工具进行密钥管理。为每个加密生成新的 DEK，并由用户控制 KEK 轮换来简化密钥轮换。<a href="/zh/docs/tasks/administer-cluster/kms-provider/">配置 KMS 提供程序</a></td>
</tr>
</tbody>
</table>
<p>每个 provider 都支持多个密钥 - 在解密时会按顺序使用密钥，如果是第一个 provider，则第一个密钥用于加密。</p>
<!--
__Storing the raw encryption key in the EncryptionConfig only moderately improves your security posture, compared to no encryption.
Please use `kms` provider for additional security.__ By default, the `identity` provider is used to protect secrets in etcd, which
provides no encryption. `EncryptionConfiguration` was introduced to encrypt secrets locally, with a locally managed key.
-->
<p><strong>在 EncryptionConfig 中保存原始的加密密钥与不加密相比只会略微地提升安全级别。
请使用 <code>kms</code> 驱动以获得更强的安全性。</strong>
默认情况下，<code>identity</code> 驱动被用来对 etcd 中的 Secret 提供保护，
而这个驱动不提供加密能力。
<code>EncryptionConfiguration</code> 的引入是为了能够使用本地管理的密钥来在本地加密 Secret 数据。</p>
<!--
Encrypting secrets with a locally managed key protects against an etcd compromise, but it fails to protect against a host compromise.
Since the encryption keys are stored on the host in the EncryptionConfig YAML file, a skilled attacker can access that file and
extract the encryption keys.
-->
<p>使用本地管理的密钥来加密 Secret 能够保护数据免受 etcd 破坏的影响，不过无法针对
主机被侵入提供防护。
这是因为加密的密钥保存在主机上的 EncryptionConfig YAML 文件中，有经验的入侵者
仍能访问该文件并从中提取出加密密钥。</p>
<!--
Envelope encryption creates dependence on a separate key, not stored in Kubernetes. In this case, an attacker would need to compromise etcd, the kubeapi-server, and the third-party KMS provider to retrieve the plaintext values, providing a higher level of security than locally-stored encryption keys.
-->
<p>封套加密（Envelope Encryption）引入了对独立密钥的依赖，而这个密钥并不保存在 Kubernetes 中。
在这种情况下下，入侵者需要攻破 etcd、kube-apiserver 和第三方的 KMS
驱动才能获得明文数据，因而这种方案提供了比本地保存加密密钥更高的安全级别。</p>
<!--
## Encrypting your data

Create a new encryption config file:
-->
<h2 id="加密你的数据">加密你的数据</h2>
<p>创建一个新的加密配置文件：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>apiserver.config.k8s.io/v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>EncryptionConfiguration<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">resources</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- <span style="color:#008000;font-weight:bold">resources</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span>- secrets<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">providers</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span>- <span style="color:#008000;font-weight:bold">aescbc</span>:<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#008000;font-weight:bold">keys</span>:<span style="color:#bbb">
</span><span style="color:#bbb">        </span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>key1<span style="color:#bbb">
</span><span style="color:#bbb">          </span><span style="color:#008000;font-weight:bold">secret</span>:<span style="color:#bbb"> </span>&lt;BASE 64 ENCODED SECRET&gt;<span style="color:#bbb">
</span><span style="color:#bbb">    </span>- <span style="color:#008000;font-weight:bold">identity</span>:<span style="color:#bbb"> </span>{}<span style="color:#bbb">
</span></code></pre></div><!--
To create a new secret perform the following steps:

1. Generate a 32 byte random key and base64 encode it. If you're on Linux or Mac OS X, run the following command:
-->
<p>遵循如下步骤来创建一个新的 secret：</p>
<ol>
<li>
<p>生成一个 32 字节的随机密钥并进行 base64 编码。如果你在 Linux 或 Mac OS X 上，请运行以下命令：</p>
<pre tabindex="0"><code>head -c 32 /dev/urandom | base64
</code></pre></li>
</ol>
<!--
2. Place that value in the secret field.
3. Set the `--experimental-encryption-provider-config` flag on the `kube-apiserver` to point to the location of the config file.
4. Restart your API server.

**IMPORTANT:** Your config file contains keys that can decrypt content in etcd, so you must properly restrict permissions on your masters so only the user who runs the kube-apiserver can read it.
-->
<ol start="2">
<li>将这个值放入到 secret 字段中。</li>
<li>设置 <code>kube-apiserver</code> 的 <code>--experimental-encryption-provider-config</code> 参数，将其指向
配置文件所在位置。</li>
<li>重启你的 API server。</li>
</ol>
<blockquote class="caution callout">
  <div><strong>注意：</strong> 你的配置文件包含可以解密 etcd 内容的密钥，因此你必须正确限制主控节点的访问权限，
以便只有能运行 kube-apiserver 的用户才能读取它。</div>
</blockquote>
<!--
## Verifying that data is encrypted

Data is encrypted when written to etcd. After restarting your `kube-apiserver`, any newly created or
updated secret should be encrypted when stored. To check, you can use the `etcdctl` command line
program to retrieve the contents of your secret.

1. Create a new secret called `secret1` in the `default` namespace:
-->
<h2 id="验证数据已被加密">验证数据已被加密</h2>
<p>数据在写入 etcd 时会被加密。重新启动你的 <code>kube-apiserver</code> 后，任何新创建或更新的密码在存储时都应该被加密。
如果想要检查，你可以使用 <code>etcdctl</code> 命令行程序来检索你的加密内容。</p>
<ol>
<li>
<p>创建一个新的 secret，名称为 <code>secret1</code>，命名空间为 <code>default</code>：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl create secret generic secret1 -n default --from-literal<span style="color:#666">=</span><span style="color:#b8860b">mykey</span><span style="color:#666">=</span>mydata
</code></pre></div></li>
</ol>
<!--
2. Using the etcdctl commandline, read that secret out of etcd:
-->
<ol start="2">
<li>
<p>使用 etcdctl 命令行，从 etcd 中读取 secret：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="color:#b8860b">ETCDCTL_API</span><span style="color:#666">=</span><span style="color:#666">3</span> etcdctl get /registry/secrets/default/secret1 <span style="color:#666">[</span>...<span style="color:#666">]</span> | hexdump -C
</code></pre></div><!--
where `[...]` must be the additional arguments for connecting to the etcd server.
-->
<p>这里的 <code>[...]</code> 是用来连接 etcd 服务的额外参数。</p>
</li>
</ol>
<!--
3. Verify the stored secret is prefixed with `k8s:enc:aescbc:v1:` which indicates the `aescbc` provider has encrypted the resulting data.
4. Verify the secret is correctly decrypted when retrieved via the API:
-->
<ol start="3">
<li>
<p>验证存储的密钥前缀是否为 <code>k8s:enc:aescbc:v1:</code>，这表明 <code>aescbc</code> provider 已加密结果数据。</p>
</li>
<li>
<p>通过 API 检索，验证 secret 是否被正确解密：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl describe secret secret1 -n default
</code></pre></div><!--
should match `mykey: mydata`, mydata is encoded, check [decoding a secret](/docs/tasks/configmap-secret/managing-secret-using-kubectl/#decoding-secret) to
completely decode the secret.
-->
<p>其输出应该是 <code>mykey: bXlkYXRh</code>，<code>mydata</code> 数据是被加密过的，请参阅
<a href="/zh/docs/tasks/configmap-secret/managing-secret-using-kubectl/#decoding-secret">解密 Secret</a>
了解如何完全解码 Secret 内容。</p>
</li>
</ol>
<!--
## Ensure all secrets are encrypted

Since secrets are encrypted on write, performing an update on a secret will encrypt that content.
-->
<h2 id="确保所有-secret-都被加密">确保所有 Secret 都被加密</h2>
<p>由于 Secret 是在写入时被加密，因此对 Secret 执行更新也会加密该内容。</p>
<pre tabindex="0"><code>kubectl get secrets --all-namespaces -o json | kubectl replace -f -
</code></pre><!--
The command above reads all secrets and then updates them to apply server side encryption.
-->
<p>上面的命令读取所有 Secret，然后使用服务端加密来更新其内容。</p>
<!--
If an error occurs due to a conflicting write, retry the command.
For larger clusters, you may wish to subdivide the secrets by namespace or script an update.
-->
<blockquote class="note callout">
  <div><strong>说明：</strong> 如果由于冲突写入而发生错误，请重试该命令。
对于较大的集群，你可能希望通过命名空间或更新脚本来对 Secret 进行划分。</div>
</blockquote>
<!--
## Rotating a decryption key

Changing the secret without incurring downtime requires a multi step operation, especially in
the presence of a highly available deployment where multiple `kube-apiserver` processes are running.

1. Generate a new key and add it as the second key entry for the current provider on all servers
2. Restart all `kube-apiserver` processes to ensure each server can decrypt using the new key
3. Make the new key the first entry in the `keys` array so that it is used for encryption in the config
4. Restart all `kube-apiserver` processes to ensure each server now encrypts using the new key
5. Run `kubectl get secrets -all-namespaces -o json | kubectl replace -f -` to encrypt all existing secrets with the new key
6. Remove the old decryption key from the config after you back up etcd with the new key in use and update all secrets

With a single `kube-apiserver`, step 2 may be skipped.
-->
<h2 id="轮换解密密钥">轮换解密密钥</h2>
<p>在不发生停机的情况下更改 Secret 需要多步操作，特别是在有多个 <code>kube-apiserver</code> 进程正在运行的
高可用环境中。</p>
<ol>
<li>生成一个新密钥并将其添加为所有服务器上当前提供程序的第二个密钥条目</li>
<li>重新启动所有 <code>kube-apiserver</code> 进程以确保每台服务器都可以使用新密钥进行解密</li>
<li>将新密钥设置为 <code>keys</code> 数组中的第一个条目，以便在配置中使用其进行加密</li>
<li>重新启动所有 <code>kube-apiserver</code> 进程以确保每个服务器现在都使用新密钥进行加密</li>
<li>运行 <code>kubectl get secrets --all-namespaces -o json | kubectl replace -f -</code> 以用新密钥加密所有现有的秘密</li>
<li>在使用新密钥备份 etcd 后，从配置中删除旧的解密密钥并更新所有密钥</li>
</ol>
<p>如果只有一个 <code>kube-apiserver</code>，第 2 步可能可以忽略。</p>
<!--
## Decrypting all data

To disable encryption at rest place the `identity` provider as the first entry in the config:
-->
<h2 id="解密所有数据">解密所有数据</h2>
<p>要禁用 rest 加密，请将 <code>identity</code> provider 作为配置中的第一个条目：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>apiserver.config.k8s.io/v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>EncryptionConfiguration<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">resources</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- <span style="color:#008000;font-weight:bold">resources</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span>- secrets<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">providers</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span>- <span style="color:#008000;font-weight:bold">identity</span>:<span style="color:#bbb"> </span>{}<span style="color:#bbb">
</span><span style="color:#bbb">    </span>- <span style="color:#008000;font-weight:bold">aescbc</span>:<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#008000;font-weight:bold">keys</span>:<span style="color:#bbb">
</span><span style="color:#bbb">        </span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>key1<span style="color:#bbb">
</span><span style="color:#bbb">          </span><span style="color:#008000;font-weight:bold">secret</span>:<span style="color:#bbb"> </span>&lt;BASE 64 ENCODED SECRET&gt;<span style="color:#bbb">
</span></code></pre></div><!--
and restart all `kube-apiserver` processes. Then run
-->
<p>并重新启动所有 <code>kube-apiserver</code> 进程。然后运行：</p>
<pre tabindex="0"><code>kubectl get secrets -all-namespaces -o json | kubectl replace -f -`
</code></pre><!--
to force all secrets to be decrypted.
-->
<p>以强制解密所有 secret。</p>


</div>



    
	
  



          </main>
        </div>
      </div>
      
<footer class="d-print-none">
  <div class="footer__links">
    <nav>
      
      
      
      <a class="text-white" href="/zh/docs/home/">主页</a>
      
      <a class="text-white" href="/zh/blog/">博客</a>
      
      <a class="text-white" href="/zh/training/">培训</a>
      
      <a class="text-white" href="/zh/partners/">合作伙伴</a>
      
      <a class="text-white" href="/zh/community/">社区</a>
      
      <a class="text-white" href="/zh/case-studies/">案例分析</a>
      
    </nav>
  </div>
  <div class="container-fluid">
    <div class="row">
      <div class="col-6 col-sm-2 text-xs-center order-sm-2">
        
        
        
<ul class="list-inline mb-0">
  
  <li class="list-inline-item mx-2 h3" data-toggle="tooltip" data-placement="top" title="User mailing list" aria-label="User mailing list">
    <a class="text-white" target="_blank" href="https://discuss.kubernetes.io">
      <i class="fa fa-envelope"></i>
    </a>
  </li>
  
  <li class="list-inline-item mx-2 h3" data-toggle="tooltip" data-placement="top" title="Twitter" aria-label="Twitter">
    <a class="text-white" target="_blank" href="https://twitter.com/kubernetesio">
      <i class="fab fa-twitter"></i>
    </a>
  </li>
  
  <li class="list-inline-item mx-2 h3" data-toggle="tooltip" data-placement="top" title="Calendar" aria-label="Calendar">
    <a class="text-white" target="_blank" href="https://calendar.google.com/calendar/embed?src=calendar%40kubernetes.io">
      <i class="fas fa-calendar-alt"></i>
    </a>
  </li>
  
  <li class="list-inline-item mx-2 h3" data-toggle="tooltip" data-placement="top" title="Youtube" aria-label="Youtube">
    <a class="text-white" target="_blank" href="https://youtube.com/kubernetescommunity">
      <i class="fab fa-youtube"></i>
    </a>
  </li>
  
</ul>

        
        
      </div>
      <div class="col-6 col-sm-2 text-right text-xs-center order-sm-3">
        
        
        
<ul class="list-inline mb-0">
  
  <li class="list-inline-item mx-2 h3" data-toggle="tooltip" data-placement="top" title="GitHub" aria-label="GitHub">
    <a class="text-white" target="_blank" href="https://github.com/kubernetes/kubernetes">
      <i class="fab fa-github"></i>
    </a>
  </li>
  
  <li class="list-inline-item mx-2 h3" data-toggle="tooltip" data-placement="top" title="Slack" aria-label="Slack">
    <a class="text-white" target="_blank" href="https://slack.k8s.io">
      <i class="fab fa-slack"></i>
    </a>
  </li>
  
  <li class="list-inline-item mx-2 h3" data-toggle="tooltip" data-placement="top" title="Contribute" aria-label="Contribute">
    <a class="text-white" target="_blank" href="https://git.k8s.io/community/contributors/guide">
      <i class="fas fa-edit"></i>
    </a>
  </li>
  
  <li class="list-inline-item mx-2 h3" data-toggle="tooltip" data-placement="top" title="Stack Overflow" aria-label="Stack Overflow">
    <a class="text-white" target="_blank" href="https://stackoverflow.com/questions/tagged/kubernetes">
      <i class="fab fa-stack-overflow"></i>
    </a>
  </li>
  
</ul>

        
        
      </div>
      <div class="col-12 col-sm-8 text-center order-sm-2">
        <small class="text-white">&copy; 2021 The Kubernetes 作者 | 文档发布基于 <a href="https://git.k8s.io/website/LICENSE" class="light-text">CC BY 4.0</a> 授权许可</small>
        <br/>
        <small class="text-white">Copyright &copy; 2021 Linux 基金会&reg;。保留所有权利。Linux 基金会已注册并使用商标。如需了解 Linux 基金会的商标列表，请访问<a href="https://www.linuxfoundation.org/trademark-usage" class="light-text">商标使用页面</a></small>
        <br/>
        <small class="text-white">ICP license: 京ICP备17074266号-3</small>
        
        
          
        
      </div>
    </div>
  </div>
</footer>


    </div>
    
<script src="/js/popper-1.14.3.min.js" integrity="sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49" crossorigin="anonymous"></script>
<script src="/js/bootstrap-4.3.1.min.js" integrity="sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM" crossorigin="anonymous"></script>











<script src="/js/main.min.40616251a9b6e4b689e7769be0340661efa4d7ebb73f957404e963e135b4ed52.js" integrity="sha256-QGFiUam25LaJ53ab4DQGYe&#43;k1&#43;u3P5V0BOlj4TW07VI=" crossorigin="anonymous"></script>






  </body>
</html>
