<!doctype html>
<html lang="zh" class="no-js">
  <head>
    

<script async src="https://www.googletagmanager.com/gtag/js?id=UA-36037335-10"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-36037335-10');
</script>


<link rel="alternate" hreflang="en" href="https://kubernetes.io/docs/reference/">
<link rel="alternate" hreflang="ko" href="https://kubernetes.io/ko/docs/reference/">
<link rel="alternate" hreflang="ja" href="https://kubernetes.io/ja/docs/reference/">
<link rel="alternate" hreflang="fr" href="https://kubernetes.io/fr/docs/reference/">
<link rel="alternate" hreflang="de" href="https://kubernetes.io/de/docs/reference/">
<link rel="alternate" hreflang="es" href="https://kubernetes.io/es/docs/reference/">
<link rel="alternate" hreflang="pt-br" href="https://kubernetes.io/pt-br/docs/reference/">
<link rel="alternate" hreflang="id" href="https://kubernetes.io/id/docs/reference/">
<link rel="alternate" hreflang="ru" href="https://kubernetes.io/ru/docs/reference/">
<link rel="alternate" hreflang="pl" href="https://kubernetes.io/pl/docs/reference/">

<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="generator" content="Hugo 0.88.1" />

<META NAME="ROBOTS" CONTENT="NOINDEX, NOFOLLOW">

<link rel="canonical" type="text/html" href="https://kubernetes.io/zh/docs/reference/">
<link rel="shortcut icon" type="image/png" href="/images/favicon.png">
<link rel="apple-touch-icon" href="/favicons/apple-touch-icon-180x180.png" sizes="180x180">
<link rel="manifest" href="/manifest.webmanifest">
<link rel="apple-touch-icon" href="/images/kubernetes-192x192.png">
<title>参考 | Kubernetes</title><meta property="og:title" content="参考" />
<meta property="og:description" content="生产级别的容器编排系统" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://kubernetes.io/zh/docs/reference/" /><meta property="og:site_name" content="Kubernetes" />

<meta itemprop="name" content="参考">
<meta itemprop="description" content="生产级别的容器编排系统"><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="参考"/>
<meta name="twitter:description" content="生产级别的容器编排系统"/>





<link rel="preload" href="/scss/main.min.0bda2f3af46d1514ab4d3cad78295716cfd9557a35a41868b7db38040502bb54.css" as="style">
<link href="/scss/main.min.0bda2f3af46d1514ab4d3cad78295716cfd9557a35a41868b7db38040502bb54.css" rel="stylesheet" integrity="">


<script
  src="/js/jquery-3.3.1.min.js"
  integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8="
  crossorigin="anonymous"></script>





<script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@type": "Organization",
    "url": "https://kubernetes.io",
    "logo": "https://kubernetes.io/images/favicon.png",
    "potentialAction": {
      "@type": "SearchAction",
      "target": "https://kubernetes.io/search/?q={search_term_string}",
      "query-input": "required name=search_term_string"
    }

  }
</script>
<meta name="theme-color" content="#326ce5">




<link rel="stylesheet" href="/css/feature-states.css">



<meta name="description" content="这是 Kubernetes 文档的参考部分。
API 参考   术语表 - 一个全面的标准化的 Kubernetes 术语表
  Kubernetes API 单页参考
  Kubernetes API 参考 v1.22。
  使用 Kubernetes API  - Kubernetes 的 API 概述
  API 的访问控制 - 关于 Kubernetes 如何控制 API 访问的详细信息
  常见的标签、注解和污点
  官方支持的客户端库 如果您需要通过编程语言调用 Kubernetes API，您可以使用 客户端库。以下是官方支持的客户端库：
 Kubernetes Go 语言客户端库 Kubernetes Python 语言客户端库 Kubernetes Java 语言客户端库 Kubernetes JavaScript 语言客户端库 Kubernetes Dotnet 语言客户端库 Kubernetes Haskell 语言客户端库  CLI  kubectl - 主要的 CLI 工具，用于运行命令和管理 Kubernetes 集群。  JSONPath - 通过 kubectl 使用 JSONPath 表达式 的语法指南。   kubeadm - 此 CLI 工具可轻松配置安全的 Kubernetes 集群。  组件   kubelet - 在每个节点上运行的主代理。kubelet 接收一组 PodSpecs 并确保其所描述的容器健康地运行。">
<meta property="og:description" content="这是 Kubernetes 文档的参考部分。
API 参考   术语表 - 一个全面的标准化的 Kubernetes 术语表
  Kubernetes API 单页参考
  Kubernetes API 参考 v1.22。
  使用 Kubernetes API  - Kubernetes 的 API 概述
  API 的访问控制 - 关于 Kubernetes 如何控制 API 访问的详细信息
  常见的标签、注解和污点
  官方支持的客户端库 如果您需要通过编程语言调用 Kubernetes API，您可以使用 客户端库。以下是官方支持的客户端库：
 Kubernetes Go 语言客户端库 Kubernetes Python 语言客户端库 Kubernetes Java 语言客户端库 Kubernetes JavaScript 语言客户端库 Kubernetes Dotnet 语言客户端库 Kubernetes Haskell 语言客户端库  CLI  kubectl - 主要的 CLI 工具，用于运行命令和管理 Kubernetes 集群。  JSONPath - 通过 kubectl 使用 JSONPath 表达式 的语法指南。   kubeadm - 此 CLI 工具可轻松配置安全的 Kubernetes 集群。  组件   kubelet - 在每个节点上运行的主代理。kubelet 接收一组 PodSpecs 并确保其所描述的容器健康地运行。">
<meta name="twitter:description" content="这是 Kubernetes 文档的参考部分。
API 参考   术语表 - 一个全面的标准化的 Kubernetes 术语表
  Kubernetes API 单页参考
  Kubernetes API 参考 v1.22。
  使用 Kubernetes API  - Kubernetes 的 API 概述
  API 的访问控制 - 关于 Kubernetes 如何控制 API 访问的详细信息
  常见的标签、注解和污点
  官方支持的客户端库 如果您需要通过编程语言调用 Kubernetes API，您可以使用 客户端库。以下是官方支持的客户端库：
 Kubernetes Go 语言客户端库 Kubernetes Python 语言客户端库 Kubernetes Java 语言客户端库 Kubernetes JavaScript 语言客户端库 Kubernetes Dotnet 语言客户端库 Kubernetes Haskell 语言客户端库  CLI  kubectl - 主要的 CLI 工具，用于运行命令和管理 Kubernetes 集群。  JSONPath - 通过 kubectl 使用 JSONPath 表达式 的语法指南。   kubeadm - 此 CLI 工具可轻松配置安全的 Kubernetes 集群。  组件   kubelet - 在每个节点上运行的主代理。kubelet 接收一组 PodSpecs 并确保其所描述的容器健康地运行。">
<meta property="og:url" content="https://kubernetes.io/zh/docs/reference/">
<meta property="og:title" content="参考">
<meta name="twitter:title" content="参考">
<meta name="twitter:image" content="https://kubernetes.io/images/favicon.png" />

<meta name="twitter:image:alt" content="Kubernetes">

<meta property="og:image" content="/images/kubernetes-horizontal-color.png">

<meta property="og:type" content="article">



<script src="/js/script.js"></script>


  </head>
  <body class="td-section">
    <header>
      
<nav class="js-navbar-scroll navbar navbar-expand navbar-dark  flex-row td-navbar" data-auto-burger="primary">
        <a class="navbar-brand" href="/zh/"></a>
	<div class="td-navbar-nav-scroll ml-md-auto" id="main_navbar">
		
		<ul class="navbar-nav mt-2 mt-lg-0">
			
			
			
			
			<li class="nav-item mr-2 mb-lg-0">
				
				<a class="nav-link active" href="/zh/docs/" >文档</span></a>
			</li>
			
			
			
			<li class="nav-item mr-2 mb-lg-0">
				
				<a class="nav-link" href="/zh/blog/" >Kubernetes 博客</span></a>
			</li>
			
			
			
			<li class="nav-item mr-2 mb-lg-0">
				
				<a class="nav-link" href="/zh/training/" >培训</span></a>
			</li>
			
			
			
			<li class="nav-item mr-2 mb-lg-0">
				
				<a class="nav-link" href="/zh/partners/" >合作伙伴</span></a>
			</li>
			
			
			
			<li class="nav-item mr-2 mb-lg-0">
				
				<a class="nav-link" href="/zh/community/" >社区</span></a>
			</li>
			
			
			
			<li class="nav-item mr-2 mb-lg-0">
				
				<a class="nav-link" href="/zh/case-studies/" >案例分析</span></a>
			</li>
			
			
			
			<li class="nav-item dropdown">
				<a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
	版本列表
</a>
<div class="dropdown-menu dropdown-menu-right" aria-labelledby="navbarDropdownMenuLink">
	
	<a class="dropdown-item" href="/releases">Release Information</a>
	
	<a class="dropdown-item" href="https://kubernetes.io/zh/docs/reference/">v1.22</a>
	
	<a class="dropdown-item" href="https://v1-21.docs.kubernetes.io/zh/docs/reference/">v1.21</a>
	
	<a class="dropdown-item" href="https://v1-20.docs.kubernetes.io/zh/docs/reference/">v1.20</a>
	
	<a class="dropdown-item" href="https://v1-19.docs.kubernetes.io/zh/docs/reference/">v1.19</a>
	
	<a class="dropdown-item" href="https://v1-18.docs.kubernetes.io/zh/docs/reference/">v1.18</a>
	
</div>
			</li>
			
			
			<li class="nav-item dropdown">
				

<a class="nav-link dropdown-toggle" href="#" id="navbarDropdownMenuLink" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
	中文 Chinese
</a>
<div class="dropdown-menu dropdown-menu-right" aria-labelledby="navbarDropdownMenuLink">
	
	<a class="dropdown-item" href="/docs/reference/">English</a>
	
	<a class="dropdown-item" href="/ko/docs/reference/">한국어 Korean</a>
	
	<a class="dropdown-item" href="/ja/docs/reference/">日本語 Japanese</a>
	
	<a class="dropdown-item" href="/fr/docs/reference/">Français</a>
	
	<a class="dropdown-item" href="/de/docs/reference/">Deutsch</a>
	
	<a class="dropdown-item" href="/es/docs/reference/">Español</a>
	
	<a class="dropdown-item" href="/pt-br/docs/reference/">Português</a>
	
	<a class="dropdown-item" href="/id/docs/reference/">Bahasa Indonesia</a>
	
	<a class="dropdown-item" href="/ru/docs/reference/">Русский</a>
	
	<a class="dropdown-item" href="/pl/docs/reference/">Polski</a>
	
</div>

			</li>
			
		</ul>
	</div>
	<button id="hamburger" onclick="kub.toggleMenu()" data-auto-burger-exclude><div></div></button>
</nav>
    </header>
    <div class="container-fluid td-outer">
      <div class="td-main">
        <div class="row flex-xl-nowrap">
          <div class="col-12 col-md-3 col-xl-2 td-sidebar d-print-none">
          </div>
          <div class="d-none d-xl-block col-xl-2 td-toc d-print-none">
          </div>
          <main class="col-12 col-md-9 col-xl-8 pl-md-5" role="main">
            




<div class="td-content">
<div class="pageinfo pageinfo-primary d-print-none">
<p>
这是本节的多页打印视图。
<a href="#" onclick="print();return false;">点击此处打印</a>.
</p><p>
<a href="/zh/docs/reference/">返回本页常规视图</a>.
</p>
</div>



<h1 class="title">参考</h1>





    <ul>
    
  
  
  
  

  
    
    
	
<li>1: <a href="#pg-2b03679960950df772fb4fe7d78427b9">词汇表</a></li>


    
  
    
    
	
<li>2: <a href="#pg-882c82a32bfb4d7946585a93a966b442">API 概述</a></li>


    
    <ul>
        
  
  
  
  

  
    
    
	
<li>2.1: <a href="#pg-2b5428a2ff6f4831fd972ef50e12b3eb">Kubernetes API 概念</a></li>


    
  
    
    
	
<li>2.2: <a href="#pg-040d9484db673074f1b8ba3465be9d91">服务器端应用（Server-Side Apply）</a></li>


    
  
    
    
	
<li>2.3: <a href="#pg-79880efc25dc8cb3b6962ad78a964319">客户端库</a></li>


    
  
    
    
	
<li>2.4: <a href="#pg-8d2ce3e7b2223cda0ccd428f4d5ea24b">Kubernetes 弃用策略</a></li>


    
  
    
    
	
<li>2.5: <a href="#pg-e4dbb59f8f23854d7b7d574e169923c4">Kubernetes API 健康端点</a></li>


    
  

    </ul>
    
  
    
    
	
<li>3: <a href="#pg-232c8c895125744f56a31038ab6fa4e9">常见的标签、注解和污点</a></li>


    
  
    
    
	
<li>4: <a href="#pg-99b26586d8a33ec06996dcf7892a9683">访问 API</a></li>


    
    <ul>
        
  
  
  
  

  
    
    
	
<li>4.1: <a href="#pg-a6264859a5ad6e2f4a6e4cff9ce4fa8b">用户认证</a></li>


    
  
    
    
	
<li>4.2: <a href="#pg-de45b6ca7419a0e308044425b2ac52bb">使用启动引导令牌（Bootstrap Tokens）认证</a></li>


    
  
    
    
	
<li>4.3: <a href="#pg-3d0c14d1e3cfade38febc343cd044c73">证书签名请求</a></li>


    
  
    
    
	
<li>4.4: <a href="#pg-518807b9b00bda46d7c7e6e0b17c18f8">使用准入控制器</a></li>


    
  
    
    
	
<li>4.5: <a href="#pg-d04751f776f1faa6a82bbb7f0a200950">动态准入控制</a></li>


    
  
    
    
	
<li>4.6: <a href="#pg-bea207258f3576b8ec7444a20d498e1d">管理服务账号</a></li>


    
  
    
    
	
<li>4.7: <a href="#pg-342be69d36f174f762c36f4fe11fcb20">鉴权概述</a></li>


    
  
    
    
	
<li>4.8: <a href="#pg-954776b47f2d90515f375623a0ce98e1">使用 RBAC 鉴权</a></li>


    
  
    
    
	
<li>4.9: <a href="#pg-9cbb97d4d9f08d67931a1baae4e6519c">使用 Node 鉴权</a></li>


    
  
    
    
	
<li>4.10: <a href="#pg-215c25173044b8f97e9b0494b0c7e53f">Webhook 模式</a></li>


    
  
    
    
	
<li>4.11: <a href="#pg-a5bdc757c01991e5e6ab1a82b90639ea">使用 ABAC 鉴权</a></li>


    
  

    </ul>
    
  
    
    
	
<li>5: <a href="#pg-60a16da3955f1de774f1f8dd756f2251">Kubernetes API</a></li>


    
    <ul>
        
  
  
  
  

  

    </ul>
    
  
    
    
	
<li>6: <a href="#pg-af7c1f9168ec67f957edc504f43faf9a">Kubernetes 问题和安全</a></li>


    
    <ul>
        
  
  
  
  

  
    
    
	
<li>6.1: <a href="#pg-980c0542a3b195a20cfd4358792e2a38">Kubernetes 问题追踪</a></li>


    
  
    
    
	
<li>6.2: <a href="#pg-1f7dc06f1cc1ea2cdde4480e54d5fb34">Kubernetes 安全和信息披露</a></li>


    
  

    </ul>
    
  
    
    
	
<li>7: <a href="#pg-5bbbc5163b35431b3bff029ab9ec57d3">安装工具</a></li>


    
    <ul>
        
  
  
  
  

  
    
    
	
<li>7.1: <a href="#pg-f351ced098abbb076bc8c4be1053672b">Kubeadm</a></li>


    
    <ul>
        
  
  
  
  

  
    
    
	
<li>7.1.1: <a href="#pg-36c22b52e8447eb3d2452d4f56fbea9b">创建 Kubeadm</a></li>


    
    <ul>
        
  
  
  
  

  
    
    
	
<li>7.1.1.1: <a href="#pg-fd3ad295c1f10bfa333f841bbdffba81"></a></li>


    
  
    
    
	
<li>7.1.1.2: <a href="#pg-185ec44b69a851237e5cbde8b34d60b8"></a></li>


    
  
    
    
	
<li>7.1.1.3: <a href="#pg-5106075da35b6c976e6f8d7d225df0ff"></a></li>


    
  
    
    
	
<li>7.1.1.4: <a href="#pg-d7af99919faca6010658b893fa2a6890"></a></li>


    
  
    
    
	
<li>7.1.1.5: <a href="#pg-8df9aba508b2736a6712ef46227eea7d"></a></li>


    
  
    
    
	
<li>7.1.1.6: <a href="#pg-018648dfc6f28bc9b969f45af0563cae"></a></li>


    
  
    
    
	
<li>7.1.1.7: <a href="#pg-4a1ff27cdf01c1c47d034278048e776b"></a></li>


    
  
    
    
	
<li>7.1.1.8: <a href="#pg-5d6b2999153cd86f56329534249fc4ec"></a></li>


    
  
    
    
	
<li>7.1.1.9: <a href="#pg-adb5eecdc351074cc2e0cc2b1b4f04a8"></a></li>


    
  
    
    
	
<li>7.1.1.10: <a href="#pg-df4c2dc6cba0be90d8d7de2fca9b87f7"></a></li>


    
  
    
    
	
<li>7.1.1.11: <a href="#pg-6d6746e8ac1f1602f7dab1056b27e5c2"></a></li>


    
  
    
    
	
<li>7.1.1.12: <a href="#pg-7449c7fa06f25b967cf531e937b0f4b2"></a></li>


    
  
    
    
	
<li>7.1.1.13: <a href="#pg-b5c6ae77d3be9bd358c68667006cfc18"></a></li>


    
  
    
    
	
<li>7.1.1.14: <a href="#pg-4f804e59ec1739e733807d2b591d771f"></a></li>


    
  
    
    
	
<li>7.1.1.15: <a href="#pg-f5cf8caa95834803b133d53c321ab4a9"></a></li>


    
  
    
    
	
<li>7.1.1.16: <a href="#pg-ee770858e2bb767b79d572b4882af656"></a></li>


    
  
    
    
	
<li>7.1.1.17: <a href="#pg-7484bf11b6183f4c329b1f66734cc886"></a></li>


    
  
    
    
	
<li>7.1.1.18: <a href="#pg-bf444d915ab856dba693c36294c5427b"></a></li>


    
  
    
    
	
<li>7.1.1.19: <a href="#pg-f5c087e087714c5290b4967dd7924b3b"></a></li>


    
  
    
    
	
<li>7.1.1.20: <a href="#pg-20703ce1c236264ad78cb1ad7244723e"></a></li>


    
  
    
    
	
<li>7.1.1.21: <a href="#pg-49aaa494ef75de67609987a43e5ee520"></a></li>


    
  
    
    
	
<li>7.1.1.22: <a href="#pg-d63311c16e6468f5a5940aadd902faa7"></a></li>


    
  
    
    
	
<li>7.1.1.23: <a href="#pg-6678a79b85306310066616185153377d"></a></li>


    
  
    
    
	
<li>7.1.1.24: <a href="#pg-8f73e208cc67d221165f6294393881a7"></a></li>


    
  
    
    
	
<li>7.1.1.25: <a href="#pg-9aec3477159c105a46f4479de1c21418"></a></li>


    
  
    
    
	
<li>7.1.1.26: <a href="#pg-045e41c28798930e21f77a90c3a90263"></a></li>


    
  
    
    
	
<li>7.1.1.27: <a href="#pg-e7d83478123771ad14f475ee44440303"></a></li>


    
  
    
    
	
<li>7.1.1.28: <a href="#pg-57a6b20d9571220989a7a445d4459468"></a></li>


    
  
    
    
	
<li>7.1.1.29: <a href="#pg-92a2c11eef37937af846b55d9b87a544"></a></li>


    
  
    
    
	
<li>7.1.1.30: <a href="#pg-dcfffcaafb438cd650475945ddc129ee"></a></li>


    
  
    
    
	
<li>7.1.1.31: <a href="#pg-6eaa2624c512051ff2a9cdbc6ee54949"></a></li>


    
  
    
    
	
<li>7.1.1.32: <a href="#pg-4b7ada30e3923594b2907dcb8b431080"></a></li>


    
  
    
    
	
<li>7.1.1.33: <a href="#pg-6d1154da2e554de858cf4e7b37c054fa"></a></li>


    
  
    
    
	
<li>7.1.1.34: <a href="#pg-d3a16914ddc849435ed864163978ddbf"></a></li>


    
  
    
    
	
<li>7.1.1.35: <a href="#pg-8a257337ea78e5d9a0c54aa971eaf991"></a></li>


    
  
    
    
	
<li>7.1.1.36: <a href="#pg-77759011117e7974cbfee9694b6f8801"></a></li>


    
  
    
    
	
<li>7.1.1.37: <a href="#pg-8e1920b2caaa8de839cd3997edca80e9"></a></li>


    
  
    
    
	
<li>7.1.1.38: <a href="#pg-00aa8c2e4b3b2fd3a4b7986976b7bfda"></a></li>


    
  
    
    
	
<li>7.1.1.39: <a href="#pg-316aa97ee5719be5a723ac1b77c44f5a"></a></li>


    
  
    
    
	
<li>7.1.1.40: <a href="#pg-759e85e62b32c0697ab37c214e99a864"></a></li>


    
  
    
    
	
<li>7.1.1.41: <a href="#pg-2e7091074560abc2a8e7b897cdd8a7b6"></a></li>


    
  
    
    
	
<li>7.1.1.42: <a href="#pg-eedb8f5a6ed4cff1dfb1a5d14176b5b3"></a></li>


    
  
    
    
	
<li>7.1.1.43: <a href="#pg-c55f2fa6bdaa124b37da090a3ef90902"></a></li>


    
  
    
    
	
<li>7.1.1.44: <a href="#pg-10f416336efdcee22d691869e7585b9f"></a></li>


    
  
    
    
	
<li>7.1.1.45: <a href="#pg-c4b6d149cda7cac896f4374c821b7fc6"></a></li>


    
  
    
    
	
<li>7.1.1.46: <a href="#pg-1db087626f4f368e932df6f12993a5ab"></a></li>


    
  
    
    
	
<li>7.1.1.47: <a href="#pg-e85da83e18a50e472eb56320af55768a"></a></li>


    
  
    
    
	
<li>7.1.1.48: <a href="#pg-eb911bdcb8bb53ceb8b253089ab0d814"></a></li>


    
  
    
    
	
<li>7.1.1.49: <a href="#pg-62c5dc89c39f3ecd6aee57545d12891a"></a></li>


    
  
    
    
	
<li>7.1.1.50: <a href="#pg-2a79e12b9455f0ca1a6d5b00a9841249"></a></li>


    
  
    
    
	
<li>7.1.1.51: <a href="#pg-a2c8efac328fcf416e558bf167ef417d"></a></li>


    
  
    
    
	
<li>7.1.1.52: <a href="#pg-d93bd37094201bdefdb3908c9a6c86b3"></a></li>


    
  
    
    
	
<li>7.1.1.53: <a href="#pg-efa9ae4c92ed1c26dc04bb049db38cec"></a></li>


    
  
    
    
	
<li>7.1.1.54: <a href="#pg-576c00359074987304b3b418cec9a5b1"></a></li>


    
  
    
    
	
<li>7.1.1.55: <a href="#pg-e6097fe5dd013abd9f356c2566ef7b63"></a></li>


    
  
    
    
	
<li>7.1.1.56: <a href="#pg-5ab65eab2498cc1893af5b3bf8fe08fc"></a></li>


    
  
    
    
	
<li>7.1.1.57: <a href="#pg-fcb78718510a9d3027d1bb9d379c0c17"></a></li>


    
  
    
    
	
<li>7.1.1.58: <a href="#pg-a0e1457f667eb757f82f8c42901aa6c5"></a></li>


    
  
    
    
	
<li>7.1.1.59: <a href="#pg-59e362bf565041872395d165e99eafc1"></a></li>


    
  
    
    
	
<li>7.1.1.60: <a href="#pg-2a5040747a02ae2b2326c9901f1725d3"></a></li>


    
  
    
    
	
<li>7.1.1.61: <a href="#pg-043bd19497eefb77a6ed30a4d704fe7c"></a></li>


    
  
    
    
	
<li>7.1.1.62: <a href="#pg-bffb0d67824e75ade7232d09754b9718"></a></li>


    
  
    
    
	
<li>7.1.1.63: <a href="#pg-a37b5872c572c71775e389df50fca215"></a></li>


    
  
    
    
	
<li>7.1.1.64: <a href="#pg-3f49598c499c3356d89d98fdc8c8ad79"></a></li>


    
  
    
    
	
<li>7.1.1.65: <a href="#pg-7d68ac74e5301f789ddd2e25dd36218e"></a></li>


    
  
    
    
	
<li>7.1.1.66: <a href="#pg-e7c1ae3d905d9b6854216e26651955cd"></a></li>


    
  
    
    
	
<li>7.1.1.67: <a href="#pg-967a98823c19c8338bfc0e1338a20fb1"></a></li>


    
  
    
    
	
<li>7.1.1.68: <a href="#pg-b5838cc93a3fdb37b61afd201a71edd9"></a></li>


    
  
    
    
	
<li>7.1.1.69: <a href="#pg-f54c84a0fdada369a87b2ced6ccfc38f"></a></li>


    
  
    
    
	
<li>7.1.1.70: <a href="#pg-0d96e214c09a8f014e984a6b980522b3"></a></li>


    
  
    
    
	
<li>7.1.1.71: <a href="#pg-48afa88840a20edf1ad613c18480d4fc"></a></li>


    
  
    
    
	
<li>7.1.1.72: <a href="#pg-14da359f76a0f36af507d289dd4a5050"></a></li>


    
  
    
    
	
<li>7.1.1.73: <a href="#pg-3fda282409b804a14879b9c65c035797"></a></li>


    
  
    
    
	
<li>7.1.1.74: <a href="#pg-e044e6c69c2b1512c8d89430e0400771"></a></li>


    
  
    
    
	
<li>7.1.1.75: <a href="#pg-9f968809f867b76728697577492429e8"></a></li>


    
  
    
    
	
<li>7.1.1.76: <a href="#pg-c3c506c1683aed34398a34ab66d609da"></a></li>


    
  
    
    
	
<li>7.1.1.77: <a href="#pg-2c1a5a4405dca745ef50b4e86f5977c7"></a></li>


    
  
    
    
	
<li>7.1.1.78: <a href="#pg-003aaef561d065ecdaeb2c325b6b9253"></a></li>


    
  
    
    
	
<li>7.1.1.79: <a href="#pg-535f050663a6d8db3a61df2b19a0714b"></a></li>


    
  
    
    
	
<li>7.1.1.80: <a href="#pg-2f0a684baffe3cdf830c16693412f8e0"></a></li>


    
  
    
    
	
<li>7.1.1.81: <a href="#pg-aba528e06c437710b269f4e41f854fdd"></a></li>


    
  
    
    
	
<li>7.1.1.82: <a href="#pg-1d7987a759cd1519def4d433710cdff1"></a></li>


    
  
    
    
	
<li>7.1.1.83: <a href="#pg-33216a69b333c330cb8b305a119abc7c"></a></li>


    
  
    
    
	
<li>7.1.1.84: <a href="#pg-53abd743076fc859067264f3e8e676e0"></a></li>


    
  
    
    
	
<li>7.1.1.85: <a href="#pg-3a08eb202d572e417768a942ad24c59f"></a></li>


    
  
    
    
	
<li>7.1.1.86: <a href="#pg-11ed4820a6c3b411d9c4b87163cf0ae7"></a></li>


    
  
    
    
	
<li>7.1.1.87: <a href="#pg-e81c9d9320242b5ed4b063beea6696f8"></a></li>


    
  
    
    
	
<li>7.1.1.88: <a href="#pg-47f2d404188d6eb1fbf6fffd7fba4e48"></a></li>


    
  
    
    
	
<li>7.1.1.89: <a href="#pg-a46a193f2322aa88cb3b2de2447b0461"></a></li>


    
  
    
    
	
<li>7.1.1.90: <a href="#pg-f5b27d7bd0eeed918f8635c68d220dc5"></a></li>


    
  
    
    
	
<li>7.1.1.91: <a href="#pg-370e9ffda66b4c48dfa54ea37c3aad21"></a></li>


    
  
    
    
	
<li>7.1.1.92: <a href="#pg-6bd27042c883aa5c498647d37762392c"></a></li>


    
  
    
    
	
<li>7.1.1.93: <a href="#pg-3a000435e1cca0be398b44b487f530c8"></a></li>


    
  
    
    
	
<li>7.1.1.94: <a href="#pg-97fbe97ca22de377e7fbf2517e0451b6"></a></li>


    
  
    
    
	
<li>7.1.1.95: <a href="#pg-bee6749065a369c2ab5b311eb43c40ba"></a></li>


    
  
    
    
	
<li>7.1.1.96: <a href="#pg-bdd9680ec894593d17f782d5e5665fd4"></a></li>


    
  
    
    
	
<li>7.1.1.97: <a href="#pg-1d005baad1a1e217d7ae0210fec96c3f"></a></li>


    
  
    
    
	
<li>7.1.1.98: <a href="#pg-c79d11d27bed54caac743c93e0b2fb24"></a></li>


    
  
    
    
	
<li>7.1.1.99: <a href="#pg-ba78e64c325e4131dd741235e2a1b2c0"></a></li>


    
  
    
    
	
<li>7.1.1.100: <a href="#pg-872d33f1fbc83cb2f0bf89b4bd545174"></a></li>


    
  
    
    
	
<li>7.1.1.101: <a href="#pg-7d8c1710684742ca940f580674225d9d"></a></li>


    
  
    
    
	
<li>7.1.1.102: <a href="#pg-28dcf20d89c7bb1c8e7a3873d7703d5d"></a></li>


    
  
    
    
	
<li>7.1.1.103: <a href="#pg-f869b6331e40c6f9eb01314f96d3113e"></a></li>


    
  
    
    
	
<li>7.1.1.104: <a href="#pg-19a94d2f7649959b218952cef00729f4"></a></li>


    
  
    
    
	
<li>7.1.1.105: <a href="#pg-b22d3ed181fb7f926ae2081f8fc8c14d"></a></li>


    
  
    
    
	
<li>7.1.1.106: <a href="#pg-ae1ea74c2c21b25a3c1eacdaf549274b"></a></li>


    
  
    
    
	
<li>7.1.1.107: <a href="#pg-633020ef232bc34f60c82153578a6c9b"></a></li>


    
  
    
    
	
<li>7.1.1.108: <a href="#pg-e938edeb3d824f9b364de617a1f10a93"></a></li>


    
  
    
    
	
<li>7.1.1.109: <a href="#pg-aa9f718186487df2ab6885cae45f5d37"></a></li>


    
  
    
    
	
<li>7.1.1.110: <a href="#pg-60d816e74ec8e0301cc484b19d7694e6"></a></li>


    
  

    </ul>
    
  
    
    
	
<li>7.1.2: <a href="#pg-82b2fcf985bae77dcb754387a9fcc64f">kubeadm init</a></li>


    
  
    
    
	
<li>7.1.3: <a href="#pg-2a2b5f34806b4b1bd2c12682ac170d68">kubeadm join</a></li>


    
  
    
    
	
<li>7.1.4: <a href="#pg-2c20539d9fabf5982e2dd931742714bd">kubeadm upgrade</a></li>


    
  
    
    
	
<li>7.1.5: <a href="#pg-5042dc49c5348b3674d3878f37f7670b">kubeadm config</a></li>


    
  
    
    
	
<li>7.1.6: <a href="#pg-6eb5bc1e7114609930a76c683cc27c2b">kubeadm reset</a></li>


    
  
    
    
	
<li>7.1.7: <a href="#pg-516f4705fb2f5f62c76c7742772726a3">kubeadm token</a></li>


    
  
    
    
	
<li>7.1.8: <a href="#pg-34c4af6f36d969ed08ba840e7fb64c6d">kubeadm version</a></li>


    
  
    
    
	
<li>7.1.9: <a href="#pg-92a39c69c3689119dd5fa12886cb73a3">kubeadm alpha</a></li>


    
  
    
    
	
<li>7.1.10: <a href="#pg-6a1fed09235bbf3644c804339928f10e">kubeadm certs</a></li>


    
  
    
    
	
<li>7.1.11: <a href="#pg-fbe8dcd222ce5795a5c325670a26b067">kubeadm init phase</a></li>


    
  
    
    
	
<li>7.1.12: <a href="#pg-62a742c564b0b5b7ac12a95e67cc425a">kubeadm join phase</a></li>


    
  
    
    
	
<li>7.1.13: <a href="#pg-b969d0033ce5d9036463521fb1f150b3">kubeadm reset phase</a></li>


    
  
    
    
	
<li>7.1.14: <a href="#pg-dfd085b5ab706bd84dda15847dd27f1b">kubeadm upgrade phase</a></li>


    
  
    
    
	
<li>7.1.15: <a href="#pg-455b6412a275b743ee8ad90f35808393">实现细节</a></li>


    
  

    </ul>
    
  

    </ul>
    
  
    
    
	
<li>8: <a href="#pg-03460a7254c6c73eb2a1bb3dd7d25910">kubectl</a></li>


    
    <ul>
        
  
  
  
  

  
    
    
	
<li>8.1: <a href="#pg-f14fe15ecc2d41b5e901ef5e872ca657">kubectl 概述</a></li>


    
  
    
    
	
<li>8.2: <a href="#pg-a938176c695852fe70362c29cf615f1c">JSONPath 支持</a></li>


    
  
    
    
	
<li>8.3: <a href="#pg-4d3e62632c189fcc3c1357cd8fb8799c">kubectl</a></li>


    
  
    
    
	
<li>8.4: <a href="#pg-d7ffbf04ffbefb241fd0722423b80f5a">kubectl 命令</a></li>


    
  
    
    
	
<li>8.5: <a href="#pg-8aba901ac13f124e5782b90ddb166ee2">kubectl 备忘单</a></li>


    
  
    
    
	
<li>8.6: <a href="#pg-8de6aceb8bf692c06cced446bac5bc92">kubectl 的用法约定</a></li>


    
  
    
    
	
<li>8.7: <a href="#pg-a7abc09192597e614b58f8b552b682f5">适用于 Docker 用户的 kubectl</a></li>


    
  

    </ul>
    
  
    
    
	
<li>9: <a href="#pg-54e562dd1441d0195970a6526b0055cc">组件工具</a></li>


    
    <ul>
        
  
  
  
  

  
    
    
	
<li>9.1: <a href="#pg-ca5d01a42c486d535539d3038aa67eb9">特性门控</a></li>


    
  
    
    
	
<li>9.2: <a href="#pg-29e506a6018204679ef5459653a7aa1f">kubelet</a></li>


    
  
    
    
	
<li>9.3: <a href="#pg-ec8ff2888d36f533a57bc9704ccc84e0">kube-apiserver</a></li>


    
  
    
    
	
<li>9.4: <a href="#pg-8a37271ec8fd36a3a1ce07c4c58533d9">kube-controller-manager</a></li>


    
  
    
    
	
<li>9.5: <a href="#pg-a727de6cb5a090d5f115f88a8606c438">kube-proxy</a></li>


    
  
    
    
	
<li>9.6: <a href="#pg-57e59e5ddd9db63da6c9d27cc0e2f254">kube-scheduler</a></li>


    
  
    
    
	
<li>9.7: <a href="#pg-1715b765e2ff39feffd103d59ec0ef07">Kubelet 认证/鉴权</a></li>


    
  
    
    
	
<li>9.8: <a href="#pg-bdd3803a4bb6efcc44a7ab03590ce93c">TLS 启动引导</a></li>


    
  

    </ul>
    
  
    
    
	
<li>10: <a href="#pg-a6ae13190e147ef3922315c2091fc258">配置 API</a></li>


    
    <ul>
        
  
  
  
  

  
    
    
	
<li>10.1: <a href="#pg-2896357fe4f62fe85522254410e0be7d">Client Authentication (v1beta1)</a></li>


    
  
    
    
	
<li>10.2: <a href="#pg-8f61883225b6bed85530d1904e148392">kube-apiserver Audit Configuration (v1)</a></li>


    
  
    
    
	
<li>10.3: <a href="#pg-d8644f8d8b33ff33a31c8b55065eaf37">kube-proxy Configuration (v1alpha1)</a></li>


    
  
    
    
	
<li>10.4: <a href="#pg-d673af4d710babea20cd6b317502afb8">kube-scheduler Configuration (v1beta1)</a></li>


    
  
    
    
	
<li>10.5: <a href="#pg-699f28965d0a72527ebd04826dda8901">kube-scheduler Policy Configuration (v1)</a></li>


    
  
    
    
	
<li>10.6: <a href="#pg-aaa2b8b78fe84a05914c155652d10956">Kubelet Configuration (v1beta1)</a></li>


    
  
    
    
	
<li>10.7: <a href="#pg-74f43b2a33c21414f1ed8c359b37d326">WebhookAdmission Configuration (v1)</a></li>


    
  

    </ul>
    
  
    
    
	
<li>11: <a href="#pg-f8b023454daa9497b7eea35b7d35c075">调度</a></li>


    
    <ul>
        
  
  
  
  

  
    
    
	
<li>11.1: <a href="#pg-5a0a68fb6a7ffefb6d5f861100fa0ae3">调度策略</a></li>


    
  
    
    
	
<li>11.2: <a href="#pg-ef4fb938b6b63c95f5f26f9b1cec3054">调度器配置</a></li>


    
  

    </ul>
    
  
    
    
	
<li>12: <a href="#pg-c808ce38575e73f72835d7ed02b03780">其他工具</a></li>


    
    <ul>
        
  
  
  
  

  

    </ul>
    
  

    </ul>


<div class="content">
      <!--
title: Reference
approvers:
- chenopis
linkTitle: "Reference"
main_menu: true
weight: 70
content_type: concept
no_list: true
-->
<!-- overview -->
<!--
This section of the Kubernetes documentation contains references.
-->
<p>这是 Kubernetes 文档的参考部分。</p>
<!-- body -->
<!--
## API Reference

* [Glossary](/docs/reference/glossary/) -  a comprehensive, standardized list of Kubernetes terminology

* [Kubernetes API Reference](/docs/reference/kubernetes-api/)
* [One-page API Reference for Kubernetes v1.22](/docs/reference/generated/kubernetes-api/v1.22/)
* [Using The Kubernetes API](/docs/reference/using-api/) - overview of the API for Kubernetes.
* [API access control](/docs/reference/access-authn-authz/) - details on how Kubernetes controls API access
* [Well-Known Labels, Annotations and Taints](/docs/reference/labels-annotations-taints/)
-->
<h2 id="api-参考">API 参考</h2>
<ul>
<li>
<p><a href="/zh/docs/reference/glossary/">术语表</a> -  一个全面的标准化的 Kubernetes 术语表</p>
</li>
<li>
<p><a href="/zh/docs/reference/kubernetes-api/">Kubernetes API 单页参考</a></p>
</li>
<li>
<p><a href="/docs/reference/generated/kubernetes-api/v1.22/">Kubernetes API 参考 v1.22</a>。</p>
</li>
<li>
<p><a href="/zh/docs/reference/using-api/">使用 Kubernetes API </a> - Kubernetes 的 API 概述</p>
</li>
<li>
<p><a href="/zh/docs/reference/access-authn-authz/">API 的访问控制</a> - 关于 Kubernetes 如何控制 API 访问的详细信息</p>
</li>
<li>
<p><a href="/zh/docs/reference/labels-annotations-taints/">常见的标签、注解和污点</a></p>
</li>
</ul>
<!--
## Officially supported client libraries

To call the Kubernetes API from a programming language, you can use
[client libraries](/docs/reference/using-api/client-libraries/). Officially supported
client libraries:

- [Kubernetes Go client library](https://github.com/kubernetes/client-go/)
- [Kubernetes Python client library](https://github.com/kubernetes-client/python)
- [Kubernetes Java client library](https://github.com/kubernetes-client/java)
- [Kubernetes JavaScript client library](https://github.com/kubernetes-client/javascript)
- [Kubernetes Dotnet client library](https://github.com/kubernetes-client/csharp)
- [Kubernetes Haskell Client library](https://github.com/kubernetes-client/haskell)
-->
<h2 id="官方支持的客户端库">官方支持的客户端库</h2>
<p>如果您需要通过编程语言调用 Kubernetes API，您可以使用
<a href="/zh/docs/reference/using-api/client-libraries/">客户端库</a>。以下是官方支持的客户端库：</p>
<ul>
<li><a href="https://github.com/kubernetes/client-go/">Kubernetes Go 语言客户端库</a></li>
<li><a href="https://github.com/kubernetes-client/python">Kubernetes Python 语言客户端库</a></li>
<li><a href="https://github.com/kubernetes-client/java">Kubernetes Java 语言客户端库</a></li>
<li><a href="https://github.com/kubernetes-client/javascript">Kubernetes JavaScript 语言客户端库</a></li>
<li><a href="https://github.com/kubernetes-client/csharp">Kubernetes Dotnet 语言客户端库</a></li>
<li><a href="https://github.com/kubernetes-client/haskell">Kubernetes Haskell 语言客户端库</a></li>
</ul>
<!--
## CLI

* [kubectl](/docs/reference/kubectl/overview/) - Main CLI tool for running commands and managing Kubernetes clusters.
    * [JSONPath](/docs/reference/kubectl/jsonpath/) - Syntax guide for using [JSONPath expressions](https://goessner.net/articles/JsonPath/) with kubectl.
* [kubeadm](/docs/reference/setup-tools/kubeadm/) - CLI tool to easily provision a secure Kubernetes cluster.
-->
<h2 id="cli">CLI</h2>
<ul>
<li><a href="/zh/docs/reference/kubectl/overview/">kubectl</a> - 主要的 CLI 工具，用于运行命令和管理 Kubernetes 集群。
<ul>
<li><a href="/zh/docs/reference/kubectl/jsonpath/">JSONPath</a> - 通过 kubectl 使用
<a href="https://goessner.net/articles/JsonPath/">JSONPath 表达式</a> 的语法指南。</li>
</ul>
</li>
<li><a href="/zh/docs/reference/setup-tools/kubeadm/">kubeadm</a> - 此 CLI 工具可轻松配置安全的 Kubernetes 集群。</li>
</ul>
<!--
## Components

* [kubelet](/docs/reference/command-line-tools-reference/kubelet/) - The
  primary agent that runs on each node. The kubelet takes a set of PodSpecs
  and ensures that the described containers are running and healthy.
* [kube-apiserver](/docs/reference/command-line-tools-reference/kube-apiserver/) -
  REST API that validates and configures data for API objects such as  pods,
  services, replication controllers.
* [kube-controller-manager](/docs/reference/command-line-tools-reference/kube-controller-manager/) - Daemon that embeds the core control loops shipped with Kubernetes.
* [kube-proxy](/docs/reference/command-line-tools-reference/kube-proxy/) - Can
  do simple TCP/UDP stream forwarding or round-robin TCP/UDP forwarding across
  a set of back-ends.
* [kube-scheduler](/docs/reference/command-line-tools-reference/kube-scheduler/) - Scheduler that manages availability, performance, and capacity.
  
  * [Scheduler Policies](/docs/reference/scheduling/policies)
  * [Scheduler Profiles](/docs/reference/scheduling/config#profiles)
-->
<h2 id="组件">组件</h2>
<ul>
<li>
<p><a href="/zh/docs/reference/command-line-tools-reference/kubelet/">kubelet</a> -
在每个节点上运行的主代理。kubelet 接收一组 PodSpecs 并确保其所描述的容器健康地运行。</p>
</li>
<li>
<p><a href="/zh/docs/reference/command-line-tools-reference/kube-apiserver/">kube-apiserver</a> -
REST API，用于验证和配置 API 对象（如 Pod、服务或副本控制器等）的数据。</p>
</li>
<li>
<p><a href="/zh/docs/reference/command-line-tools-reference/kube-controller-manager/">kube-controller-manager</a> -
一个守护进程，其中包含 Kubernetes 所附带的核心控制回路。</p>
</li>
<li>
<p><a href="/zh/docs/reference/command-line-tools-reference/kube-proxy/">kube-proxy</a> -
可进行简单的 TCP/UDP 流转发或针对一组后端执行轮流 TCP/UDP 转发。</p>
</li>
<li>
<p><a href="/zh/docs/reference/command-line-tools-reference/kube-scheduler/">kube-scheduler</a> -
一个调度程序，用于管理可用性、性能和容量。</p>
<ul>
<li><a href="/zh/docs/reference/scheduling/policies">调度策略</a></li>
<li><a href="/zh/docs/reference/scheduling/config#profiles">调度配置</a></li>
</ul>
</li>
</ul>
<!--
## Config APIs

This section hosts the documentation for "unpublished" APIs which are used to
configure  kubernetes components or tools. Most of these APIs are not exposed
by the API server in a RESTful way though they are essential for a user or an
operator to use or manage a cluster.

* [kubelet configuration (v1beta1)](/docs/reference/config-api/kubelet-config.v1beta1/)
* [kube-scheduler configuration (v1beta1)](/docs/reference/config-api/kube-scheduler-config.v1beta1/)
* [kube-scheduler policy reference (v1)](/docs/reference/config-api/kube-scheduler-policy-config.v1/)
* [kube-proxy configuration (v1alpha1)](/docs/reference/config-api/kube-proxy-config.v1alpha1/)
* [`audit.k8s.io/v1` API](/docs/reference/config-api/apiserver-audit.v1/)
* [Client authentication API (v1beta1)](/docs/reference/config-api/client-authentication.v1beta1/)
* [WebhookAdmission configuration (v1)](/docs/reference/config-api/apiserver-webhookadmission.v1/)
-->
<h2 id="配置-api">配置 API</h2>
<p>本节包含用于配置 kubernetes 组件或工具的 &quot;未发布&quot; API 的文档。
尽管这些 API 对于用户或操作者使用或管理集群来说是必不可少的，
它们大都没有以 RESTful 的方式在 API 服务器上公开。</p>
<ul>
<li><a href="/zh/docs/reference/config-api/kubelet-config.v1beta1/">kubelet 配置 (v1beta1)</a></li>
<li><a href="/zh/docs/reference/config-api/kube-scheduler-config.v1beta1/">kube-scheduler 配置 (v1beta1)</a></li>
<li><a href="/zh/docs/reference/config-api/kube-scheduler-policy-config.v1/">kube-scheduler 策略参考 (v1)</a></li>
<li><a href="/zh/docs/reference/config-api/kube-proxy-config.v1alpha1/">kube-proxy 配置 (v1alpha1)</a></li>
<li><a href="/zh/docs/reference/config-api/apiserver-audit.v1/"><code>audit.k8s.io/v1</code> API</a></li>
<li><a href="/zh/docs/reference/config-api/client-authentication.v1beta1/">客户端认证 API (v1beta1)</a></li>
<li><a href="/zh/docs/reference/config-api/apiserver-webhookadmission.v1/">WebhookAdmission 配置 (v1)</a></li>
</ul>
<!--
## Design Docs

An archive of the design docs for Kubernetes functionality. Good starting points are
[Kubernetes Architecture](https://git.k8s.io/community/contributors/design-proposals/architecture/architecture.md) and
[Kubernetes Design Overview](https://git.k8s.io/community/contributors/design-proposals).
-->
<h2 id="设计文档">设计文档</h2>
<p>Kubernetes 功能的设计文档归档，不妨考虑从
<a href="https://git.k8s.io/community/contributors/design-proposals/architecture/architecture.md">Kubernetes 架构</a> 和
<a href="https://git.k8s.io/community/contributors/design-proposals">Kubernetes 设计概述</a>
开始阅读。</p>

</div>
</div>


  
  
  
  

  
  

  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-2b03679960950df772fb4fe7d78427b9">1 - 词汇表</h1>
    
	
</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-882c82a32bfb4d7946585a93a966b442">2 - API 概述</h1>
    
	<!-- overview -->
<!--
This section provides reference information for the Kubernetes API.
-->
<p>本文提供了 Kubernetes API 的参考信息。</p>
<!--
The REST API is the fundamental fabric of Kubernetes. All operations and
communications between components, and external user commands are REST API
calls that the API Server handles. Consequently, everything in the Kubernetes
platform is treated as an API object and has a corresponding entry in the
[API](/docs/reference/generated/kubernetes-api/v1.22/).
-->
<p>REST API 是 Kubernetes 的基本结构。
所有操作和组件之间的通信及外部用户命令都是调用 API 服务器处理的 REST API。
因此，Kubernetes 平台视一切皆为 API 对象，
且它们在 <a href="/docs/reference/generated/kubernetes-api/v1.22/">API</a> 中有相应的定义。</p>
<!--
The [Kubernetes API reference](/docs/reference/generated/kubernetes-api/v1.22/)
lists the API for Kubernetes version v1.22.
-->
<p><a href="/docs/reference/generated/kubernetes-api/v1.22/">Kubernetes API 参考</a>列
出了 Kubernetes v1.22 版本的 API。</p>
<!--
For general background information, read
[The Kubernetes API](/docs/concepts/overview/kubernetes-api/).
[Controlling Access to the Kubernetes API](/docs/concepts/security/controlling-access/)
describes how clients can authenticate to the Kubernetes API server, and how their
requests are authorized.
-->
<p>如需了解一般背景信息，请查阅 <a href="/zh/docs/concepts/overview/kubernetes-api/">Kubernetes API</a>。
<a href="/zh/docs/concepts/security/controlling-access/">Kubernetes API 控制访问</a>描述了客户端如何
向 Kubernetes API 服务器进行身份认证以及他们的请求如何被鉴权。</p>
<!--
## API versioning
-->
<h2 id="api-版本控制">API 版本控制</h2>
<!--
The JSON and Protobuf serialization schemas follow the same guidelines for
schema changes. The following descriptions cover both formats.
-->
<p>JSON 和 Protobuf 序列化模式遵循相同的模式更改原则。
以下描述涵盖了这两种格式。</p>
<!--
The API versioning and software versioning are indirectly related.
The [API and release versioning proposal](https://git.k8s.io/community/contributors/design-proposals/release/versioning.md)
describes the relationship between API versioning and software versioning.
-->
<p>API 版本控制和软件版本控制是间接相关的。
<a href="https://git.k8s.io/community/contributors/design-proposals/release/versioning.md">API 和发布版本控制提案</a>
描述了 API 版本控制和软件版本控制间的关系。</p>
<!--
Different API versions indicate different levels of stability and support. You
can find more information about the criteria for each level in the
[API Changes documentation](https://git.k8s.io/community/contributors/devel/sig-architecture/api_changes.md#alpha-beta-and-stable-versions).
-->
<p>不同的 API 版本代表着不同的稳定性和支持级别。
你可以在 <a href="https://git.k8s.io/community/contributors/devel/sig-architecture/api_changes.md#alpha-beta-and-stable-versions">API 变更文档</a>
中查看到更多的不同级别的判定标准。</p>
<!--
Here's a summary of each level:
-->
<p>下面是每个级别的摘要：</p>
<!--
- Alpha:
  - The version names contain `alpha` (for example, `v1alpha1`).
  - The software may contain bugs. Enabling a feature may expose bugs. A
    feature may be disabled by default.
  - The support for a feature may be dropped at any time without notice.
  - The API may change in incompatible ways in a later software release without notice.
  - The software is recommended for use only in short-lived testing clusters,
    due to increased risk of bugs and lack of long-term support.
-->
<ul>
<li>Alpha:
<ul>
<li>版本名称包含 <code>alpha</code>（例如，<code>v1alpha1</code>）。</li>
<li>软件可能会有 Bug。启用某个特性可能会暴露出 Bug。
某些特性可能默认禁用。</li>
<li>对某个特性的支持可能会随时被删除，恕不另行通知。</li>
<li>API 可能在以后的软件版本中以不兼容的方式更改，恕不另行通知。</li>
<li>由于缺陷风险增加和缺乏长期支持，建议该软件仅用于短期测试集群。</li>
</ul>
</li>
</ul>
<!--
- Beta:
  - The version names contain `beta` (for example, `v2beta3`).
  - The software is well tested. Enabling a feature is considered safe.
    Features are enabled by default.
  - The support for a feature will not be dropped, though the details may change.
-->
<ul>
<li>
<p>Beta:</p>
<ul>
<li>版本名称包含 <code>beta</code> （例如， <code>v2beta3</code>）。</li>
<li>软件被很好的测试过。启用某个特性被认为是安全的。
特性默认开启。</li>
<li>尽管一些特性会发生细节上的变化，但它们将会被长期支持。</li>
</ul>
<!--
- The schema and/or semantics of objects may change in incompatible ways in
  a subsequent beta or stable release. When this happens, migration
  instructions are provided. Schema changes may require deleting, editing, and
  re-creating API objects. The editing process may not be straightforward.
  The migration may require downtime for applications that rely on the feature.
- The software is not recommended for production uses. Subsequent releases
  may introduce incompatible changes. If you have multiple clusters which
  can be upgraded independently, you may be able to relax this restriction.
-->
<ul>
<li>在随后的 Beta 版或稳定版中，对象的模式和（或）语义可能以不兼容的方式改变。
当这种情况发生时，将提供迁移说明。
模式更改可能需要删除、编辑和重建 API 对象。
编辑过程可能并不简单。
对于依赖此功能的应用程序，可能需要停机迁移。</li>
<li>该版本的软件不建议生产使用。
后续发布版本可能会有不兼容的变动。
如果你有多个集群可以独立升级，可以放宽这一限制。</li>
</ul>
<!--
Please try beta features and provide feedback. After the features exit beta, it
may not be practical to make more changes.
-->
<blockquote class="note callout">
  <div><strong>说明：</strong> 请试用测试版特性时并提供反馈。特性完成 Beta 阶段测试后，
就可能不会有太多的变更了。</div>
</blockquote>
</li>
</ul>
<!--
- Stable:
  - The version name is `vX` where `X` is an integer.
  - The stable versions of features appear in released software for many subsequent versions.
-->
<ul>
<li>Stable:
<ul>
<li>版本名称如 <code>vX</code>，其中 <code>X</code> 为整数。</li>
<li>特性的稳定版本会出现在后续很多版本的发布软件中。</li>
</ul>
</li>
</ul>
<!--## API groups-->
<h2 id="api-组">API 组</h2>
<!--
[API groups](https://git.k8s.io/community/contributors/design-proposals/api-machinery/api-group.md)
make it easier to extend the Kubernetes API.
The API group is specified in a REST path and in the `apiVersion` field of a
serialized object.
-->
<p><a href="https://git.k8s.io/community/contributors/design-proposals/api-machinery/api-group.md">API 组</a>
能够简化对 Kubernetes API 的扩展。
API 组信息出现在REST 路径中，也出现在序列化对象的 <code>apiVersion</code> 字段中。</p>
<!--
There are several API groups in Kubernetes:

*  The *core* (also called *legacy*) group is found at REST path `/api/v1`.
   The core group is not specified as part of the `apiVersion` field, for
   example, `apiVersion: v1`.
*  The named groups are at REST path `/apis/$GROUP_NAME/$VERSION` and use
   `apiVersion: $GROUP_NAME/$VERSION` (for example, `apiVersion: batch/v1`).
   You can find the full list of supported API groups in
   [Kubernetes API reference](/docs/reference/generated/kubernetes-api/v1.22/#-strong-api-groups-strong-).
-->
<p>以下是 Kubernetes 中的几个组：</p>
<ul>
<li><em>核心</em>（也叫 <em>legacy</em>）组的 REST 路径为 <code>/api/v1</code>。
核心组并不作为 <code>apiVersion</code> 字段的一部分，例如， <code>apiVersion: v1</code>。</li>
<li>指定的组位于 REST 路径 <code>/apis/$GROUP_NAME/$VERSION</code>，
并且使用 <code>apiVersion: $GROUP_NAME/$VERSION</code> （例如， <code>apiVersion: batch/v1</code>）。
你可以在 <a href="/docs/reference/generated/kubernetes-api/v1.22/#-strong-api-groups-strong-">Kubernetes API 参考文档</a>
中查看全部的 API 组。</li>
</ul>
<!--
## Enabling or disabling API groups   {#enabling-or-disabling}

Certain resources and API groups are enabled by default. You can enable or
disable them by setting `--runtime-config` on the API server.  The
`--runtime-config` flag accepts comma separated `<key>[=<value>]` pairs
describing the runtime configuration of the API server. If the `=<value>`
part is omitted, it is treated as if `=true` is specified. For example:

 - to disable `batch/v1`, set `--runtime-config=batch/v1=false`
 - to enable `batch/v2alpha1`, set `--runtime-config=batch/v2alpha1`
-->
<h2 id="enabling-or-disabling">启用或禁用 API 组  </h2>
<p>资源和 API 组是在默认情况下被启用的。
你可以通过在 API 服务器上设置 <code>--runtime-config</code> 参数来启用或禁用它们。
<code>--runtime-config</code> 参数接受逗号分隔的 <code>&lt;key&gt;[=&lt;value&gt;]</code> 对，
来描述 API 服务器的运行时配置。如果省略了 <code>=&lt;value&gt;</code> 部分，那么视其指定为 <code>=true</code>。
例如：</p>
<ul>
<li>禁用 <code>batch/v1</code>， 对应参数设置 <code>--runtime-config=batch/v1=false</code></li>
<li>启用 <code>batch/v2alpha1</code>， 对应参数设置 <code>--runtime-config=batch/v2alpha1</code></li>
</ul>
<!--
When you enable or disable groups or resources, you need to restart the API
server and controller manager to pick up the `--runtime-config` changes.
-->
<blockquote class="note callout">
  <div><strong>说明：</strong> 启用或禁用组或资源时，
你需要重启 API 服务器和控制器管理器来使 <code>--runtime-config</code> 生效。</div>
</blockquote>
<!--
## Persistence
-->
<h2 id="持久化">持久化</h2>
<!--
Kubernetes stores its serialized state in terms of the API resources by writing them into
-->
<p>Kubernetes 通过 API 资源来将序列化的状态写到 <a class='glossary-tooltip' title='etcd 是兼具一致性和高可用性的键值数据库，用作保存 Kubernetes 所有集群数据的后台数据库。' data-toggle='tooltip' data-placement='top' href='/zh/docs/tasks/administer-cluster/configure-upgrade-etcd/' target='_blank' aria-label='etcd'>etcd</a> 中存储。</p>
<h2 id="接下来">接下来</h2>
<!--
- Learn more about [API conventions](https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#api-conventions)
- Read the design documentation for
  [aggregator](https://github.com/kubernetes/community/blob/master/contributors/design-proposals/api-machinery/aggregated-api-servers.md)
-->
<ul>
<li>进一步了解 <a href="https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#api-conventions">API 惯例</a></li>
<li>阅读 <a href="https://github.com/kubernetes/community/blob/master/contributors/design-proposals/api-machinery/aggregated-api-servers.md">聚合器</a></li>
</ul>

</div>



    
      
  
  
  
  

  
  

  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-2b5428a2ff6f4831fd972ef50e12b3eb">2.1 - Kubernetes API 概念</h1>
    
	<!--
title: Kubernetes API Concepts
reviewers:
- smarterclayton
- lavalamp
- liggitt
content_type: concept
weight: 20
-->
<!-- overview -->
<!--
This page describes common concepts in the Kubernetes API.
-->
<p>本页描述 Kubernetes API 的通用概念。</p>
<!-- body -->
<!--
The Kubernetes API is a resource-based (RESTful) programmatic interface provided via HTTP. It supports retrieving, creating,
updating, and deleting primary resources via the standard HTTP verbs (POST, PUT, PATCH, DELETE, GET), includes additional subresources for many objects that allow fine grained authorization (such as binding a pod to a node), and can accept and serve those resources in different representations for convenience or efficiency. It also supports efficient change notifications on resources via "watches" and consistent lists to allow other components to effectively cache and synchronize the state of resources.
-->
<p>Kubernetes API 是基于资源的（RESTful）、通过 HTTP 提供的编程接口。
API 支持通过标准的 HTTP 动词（POST、PUT、PATCH、DELETE 和  GET）
检视、创建、更新和删除主要资源，为很多允许细粒度权限控制的对象提供子资源
（如将 Pod 绑定到节点上），并且出于便利性或效率考虑，支持并提供这些资源的
不同表示形式。
Kubernetes  API 还通过 &quot;watch&quot; 和一致性的列表支持高效的资源变更通知，
从而允许其他组件对资源的状态进行高效的缓存和同步。</p>
<!--
## Standard API terminology

Most Kubernetes API resource types are [objects](/docs/concepts/overview/working-with-objects/kubernetes-objects/#kubernetes-objects): they represent a concrete instance of a concept on the cluster, like a pod or namespace. A smaller number of API resource types are "virtual" - they often represent operations rather than objects, such as a permission check (use a POST with a JSON-encoded body of `SubjectAccessReview` to the `subjectaccessreviews` resource). All objects will have a unique name to allow idempotent creation and retrieval, but virtual resource types may not have unique names if they are not retrievable or do not rely on idempotency.
-->
<h2 id="standard-api-terminology">标准 API 术语 </h2>
<p>大多数 Kubernetes API 资源类型都是
<a href="/zh/docs/concepts/overview/working-with-objects/kubernetes-objects/#kubernetes-objects">对象</a>：
它们代表的是集群中某一概念的具体实例，例如一个 Pod 或名字空间。
为数不多的几个 API 资源类型是“虚拟的” - 它们通常代表的是操作而非对象本身，
例如访问权限检查（使用 POST 请求发送一个 JSON 编码的 <code>SubjectAccessReview</code>
负载到 <code>subjectaccessreviews</code> 资源）。
所有对象都有一个唯一的名字，以便支持幂等的创建和检视操作，不过如果虚拟资源类型
不可检视或者不要求幂等，可以不具有唯一的名字。</p>
<!--
Kubernetes generally leverages standard RESTful terminology to describe the API concepts:

* A **resource type** is the name used in the URL (`pods`, `namespaces`, `services`)
* All resource types have a concrete representation in JSON (their object schema) which is called a **kind**
* A list of instances of a resource type is known as a **collection**
* A single instance of the resource type is called a **resource**
-->
<p>Kubernetes 一般会利用标准的 RESTful 术语来描述 API 概念：</p>
<ul>
<li><strong>资源类型（Resource Type）</strong> 是在 URL 中使用的名称（<code>pods</code>、<code>namespaces</code>、<code>services</code>）</li>
<li>所有资源类型都有具有一个 JSON 形式（其对象的模式定义）的具体表示，称作<strong>类别（Kind）</strong></li>
<li>某资源类型的实例的列表称作 <strong>集合（Collection）</strong></li>
<li>资源类型的单个实例被称作 <strong>资源（Resource）</strong></li>
</ul>
<!--
All resource types are either scoped by the cluster (`/apis/GROUP/VERSION/*`) or to a namespace (`/apis/GROUP/VERSION/namespaces/NAMESPACE/*`). A namespace-scoped resource type will be deleted when its namespace is deleted and access to that resource type is controlled by authorization checks on the namespace scope. The following paths are used to retrieve collections and resources:

* Cluster-scoped resources:
  * `GET /apis/GROUP/VERSION/RESOURCETYPE` - return the collection of resources of the resource type
  * `GET /apis/GROUP/VERSION/RESOURCETYPE/NAME` - return the resource with NAME under the resource type
* Namespace-scoped resources:
  * `GET /apis/GROUP/VERSION/RESOURCETYPE` - return the collection of all instances of the resource type across all namespaces
  * `GET /apis/GROUP/VERSION/namespaces/NAMESPACE/RESOURCETYPE` - return collection of all instances of the resource type in NAMESPACE
  * `GET /apis/GROUP/VERSION/namespaces/NAMESPACE/RESOURCETYPE/NAME` - return the instance of the resource type with NAME in NAMESPACE
-->
<p>所有资源类型要么是集群作用域的（<code>/apis/GROUP/VERSION/*</code>），要么是名字空间
作用域的（<code>/apis/GROUP/VERSION/namespaces/NAMESPACE/*</code>）。
名字空间作用域的资源类型会在其名字空间被删除时也被删除，并且对该资源类型的
访问是由定义在名字空间域中的授权检查来控制的。
下列路径用来检视集合和资源：</p>
<ul>
<li>集群作用域的资源：
<ul>
<li><code>GET /apis/GROUP/VERSION/RESOURCETYPE</code> - 返回指定资源类型的资源的集合</li>
<li><code>GET /apis/GROUP/VERSION/RESOURCETYPE/NAME</code> - 返回指定资源类型下名称为 NAME 的资源</li>
</ul>
</li>
<li>名字空间作用域的资源：
<ul>
<li><code>GET /apis/GROUP/VERSION/RESOURCETYPE</code> - 返回所有名字空间中指定资源类型的全部实例的集合</li>
<li><code>GET /apis/GROUP/VERSION/namespaces/NAMESPACE/RESOURCETYPE</code> - 返回名字空间 NAMESPACE 内给定资源类型的全部实例的集合</li>
<li><code>GET /apis/GROUP/VERSION/namespaces/NAMESPACE/RESOURCETYPE/NAME</code> - 返回名字空间 NAMESPACE 中给定资源类型的名称为 NAME 的实例</li>
</ul>
</li>
</ul>
<!--
Since a namespace is a cluster-scoped resource type, you can retrieve the list of all namespaces with `GET /api/v1/namespaces` and details about a particular namespace with `GET /api/v1/namespaces/NAME`.

Almost all object resource types support the standard HTTP verbs - GET, POST, PUT, PATCH, and DELETE. Kubernetes uses the term **list** to describe returning a collection of resources to distinguish from retrieving a single resource which is usually called a **get**.
-->
<p>由于名字空间本身是一个集群作用域的资源类型，你可以通过 <code>GET /api/v1/namespaces/</code>
检视所有名字空间的列表，使用 <code>GET /api/v1/namespaces/NAME</code> 查看特定名字空间的
详细信息。</p>
<p>几乎所有对象资源类型都支持标准的 HTTP 动词 - GET、POST、PUT、PATCH 和 DELETE。
Kubernetes 使用术语 <strong>list</strong> 来描述返回资源集合的操作，以便与返回单个资源的、
通常称作 <strong>get</strong> 的操作相区分。</p>
<!--
Some resource types will have one or more sub-resources, represented as sub paths below the resource:

* Cluster-scoped subresource: `GET /apis/GROUP/VERSION/RESOURCETYPE/NAME/SUBRESOURCE`
* Namespace-scoped subresource: `GET /apis/GROUP/VERSION/namespaces/NAMESPACE/RESOURCETYPE/NAME/SUBRESOURCE`

The verbs supported for each subresource will differ depending on the object - see the API documentation more information. It is not possible to access sub-resources across multiple resources - generally a new virtual resource type would be used if that becomes necessary.
-->
<p>某些资源类型有一个或多个子资源（Sub-resource），表现为对应资源下面的子路径：</p>
<ul>
<li>集群作用域的子资源：<code>GET /apis/GROUP/VERSION/RESOURCETYPE/NAME/SUBRESOURCE</code></li>
<li>名字空间作用域的子资源：<code>GET /apis/GROUP/VERSION/namespaces/NAMESPACE/RESOURCETYPE/NAME/SUBRESOURCE</code></li>
</ul>
<p>取决于对象是什么，每个子资源所支持的动词有所不同 - 参见 API 文档以了解更多信息。
跨多个资源来访问其子资源是不可能的 - 如果需要这一能力，则通常意味着需要一种
新的虚拟资源类型了。</p>
<!--
## Efficient detection of changes

To enable clients to build a model of the current state of a cluster, all Kubernetes object resource types are required to support consistent lists and an incremental change notification feed called a **watch**.  Every Kubernetes object has a `resourceVersion` field representing the version of that resource as stored in the underlying database. When retrieving a collection of resources (either namespace or cluster scoped), the response from the server will contain a `resourceVersion` value that can be used to initiate a watch against the server. The server will return all changes (creates, deletes, and updates) that occur after the supplied `resourceVersion`. This allows a client to fetch the current state and then watch for changes without missing any updates. If the client watch is disconnected they can restart a new watch from the last returned `resourceVersion`, or perform a new collection request and begin again. See [Resource Version Semantics](#resource-versions) for more detail.

For example:
-->
<h2 id="efficient-detection-of-changes">高效检测变更 </h2>
<p>为了使客户端能够构造一个模型来表达集群的当前状态，所有 Kubernetes 对象资源类型
都需要支持一致的列表和一个称作 <strong>watch</strong> 的增量变更通知信源（feed）。
每个 Kubernetes 对象都有一个 <code>resourceVersion</code> 字段，代表该资源在下层数据库中
存储的版本。检视资源集合（名字空间作用域或集群作用域）时，服务器返回的响应
中会包含 <code>resourceVersion</code> 值，可用来向服务器发起 watch 请求。
服务器会返回所提供的 <code>resourceVersion</code> 之后发生的所有变更（创建、删除和更新）。
这使得客户端能够取回当前的状态并监视其变更，且不会错过任何变更事件。
客户端的监视连接被断开时，可以从最后返回的 <code>resourceVersion</code> 重启新的监视连接，
或者执行一个新的集合请求之后从头开始监视操作。
参阅<a href="#resource-versions">资源版本语义</a>以了解更多细节。</p>
<p>例如：</p>
<!--
1. List all of the pods in a given namespace.
-->
<ol>
<li>
<p>列举给定名字空间中的所有 Pods：</p>
<pre tabindex="0"><code class="language-console" data-lang="console">GET /api/v1/namespaces/test/pods
---
200 OK
Content-Type: application/json
{
  &quot;kind&quot;: &quot;PodList&quot;,
  &quot;apiVersion&quot;: &quot;v1&quot;,
  &quot;metadata&quot;: {&quot;resourceVersion&quot;:&quot;10245&quot;},
  &quot;items&quot;: [...]
}
</code></pre></li>
</ol>
<!--
2. Starting from resource version 10245, receive notifications of any creates, deletes, or updates as individual JSON objects.
-->
<ol start="2">
<li>
<p>从资源版本 10245 开始，以 JSON 对象的形式接收所有创建、删除或更新操作的通知：</p>
<pre tabindex="0"><code class="language-console" data-lang="console">GET /api/v1/namespaces/test/pods?watch=1&amp;resourceVersion=10245
---
200 OK
Transfer-Encoding: chunked
Content-Type: application/json

{
  &quot;type&quot;: &quot;ADDED&quot;,
  &quot;object&quot;: {&quot;kind&quot;: &quot;Pod&quot;, &quot;apiVersion&quot;: &quot;v1&quot;, &quot;metadata&quot;: {&quot;resourceVersion&quot;: &quot;10596&quot;, ...}, ...}
}
{
  &quot;type&quot;: &quot;MODIFIED&quot;,
  &quot;object&quot;: {&quot;kind&quot;: &quot;Pod&quot;, &quot;apiVersion&quot;: &quot;v1&quot;, &quot;metadata&quot;: {&quot;resourceVersion&quot;: &quot;11020&quot;, ...}, ...}
}
...
</code></pre></li>
</ol>
<!--
A given Kubernetes server will only preserve a historical list of changes for a limited time. Clusters using etcd3 preserve changes in the last 5 minutes by default.  When the requested watch operations fail because the historical version of that resource is not available, clients must handle the case by recognizing the status code `410 Gone`, clearing their local cache, performing a list operation, and starting the watch from the `resourceVersion` returned by that new list operation. Most client libraries offer some form of standard tool for this logic. (In Go this is called a `Reflector` and is located in the `k8s.io/client-go/cache` package.)
-->
<p>给定的 Kubernetes 服务器只会保留一定的时间内发生的历史变更列表。
使用 etcd3 的集群默认保存过去 5 分钟内发生的变更。
当所请求的 watch 操作因为资源的历史版本不存在而失败，客户端必须能够处理
因此而返回的状态代码 <code>410 Gone</code>，清空其本地的缓存，重新执行 list 操作，
并基于新的 list 操作所返回的 <code>resourceVersion</code> 来开始新的 watch 操作。
大多数客户端库都能够提供某种形式的、包含此逻辑的工具。
（在 Go 语言客户端库中，这一设施称作 <code>Reflector</code>，位于
<code>k8s.io/client-go/cache</code> 包中。)</p>
<!--
### Watch bookmarks

To mitigate the impact of short history window, we introduced a concept of `bookmark` watch event. It is a special kind of event to mark that all changes up to a given `resourceVersion` the client is requesting have already been sent. Object returned in that event is of the type requested by the request, but only `resourceVersion` field is set, e.g.:
-->
<h3 id="Watch-bookmark">监视书签 </h3>
<p>为了处理历史窗口过短的问题，我们引入了 <code>bookmark（书签）</code> 监视事件的概念。
该事件是一种特殊事件，用来标示客户端所请求的、指定的 <code>resourceVersion</code> 之前
的所有变更都以被发送。该事件中返回的对象是所请求的资源类型，但其中仅包含
<code>resourceVersion</code> 字段，例如：</p>
<pre tabindex="0"><code class="language-console" data-lang="console">GET /api/v1/namespaces/test/pods?watch=1&amp;resourceVersion=10245&amp;allowWatchBookmarks=true
---
200 OK
Transfer-Encoding: chunked
Content-Type: application/json

{
  &quot;type&quot;: &quot;ADDED&quot;,
  &quot;object&quot;: {&quot;kind&quot;: &quot;Pod&quot;, &quot;apiVersion&quot;: &quot;v1&quot;, &quot;metadata&quot;: {&quot;resourceVersion&quot;: &quot;10596&quot;, ...}, ...}
}
...
{
  &quot;type&quot;: &quot;BOOKMARK&quot;,
  &quot;object&quot;: {&quot;kind&quot;: &quot;Pod&quot;, &quot;apiVersion&quot;: &quot;v1&quot;, &quot;metadata&quot;: {&quot;resourceVersion&quot;: &quot;12746&quot;} }
}
</code></pre><!--
`Bookmark` events can be requested by `allowWatchBookmarks=true` option in watch requests, but clients shouldn't assume bookmarks are returned at any specific interval, nor may they assume the server will send any `bookmark` event.
-->
<p>通过在 watch 请求中设置 <code>allowWatchBookmarks=true</code> 选项，可以请求 <code>bookmark</code>
事件，但是客户端不能假定服务器端会按某特定时间间隔返回书签事件，甚至也不能
假定服务器一定会发送 <code>bookmark</code> 事件。</p>
<!--
## Retrieving large results sets in chunks
-->
<h2 id="retrieving-large-results-sets-in-chunks">分块检视大体量结果 </h2>





<div style="margin-top: 10px; margin-bottom: 10px;">
<b>FEATURE STATE:</b> <code>Kubernetes v1.9 [beta]</code>
</div>

<!--
On large clusters, retrieving the collection of some resource types may result in very large responses that can impact the server and client. For instance, a cluster may have tens of thousands of pods, each of which is 1-2kb of encoded JSON. Retrieving all pods across all namespaces may result in a very large response (10-20MB) and consume a large amount of server resources. Starting in Kubernetes 1.9 the server supports the ability to break a single large collection request into many smaller chunks while preserving the consistency of the total request. Each chunk can be returned sequentially which reduces both the total size of the request and allows user-oriented clients to display results incrementally to improve responsiveness.
-->
<p>在较大规模的集群中，检视某些资源类型的集合时可能会返回较大体量的响应数据，对
服务器和客户端都会造成影响。例如，某集群可能包含数万个 Pod，每个 Pod 的 JSON
编码都有 1-2 KB 的大小。返回所有名字空间的全部 Pod 时，其结果可能体量很大
（10-20 MB）且耗用大量的服务器资源。
从 Kubernetes 1.9 开始，服务器支持将单一的大体量集合请求分解成多个小数据块
同时还保证整个请求的一致性的能力。
各个数据块可以按顺序返回，进而降低请求的尺寸，允许面向用户的客户端以增量形式
呈现返回结果，改进系统响应效果。</p>
<!--
To retrieve a single list in chunks, two new parameters `limit` and `continue`
are supported on collection requests and a new field `continue` is returned
from all list operations in the list `metadata` field. A client should specify
the maximum results they wish to receive in each chunk with `limit` and the
server will return up to `limit` resources in the result and include a
`continue` value if there are more resources in the collection. The client can
then pass this `continue` value to the server on the next request to instruct
the server to return the next chunk of results. By continuing until the server
returns an empty `continue` value the client can consume the full set of
results.
-->
<p>为了用分块的形式返回一个列表，集合请求上可以设置两个新的参数 <code>limit</code> 和
<code>continue</code>，并且所有 list 操作的返回结果列表的 <code>metadata</code> 字段中会包含一个
新的 <code>continue</code> 字段。
客户端应该将 <code>limit</code> 设置为希望在每个数据块中收到的结果个数上限，而服务器则
会在结果中至多返回 <code>limit</code> 个资源并在集合中还有更多资源的时候包含一个
<code>continue</code> 值。客户端在下次请求时则可以将此 <code>continue</code> 值传递给服务器，
告知后者要从何处开始返回结果的下一个数据块。
通过重复这一操作直到服务器端返回空的 <code>continue</code> 值，客户端可以受到结果的
全集。</p>
<!--
Like a watch operation, a `continue` token will expire after a short amount of time (by default 5 minutes) and return a `410 Gone` if more results cannot be returned. In this case, the client will need to start from the beginning or omit the `limit` parameter.

For example, if there are 1,253 pods on the cluster and the client wants to receive chunks of 500 pods at a time, they would request those chunks as follows:
-->
<p>与 watch 操作类似，<code>continue</code> 令牌也会在很短的时间（默认为 5 分钟）内过期，
并在无法返回更多结果时返回 <code>410 Gone</code> 代码。
这时，客户端需要从头开始执行上述检视操作或者忽略 <code>limit</code> 参数。</p>
<p>例如，如果集群上有 1253 个 Pods，客户端希望每次收到包含至多 500 个 Pod 的
数据块，它应按下面的步骤来请求数据块：</p>
<!--
1. List all of the pods on a cluster, retrieving up to 500 pods each time.
-->
<ol>
<li>列举集群中所有 Pod，每次接收至多 500 个 Pods：</li>
</ol>
<pre tabindex="0"><code class="language-console" data-lang="console">GET /api/v1/pods?limit=500
---
200 OK
Content-Type: application/json

{
  &quot;kind&quot;: &quot;PodList&quot;,
  &quot;apiVersion&quot;: &quot;v1&quot;,
  &quot;metadata&quot;: {
    &quot;resourceVersion&quot;:&quot;10245&quot;,
    &quot;continue&quot;: &quot;ENCODED_CONTINUE_TOKEN&quot;,
    ...
  },
  &quot;items&quot;: [...] // returns pods 1-500
}
</code></pre><!--
2. Continue the previous call, retrieving the next set of 500 pods.
-->
<ol start="2">
<li>继续前面的调用，返回下一组 500 个 Pods：</li>
</ol>
<pre tabindex="0"><code class="language-console" data-lang="console">GET /api/v1/pods?limit=500&amp;continue=ENCODED_CONTINUE_TOKEN
---
200 OK
Content-Type: application/json

{
  &quot;kind&quot;: &quot;PodList&quot;,
  &quot;apiVersion&quot;: &quot;v1&quot;,
  &quot;metadata&quot;: {
    &quot;resourceVersion&quot;:&quot;10245&quot;,
    &quot;continue&quot;: &quot;ENCODED_CONTINUE_TOKEN_2&quot;,
    ...
  },
  &quot;items&quot;: [...] // returns pods 501-1000
}
</code></pre><!--
3. Continue the previous call, retrieving the last 253 pods.
-->
<ol start="3">
<li>继续前面的调用，返回最后 253 个 Pods：</li>
</ol>
<pre tabindex="0"><code class="language-console" data-lang="console">GET /api/v1/pods?limit=500&amp;continue=ENCODED_CONTINUE_TOKEN_2
---
200 OK
Content-Type: application/json

{
  &quot;kind&quot;: &quot;PodList&quot;,
  &quot;apiVersion&quot;: &quot;v1&quot;,
  &quot;metadata&quot;: {
    &quot;resourceVersion&quot;:&quot;10245&quot;,
    &quot;continue&quot;: &quot;&quot;, // continue token is empty because we have reached the end of the list
    ...
  },
  &quot;items&quot;: [...] // returns pods 1001-1253
}
</code></pre><!--
Note that the `resourceVersion` of the list remains constant across each request, indicating the server is showing us a consistent snapshot of the pods. Pods that are created, updated, or deleted after version `10245` would not be shown unless the user makes a list request without the `continue` token.  This allows clients to break large requests into smaller chunks and then perform a watch operation on the full set without missing any updates.
-->
<p>注意 list 操作的 <code>resourceVersion</code> 在每个请求中都设置的是同一个数值，
这表明服务器要向我们展示一个一致的 Pods 快照视图。
在版本 <code>10245</code> 之后创建、更新或删除的 Pods 都不会显示出来，除非用户发出
list 请求时不指定 <code>continue</code> 令牌。
这一设计使得客户端能够将较大的响应切分为较小的数据块，且能够对较大的集合
执行监视动作而不会错失任何更新事件。</p>
<!--
## Receiving resources as Tables

The output from the `kubectl get` command is a simple tabular representation of one or more instances of a particular resource type. In the past, clients were required to reproduce the tabular and describe output implemented in `kubectl` to perform simple lists of objects.
A few limitations of that approach include non-trivial logic when dealing with certain objects. Additionally, types provided by API aggregation or third party resources are not known at compile time. This means that generic implementations had to be in place for types unrecognized by a client.
-->
<h2 id="receiving-resources-as-tables">以表格形式接收资源 </h2>
<p><code>kubectl get</code> 命令的输出是一个包含一个或多个资源的简单表格形式。
过去，客户端需要重复 <code>kubectl</code> 中所实现的表格输出和描述输出逻辑，以执行
简单的对象列表操作。
这一方法在处理某些对象时，需要引入不容忽视的逻辑。
此外，<a href="/zh/docs/concepts/extend-kubernetes/api-extension/apiserver-aggregation/">API 聚合</a>
和<a href="/zh/docs/concepts/extend-kubernetes/api-extension/custom-resources/">定制资源</a>
所提供的资源类型都是编译时不可预知的。这意味着，客户端必须针对无法
识别的类型提供通用的实现逻辑。</p>
<!--
In order to avoid potential limitations as described above, clients may request the Table representation of objects, delegating specific details of printing to the server. The Kubernetes API implements standard HTTP content type negotiation: passing an `Accept` header containing a value of `application/json;as=Table;g=meta.k8s.io;v=v1beta1` with a `GET` call will request that the server return objects in the Table content type.

For example:
-->
<p>为了避免上述各种潜在的局限性，客户端可以请求服务器端返回对象的表格（Table）
表现形式，从而将打印输出的特定细节委托给服务器。
Kubernetes API 实现标准的 HTTP 内容类型（Content Type）协商：为 <code>GET</code> 调用
传入一个值为 <code>application/json;as=Table;g=meta.k8s.io;v=v1beta1</code> 的 <code>Accept</code>
头部即可请求服务器以 Table 的内容类型返回对象。</p>
<p>例如，以 Table 格式列举集群中所有 Pods：</p>
<pre tabindex="0"><code class="language-console" data-lang="console">GET /api/v1/pods
Accept: application/json;as=Table;g=meta.k8s.io;v=v1beta1
---
200 OK
Content-Type: application/json

{
    &quot;kind&quot;: &quot;Table&quot;,
    &quot;apiVersion&quot;: &quot;meta.k8s.io/v1beta1&quot;,
    ...
    &quot;columnDefinitions&quot;: [
        ...
    ]
}
</code></pre><!--
For API resource types that do not have a custom Table definition on the
server, a default Table response is returned by the server, consisting of the
resource's `name` and `creationTimestamp` fields.
-->
<p>对于在服务器上不存在定制的 Table 定义的 API 资源类型而言，服务器会返回
一个默认的 Table 响应，其中包含资源的 <code>name</code> 和 <code>creationTimestamp</code> 字段。</p>
<pre tabindex="0"><code class="language-console" data-lang="console">GET /apis/crd.example.com/v1alpha1/namespaces/default/resources
---
200 OK
Content-Type: application/json
...

{
    &quot;kind&quot;: &quot;Table&quot;,
    &quot;apiVersion&quot;: &quot;meta.k8s.io/v1beta1&quot;,
    ...
    &quot;columnDefinitions&quot;: [
        {
            &quot;name&quot;: &quot;Name&quot;,
            &quot;type&quot;: &quot;string&quot;,
            ...
        },
        {
            &quot;name&quot;: &quot;Created At&quot;,
            &quot;type&quot;: &quot;date&quot;,
            ...
        }
    ]
}
</code></pre><!--
Table responses are available beginning in version 1.10 of the kube-apiserver.
As such, not all API resource types will support a Table response,
specifically when using a client against older clusters. Clients that must
work against all resource types, or can potentially deal with older clusters,
should specify multiple content types in their `Accept` header to support
fallback to non-Tabular JSON:
-->
<p><code>kube-apiserver</code> 从 1.10 版本开始提供 Table 响应。
因此，并非所有 API 资源类型都支持 Table 响应，尤其是使用客户端访问较老的集群时。
如果客户端需要能够处理所有资源类型，或者有可能需要与较老的集群交互，
则需要在其 <code>Accept</code> 头部设定多个内容类型值，以便可以回退到非表格形式的 JSON
表示。</p>
<pre tabindex="0"><code>Accept: application/json;as=Table;g=meta.k8s.io;v=v1beta1, application/json
</code></pre><!--
## Alternate representations of resources

By default, Kubernetes returns objects serialized to JSON with content type `application/json`. This is the default serialization format for the API. However, clients may request the more efficient Protobuf representation of these objects for better performance at scale. The Kubernetes API implements standard HTTP content type negotiation: passing an `Accept` header with a `GET` call will request that the server return objects in the provided content type, while sending an object in Protobuf to the server for a `PUT` or `POST` call takes the `Content-Type` header. The server will return a `Content-Type` header if the requested format is supported, or the `406 Not acceptable` error if an invalid content type is provided.

See the API documentation for a list of supported content types for each API.

For example:
-->
<h2 id="alternate-representations-of-resources">资源的其他表示形式 </h2>
<p>默认情况下，Kubernetes 返回 JSON 序列化的的对象并设定内容类型为
<code>application/json</code>。这是 API 的默认序列化格式。
不过，客户端也可出于大规模环境中更佳性能的需求而请求对象的更为高效的 Protobuf
表现形式。
Kubernetes API 实现了标准的 HTTP 内容类型协商：为 <code>GET</code> 调用传递一个 <code>Accept</code>
头部来请求服务器以所指定的内容类型返回对象，同时在通过 <code>PUT</code> 或 <code>POST</code> 调用
向服务器发送 Protobuf 格式的对象时提供 <code>Content-Type</code> 头部。
服务器会能够支持所请求的格式时返回 <code>Content-Type</code> 头部，并在所提供的内容类型
不合法时返回 <code>406 Not acceptable（无法接受）</code> 错误。</p>
<p>请参阅 API 文档了解每个 API 所支持的内容类型。</p>
<p>例如：</p>
<!--
1. List all of the pods on a cluster in Protobuf format.
-->
<ol>
<li>以 Protobuf 格式列举集群上的所有 Pods：</li>
</ol>
<pre tabindex="0"><code class="language-console" data-lang="console">GET /api/v1/pods
Accept: application/vnd.kubernetes.protobuf
---
200 OK
Content-Type: application/vnd.kubernetes.protobuf

... binary encoded PodList object
</code></pre><!--
2. Create a pod by sending Protobuf encoded data to the server, but request a response in JSON.
-->
<ol start="2">
<li>通过向服务器发送 Protobuf 编码的数据创建 Pod，但请求以 JSON 形式接收响应：</li>
</ol>
<pre tabindex="0"><code class="language-console" data-lang="console">POST /api/v1/namespaces/test/pods
Content-Type: application/vnd.kubernetes.protobuf
Accept: application/json
... binary encoded Pod object
---
200 OK
Content-Type: application/json

{
  &quot;kind&quot;: &quot;Pod&quot;,
  &quot;apiVersion&quot;: &quot;v1&quot;,
  ...
}
</code></pre><!--
Not all API resource types will support Protobuf, specifically those defined
via Custom Resource Definitions or those that are API extensions. Clients that
must work against all resource types should specify multiple content types in
their `Accept` header to support fallback to JSON:
-->
<p>并非所有 API 资源类型都支持 Protobuf，尤其是那些通过定制资源定义（CRD）或通过
API 扩展而加入的资源。如果客户端必须能够处理所有资源类型，则应在其 <code>Accept</code>
头部指定多种内容类型以便可以回退到 JSON 格式：</p>
<pre tabindex="0"><code class="language-console" data-lang="console">Accept: application/vnd.kubernetes.protobuf, application/json
</code></pre><!--
### Protobuf encoding

Kubernetes uses an envelope wrapper to encode Protobuf responses. That wrapper starts with a 4 byte magic number to help identify content in disk or in etcd as Protobuf (as opposed to JSON), and then is followed by a Protobuf encoded wrapper message, which describes the encoding and type of the underlying object and then contains the object.

The wrapper format is:
-->
<h3 id="protobuf-encoding">Protobuf encoding</h3>
<p>Kubernetes 使用封套形式来对 Protobuf 响应进行编码。
封套外层由 4 个字节的特殊数字开头，便于从磁盘文件或 etcd 中辩识 Protobuf
格式的（而不是 JSON）数据。
接下来存放的是 Protobuf 编码的封套消息，其中描述下层对象的编码和类型，最后
才是对象本身。</p>
<p>封套格式如下：</p>
<!--
```console
A four byte magic number prefix:
  Bytes 0-3: "k8s\x00" [0x6b, 0x38, 0x73, 0x00]

An encoded Protobuf message with the following IDL:
  message Unknown {
    // typeMeta should have the string values for "kind" and "apiVersion" as set on the JSON object
    optional TypeMeta typeMeta = 1;

    // raw will hold the complete serialized object in protobuf. See the protobuf definitions in the client libraries for a given kind.
    optional bytes raw = 2;

    // contentEncoding is encoding used for the raw data. Unspecified means no encoding.
    optional string contentEncoding = 3;

    // contentType is the serialization method used to serialize 'raw'. Unspecified means application/vnd.kubernetes.protobuf and is usually
    // omitted.
    optional string contentType = 4;
  }

  message TypeMeta {
    // apiVersion is the group/version for this type
    optional string apiVersion = 1;
    // kind is the name of the object schema. A protobuf definition should exist for this object.
    optional string kind = 2;
  }
```
-->
<pre tabindex="0"><code class="language-console" data-lang="console">四个字节的特殊数字前缀：
  字节 0-3: &quot;k8s\x00&quot; [0x6b, 0x38, 0x73, 0x00]

使用下面 IDL 来编码的 Protobuf 消息：
  message Unknown {
    // typeMeta 应该包含 &quot;kind&quot; 和 &quot;apiVersion&quot; 的字符串值，就像
    // 对应的 JSON 对象中所设置的那样
    optional TypeMeta typeMeta = 1;

    // raw 中将保存用 protobuf 序列化的完整对象。
    // 参阅客户端库中为指定 kind 所作的 protobuf 定义
    optional bytes raw = 2;

    // contentEncoding 用于 raw 数据的编码格式。未设置此值意味着没有特殊编码。
    optional string contentEncoding = 3;

    // contentType 包含 raw 数据所采用的序列化方法。
    // 未设置此值意味着  application/vnd.kubernetes.protobuf，且通常被忽略
    optional string contentType = 4;
  }

  message TypeMeta {
    // apiVersion 是 type 对应的组名/版本
    optional string apiVersion = 1;
    // kind 是对象模式定义的名称。此对象应该存在一个 protobuf 定义。
    optional string kind = 2;
  }
</code></pre><!--
Clients that receive a response in `application/vnd.kubernetes.protobuf` that does not match the expected prefix should reject the response, as future versions may need to alter the serialization format in an incompatible way and will do so by changing the prefix.
-->
<p>收到 <code>application/vnd.kubernetes.protobuf</code> 格式响应的客户端在响应与预期的前缀
不匹配时应该拒绝响应，因为将来的版本可能需要以某种不兼容的方式更改序列化格式，
并且这种更改是通过变更前缀完成的。</p>
<!--
## Resource deletion

Resources are deleted in two phases: 1) finalization, and 2) removal.
-->
<h2 id="resource-deletion">资源删除 </h2>
<p>资源删除要经过两个阶段：1) 终止（finalization），和 2）去除。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-json" data-lang="json">{
  <span style="color:#008000;font-weight:bold">&#34;kind&#34;</span>: <span style="color:#b44">&#34;ConfigMap&#34;</span>,
  <span style="color:#008000;font-weight:bold">&#34;apiVersion&#34;</span>: <span style="color:#b44">&#34;v1&#34;</span>,
  <span style="color:#008000;font-weight:bold">&#34;metadata&#34;</span>: {
    <span style="color:#008000;font-weight:bold">&#34;finalizers&#34;</span>: {<span style="color:#008000;font-weight:bold">&#34;url.io/neat-finalization&#34;</span>, <span style="color:#008000;font-weight:bold">&#34;other-url.io/my-finalizer&#34;</span>},
    <span style="color:#008000;font-weight:bold">&#34;deletionTimestamp&#34;</span>: <span style="">nil</span>,
  }
}
</code></pre></div><!--
When a client first deletes a resource, the `.metadata.deletionTimestamp` is
set to the current time.  Once the `.metadata.deletionTimestamp` is set,
external controllers that act on finalizers may start performing their cleanup
work at any time, in any order.  Order is NOT enforced because it introduces
significant risk of stuck `.metadata.finalizers`.  `.metadata.finalizers` is a
shared field, any actor with permission can reorder it.  If the finalizer list
is processed in order, then this can lead to a situation in which the
component responsible for the first finalizer in the list is waiting for a
signal (field value, external system, or other) produced by a component
responsible for a finalizer later in the list, resulting in a deadlock.
Without enforced ordering finalizers are free to order amongst themselves and
are not vulnerable to ordering changes in the list.

Once the last finalizer is removed, the resource is actually removed from
etcd.
-->
<p>当客户端首先删除某资源时，其 <code>.metadata.deletionTimestamp</code> 会被设置为当前时间。
一旦 <code>.metadata.deletionTimestamp</code> 被设置，则对终结器（finalizers）执行动作
的外部控制器就可以在任何时候、以任何顺序执行其清理工作。
这里不强调顺序是因为很可能带来 <code>.metadata.finalizers</code> 被锁定的风险。
<code>.metadata.finalizers</code> 是一个共享的字段，任何具有相关权限的主体都可以对其
执行重排序的操作。如果终结器列表要按顺序处理，则很可能导致负责列表中第一个
终结器的组件要等待负责列表中排序靠后的终结器的组件的信号（可能是字段值变更、
外部系统或者其他形式），从而导致死锁行为。
在不对终结器顺序作强制要求的情况下，终结器可以自行排序，且不会因为其在列表
中的顺序而引入任何不稳定因素。</p>
<p>当最后一个终结器也被移除时，资源才真正从 etcd 中移除。</p>
<!--
## Single resource API

API verbs GET, CREATE, UPDATE, PATCH, DELETE and PROXY support single resources only.
These verbs with single resource support have no support for submitting
multiple resources together in an ordered or unordered list or transaction.
Clients including kubectl will parse a list of resources and make
single-resource API requests.

API verbs LIST and WATCH support getting multiple resources, and
DELETECOLLECTION supports deleting multiple resources.
-->
<h2 id="single-resource-api">单个资源 API </h2>
<p>API 动词 GET、CREATE、UPDATE、PATCH、DELETE 和 PROXY 仅支持单个资源。
这些支持单一资源的动词不支持以有序或无序列表甚或事务的形式同时提交给
多个资源。
包括 kubectl 在内的客户端将解析资源的列表，并执行单一资源的 API 请求。</p>
<p>API 动词 LIST 和 WATCH 支持获取多个资源，而 DELETECOLLECTION 支持删除多个
资源。</p>
<!--
## Dry-run
-->
<h2 id="dry-run">试运行 </h2>





<div style="margin-top: 10px; margin-bottom: 10px;">
<b>FEATURE STATE:</b> <code>Kubernetes v1.18 [stable]</code>
</div>

<!--
The modifying verbs (`POST`, `PUT`, `PATCH`, and `DELETE`) can accept requests in a _dry run_ mode. Dry run mode helps to evaluate a request through the typical request stages (admission chain, validation, merge conflicts) up until persisting objects to storage. The response body for the request is as close as possible to a non-dry-run response. The system guarantees that dry-run requests will not be persisted in storage or have any other side effects.
-->
<p>修改性质的动词（<code>POST</code>、<code>PUT</code>、<code>PATCH</code> 和 <code>DELETE</code>）可以支持 <em>试运行（dry
run）</em> 模式的请求。试运行模式可帮助通过典型的请求阶段（准入控制链、合法性
检查、合并冲突）来评估请求，只是最终的对象不会写入存储。请求的响应主体与
非试运行模式下的响应尽可能接近。系统会保证试运行模式的请求不会被写入到存储
中，也不会产生其他副作用。</p>
<!--
### Make a dry-run request

Dry-run is triggered by setting the `dryRun` query parameter. This parameter is a string, working as an enum, and the only accepted values are:

* `All`: Every stage runs as normal, except for the final storage stage. Admission controllers are run to check that the request is valid, mutating controllers mutate the request, merge is performed on `PATCH`, fields are defaulted, and schema validation occurs. The changes are not persisted to the underlying storage, but the final object which would have been persisted is still returned to the user, along with the normal status code. If the request would trigger an admission controller which would have side effects, the request will be failed rather than risk an unwanted side effect. All built in admission control plugins support dry-run. Additionally, admission webhooks can declare in their [configuration object](/docs/reference/generated/kubernetes-api/v1.22/#webhook-v1beta1-admissionregistration-k8s-io) that they do not have side effects by setting the sideEffects field to "None". If a webhook actually does have side effects, then the sideEffects field should be set to "NoneOnDryRun", and the webhook should also be modified to understand the `DryRun` field in AdmissionReview, and prevent side effects on dry-run requests.
* Leave the value empty, which is also the default: Keep the default modifying behavior.

For example:
-->
<h3 id="make-a-dry-run-request">发起试运行请求 </h3>
<p>通过设置 <code>dryRun</code> 查询参数可以触发试运行模式。此参数是一个字符串，以枚举值
的形式工作且可接受的值只有：</p>
<ul>
<li>
<p><code>All</code>：每个阶段被会正常运行，除了最后的存储阶段。准入控制器会被运行来检查请求
是否合法，变更性（Mutating）控制器会变更请求，<code>PATCH</code> 请求也会触发合并操作，
对象字段的默认值也会被设置，且基于模式定义的合法性检查也会被执行。
所生成的变更不会被写入到下层的持久性存储中，但本来会写入到数据库中的最终对象
会和正常的状态代码一起被返回给用户。如果请求会触发准入控制器而该准入控制器
带有一定的副作用，则请求会失败而不是冒险产生不希望的副作用。
所有的内置准入控制器插件都支持试运行模式。此外，准入控制 Webhook 也可在其
<a href="/docs/reference/generated/kubernetes-api/v1.22/#webhook-v1beta1-admissionregistration-k8s-io">配置对象</a>
中通过将 <code>sideEffects</code> 字段设置为 &quot;None&quot; 来声明自身不会产生副作用。
如果某 Webhook 确实会产生副作用，那么 <code>sideEffects</code> 字段应该设置为 &quot;NoneOnDryRun&quot;，
并且 Webhook 应该被更改以支持 AdmissionReview 中的 <code>dryRun</code> 字段，从而避免
在试运行时产生副作用。</p>
</li>
<li>
<p>空字符串（也即默认值）：保留默认的修改行为。</p>
</li>
</ul>
<p>例如：</p>
<pre tabindex="0"><code class="language-console" data-lang="console">POST /api/v1/namespaces/test/pods?dryRun=All
Content-Type: application/json
Accept: application/json
</code></pre><!--
The response would look the same as for non-dry-run request, but the values of some generated fields may differ.
-->
<p>响应会与非试运行模式请求的响应看起来相同，只是某些生成字段的值可能会不同。</p>
<!--
### Dry-run authorization

Authorization for dry-run and non-dry-run requests is identical. Thus, to make
a dry-run request, the user must be authorized to make the non-dry-run request.

For example, to run a dry-run `PATCH` for Deployments, you must have the
`PATCH` permission for Deployments, as in the example of the RBAC rule below.
-->
<h3 id="dry-run-authorization">试运行的授权   </h3>
<p>试运行和非试运行请求的鉴权是完全相同的。因此，要发起一个试运行请求，用户必须
被授权执行非试运行请求。</p>
<p>例如，要在 Deployment 对象上试运行 <code>PATCH</code> 操作，你必须具有对 Deployment 执行
<code>PATCH</code> 操作的访问权限，如下面的 RBAC 规则所示：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">rules</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">apiGroups</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;extensions&#34;</span>,<span style="color:#bbb"> </span><span style="color:#b44">&#34;apps&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">resources</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;deployments&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">verbs</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;patch&#34;</span>]<span style="color:#bbb">
</span></code></pre></div><!--
See [Authorization Overview](/docs/reference/access-authn-authz/authorization/).
-->
<p>参阅<a href="/zh/docs/reference/access-authn-authz/authorization/">鉴权概述</a>以了解鉴权细节。</p>
<!--
### Generated values

Some values of an object are typically generated before the object is persisted. It is important not to rely upon the values of these fields set by a dry-run request, since these values will likely be different in dry-run mode from when the real request is made. Some of these fields are:

* `name`: if `generateName` is set, `name` will have a unique random name
* `creationTimestamp`/`deletionTimestamp`: records the time of creation/deletion
* `UID`: uniquely identifies the object and is randomly generated (non-deterministic)
* `resourceVersion`: tracks the persisted version of the object
* Any field set by a mutating admission controller
* For the `Service` resource: Ports or IPs that kube-apiserver assigns to v1.Service objects
-->
<h3 id="generated-values">生成的值 </h3>
<p>对象的某些值通常是在对象被写入数据库之前生成的。很重要的一点是不要依赖试运行
请求为这些字段所设置的值，因为试运行模式下所得到的这些值与真实请求所获得的
值很可能不同。这类字段有：</p>
<ul>
<li><code>name</code>：如果设置了 <code>generateName</code> 字段，则 <code>name</code> 会获得一个唯一的随机名称</li>
<li><code>creationTimestamp</code>/<code>deletionTimestamp</code>：记录对象的创建/删除时间</li>
<li><code>UID</code>：唯一性标识对象，取值随机生成（非确定性）</li>
<li><code>resourceVersion</code>： 跟踪对象的持久化（存储）版本</li>
<li>变更性准入控制器所设置的字段</li>
<li>对于 <code>Service</code> 资源：<code>kube-apiserver</code> 为 <code>v1.Service</code> 对象分配的端口和 IP</li>
</ul>
<!--
## Server Side Apply
-->
<h2 id="server-side-apply">服务器端应用 </h2>





<div style="margin-top: 10px; margin-bottom: 10px;">
<b>FEATURE STATE:</b> <code>Kubernetes v1.16 [beta]</code>
</div>

<!--
Starting from Kubernetes v1.18, you can enable the
[Server Side Apply](/docs/reference/using-api/server-side-apply/)
feature so that the control plane tracks managed fields for all newly created objects.
Server Side Apply provides a clear pattern for managing field conflicts,
offers server-side `Apply` and `Update` operations, and replaces the
client-side functionality of `kubectl apply`. For more details about this
feature, see the section on
[Server Side Apply](/docs/reference/using-api/server-side-apply/).
-->
<p>从 Kubernetes v1.18 开始，可以启用<a href="/zh/docs/reference/using-api/server-side-apply/">服务器端应用</a>功能
特性，启用该特性后，控制面会跟踪所有新创建的对象的托管字段。服务器端应用提供了一种简洁的模式来管理字段冲突，提供服务器端的 <code>Apply</code> 和 <code>Update</code> 操作，并取代了
<code>kubectl apply</code> 的客户端功能。有关该特性的详细描述，请参见<a href="/zh/docs/reference/using-api/server-side-apply/">服务器端应用</a>章节</p>
<!--
## Resource Versions

Resource versions are strings that identify the server's internal version of an object. Resource versions can be used by clients to determine when objects have changed, or to express data consistency requirements when getting, listing and watching resources. Resource versions must be treated as opaque by clients and passed unmodified back to the server. For example, clients must not assume resource versions are numeric, and may only compare two resource version for equality (i.e. must not compare resource versions for greater-than or less-than relationships).
-->
<h2 id="resource-versions">资源版本  </h2>
<p>资源版本采用字符串来表达，用来标示对象的服务器端内部版本。
客户端可以使用资源版本来判定对象是否被更改，或者在读取、列举或监视资源时
用来表达数据一致性需求。
客户端必需将资源版本视为不透明的对象，将其原封不动地传递回服务器端。
例如，客户端一定不能假定资源版本是某种数值标识，也不可以对两个资源版本值
进行比较看其是否相同（也就是不可以比较两个版本值以判断其中一个比另一个
大或小）。</p>
<!--
### ResourceVersion in metadata

Clients find resource versions in resources, including the resources in watch events, and list responses returned from the server:

[v1.meta/ObjectMeta](/docs/reference/generated/kubernetes-api/v1.22/#objectmeta-v1-meta) - The `metadata.resourceVersion` of a resource instance identifies the resource version the instance was last modified at.

[v1.meta/ListMeta](/docs/reference/generated/kubernetes-api/v1.22/#listmeta-v1-meta) - The `metadata.resourceVersion` of a resource collection (i.e. a list response) identifies the resource version at which the list response was constructed.
-->
<h3 id="resourceVersion-in-metadata"><code>metadata</code> 中的 <code>resourceVersion</code> </h3>
<p>客户端可以在资源中看到资源版本信息，这里的资源包括从服务器返回的 Watch 事件
以及 list 操作响应：</p>
<p><a href="/docs/reference/generated/kubernetes-api/v1.22/#objectmeta-v1-meta">v1.meta/ObjectMeta</a> - 资源
的 <code>metadata.resourceVersion</code> 值标明该实例上次被更改时的资源版本。</p>
<p><a href="/docs/reference/generated/kubernetes-api/v1.22/#listmeta-v1-meta">v1.meta/ListMeta</a> - 资源集合
（即 list 操作的响应）的 <code>metadata.resourceVersion</code> 所标明的是 list 响应被构造
时的资源版本。</p>
<!--
### The ResourceVersion Parameter

The get, list and watch operations support the `resourceVersion` parameter.

The exact meaning of this parameter differs depending on the operation and the value of `resourceVersion`.

For get and list, the semantics of resource version are:

**Get:**
-->
<h3 id="the-resourceversion-parameter"><code>resourceVersion</code> 参数  </h3>
<p>GET、LIST 和 WATCH 操作都支持 <code>resourceVersion</code> 参数。</p>
<p>参数的具体含义取决于所执行的操作和所给的 <code>resourceVersion</code> 值：</p>
<p>对于 GET 和 LIST 而言，资源版本的语义为：</p>
<p><strong>GET：</strong></p>
<!--
| resourceVersion unset | resourceVersion="0" | resourceVersion="{value other than 0}" |
|------------------------|---------------------|----------------------------------------|
| Most Recent           | Any                 | Not older than                         |
-->
<table>
<thead>
<tr>
<th>resourceVersion 未设置</th>
<th>resourceVersion=&quot;0&quot;</th>
<th>resourceVersion=&quot;&lt;非零值&gt;&quot;</th>
</tr>
</thead>
<tbody>
<tr>
<td>最新版本</td>
<td>任何版本</td>
<td>不老于给定版本</td>
</tr>
</tbody>
</table>
<p><strong>LIST：</strong></p>
<!--
v1.19+ API servers and newer support the `resourceVersionMatch` parameter, which
determines how resourceVersion is applied to list calls.  It is highly
recommended that `resourceVersionMatch` be set for list calls where
`resourceVersion` is set. If `resourceVersion` is unset, `resourceVersionMatch`
is not allowed.  For backward compatibility, clients must tolerate the server
ignoring `resourceVersionMatch`:
-->
<p>v1.19 及以上版本的 API 服务器支持 <code>resourceVersionMatch</code> 参数，用以确定如何对
LIST 调用应用 resourceVersion 值。
强烈建议在为 LIST 调用设置了 <code>resourceVersion</code> 时也设置 <code>resourceVersionMatch</code>。
如果 <code>resourceVersion</code> 未设置，则 <code>resourceVersionMatch</code> 是不允许设置的。
为了向后兼容，客户端必须能够容忍服务器在某些场景下忽略 <code>resourceVersionMatch</code> 的行为：</p>
<!--
- When using `resourceVersionMatch=NotOlderThan` and limit is set, clients must
  handle HTTP 410 "Gone" responses. For example, the client might retry with a
  newer `resourceVersion` or fall back to `resourceVersion=""`.

- When using `resourceVersionMatch=Exact` and `limit` is unset, clients must
  verify that the `resourceVersion` in the `ListMeta` of the response matches
  the requested `resourceVersion`, and handle the case where it does not. For
  example, the client might fall back to a request with `limit` set.
-->
<ul>
<li>
<p>当设置 <code>resourceVersionMatch=NotOlderThan</code> 且指定了 <code>limit</code> 时，客户端必须能够
处理 HTTP 410 &quot;Gone&quot; 响应。例如，客户端可以使用更新一点的 <code>resourceVersion</code>
来重试，或者回退到 <code>resourceVersion=&quot;&quot;</code> （即允许返回任何版本）。</p>
</li>
<li>
<p>当设置了 <code>resourceVersionMatch=Exact</code> 且未指定 <code>limit</code> 时，客户端必须验证
响应数据中 <code>ListMeta</code> 的 <code>resourceVersion</code> 与所请求的 <code>resourceVersion</code> 匹配，
并处理二者可能不匹配的情况。例如，客户端可以重试设置了 <code>limit</code> 的请求。</p>
</li>
</ul>
<!--
Unless you have strong consistency requirements, using `resourceVersionMatch=NotOlderThan` and
a known `resourceVersion` is preferable since it can achieve better performance and scalability
of your cluster than leaving `resourceVersion` and `resourceVersionMatch` unset, which requires
quorum read to be served.
-->
<p>除非你对一致性有着非常强烈的需求，使用 <code>resourceVersionMatch=NotOlderThan</code>
同时为 <code>resourceVersion</code> 设定一个已知值是优选的交互方式，因为与不设置
<code>resourceVersion</code> 和 <code>resourceVersionMatch</code> 相比，这种配置可以取得更好的
集群性能和可扩缩性。后者需要提供带票选能力的读操作。</p>
<!--
{{< table caption="resourceVersionMatch and paging parameters for list" >}}

| resourceVersionMatch param            | paging params                 | resourceVersion unset | resourceVersion="0"                       | resourceVersion="{value other than 0}" |
|---------------------------------------|-------------------------------|-----------------------|-------------------------------------------|----------------------------------------|
| resourceVersionMatch unset            | limit unset                   | Most Recent           | Any                                       | Not older than                         |
| resourceVersionMatch unset            | limit=\<n\>, continue unset     | Most Recent           | Any                                       | Exact                                  |
| resourceVersionMatch unset            | limit=\<n\>, continue=\<token\> | Continue Token, Exact | Invalid, treated as Continue Token, Exact | Invalid, HTTP `400 Bad Request`        |
| resourceVersionMatch=Exact [1]        | limit unset                   | Invalid               | Invalid                                   | Exact                                  |
| resourceVersionMatch=Exact [1]        | limit=\<n\>, continue unset     | Invalid               | Invalid                                   | Exact                                  |
| resourceVersionMatch=NotOlderThan [1] | limit unset                   | Invalid               | Any                                       | Not older than                         |
| resourceVersionMatch=NotOlderThan [1] | limit=\<n\>, continue unset     | Invalid               | Any                                       | Not older than                         |

{{< /table >}}

**Footnotes:**

[1] If the server does not honor the `resourceVersionMatch` parameter, it is treated as if it is unset.
-->





<table><caption style="display: none;">list 操作的 resourceVersionMatch 与分页参数</caption>
<thead>
<tr>
<th>resourceVersionMatch 参数</th>
<th>分页参数</th>
<th>resourceVersion 未设置</th>
<th>resourceVersion=&quot;0&quot;</th>
<th>resourceVersion=&quot;&lt;非零值&gt;&quot;</th>
</tr>
</thead>
<tbody>
<tr>
<td>resourceVersionMatch 未设置</td>
<td>limit 未设置</td>
<td>最新版本</td>
<td>任意版本</td>
<td>不老于指定版本</td>
</tr>
<tr>
<td>resourceVersionMatch 未设置</td>
<td>limit=&lt;n&gt;, continue 未设置</td>
<td>最新版本</td>
<td>任意版本</td>
<td>精确匹配</td>
</tr>
<tr>
<td>resourceVersionMatch 未设置</td>
<td>limit=&lt;n&gt;, continue=&lt;token&gt;</td>
<td>从 token 开始、精确匹配</td>
<td>非法请求，视为从 token 开始、精确匹配</td>
<td>非法请求，返回 HTTP <code>400 Bad Request</code></td>
</tr>
<tr>
<td>resourceVersionMatch=Exact [1]</td>
<td>limit 未设置</td>
<td>非法请求</td>
<td>非法请求</td>
<td>精确匹配</td>
</tr>
<tr>
<td>resourceVersionMatch=Exact [1]</td>
<td>limit=&lt;n&gt;, continue 未设置</td>
<td>非法请求</td>
<td>非法请求</td>
<td>精确匹配</td>
</tr>
<tr>
<td>resourceVersionMatch=NotOlderThan [1]</td>
<td>limit 未设置</td>
<td>非法请求</td>
<td>任意版本</td>
<td>不老于指定版本</td>
</tr>
<tr>
<td>resourceVersionMatch=NotOlderThan [1]</td>
<td>limit=&lt;n&gt;, continue 未设置</td>
<td>非法请求</td>
<td>任意版本</td>
<td>不老于指定版本</td>
</tr>
</tbody>
</table>

<p><strong>脚注：</strong></p>
<p>[1] 如果服务器无法正确处理 <code>resourceVersionMatch</code> 参数，其行为与未设置该参数相同。
</small></p>
<!--
The meaning of the get and list semantics are:

- **Most Recent:** Return data at the most recent resource version. The returned data must be
  consistent (i.e. served from etcd via a quorum read).
- **Any:** Return data at any resource version. The newest available resource version is preferred,
  but strong consistency is not required; data at any resource version may be served. It is possible
  for the request to return data at a much older resource version that the client has previously
  observed, particularly in high availability configurations, due to partitions or stale
  caches. Clients that cannot tolerate this should not use this semantic.
-->
<p>GET 和 LIST 操作的语义含义如下：</p>
<ul>
<li><strong>最新版本：</strong> 返回资源版本为最新的数据。所返回的数据必须一致
（通过票选读操作从 etcd 中取出）。</li>
<li><strong>任意版本：</strong> 返回任意资源版本的数据。优选最新可用的资源版本，不过不能保证
强一致性；返回的数据可能是任何资源版本的。请求返回的数据有可能是客户端以前
看到过的很老的资源版本。尤其在某些高可用配置环境中，网络分区或者高速缓存
未被更新等状态都可能导致这种状况。不能容忍这种不一致性的客户端不应采用此
语义。</li>
</ul>
<!--
- **Not older than:** Return data at least as new as the provided resourceVersion. The newest
  available data is preferred, but any data not older than the provided resourceVersion may be
  served.  For list requests to servers that honor the resourceVersionMatch parameter, this
  guarantees that resourceVersion in the ListMeta is not older than the requested resourceVersion,
  but does not make any guarantee about the resourceVersion in the ObjectMeta of the list items
  since ObjectMeta.resourceVersion tracks when an object was last updated, not how up-to-date the
  object is when served.
- **Exact:** Return data at the exact resource version provided. If the provided resourceVersion is
  unavailable, the server responds with HTTP 410 "Gone".  For list requests to servers that honor the
  resourceVersionMatch parameter, this guarantees that resourceVersion in the ListMeta is the same as
  the requested resourceVersion, but does not make any guarantee about the resourceVersion in the
  ObjectMeta of the list items since ObjectMeta.resourceVersion tracks when an object was last
  updated, not how up-to-date the object is when served.
- **Continue Token, Exact:** Return data at the resource version of the initial paginated list
  call. The returned Continue Tokens are responsible for keeping track of the initially provided
  resource version for all paginated list calls after the initial paginated list call.
-->
<ul>
<li>
<p><strong>不老于指定版本：</strong> 返回至少比所提供的 <code>resourceVersion</code> 还要新的数据。
优选最新的可用数据，不过最终提供的可能是不老于所给 <code>resourceVersion</code> 的任何版本。
对于发给能够正确处理 <code>resourceVersionMatch</code> 参数的服务器的 LIST 请求，此语义
保证 <code>ListMeta</code> 中的 <code>resourceVersion</code> 不老于请求的 <code>resourceVersion</code>，不过
不对列表条目之 <code>ObjectMeta</code> 的 <code>resourceVersion</code> 提供任何保证。
这是因为 <code>ObjectMeta.resourceVersion</code> 所跟踪的是列表条目对象上次更新的时间，
而不是对象被返回时是否是最新。</p>
</li>
<li>
<p><strong>确定版本：</strong> 返回精确匹配所给资源版本的数据。如果所指定的 resourceVersion
的数据不可用，服务器会响应 HTTP 410 &quot;Gone&quot;。
对于发送给能够正确处理 <code>resourceVersionMatch</code> 参数的服务器的 LIST 请求而言，
此语义会保证 ListMeta 中的 <code>resourceVersion</code> 与所请求的 <code>resourceVersion</code>
匹配， 不过不对列表条目之 <code>ObjectMeta</code> 的 <code>resourceVersion</code> 提供任何保证。
这是因为 <code>ObjectMeta.resourceVersion</code> 所跟踪的是列表条目对象上次更新的时间，
而不是对象被返回时是否是最新。</p>
</li>
<li>
<p><strong>Continue 令牌、精确匹配：</strong> 返回原先带分页参数的 LIST 调用中指定的资源版本的数据。
在最初的带分页参数的 LIST 调用之后，所有分页式的 LIST 调用都使用所返回的 Continue
令牌来跟踪最初提供的资源版本，</p>
</li>
</ul>
<!--
For watch, the semantics of resource version are:
-->
<p>对于 WATCH 操作而言，资源版本的语义如下：</p>
<p><strong>WATCH：</strong></p>
<!--





<table><caption style="display: none;">resourceVersion for watch</caption>
<thead>
<tr>
<th>resourceVersion unset</th>
<th>resourceVersion=&quot;0&quot;</th>
<th>resourceVersion=&quot;{value other than 0}&quot;</th>
</tr>
</thead>
<tbody>
<tr>
<td>Get State and Start at Most Recent</td>
<td>Get State and Start at Any</td>
<td>Start at Exact</td>
</tr>
</tbody>
</table>

-->





<table><caption style="display: none;">watch 操作的 resourceVersion 设置</caption>
<thead>
<tr>
<th>resourceVersion 未设置</th>
<th>resourceVersion=&quot;0&quot;</th>
<th>resourceVersion=&quot;&lt;非零值&gt;&quot;</th>
</tr>
</thead>
<tbody>
<tr>
<td>读取状态并从最新版本开始</td>
<td>读取状态并从任意版本开始</td>
<td>从指定版本开始</td>
</tr>
</tbody>
</table>

<!--
The meaning of the watch semantics are:

- **Get State and Start at Most Recent:** Start a watch at the most recent
  resource version, which must be consistent (i.e. served from etcd via a
  quorum read). To establish initial state, the watch begins with synthetic
  "Added" events of all resources instances that exist at the starting resource
  version. All following watch events are for all changes that occurred after
  the resource version the watch started at.
-->
<p>WATCH 操作语义的含义如下：</p>
<ul>
<li><strong>读取状态并从最新版本开始：</strong> 从最新的资源版本开始 WATCH 操作。这里的
最新版本必须是一致的（即通过票选读操作从 etcd 中取出）。为了建立初始状态，
WATCH 首先会处理一组合成的 &quot;Added&quot; 事件，这些事件涵盖在初始资源版本中存在
的所有资源实例。
所有后续的 WATCH 事件都是关于 WATCH 开始时所处资源版本之后发生的变更。</li>
</ul>
<!--
- **Get State and Start at Any:** Warning: Watches initialize this way may
  return arbitrarily stale data! Please review this semantic before using it,
  and favor the other semantics where possible. Start a watch at any resource
  version, the most recent resource version available is preferred, but not
  required; any starting resource version is allowed. It is possible for the
  watch to start at a much older resource version that the client has previously
  observed, particularly in high availability configurations, due to partitions
  or stale caches. Clients that cannot tolerate this should not start a watch
  with this semantic. To establish initial state, the watch begins with
  synthetic "Added" events for all resources instances that exist at the
  starting resource version. All following watch events are for all changes that
  occurred after the resource version the watch started at.
-->
<ul>
<li><strong>读取状态并从任意版本开始：</strong> 警告：通过这种方式初始化的 WATCH 操作可能会
返回任何状态的停滞数据。请在使用此语义之前执行复核，并在可能的情况下采用其他
语义。此语义会从任意资源版本开始执行 WATCH 操作，优选最新的可用的资源版本，
不过不是必须的；采用任何资源版本作为起始版本都是被允许的。
WATCH 操作有可能起始于客户端已经观测到的很老的版本。在高可用配置环境中，因为
网络分裂或者高速缓存未及时更新的原因都会造成此现象。
如果客户端不能容忍这种不一致性，就不要使用此语义来启动 WATCH 操作。
为了建立初始状态，WATCH 首先会处理一组合成的 &quot;Added&quot; 事件，这些事件涵盖在
初始资源版本中存在的所有资源实例。
所有后续的 WATCH 事件都是关于 WATCH 开始时所处资源版本之后发生的变更。</li>
</ul>
<!--
- **Start at Exact:** Start a watch at an exact resource version. The watch
  events are for all changes after the provided resource version. Unlike "Get
  State and Start at Most Recent" and "Get State and Start at Any", the watch is
  not started with synthetic "Added" events for the provided resource version.
  The client is assumed to already have the initial state at the starting
  resource version since the client provided the resource version.
-->
<ul>
<li><strong>从指定版本开始：</strong> 从某确切资源版本开始执行 WATCH 操作。WATCH 事件都是
关于 WATCH 开始时所处资源版本之后发生的变更。与前面两种语义不同，WATCH 操作
开始的时候不会生成或处理为所提供资源版本合成的 &quot;Added&quot; 事件。
我们假定客户端既然能够提供确切资源版本，就应该已经拥有了起始资源版本对应的初始状态。</li>
</ul>
<!--
### "410 Gone" responses

Servers are not required to serve all older resource versions and may return a
HTTP `410 (Gone)` status code if a client requests a resourceVersion older
than the server has retained. Clients must be able to tolerate `410 (Gone)`
responses. See [Efficient detection of
changes](#efficient-detection-of-changes) for details on how to handle `410
(Gone)` responses when watching resources.

If you request a a resourceVersion outside the applicable limit then,
depending on whether a request is served from cache or not, the API server may
reply with a `410 Gone` HTTP response.
-->
<h3 id="410-gone-responses">&quot;410 Gone&quot; 响应    </h3>
<p>服务器不需要提供所有老的资源版本，在客户端请求的是早于服务器端所保留版本的
<code>resourceVersion</code> 时，可以返回 HTTP <code>410 (Gone)</code> 状态码。
客户端必须能够容忍 <code>410 (Gone)</code> 响应。
参阅<a href="#efficient-detection-of-changes">高效检测变更</a>以了解如何在监测资源时
处理 <code>410 (Gone)</code> 响应。</p>
<p>如果所请求的 <code>resourceVersion</code> 超出了可应用的 <code>limit</code>，那么取决于请求是否
是通过高速缓存来满足的，API 服务器可能会返回一个 <code>410 Gone</code> HTTP 响应。</p>
<!--
### Unavailable resource versions

Servers are not required to serve unrecognized resource versions. List and Get requests for unrecognized resource versions may wait briefly for the resource version to become available, should timeout with a `504 (Gateway Timeout)` if the provided resource versions does not become available in a reasonable amount of time, and may respond with a `Retry-After` response header indicating how many seconds a client should wait before retrying the request. Currently the kube-apiserver also identifies these responses with a "Too large resource version" message. Watch requests for a unrecognized resource version may wait indefinitely (until the request timeout) for the resource version to become available.
-->
<h3 id="unavailable-resource-versions">不可用的资源版本 </h3>
<p>服务器不必未无法识别的资源版本提供服务。针对无法识别的资源版本的 LIST 和 GET 请求
可能会短暂等待，以期资源版本可用。如果所给的资源版本在一定的时间段内仍未变得
可用，服务器应该超时并返回 <code>504 (Gateway Timeout)</code>，且可在响应中添加
<code>Retry-After</code> 响应头部字段，标明客户端在再次尝试之前应该等待多少秒钟。
目前，<code>kube-apiserver</code> 也能使用 <code>Too large resource version（资源版本过高）</code>
消息来标识这类响应。针对某无法识别的资源版本的 WATCH 操作可能会无限期
（直到请求超时）地等待下去，直到资源版本可用。</p>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-040d9484db673074f1b8ba3465be9d91">2.2 - 服务器端应用（Server-Side Apply）</h1>
    
	<!-- 
title: Server-Side Apply
reviewers:
- smarterclayton
- apelisse
- lavalamp
- liggitt
content_type: concept
weight: 25
min-kubernetes-server-version: 1.16
-->
<!-- overview -->





<div style="margin-top: 10px; margin-bottom: 10px;">
<b>FEATURE STATE:</b> <code>Kubernetes v1.16 [beta]</code>
</div>

<!-- 
## Introduction

Server Side Apply helps users and controllers manage their resources through
declarative configurations. Clients can create and/or modify their
[objects](/docs/concepts/overview/working-with-objects/kubernetes-objects/)
declaratively by sending their fully specified intent.
-->
<h2 id="introduction">简介</h2>
<p>服务器端应用协助用户、控制器通过声明式配置的方式管理他们的资源。
客户端可以发送完整描述的目标（A fully specified intent），
声明式地创建和/或修改
<a href="/zh/docs/concepts/overview/working-with-objects/kubernetes-objects/">对象</a>。</p>
<!-- 
A fully specified intent is a partial object that only includes the fields and
values for which the user has an opinion. That intent either creates a new
object or is [combined](#merge-strategy), by the server, with the existing object.

The system supports multiple appliers collaborating on a single object.
-->
<p>一个完整描述的目标并不是一个完整的对象，仅包括能体现用户意图的字段和值。
该目标（intent）可以用来创建一个新对象，
也可以通过服务器来实现与现有对象的<a href="#merge-strategy">合并</a>。</p>
<p>系统支持多个应用者（appliers）在同一个对象上开展协作。</p>
<!-- 
Changes to an object's fields are tracked through a "[field management](#field-management)"
mechanism. When a field's value changes, ownership moves from its current
manager to the manager making the change. When trying to apply an object,
fields that have a different value and are owned by another manager will
result in a [conflict](#conflicts). This is done in order to signal that the
operation might undo another collaborator's changes. Conflicts can be forced,
in which case the value will be overridden, and the ownership will be
transferred.
-->
<p>“<a href="#field-management">字段管理（field management）</a>”机制追踪对象字段的变化。
当一个字段值改变时，其所有权从当前管理器（manager）转移到施加变更的管理器。
当尝试将新配置应用到一个对象时，如果字段有不同的值，且由其他管理器管理，
将会引发<a href="#conflicts">冲突</a>。
冲突引发警告信号：此操作可能抹掉其他协作者的修改。
冲突可以被刻意忽略，这种情况下，值将会被改写，所有权也会发生转移。</p>
<!-- 
If you remove a field from a configuration and apply the configuration, server
side apply checks if there are any other field managers that also own the
field.  If the field is not owned by any other field managers, it is either
deleted from the live object or reset to its default value, if it has one. The
same rule applies to associative list or map items.
-->
<p>当你从配置文件中删除一个字段，然后应用这个配置文件，
这将触发服务端应用检查此字段是否还被其他字段管理器拥有。
如果没有，那就从活动对象中删除该字段；如果有，那就重置为默认值。
该规则同样适用于 list 或 map 项目。</p>
<!-- 
Server side apply is meant both as a replacement for the original `kubectl
apply` and as a simpler mechanism for controllers to enact their changes.

If you have Server Side Apply enabled, the control plane tracks managed fields
for all newly created objects.
-->
<p>服务器端应用既是原有 <code>kubectl apply</code> 的替代品，
也是控制器发布自身变化的一个简化机制。</p>
<p>如果你启用了服务器端应用，控制平面就会跟踪被所有新创建对象管理的字段。</p>
<!-- 
## Field Management

Compared to the `last-applied` annotation managed by `kubectl`, Server Side
Apply uses a more declarative approach, which tracks a user's field management,
rather than a user's last applied state. This means that as a side effect of
using Server Side Apply, information about which field manager manages each
field in an object also becomes available.
-->
<h2 id="field-management">字段管理</h2>
<p>相对于通过 <code>kubectl</code> 管理的注解 <code>last-applied</code>，
服务器端应用使用了一种更具声明式特点的方法：
它持续的跟踪用户的字段管理，而不仅仅是最后一次的执行状态。
这就意味着，作为服务器端应用的一个副作用，
关于用哪一个字段管理器负责管理对象中的哪个字段的这类信息，都要对外界开放了。</p>
<!-- 
For a user to manage a field, in the Server Side Apply sense, means that the
user relies on and expects the value of the field not to change. The user who
last made an assertion about the value of a field will be recorded as the
current field manager. This can be done either by changing the value with
`POST`, `PUT`, or non-apply `PATCH`, or by including the field in a config sent
to the Server Side Apply endpoint. When using Server-Side Apply, trying to
change a field which is managed by someone else will result in a rejected
request (if not forced, see [Conflicts](#conflicts)).
-->
<p>用户管理字段这件事，在服务器端应用的场景中，意味着用户依赖并期望字段的值不要改变。
最后一次对字段值做出断言的用户将被记录到当前字段管理器。
这可以通过发送 <code>POST</code>、 <code>PUT</code>、
或非应用（non-apply）方式的 <code>PATCH</code> 等命令来修改字段值的方式实现，
或通过把字段放在配置文件中，然后发送到服务器端应用的服务端点的方式实现。
当使用服务器端应用，尝试着去改变一个被其他人管理的字段，
会导致请求被拒绝（在没有设置强制执行时，参见<a href="#conflicts">冲突</a>）。</p>
<!-- 
When two or more appliers set a field to the same value, they share ownership of
that field. Any subsequent attempt to change the value of the shared field, by any of
the appliers, results in a conflict. Shared field owners may give up ownership
of a field by removing it from their configuration.

Field management is stored in a`managedFields` field that is part of an object's
[`metadata`](/docs/reference/generated/kubernetes-api/v1.22/#objectmeta-v1-meta).

A simple example of an object created by Server Side Apply could look like this:
-->
<p>如果两个或以上的应用者均把同一个字段设置为相同值，他们将共享此字段的所有权。
后续任何改变共享字段值的尝试，不管由那个应用者发起，都会导致冲突。
共享字段的所有者可以放弃字段的所有权，这只需从配置文件中删除该字段即可。</p>
<p>字段管理的信息存储在 <code>managedFields</code> 字段中，该字段是对象的
<a href="/docs/reference/generated/kubernetes-api/v1.22/#objectmeta-v1-meta"><code>metadata</code></a>
中的一部分。</p>
<p>服务器端应用创建对象的简单示例如下：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>ConfigMap<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>test-cm<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">namespace</span>:<span style="color:#bbb"> </span>default<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">labels</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">test-label</span>:<span style="color:#bbb"> </span>test<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">managedFields</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- <span style="color:#008000;font-weight:bold">manager</span>:<span style="color:#bbb"> </span>kubectl<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">operation</span>:<span style="color:#bbb"> </span>Apply<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>v1<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">time</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;2010-10-10T0:00:00Z&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">fieldsType</span>:<span style="color:#bbb"> </span>FieldsV1<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">fieldsV1</span>:<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">f:metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#008000;font-weight:bold">f:labels</span>:<span style="color:#bbb">
</span><span style="color:#bbb">          </span><span style="color:#008000;font-weight:bold">f:test-label</span>:<span style="color:#bbb"> </span>{}<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">f:data</span>:<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#008000;font-weight:bold">f:key</span>:<span style="color:#bbb"> </span>{}<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">data</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">key</span>:<span style="color:#bbb"> </span>some value<span style="color:#bbb">
</span></code></pre></div><!-- 
The above object contains a single manager in `metadata.managedFields`. The
manager consists of basic information about the managing entity itself, like
operation type, API version, and the fields managed by it.

This field is managed by the  API server and should not be changed by
the user.
-->
<p>上述对象在 <code>metadata.managedFields</code> 中包含了唯一的管理器。
管理器由管理实体自身的基本信息组成，比如操作类型、API 版本、以及它管理的字段。</p>
<blockquote class="note callout">
  <div><strong>说明：</strong> 该字段由 API 服务器管理，用户不应该改动它。</div>
</blockquote>
<!-- 
Nevertheless it is possible to change `metadata.managedFields` through an
`Update` operation. Doing so is highly discouraged, but might be a reasonable
option to try if, for example, the `managedFields` get into an inconsistent
state (which clearly should not happen).

The format of the `managedFields` is described in the
[API](/docs/reference/generated/kubernetes-api/v1.22/#fieldsv1-v1-meta).
-->
<p>不过，执行 <code>Update</code> 操作修改 <code>metadata.managedFields</code> 也是可实现的。
强烈不鼓励这么做，但当发生如下情况时，
比如 <code>managedFields</code> 进入不一致的状态（显然不应该发生这种情况），
这么做也是一个合理的尝试。</p>
<p><code>managedFields</code> 的格式在
<a href="/docs/reference/generated/kubernetes-api/v1.22/#fieldsv1-v1-meta">API</a>
文档中描述。</p>
<!-- 
## Conflicts

A conflict is a special status error that occurs when an `Apply` operation tries
to change a field, which another user also claims to manage. This prevents an
applier from unintentionally overwriting the value set by another user. When
this occurs, the applier has 3 options to resolve the conflicts:
-->
<h2 id="conflicts">冲突</h2>
<p>冲突是一种特定的错误状态，
发生在执行 <code>Apply</code> 改变一个字段，而恰巧该字段被其他用户声明过主权时。
这可以防止一个应用者不小心覆盖掉其他用户设置的值。
冲突发生时，应用者有三种办法来解决它：</p>
<!-- 
* **Overwrite value, become sole manager:** If overwriting the value was
  intentional (or if the applier is an automated process like a controller) the
  applier should set the `force` query parameter to true and make the request
  again. This forces the operation to succeed, changes the value of the field,
  and removes the field from all other managers' entries in managedFields.

* **Don't overwrite value, give up management claim:** If the applier doesn't
  care about the value of the field anymore, they can remove it from their
  config and make the request again. This leaves the value unchanged, and causes
  the field to be removed from the applier's entry in managedFields.

* **Don't overwrite value, become shared manager:** If the applier still cares
  about the value of the field, but doesn't want to overwrite it, they can
  change the value of the field in their config to match the value of the object
  on the server, and make the request again. This leaves the value unchanged,
  and causes the field's management to be shared by the applier and all other
  field managers that already claimed to manage it.
-->
<ul>
<li>
<p><strong>覆盖前值，成为唯一的管理器：</strong> 如果打算覆盖该值（或应用者是一个自动化部件，比如控制器），
应用者应该设置查询参数 <code>force</code> 为 true，然后再发送一次请求。
这将强制操作成功，改变字段的值，从所有其他管理器的 managedFields 条目中删除指定字段。</p>
</li>
<li>
<p><strong>不覆盖前值，放弃管理权：</strong> 如果应用者不再关注该字段的值，
可以从配置文件中删掉它，再重新发送请求。
这就保持了原值不变，并从 managedFields 的应用者条目中删除该字段。</p>
</li>
<li>
<p><strong>不覆盖前值，成为共享的管理器：</strong> 如果应用者仍然关注字段值，并不想覆盖它，
他们可以在配置文件中把字段的值改为和服务器对象一样，再重新发送请求。
这样在不改变字段值的前提下，
就实现了字段管理被应用者和所有声明了管理权的其他的字段管理器共享。</p>
</li>
</ul>
<!-- 
## Managers

Managers identify distinct workflows that are modifying the object (especially
useful on conflicts!), and can be specified through the `fieldManager` query
parameter as part of a modifying request. It is required for the apply endpoint,
though kubectl will default it to `kubectl`. For other updates, its default is
computed from the user-agent.
-->
<h2 id="managers">管理器</h2>
<p>管理器识别出正在修改对象的工作流程（在冲突时尤其有用）,
管理器可以通过修改请求的参数 <code>fieldManager</code> 指定。
虽然 kubectl 默认发往 <code>kubectl</code> 服务端点，但它则请求到应用的服务端点（apply endpoint）。
对于其他的更新，它默认的是从用户代理计算得来。</p>
<!-- 
## Apply and Update

The two operation types considered by this feature are `Apply` (`PATCH` with
content type `application/apply-patch+yaml`) and `Update` (all other operations
which modify the object). Both operations update the `managedFields`, but behave
a little differently.

Whether you are submitting JSON data or YAML data, use
`application/apply-patch+yaml` as the `Content-Type` header value.

All JSON documents are valid YAML.
-->
<h2 id="apply-and-update">应用和更新</h2>
<p>此特性涉及两类操作，分别是 <code>Apply</code>
（内容类型为 <code>application/apply-patch+yaml</code> 的 <code>PATCH</code> 请求）
和 <code>Update</code> （所有修改对象的其他操作）。
这两类操作都会更新字段 <code>managedFields</code>，但行为表现有一点不同。</p>
<blockquote class="note callout">
  <div><strong>说明：</strong> <p>不管你提交的是 JSON 数据还是 YAML 数据，
都要使用 <code>application/apply-patch+yaml</code> 作为 <code>Content-Type</code> 的值。</p>
<p>所有的 JSON 文档 都是合法的 YAML。</p>
</div>
</blockquote>
<!-- 
For instance, only the apply operation fails on conflicts while update does
not. Also, apply operations are required to identify themselves by providing a
`fieldManager` query parameter, while the query parameter is optional for update
operations. Finally, when using the apply operation you cannot have
`managedFields` in the object that is being applied.

An example object with multiple managers could look like this:
-->
<p>例如，在冲突发生的时候，只有 <code>apply</code> 操作失败，而 <code>update</code> 则不会。
此外，<code>apply</code> 操作必须通过提供一个 <code>fieldManager</code> 查询参数来标识自身，
而此查询参数对于 <code>update</code> 操作则是可选的。
最后，当使用 <code>apply</code> 命令时，你不能在应用中的对象中持有 <code>managedFields</code>。</p>
<p>一个包含多个管理器的对象，示例如下：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>ConfigMap<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>test-cm<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">namespace</span>:<span style="color:#bbb"> </span>default<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">labels</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">test-label</span>:<span style="color:#bbb"> </span>test<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">managedFields</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- <span style="color:#008000;font-weight:bold">manager</span>:<span style="color:#bbb"> </span>kubectl<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">operation</span>:<span style="color:#bbb"> </span>Apply<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>v1<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">fields</span>:<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">f:metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#008000;font-weight:bold">f:labels</span>:<span style="color:#bbb">
</span><span style="color:#bbb">          </span><span style="color:#008000;font-weight:bold">f:test-label</span>:<span style="color:#bbb"> </span>{}<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- <span style="color:#008000;font-weight:bold">manager</span>:<span style="color:#bbb"> </span>kube-controller-manager<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">operation</span>:<span style="color:#bbb"> </span>Update<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>v1<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">time</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#39;2019-03-30T16:00:00.000Z&#39;</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">fields</span>:<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">f:data</span>:<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#008000;font-weight:bold">f:key</span>:<span style="color:#bbb"> </span>{}<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">data</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">key</span>:<span style="color:#bbb"> </span>new value<span style="color:#bbb">
</span></code></pre></div><!-- 
In this example, a second operation was run as an `Update` by the manager called
`kube-controller-manager`. The update changed a value in the data field which
caused the field's management to change to the `kube-controller-manager`.

If this update would have been an `Apply` operation, the operation
would have failed due to conflicting ownership.
-->
<p>在这个例子中，
第二个操作被管理器 <code>kube-controller-manager</code> 以 <code>Update</code> 的方式运行。
此 <code>update</code> 更改 data 字段的值，
并使得字段管理器被改为 <code>kube-controller-manager</code>。</p>
<p>如果把 <code>update</code> 操作改为 <code>Apply</code>，那就会因为所有权冲突的原因，导致操作失败。</p>
<!-- 
## Merge strategy

The merging strategy, implemented with Server Side Apply, provides a generally
more stable object lifecycle. Server Side Apply tries to merge fields based on
the actor who manages them instead of overruling based on values. This way
multiple actors can update the same object without causing unexpected interference.
-->
<h2 id="merge-strategy">合并策略</h2>
<p>由服务器端应用实现的合并策略，提供了一个总体更稳定的对象生命周期。
服务器端应用试图依据负责管理它们的主体来合并字段，而不是根据值来否决。
这么做是为了多个主体可以更新同一个对象，且不会引起意外的相互干扰。</p>
<!-- 
When a user sends a "fully-specified intent" object to the Server Side Apply
endpoint, the server merges it with the live object favoring the value in the
applied config if it is specified in both places. If the set of items present in
the applied config is not a superset of the items applied by the same user last
time, each missing item not managed by any other appliers is removed. For
more information about how an object's schema is used to make decisions when
merging, see
[sigs.k8s.io/structured-merge-diff](https://sigs.k8s.io/structured-merge-diff).
-->
<p>当用户发送一个“完整描述的目标”对象到服务器端应用的服务端点，
服务器会将它和活动对象做一次合并，如果两者中有重复定义的值，那就以配置文件的为准。
如果配置文件中的项目集合不是此用户上一次操作项目的超集，
所有缺少的、没有其他应用者管理的项目会被删除。
关于合并时用来做决策的对象规格的更多信息，参见
<a href="https://sigs.k8s.io/structured-merge-diff">sigs.k8s.io/structured-merge-diff</a>.</p>
<!-- 
A number of markers were added in Kubernetes 1.16 and 1.17, to allow API
developers to describe the merge strategy supported by lists, maps, and
structs. These markers can be applied to objects of the respective type,
in Go files or in the OpenAPI schema definition of the
[CRD](/docs/reference/generated/kubernetes-api/v1.22#jsonschemaprops-v1-apiextensions-k8s-io):
-->
<p>Kubernetes 1.16 和 1.17 中添加了一些标记，
允许 API 开发人员描述由 list、map、和 structs 支持的合并策略。
这些标记可应用到相应类型的对象，在 Go 文件或在
<a href="/docs/reference/generated/kubernetes-api/v1.22#jsonschemaprops-v1-apiextensions-k8s-io">CRD</a>
的 OpenAPI 的模式中定义：</p>
<!-- 
| Golang marker | OpenAPI extension | Accepted values | Description | Introduced in |
|---|---|---|---|---|
| `//+listType` | `x-kubernetes-list-type` | `atomic`/`set`/`map` | Applicable to lists. `set` applies to lists that include only scalar elements. These elements must be unique. `map` applies to lists of nested types only. The key values (see `listMapKey`) must be unique in the list. `atomic` can apply to any list. If configured as `atomic`, the entire list is replaced during merge. At any point in time, a single manager owns the list. If `set` or `map`, different managers can manage entries separately. | 1.16          |
| `//+listMapKey` | `x-kubernetes-list-map-keys` | List of field names, e.g. `["port", "protocol"]` | Only applicable when `+listType=map`. A list of field names whose values uniquely identify entries in the list. While there can be multiple keys, `listMapKey` is singular because keys need to be specified individually in the Go type. The key fields must be scalars. | 1.16 |
| `//+mapType` | `x-kubernetes-map-type` | `atomic`/`granular` | Applicable to maps. `atomic` means that the map can only be entirely replaced by a single manager. `granular` means that the map supports separate managers updating individual fields. | 1.17 |
| `//+structType` | `x-kubernetes-map-type` | `atomic`/`granular` | Applicable to structs; otherwise same usage and OpenAPI annotation as `//+mapType`.| 1.17 |
-->
<table>
<thead>
<tr>
<th>Golang 标记</th>
<th>OpenAPI extension</th>
<th>可接受的值</th>
<th>描述</th>
<th>引入版本</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>//+listType</code></td>
<td><code>x-kubernetes-list-type</code></td>
<td><code>atomic</code>/<code>set</code>/<code>map</code></td>
<td>适用于 list。<code>set</code> 适用于仅包含标量元素的列表。这些元素必须是不重复的。<code>map</code> 仅适用于包含嵌套类型的列表。列表中的键（参见 <code>listMapKey</code>）不可以重复。<code>atomic</code> 适用于任何类型的列表。如果配置为 <code>atomic</code>，则合并时整个列表会被替换掉。任何时候，只有一个管理器负责管理指定列表。如果配置为 <code>set</code> 或 <code>map</code>，不同的管理器也可以分开管理条目。</td>
<td>1.16</td>
</tr>
<tr>
<td><code>//+listMapKey</code></td>
<td><code>x-kubernetes-list-map-keys</code></td>
<td>字段名称的列表，例如，<code>[&quot;port&quot;, &quot;protocol&quot;]</code></td>
<td>仅当 <code>+listType=map</code> 时适用。取值为字段名称的列表，这些字段值的组合能够唯一标识列表中的条目。尽管可以存在多个键，<code>listMapKey</code> 是单数的，这是因为键名需要在 Go 类型中各自独立指定。键字段必须是标量。</td>
<td>1.16</td>
</tr>
<tr>
<td><code>//+mapType</code></td>
<td><code>x-kubernetes-map-type</code></td>
<td><code>atomic</code>/<code>granular</code></td>
<td>适用于 map。 <code>atomic</code> 指 map 只能被单个的管理器整个的替换。 <code>granular</code> 指 map 支持多个管理器各自更新自己的字段。</td>
<td>1.17</td>
</tr>
<tr>
<td><code>//+structType</code></td>
<td><code>x-kubernetes-map-type</code></td>
<td><code>atomic</code>/<code>granular</code></td>
<td>适用于 structs；否则就像 <code>//+mapType</code> 有相同的用法和 openapi 注释.</td>
<td>1.17</td>
</tr>
</tbody>
</table>
<!--
If `listType` is missing, the API server interprets a
`patchMergeStrategy=merge` marker as a `listType=map` and the
corresponding `patchMergeKey` marker as a `listMapKey`.

The `atomic` list type is recursive.

These markers are specified as comments and don't have to be repeated as
field tags.
-->
<p>若未指定 <code>listType</code>，API 服务器将 <code>patchMergeStrategy=merge</code> 标记解释为
<code>listType=map</code> 并且视对应的 <code>patchMergeKey</code> 标记为 <code>listMapKey</code> 取值。</p>
<p><code>atomic</code> 列表类型是递归的。</p>
<p>这些标记都是用源代码注释的方式给出的，不必作为字段标签（tag）再重复。</p>
<!--
### Compatibility across topology changes
-->
<h3 id="compatibility-across-toplogy-changes">拓扑变化时的兼容性 </h3>
<!--
On rare occurences, a CRD or built-in type author may want to change the
specific topology of a field in their resource without incrementing its
version. Changing the topology of types, by upgrading the cluster or
updating the CRD, has different consequences when updating existing
objects. There are two categories of changes: when a field goes from
`map`/`set`/`granular` to `atomic` and the other way around.
-->
<p>在极少的情况下，CRD 或者内置类型的作者可能希望更改其资源中的某个字段的
拓扑配置，同时又不提升版本号。
通过升级集群或者更新 CRD 来更改类型的拓扑信息与更新现有对象的结果不同。
变更的类型有两种：一种是将字段从 <code>map</code>/<code>set</code>/<code>granular</code> 更改为 <code>atomic</code>，
另一种是做逆向改变。</p>
<!--
When the `listType`, `mapType`, or `structType` changes from
`map`/`set`/`granular` to `atomic`, the whole list, map or struct of
existing objects will end-up being owned by actors who owned an element
of these types. This means that any further change to these objects
would cause a conflict.
-->
<p>当 <code>listType</code>、<code>mapType</code> 或 <code>structType</code> 从 <code>map</code>/<code>set</code>/<code>granular</code> 改为
<code>atomic</code> 时，现有对象的整个列表、映射或结构的属主都会变为这些类型的
元素之一的属主。这意味着，对这些对象的进一步变更会引发冲突。</p>
<!--
When a list, map, or struct changes from `atomic` to
`map`/`set`/`granular`, the API server won't be able to infer the new
ownership of these fields. Because of that, no conflict will be produced
when objects have these fields updated. For that reason, it is not
recommended to change a type from `atomic` to `map`/`set`/`granular`.

Take for example, the custom resource:
-->
<p>当一个列表、映射或结构从 <code>atomic</code> 改为 <code>map</code>/<code>set</code>/<code>granular</code> 之一
时，API 服务器无法推导这些字段的新的属主。因此，当对象的这些字段
再次被更新时不会引发冲突。出于这一原因，不建议将某类型从 <code>atomic</code> 改为
<code>map</code>/<code>set</code>/<code>granular</code>。</p>
<p>以下面的自定义资源为例：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>example.com/v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>Foo<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>foo-sample<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">managedFields</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- <span style="color:#008000;font-weight:bold">manager</span>:<span style="color:#bbb"> </span>manager-one<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">operation</span>:<span style="color:#bbb"> </span>Apply<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>example.com/v1<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">fields</span>:<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">f:spec</span>:<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#008000;font-weight:bold">f:data</span>:<span style="color:#bbb"> </span>{}<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">spec</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">data</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">key1</span>:<span style="color:#bbb"> </span>val1<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">key2</span>:<span style="color:#bbb"> </span>val2<span style="color:#bbb">
</span></code></pre></div><!--
Before `spec.data` gets changed from `atomic` to `granular`,
`manager-one` owns the field `spec.data`, and all the fields within it
(`key1` and `key2`). When the CRD gets changed to make `spec.data`
`granular`, `manager-one` continues to own the top-level field
`spec.data` (meaning no other managers can delete the map called `data`
without a conflict), but it no longer owns `key1` and `key2`, so another
manager can then modify or delete those fields without conflict.
-->
<p>在 <code>spec.data</code> 从 <code>atomic</code> 改为 <code>granular</code> 之前，<code>manager-one</code> 是
<code>spec.data</code> 字段及其所包含字段（<code>key1</code> 和 <code>key2</code>）的属主。
当对应的 CRD 被更改，使得 <code>spec.data</code> 变为 <code>granular</code> 拓扑时，
<code>manager-one</code> 继续拥有顶层字段 <code>spec.data</code>（这意味着其他管理者想
删除名为 <code>data</code> 的映射而不引起冲突是不可能的），但不再拥有
<code>key1</code> 和 <code>key2</code>。因此，其他管理者可以在不引起冲突的情况下更改
或删除这些字段。</p>
<!-- 
### Custom Resources

By default, Server Side Apply treats custom resources as unstructured data. All
keys are treated the same as struct fields, and all lists are considered atomic.

If the Custom Resource Definition defines a
[schema](/docs/reference/generated/kubernetes-api/v1.22#jsonschemaprops-v1-apiextensions-k8s-io)
that contains annotations as defined in the previous "Merge Strategy"
section, these annotations will be used when merging objects of this
type.
-->
<h3 id="custom-resources">自定义资源</h3>
<p>默认情况下，服务器端应用把自定义资源看做非结构化数据。
所有的键值（keys）就像 struct 的字段一样被处理，
所有的 list 被认为是原子性的。</p>
<p>如果自定义资源定义（Custom Resource Definition，CRD）定义了一个
<a href="/docs/reference/generated/kubernetes-api/v1.22#jsonschemaprops-v1-apiextensions-k8s-io">模式</a>，
它包含类似以前“合并策略”章节中定义过的注解，
这些注解将在合并此类型的对象时使用。</p>
<!-- 
## Using Server-Side Apply in a controller

As a developer of a controller, you can use server-side apply as a way to
simplify the update logic of your controller. The main differences with a
read-modify-write and/or patch are the following:

* the applied object must contain all the fields that the controller cares about.
* there are no way to remove fields that haven't been applied by the controller
  before (controller can still send a PATCH/UPDATE for these use-cases).
* the object doesn't have to be read beforehand, `resourceVersion` doesn't have
  to be specified.

It is strongly recommended for controllers to always "force" conflicts, since they
might not be able to resolve or act on these conflicts.
-->
<h2 id="using-server-side-apply-in-controller">在控制器中使用服务器端应用</h2>
<p>控制器的开发人员可以把服务器端应用作为简化控制器的更新逻辑的方式。
读-改-写 和/或 patch 的主要区别如下所示：</p>
<ul>
<li>应用的对象必须包含控制器关注的所有字段。</li>
<li>对于在控制器没有执行过应用操作之前就已经存在的字段，不能删除。
（控制器在这种用例环境下，依然可以发送一个 PATCH/UPDATE）</li>
<li>对象不必事先读取，<code>resourceVersion</code> 不必指定。</li>
</ul>
<p>强烈推荐：设置控制器在冲突时强制执行，这是因为冲突发生时，它们没有其他解决方案或措施。</p>
<!-- 
## Transferring Ownership

In addition to the concurrency controls provided by [conflict resolution](#conflicts),
Server Side Apply provides ways to perform coordinated
field ownership transfers from users to controllers.

This is best explained by example. Let's look at how to safely transfer
ownership of the `replicas` field from a user to a controller while enabling
automatic horizontal scaling for a Deployment, using the HorizontalPodAutoscaler
resource and its accompanying controller.

Say a user has defined deployment with `replicas` set to the desired value:
-->
<h2 id="transferring-ownership">转移所有权</h2>
<p>除了通过<a href="#conflicts">冲突解决方案</a>提供的并发控制，
服务器端应用提供了一些协作方式来将字段所有权从用户转移到控制器。</p>
<p>最好通过例子来说明这一点。
让我们来看看，在使用 Horizo​​ntalPodAutoscaler 资源和与之配套的控制器，
且开启了 Deployment 的自动水平扩展功能之后，
怎么安全的将 <code>replicas</code> 字段的所有权从用户转移到控制器。</p>
<p>假设用户定义了 Deployment，且 <code>replicas</code> 字段已经设置为期望的值：</p>


 













<div class="highlight">
    <div class="copy-code-icon" style="text-align:right">
    <a href="https://raw.githubusercontent.com/kubernetes/website/main/content/zh/examples/application/ssa/nginx-deployment.yaml" download="application/ssa/nginx-deployment.yaml"><code>application/ssa/nginx-deployment.yaml</code>
    </a>
    <img src="/images/copycode.svg" style="max-height:24px; cursor: pointer" onclick="copyCode('application-ssa-nginx-deployment-yaml')" title="Copy application/ssa/nginx-deployment.yaml to clipboard">
    </img>
    </div>
    <div class="includecode" id="application-ssa-nginx-deployment-yaml">
    <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>apps/v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>Deployment<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>nginx-deployment<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">labels</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">app</span>:<span style="color:#bbb"> </span>nginx<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">spec</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">replicas</span>:<span style="color:#bbb"> </span><span style="color:#666">3</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">selector</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">matchLabels</span>:<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">app</span>:<span style="color:#bbb"> </span>nginx<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">template</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">labels</span>:<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#008000;font-weight:bold">app</span>:<span style="color:#bbb"> </span>nginx<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">spec</span>:<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">containers</span>:<span style="color:#bbb">
</span><span style="color:#bbb">      </span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>nginx<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#008000;font-weight:bold">image</span>:<span style="color:#bbb"> </span>nginx:1.14.2<span style="color:#bbb">
</span></code></pre></div>
    </div>
</div>


<!-- 
And the user has created the deployment using server side apply like so:
-->
<p>并且，用户使用服务器端应用，像这样创建 Deployment：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl apply -f https://k8s.io/examples/application/ssa/nginx-deployment.yaml --server-side
</code></pre></div><!-- 
Then later, HPA is enabled for the deployment, e.g.:
-->
<p>然后，为 Deployment 启用 HPA，例如：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl autoscale deployment nginx-deployment --cpu-percent<span style="color:#666">=</span><span style="color:#666">50</span> --min<span style="color:#666">=</span><span style="color:#666">1</span> --max<span style="color:#666">=</span><span style="color:#666">10</span>
</code></pre></div><!-- 
Now, the user would like to remove `replicas` from their configuration, so they
don't accidentally fight with the HPA controller. However, there is a race: it
might take some time before HPA feels the need to adjust `replicas`, and if
the user removes `replicas` before the HPA writes to the field and becomes
its owner, then apiserver will set `replicas` to 1, its default value. This
is not what the user wants to happen, even temporarily.
-->
<p>现在，用户希望从他们的配置中删除 <code>replicas</code>，所以他们总是和 HPA 控制器冲突。
然而，这里存在一个竟态：
在 HPA 需要调整 <code>replicas</code> 之前会有一个时间窗口，
如果在 HPA 写入字段成为所有者之前，用户删除了<code>replicas</code>，
那 API 服务器就会把 <code>replicas</code> 的值设为1， 也就是默认值。
这不是用户希望发生的事情，即使是暂时的。</p>
<!-- 
There are two solutions:

- (basic) Leave `replicas` in the configuration; when HPA eventually writes to that
  field, the system gives the user a conflict over it. At that point, it is safe
  to remove from the configuration.

- (more advanced) If, however, the user doesn't want to wait, for example
  because they want to keep the cluster legible to coworkers, then they can take
  the following steps to make it safe to remove `replicas` from their
  configuration:

First, the user defines a new configuration containing only the `replicas` field:
-->
<p>这里有两个解决方案：</p>
<ul>
<li>（基本操作）把 <code>replicas</code> 留在配置文件中；当 HPA 最终写入那个字段，
系统基于此事件告诉用户：冲突发生了。在这个时间点，可以安全的删除配置文件。</li>
<li>（高级操作）然而，如果用户不想等待，比如他们想为合作伙伴保持集群清晰，
那他们就可以执行以下步骤，安全的从配置文件中删除 <code>replicas</code>。</li>
</ul>
<p>首先，用户新定义一个只包含 <code>replicas</code> 字段的配置文件：</p>


 













<div class="highlight">
    <div class="copy-code-icon" style="text-align:right">
    <a href="https://raw.githubusercontent.com/kubernetes/website/main/content/zh/examples/application/ssa/nginx-deployment-replicas-only.yaml" download="application/ssa/nginx-deployment-replicas-only.yaml"><code>application/ssa/nginx-deployment-replicas-only.yaml</code>
    </a>
    <img src="/images/copycode.svg" style="max-height:24px; cursor: pointer" onclick="copyCode('application-ssa-nginx-deployment-replicas-only-yaml')" title="Copy application/ssa/nginx-deployment-replicas-only.yaml to clipboard">
    </img>
    </div>
    <div class="includecode" id="application-ssa-nginx-deployment-replicas-only-yaml">
    <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>apps/v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>Deployment<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>nginx-deployment<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">spec</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">replicas</span>:<span style="color:#bbb"> </span><span style="color:#666">3</span><span style="color:#bbb">
</span></code></pre></div>
    </div>
</div>


<!-- 
The user applies that configuration using the field manager name `handover-to-hpa`:
-->
<p>用户使用名为 <code>handover-to-hpa</code> 的字段管理器，应用此配置文件。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl apply -f https://k8s.io/examples/application/ssa/nginx-deployment-replicas-only.yaml <span style="color:#b62;font-weight:bold">\
</span><span style="color:#b62;font-weight:bold"></span>  --server-side --field-manager<span style="color:#666">=</span>handover-to-hpa <span style="color:#b62;font-weight:bold">\
</span><span style="color:#b62;font-weight:bold"></span>  --validate<span style="color:#666">=</span><span style="color:#a2f">false</span>
</code></pre></div><!-- 
If the apply results in a conflict with the HPA controller, then do nothing. The
conflict indicates the controller has claimed the field earlier in the
process than it sometimes does.

At this point the user may remove the `replicas` field from their configuration.
-->
<p>如果应用操作和 HPA 控制器产生冲突，那什么都不做。
冲突表明控制器在更早的流程中已经对字段声明过所有权。</p>
<p>在此时间点，用户可以从配置文件中删除 <code>replicas</code> 。</p>


 













<div class="highlight">
    <div class="copy-code-icon" style="text-align:right">
    <a href="https://raw.githubusercontent.com/kubernetes/website/main/content/zh/examples/application/ssa/nginx-deployment-no-replicas.yaml" download="application/ssa/nginx-deployment-no-replicas.yaml"><code>application/ssa/nginx-deployment-no-replicas.yaml</code>
    </a>
    <img src="/images/copycode.svg" style="max-height:24px; cursor: pointer" onclick="copyCode('application-ssa-nginx-deployment-no-replicas-yaml')" title="Copy application/ssa/nginx-deployment-no-replicas.yaml to clipboard">
    </img>
    </div>
    <div class="includecode" id="application-ssa-nginx-deployment-no-replicas-yaml">
    <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>apps/v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>Deployment<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>nginx-deployment<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">labels</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">app</span>:<span style="color:#bbb"> </span>nginx<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">spec</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">selector</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">matchLabels</span>:<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">app</span>:<span style="color:#bbb"> </span>nginx<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">template</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">labels</span>:<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#008000;font-weight:bold">app</span>:<span style="color:#bbb"> </span>nginx<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">spec</span>:<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">containers</span>:<span style="color:#bbb">
</span><span style="color:#bbb">      </span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>nginx<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#008000;font-weight:bold">image</span>:<span style="color:#bbb"> </span>nginx:1.14.2<span style="color:#bbb">
</span></code></pre></div>
    </div>
</div>


<!-- 
Note that whenever the HPA controller sets the `replicas` field to a new value,
the temporary field manager will no longer own any fields and will be
automatically deleted. No clean up is required.
-->
<p>注意，只要 HPA 控制器为 <code>replicas</code> 设置了一个新值，
该临时字段管理器将不再拥有任何字段，会被自动删除。
这里不需要执行清理工作。</p>
<!-- 
### Transferring Ownership Between Users

Users can transfer ownership of a field between each other by setting the field
to the same value in both of their applied configs, causing them to share
ownership of the field. Once the users share ownership of the field, one of them
can remove the field from their applied configuration to give up ownership and
complete the transfer to the other user.
-->
<h3 id="transferring-ownership-between-users">在用户之间转移所有权</h3>
<p>通过在配置文件中把一个字段设置为相同的值，用户可以在他们之间转移字段的所有权，
从而共享了字段的所有权。
当用户共享了字段的所有权，任何一个用户可以从他的配置文件中删除该字段，
并应用该变更，从而放弃所有权，并实现了所有权向其他用户的转移。</p>
<!-- 
## Comparison with Client Side Apply

A consequence of the conflict detection and resolution implemented by Server
Side Apply is that an applier always has up to date field values in their local
state. If they don't, they get a conflict the next time they apply. Any of the
three options to resolve conflicts results in the applied configuration being an
up to date subset of the object on the server's fields.

This is different from Client Side Apply, where outdated values which have been
overwritten by other users are left in an applier's local config. These values
only become accurate when the user updates that specific field, if ever, and an
applier has no way of knowing whether their next apply will overwrite other
users' changes.

Another difference is that an applier using Client Side Apply is unable to
change the API version they are using, but Server Side Apply supports this use
case.
-->
<h2 id="comparison-with-client-side-apply">与客户端应用的对比</h2>
<p>由服务器端应用实现的冲突检测和解决方案的一个结果就是，
应用者总是可以在本地状态中得到最新的字段值。
如果得不到最新值，下次执行应用操作时就会发生冲突。
解决冲突三个选项的任意一个都会保证：此应用过的配置文件是服务器上对象字段的最新子集。</p>
<p>这和客户端应用（Client Side Apply） 不同，如果有其他用户覆盖了此值，
过期的值被留在了应用者本地的配置文件中。
除非用户更新了特定字段，此字段才会准确，
应用者没有途径去了解下一次应用操作是否会覆盖其他用户的修改。</p>
<p>另一个区别是使用客户端应用的应用者不能改变他们正在使用的 API 版本，但服务器端应用支持这个场景。</p>
<!-- 
## Upgrading from client-side apply to server-side apply

Client-side apply users who manage a resource with `kubectl apply` can start
using server-side apply with the following flag.
-->
<h2 id="upgrading-from-client-side-apply-to-server-side-apply">从客户端应用升级到服务器端应用</h2>
<p>客户端应用方式时，用户使用 <code>kubectl apply</code> 管理资源，
可以通过使用下面标记切换为使用服务器端应用。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl apply --server-side <span style="color:#666">[</span>--dry-run<span style="color:#666">=</span>server<span style="color:#666">]</span>
</code></pre></div><!-- 
By default, field management of the object transfers from client-side apply to
kubectl server-side apply without encountering conflicts.

Keep the `last-applied-configuration` annotation up to date.
The annotation infers client-side apply's managed fields.
Any fields not managed by client-side apply raise conflicts.

For example, if you used `kubectl scale` to update the replicas field after
client-side apply, then this field is not owned by client-side apply and
creates conflicts on `kubectl apply --server-side`.

This behavior applies to server-side apply with the `kubectl` field manager.
As an exception, you can opt-out of this behavior by specifying a different,
non-default field manager, as seen in the following example. The default field
manager for kubectl server-side apply is `kubectl`.
-->
<p>默认情况下，对象的字段管理从客户端应用方式迁移到 kubectl 触发的服务器端应用时，不会发生冲突。</p>
<blockquote class="caution callout">
  <div><strong>注意：</strong> <p>保持注解 <code>last-applied-configuration</code> 是最新的。
从注解能推断出字段是由客户端应用管理的。
任何没有被客户端应用管理的字段将引发冲突。</p>
<p>举例说明，比如你在客户端应用之后，
使用 <code>kubectl scale</code> 去更新 <code>replicas</code> 字段，
可是该字段并没有被客户端应用所拥有，
在执行 <code>kubectl apply --server-side</code> 时就会产生冲突。</p>
</div>
</blockquote>

<p>此操作以 <code>kubectl</code> 作为字段管理器来应用到服务器端应用。
作为例外，可以指定一个不同的、非默认字段管理器停止的这种行为，如下面的例子所示。
对于 kubectl 触发的服务器端应用，默认的字段管理器是 <code>kubectl</code>。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl apply --server-side --field-manager<span style="color:#666">=</span>my-manager <span style="color:#666">[</span>--dry-run<span style="color:#666">=</span>server<span style="color:#666">]</span>
</code></pre></div><!-- 
## Downgrading from server-side apply to client-side apply

If you manage a resource with `kubectl apply --server-side`,
you can downgrade to client-side apply directly with `kubectl apply`.

Downgrading works because kubectl server-side apply keeps the
`last-applied-configuration` annotation up-to-date if you use
`kubectl apply`.

This behavior applies to server-side apply with the `kubectl` field manager.
As an exception, you can opt-out of this behavior by specifying a different,
non-default field manager, as seen in the following example. The default field
manager for kubectl server-side apply is `kubectl`.
-->
<h2 id="downgrading-from-server-side-apply-to-client-side-apply">从服务器端应用降级到客户端应用</h2>
<p>如果你用 <code>kubectl apply --server-side</code> 管理一个资源，
可以直接用 <code>kubectl apply</code> 命令将其降级为客户端应用。</p>
<p>降级之所以可行，这是因为 <code>kubectl server-side apply</code>
会保存最新的 <code>last-applied-configuration</code> 注解。</p>
<p>此操作以 <code>kubectl</code> 作为字段管理器应用到服务器端应用。
作为例外，可以指定一个不同的、非默认字段管理器停止这种行为，如下面的例子所示。
对于 kubectl 触发的服务器端应用，默认的字段管理器是 <code>kubectl</code>。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl apply --server-side --field-manager<span style="color:#666">=</span>my-manager <span style="color:#666">[</span>--dry-run<span style="color:#666">=</span>server<span style="color:#666">]</span>
</code></pre></div><!-- 
## API Endpoint

With the Server Side Apply feature enabled, the `PATCH` endpoint accepts the
additional `application/apply-patch+yaml` content type. Users of Server Side
Apply can send partially specified objects as YAML to this endpoint.  When
applying a configuration, one should always include all the fields that they
have an opinion about.
-->
<h2 id="api-endpoint">API 端点</h2>
<p>启用了服务器端应用特性之后，
<code>PATCH</code> 服务端点接受额外的内容类型 <code>application/apply-patch+yaml</code>。
服务器端应用的用户就可以把 YAMl 格式的
部分定义对象（partially specified objects）发送到此端点。
当一个配置文件被应用时，它应该包含所有体现你意图的字段。</p>
<!-- 
## Clearing ManagedFields

It is possible to strip all managedFields from an object by overwriting them
using `MergePatch`, `StrategicMergePatch`, `JSONPatch` or `Update`, so every
non-apply operation. This can be done by overwriting the managedFields field
with an empty entry. Two examples are:
-->
<h2 id="clearing-managedfields">清除 ManagedFields</h2>
<p>可以从对象中剥离所有 managedField，
实现方法是通过使用 <code>MergePatch</code>、 <code>StrategicMergePatch</code>、
<code>JSONPatch</code>、 <code>Update</code>、以及所有的非应用方式的操作来覆盖它。
这可以通过用空条目覆盖 managedFields 字段的方式实现。</p>
<pre tabindex="0"><code class="language-console" data-lang="console">PATCH /api/v1/namespaces/default/configmaps/example-cm
Content-Type: application/merge-patch+json
Accept: application/json
Data: {&quot;metadata&quot;:{&quot;managedFields&quot;: [{}]}}
</code></pre><pre tabindex="0"><code class="language-console" data-lang="console">PATCH /api/v1/namespaces/default/configmaps/example-cm
Content-Type: application/json-patch+json
Accept: application/json
Data: [{&quot;op&quot;: &quot;replace&quot;, &quot;path&quot;: &quot;/metadata/managedFields&quot;, &quot;value&quot;: [{}]}]
</code></pre><!-- 
This will overwrite the managedFields with a list containing a single empty
entry that then results in the managedFields being stripped entirely from the
object. Note that setting the managedFields to an empty list will not
reset the field. This is on purpose, so managedFields never get stripped by
clients not aware of the field.

In cases where the reset operation is combined with changes to other fields
than the managedFields, this will result in the managedFields being reset
first and the other changes being processed afterwards. As a result the
applier takes ownership of any fields updated in the same request.
-->
<p>这一操作将用只包含一个空条目的列表覆写 managedFields，
来实现从对象中整个的去除 managedFields。
注意，只把 managedFields 设置为空列表并不会重置字段。
这么做是有目的的，所以 managedFields 将永远不会被与该字段无关的客户删除。</p>
<p>在重置操作结合 managedFields 以外其他字段更改的场景中，
将导致 managedFields 首先被重置，其他改变被押后处理。
其结果是，应用者取得了同一个请求中所有字段的所有权。</p>
<!-- 
Server Side Apply does not correctly track ownership on
sub-resources that don't receive the resource object type. If you are
using Server Side Apply with such a sub-resource, the changed fields
won't be tracked.
-->
<blockquote class="caution callout">
  <div><strong>注意：</strong> 对于不接受资源对象类型的子资源（sub-resources），
服务器端应用不能正确地跟踪其所有权。
如果你对这样的子资源使用服务器端应用，变更的字段将不会被跟踪。</div>
</blockquote>

<!-- 
## Disabling the feature

Server Side Apply is a beta feature, so it is enabled by default. To turn this
[feature gate](/docs/reference/command-line-tools-reference/feature-gates) off,
you need to include the `--feature-gates ServerSideApply=false` flag when
starting `kube-apiserver`. If you have multiple `kube-apiserver` replicas, all
should have the same flag setting.
-->
<h2 id="disabling-the-feature">禁用此功能</h2>
<p>服务器端应用是一个 Beta 版特性，默认启用。
要关闭此<a href="/zh/docs/reference/command-line-tools-reference/feature-gates">特性门控</a>，
你需要在启动 <code>kube-apiserver</code> 时包含参数 <code>--feature-gates ServerSideApply=false</code>。
如果你有多个 <code>kube-apiserver</code> 副本，它们的标志设置应该都相同。</p>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-79880efc25dc8cb3b6962ad78a964319">2.3 - 客户端库</h1>
    
	<!--
title: Client Libraries
reviewers:
- ahmetb
content_type: concept
weight: 30
-->
<!-- overview -->
<!--
This page contains an overview of the client libraries for using the Kubernetes
API from various programming languages.
-->
<p>本页面包含基于各种编程语言使用 Kubernetes API 的客户端库概述。</p>
<!-- body -->
<!--
To write applications using the [Kubernetes REST API](/docs/reference/using-api/),
you do not need to implement the API calls and request/response types yourself.
You can use a client library for the programming language you are using.
-->
<p>在使用 <a href="/zh/docs/reference/using-api/">Kubernetes REST API</a> 编写应用程序时，
您并不需要自己实现 API 调用和 “请求/响应” 类型。
您可以根据自己的编程语言需要选择使用合适的客户端库。</p>
<!--
Client libraries often handle common tasks such as authentication for you.
Most client libraries can discover and use the Kubernetes Service Account to
authenticate if the API client is running inside the Kubernetes cluster, or can
understand the [kubeconfig file](/docs/tasks/access-application-cluster/configure-access-multiple-clusters/)
format to read the credentials and the API Server address.
-->
<p>客户端库通常为您处理诸如身份验证之类的常见任务。
如果 API 客户端在 Kubernetes 集群中运行，大多数客户端库可以发现并使用 Kubernetes 服务帐户进行身份验证，
或者能够理解 <a href="/zh/docs/tasks/access-application-cluster/configure-access-multiple-clusters/">kubeconfig 文件</a>
格式来读取凭据和 API 服务器地址。</p>
<!--
## Officially-supported Kubernetes client libraries
-->
<h2 id="officially-supported-kubernetes-client-libraries">官方支持的 Kubernetes 客户端库 </h2>
<!--
The following client libraries are officially maintained by
[Kubernetes SIG API Machinery](https://github.com/kubernetes/community/tree/master/sig-api-machinery).
-->
<p>以下客户端库由 <a href="https://github.com/kubernetes/community/tree/master/sig-api-machinery">Kubernetes SIG API Machinery</a> 正式维护。</p>
<!--
| Language | Client Library | Sample Programs |
|----------|----------------|-----------------|
| dotnet   | [github.com/kubernetes-client/csharp](https://github.com/kubernetes-client/csharp) | [browse](https://github.com/kubernetes-client/csharp/tree/master/examples/simple)
| Go       | [github.com/kubernetes/client-go/](https://github.com/kubernetes/client-go/) | [browse](https://github.com/kubernetes/client-go/tree/master/examples)
| Haskell  | [github.com/kubernetes-client/haskell](https://github.com/kubernetes-client/haskell) | [browse](https://github.com/kubernetes-client/haskell/tree/master/kubernetes-client/example)
| Java     | [github.com/kubernetes-client/java](https://github.com/kubernetes-client/java/) | [browse](https://github.com/kubernetes-client/java#installation)
| JavaScript   | [github.com/kubernetes-client/javascript](https://github.com/kubernetes-client/javascript) | [browse](https://github.com/kubernetes-client/javascript/tree/master/examples)
| Python   | [github.com/kubernetes-client/python/](https://github.com/kubernetes-client/python/) | [browse](https://github.com/kubernetes-client/python/tree/master/examples)
-->
<table>
<thead>
<tr>
<th>语言</th>
<th>客户端库</th>
<th>样例程序</th>
</tr>
</thead>
<tbody>
<tr>
<td>dotnet</td>
<td><a href="https://github.com/kubernetes-client/csharp">github.com/kubernetes-client/csharp</a></td>
<td><a href="https://github.com/kubernetes-client/csharp/tree/master/examples/simple">浏览</a></td>
</tr>
<tr>
<td>Go</td>
<td><a href="https://github.com/kubernetes/client-go/">github.com/kubernetes/client-go/</a></td>
<td><a href="https://github.com/kubernetes/client-go/tree/master/examples">浏览</a></td>
</tr>
<tr>
<td>Haskell</td>
<td><a href="https://github.com/kubernetes-client/haskell">github.com/kubernetes-client/haskell</a></td>
<td><a href="https://github.com/kubernetes-client/haskell/tree/master/kubernetes-client/example">浏览</a></td>
</tr>
<tr>
<td>Java</td>
<td><a href="https://github.com/kubernetes-client/java/">github.com/kubernetes-client/java</a></td>
<td><a href="https://github.com/kubernetes-client/java#installation">浏览</a></td>
</tr>
<tr>
<td>JavaScript</td>
<td><a href="https://github.com/kubernetes-client/javascript">github.com/kubernetes-client/javascript</a></td>
<td><a href="https://github.com/kubernetes-client/javascript/tree/master/examples">浏览</a></td>
</tr>
<tr>
<td>Python</td>
<td><a href="https://github.com/kubernetes-client/python/">github.com/kubernetes-client/python/</a></td>
<td><a href="https://github.com/kubernetes-client/python/tree/master/examples">浏览</a></td>
</tr>
</tbody>
</table>
<!--
## Community-maintained client libraries
-->
<h2 id="community-maintained-client-libraries">社区维护的客户端库 </h2>
<blockquote class="callout caution" role="alert">
  <strong>注意：</strong>
  本部分链接到提供 Kubernetes 所需功能的第三方项目。Kubernetes 项目作者不负责这些项目。此页面遵循<a href="https://github.com/cncf/foundation/blob/master/website-guidelines.md" target="_blank">CNCF 网站指南</a>，按字母顺序列出项目。要将项目添加到此列表中，请在提交更改之前阅读<a href="/docs/contribute/style/content-guide/#third-party-content">内容指南</a>。
</blockquote>
<!--
The following Kubernetes API client libraries are provided and maintained by
their authors, not the Kubernetes team.
-->
<p>以下 Kubernetes API 客户端库是由社区，而非 Kubernetes 团队支持、维护的。</p>
<!--
| Language             | Client Library                           |
| -------------------- | ---------------------------------------- |
| Clojure              | [github.com/yanatan16/clj-kubernetes-api](https://github.com/yanatan16/clj-kubernetes-api) |
| DotNet               | [github.com/tonnyeremin/kubernetes_gen](https://github.com/tonnyeremin/kubernetes_gen) |
| DotNet (RestSharp)   | [github.com/masroorhasan/Kubernetes.DotNet](https://github.com/masroorhasan/Kubernetes.DotNet) |
| Elixir               | [github.com/obmarg/kazan](https://github.com/obmarg/kazan/) |
| Elixir               | [github.com/coryodaniel/k8s](https://github.com/coryodaniel/k8s) |
| Go                   | [github.com/ericchiang/k8s](https://github.com/ericchiang/k8s) |
| Java (OSGi)          | [bitbucket.org/amdatulabs/amdatu-kubernetes](https://bitbucket.org/amdatulabs/amdatu-kubernetes) |
| Java (Fabric8, OSGi) | [github.com/fabric8io/kubernetes-client](https://github.com/fabric8io/kubernetes-client) |
| Java                 | [github.com/manusa/yakc](https://github.com/manusa/yakc) |
| Lisp                 | [github.com/brendandburns/cl-k8s](https://github.com/brendandburns/cl-k8s) |
| Lisp                 | [github.com/xh4/cube](https://github.com/xh4/cube) |
| Node.js (TypeScript) | [github.com/Goyoo/node-k8s-client](https://github.com/Goyoo/node-k8s-client) |
| Node.js              | [github.com/ajpauwels/easy-k8s](https://github.com/ajpauwels/easy-k8s)
| Node.js              | [github.com/godaddy/kubernetes-client](https://github.com/godaddy/kubernetes-client) |
| Node.js              | [github.com/tenxcloud/node-kubernetes-client](https://github.com/tenxcloud/node-kubernetes-client) |
| Perl                 | [metacpan.org/pod/Net::Kubernetes](https://metacpan.org/pod/Net::Kubernetes) |
| PHP                  | [github.com/allansun/kubernetes-php-client](https://github.com/allansun/kubernetes-php-client) |
| PHP                  | [github.com/maclof/kubernetes-client](https://github.com/maclof/kubernetes-client) |
| PHP                  | [github.com/travisghansen/kubernetes-client-php](https://github.com/travisghansen/kubernetes-client-php) |
| PHP                  | [github.com/renoki-co/php-k8s](https://github.com/renoki-co/php-k8s) |
| Python               | [github.com/fiaas/k8s](https://github.com/fiaas/k8s) |
| Python               | [github.com/mnubo/kubernetes-py](https://github.com/mnubo/kubernetes-py) |
| Python               | [github.com/tomplus/kubernetes_asyncio](https://github.com/tomplus/kubernetes_asyncio) |
| Python               | [github.com/Frankkkkk/pykorm](https://github.com/Frankkkkk/pykorm) |
| Ruby                 | [github.com/abonas/kubeclient](https://github.com/abonas/kubeclient) |
| Ruby                 | [github.com/Ch00k/kuber](https://github.com/Ch00k/kuber) |
| Ruby                 | [github.com/k8s-ruby/k8s-ruby](https://github.com/k8s-ruby/k8s-ruby) |
| Ruby                 | [github.com/kontena/k8s-client](https://github.com/kontena/k8s-client) |
| Rust                 | [github.com/clux/kube-rs](https://github.com/clux/kube-rs) |
| Rust                 | [github.com/ynqa/kubernetes-rust](https://github.com/ynqa/kubernetes-rust) |
| Scala                | [github.com/hagay3/skuber](https://github.com/hagay3/skuber) |
| Scala                | [github.com/joan38/kubernetes-client](https://github.com/joan38/kubernetes-client) |
-->
<table>
<thead>
<tr>
<th>语言</th>
<th>客户端库</th>
</tr>
</thead>
<tbody>
<tr>
<td>Clojure</td>
<td><a href="https://github.com/yanatan16/clj-kubernetes-api">github.com/yanatan16/clj-kubernetes-api</a></td>
</tr>
<tr>
<td>DotNet</td>
<td><a href="https://github.com/tonnyeremin/kubernetes_gen">github.com/tonnyeremin/kubernetes_gen</a></td>
</tr>
<tr>
<td>DotNet (RestSharp)</td>
<td><a href="https://github.com/masroorhasan/Kubernetes.DotNet">github.com/masroorhasan/Kubernetes.DotNet</a></td>
</tr>
<tr>
<td>Elixir</td>
<td><a href="https://github.com/obmarg/kazan/">github.com/obmarg/kazan</a></td>
</tr>
<tr>
<td>Elixir</td>
<td><a href="https://github.com/coryodaniel/k8s">github.com/coryodaniel/k8s</a></td>
</tr>
<tr>
<td>Go</td>
<td><a href="https://github.com/ericchiang/k8s">github.com/ericchiang/k8s</a></td>
</tr>
<tr>
<td>Java (OSGi)</td>
<td><a href="https://bitbucket.org/amdatulabs/amdatu-kubernetes">bitbucket.org/amdatulabs/amdatu-kubernetes</a></td>
</tr>
<tr>
<td>Java (Fabric8, OSGi)</td>
<td><a href="https://github.com/fabric8io/kubernetes-client">github.com/fabric8io/kubernetes-client</a></td>
</tr>
<tr>
<td>Java</td>
<td><a href="https://github.com/manusa/yakc">github.com/manusa/yakc</a></td>
</tr>
<tr>
<td>Lisp</td>
<td><a href="https://github.com/brendandburns/cl-k8s">github.com/brendandburns/cl-k8s</a></td>
</tr>
<tr>
<td>Lisp</td>
<td><a href="https://github.com/xh4/cube">github.com/xh4/cube</a></td>
</tr>
<tr>
<td>Node.js (TypeScript)</td>
<td><a href="https://github.com/Goyoo/node-k8s-client">github.com/Goyoo/node-k8s-client</a></td>
</tr>
<tr>
<td>Node.js</td>
<td><a href="https://github.com/ajpauwels/easy-k8s">github.com/ajpauwels/easy-k8s</a></td>
</tr>
<tr>
<td>Node.js</td>
<td><a href="https://github.com/godaddy/kubernetes-client">github.com/godaddy/kubernetes-client</a></td>
</tr>
<tr>
<td>Node.js</td>
<td><a href="https://github.com/tenxcloud/node-kubernetes-client">github.com/tenxcloud/node-kubernetes-client</a></td>
</tr>
<tr>
<td>Perl</td>
<td><a href="https://metacpan.org/pod/Net::Kubernetes">metacpan.org/pod/Net::Kubernetes</a></td>
</tr>
<tr>
<td>PHP</td>
<td><a href="https://github.com/allansun/kubernetes-php-client">github.com/allansun/kubernetes-php-client</a></td>
</tr>
<tr>
<td>PHP</td>
<td><a href="https://github.com/maclof/kubernetes-client">github.com/maclof/kubernetes-client</a></td>
</tr>
<tr>
<td>PHP</td>
<td><a href="https://github.com/travisghansen/kubernetes-client-php">github.com/travisghansen/kubernetes-client-php</a></td>
</tr>
<tr>
<td>PHP</td>
<td><a href="https://github.com/renoki-co/php-k8s">github.com/renoki-co/php-k8s</a></td>
</tr>
<tr>
<td>Python</td>
<td><a href="https://github.com/fiaas/k8s">github.com/fiaas/k8s</a></td>
</tr>
<tr>
<td>Python</td>
<td><a href="https://github.com/mnubo/kubernetes-py">github.com/mnubo/kubernetes-py</a></td>
</tr>
<tr>
<td>Python</td>
<td><a href="https://github.com/tomplus/kubernetes_asyncio">github.com/tomplus/kubernetes_asyncio</a></td>
</tr>
<tr>
<td>Python</td>
<td><a href="https://github.com/Frankkkkk/pykorm">github.com/Frankkkkk/pykorm</a></td>
</tr>
<tr>
<td>Ruby</td>
<td><a href="https://github.com/abonas/kubeclient">github.com/abonas/kubeclient</a></td>
</tr>
<tr>
<td>Ruby</td>
<td><a href="https://github.com/Ch00k/kuber">github.com/Ch00k/kuber</a></td>
</tr>
<tr>
<td>Ruby</td>
<td><a href="https://github.com/k8s-ruby/k8s-ruby">github.com/k8s-ruby/k8s-ruby</a></td>
</tr>
<tr>
<td>Ruby</td>
<td><a href="https://github.com/kontena/k8s-client">github.com/kontena/k8s-client</a></td>
</tr>
<tr>
<td>Rust</td>
<td><a href="https://github.com/clux/kube-rs">github.com/clux/kube-rs</a></td>
</tr>
<tr>
<td>Rust</td>
<td><a href="https://github.com/ynqa/kubernetes-rust">github.com/ynqa/kubernetes-rust</a></td>
</tr>
<tr>
<td>Scala</td>
<td><a href="https://github.com/hagay3/skuber">github.com/hagay3/skuber</a></td>
</tr>
<tr>
<td>Scala</td>
<td><a href="https://github.com/joan38/kubernetes-client">github.com/joan38/kubernetes-client</a></td>
</tr>
<tr>
<td>Swift</td>
<td><a href="https://github.com/swiftkube/client">github.com/swiftkube/client</a></td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-8d2ce3e7b2223cda0ccd428f4d5ea24b">2.4 - Kubernetes 弃用策略</h1>
    
	<!--
reviewers:
- bgrant0607
- lavalamp
- thockin
title: Kubernetes Deprecation Policy
content_type: concept
weight: 40
-->
<!-- overview -->
<!--
This document details the deprecation policy for various facets of the system.
-->
<p>本文档详细解释系统中各个层面的弃用策略（Deprecation Policy）。</p>
<!-- body -->
<!--
Kubernetes is a large system with many components and many contributors.  As
with any such software, the feature set naturally evolves over time, and
sometimes a feature may need to be removed. This could include an API, a flag,
or even an entire feature. To avoid breaking existing users, Kubernetes follows
a deprecation policy for aspects of the system that are slated to be removed.
-->
<p>Kubernetes 是一个组件众多、贡献者人数众多的大系统。
就像很多类似的软件，所提供的功能特性集合会随着时间推移而自然发生变化，
而且有时候某个功能特性可能需要被去除。被去除的可能是一个 API、一个参数标志或者
甚至某整个功能特性。为了避免影响到现有用户，Kubernetes 对于其中渐次移除
的各个方面规定了一种弃用策略并遵从此策略。</p>
<!--
## Deprecating parts of the API

Since Kubernetes is an API-driven system, the API has evolved over time to
reflect the evolving understanding of the problem space. The Kubernetes API is
actually a set of APIs, called "API groups", and each API group is
independently versioned.  [API versions](/docs/reference/using-api/#api-versioning) fall
into 3 main tracks, each of which has different policies for deprecation:
-->
<h2 id="deprecating-parts-of-the-api">弃用 API 的一部分 </h2>
<p>由于 Kubernetes 是一个 API 驱动的系统，API 会随着时间推移而演化，以反映
人们对问题空间的认识的变化。Kubernetes API 实际上是一个 API 集合，其中每个
成员称作“API 组（API Group）”，并且每个 API 组都是独立管理版本的。
<a href="/zh/docs/reference/using-api/#api-versioning">API 版本</a>会有
三类，每类有不同的废弃策略：</p>
<!--
| Example  | Track                            |
|----------|----------------------------------|
| v1       | GA (generally available, stable) |
| v1beta1  | Beta (pre-release)               |
| v1alpha1 | Alpha (experimental)             |
-->
<table>
<thead>
<tr>
<th>示例</th>
<th>分类</th>
</tr>
</thead>
<tbody>
<tr>
<td>v1</td>
<td>正式发布（Generally available，GA，稳定版本）</td>
</tr>
<tr>
<td>v1beta1</td>
<td>Beta （预发布）</td>
</tr>
<tr>
<td>v1alpha1</td>
<td>Alpha （试验性）</td>
</tr>
</tbody>
</table>
<!--
A given release of Kubernetes can support any number of API groups and any
number of versions of each.

The following rules govern the deprecation of elements of the API.  This
includes:
-->
<p>给定的 Kubernetes 发布版本中可以支持任意数量的 API 组，且每组可以包含
任意个数的版本。</p>
<p>下面的规则负责指导 API 元素的弃用，具体元素包括：</p>
<!--
   * REST resources (aka API objects)
   * Fields of REST resources
   * Annotations on REST resources, including "beta" annotations but not
     including "alpha" annotations.
   * Enumerated or constant values
   * Component config structures
-->
<ul>
<li>REST 资源（也即 API 对象）</li>
<li>REST 资源的字段</li>
<li>REST 资源的注解，包含“beta”类注解但不包含“alpha”类注解</li>
<li>枚举值或者常数值</li>
<li>组件配置结构</li>
</ul>
<!--
These rules are enforced between official releases, not between
arbitrary commits to master or release branches.

**Rule #1: API elements may only be removed by incrementing the version of the
API group.**

Once an API element has been added to an API group at a particular version, it
can not be removed from that version or have its behavior significantly
changed, regardless of track.
-->
<p>以下是跨正式发布版本时要实施的规则，不适用于对 master 或发布分支上
不同提交之间的变化。</p>
<p><strong>规则 #1：只能在增加 API 组版本号时删除 API 元素。</strong></p>
<p>一旦在某个特定 API 组版本中添加了 API 元素，则该元素不可从该版本中删除，
且其行为也不能大幅度地变化，无论属于哪一类（GA、Alpha 或 Beta）。</p>
<!--
For historical reasons, there are 2 "monolithic" API groups - "core" (no
group name) and "extensions".  Resources will incrementally be moved from these
legacy API groups into more domain-specific API groups.
-->
<blockquote class="note callout">
  <div><strong>说明：</strong> 由于历史原因，Kubernetes 中存在两个“单体式（Monolithic）”API 组 -
“core”（无组名）和“extensions”。这两个遗留 API 组中的资源会被逐渐迁移到
更为特定领域的 API 组中。</div>
</blockquote>
<!--
**Rule #2: API objects must be able to round-trip between API versions in a given
release without information loss, with the exception of whole REST resources
that do not exist in some versions.**
-->
<p><strong>规则 #2：在给定的发布版本中，API 对象必须能够在不同的 API 版本之间来回
转换且不造成信息丢失，除非整个 REST 资源在某些版本中完全不存在。</strong></p>
<!--
For example, an object can be written as v1 and then read back as v2 and
converted to v1, and the resulting v1 resource will be identical to the
original.  The representation in v2 might be different from v1, but the system
knows how to convert between them in both directions.  Additionally, any new
field added in v2 must be able to round-trip to v1 and back, which means v1
might have to add an equivalent field or represent it as an annotation.
-->
<p>例如，一个对象可被用 v1 来写入之后用 v2 来读出并转换为 v1，所得到的 v1 必须
与原来的 v1 对象完全相同。v2 中的表现形式可能与 v1 不同，但系统知道如何
在两个版本之间执行双向转换。
此外，v2 中添加的所有新字段都必须能够转换为 v1 再转换回来。这意味着 v1 必须
添加一个新的等效字段或者将其表现为一个注解。</p>
<!--
**Rule #3: An API version in a given track may not be deprecated until a new
API version at least as stable is released.**

GA API versions can replace GA API versions as well as beta and alpha API
versions.  Beta API versions *may not* replace GA API versions.
-->
<p><strong>规则 #3：给定类别的 API 版本在新的、稳定性未降低的 API 版本发布之前不可被废弃。</strong></p>
<p>一个正式发布的（GA）API 版本可替换现有的正式 API 版本或 alpha、beta API 版本。
Beta API 版本 <em>不可以</em> 替代正式的 API 版本。</p>
<!--
**Rule #4a: Other than the most recent API versions in each track, older API
versions must be supported after their announced deprecation for a duration of
no less than:**

   * **GA: 12 months or 3 releases (whichever is longer)**
   * **Beta: 9 months or 3 releases (whichever is longer)**
   * **Alpha: 0 releases**

This covers the [maximum supported version skew of 2 releases](/docs/setup/release/version-skew-policy/).
-->
<p><strong>规则 #4a：除了每类 API 版本中的最新版本，旧的 API 版本在其被宣布被废弃之后
至少以下时长内仍需被支持：</strong></p>
<ul>
<li><strong>GA：12 个月或者 3 个发布版本（取其较长者）</strong></li>
<li><strong>Beta: 9 个月或者 3 个发布版本（取其较长者）</strong></li>
<li><strong>Alpha: 0 个发布版本</strong></li>
</ul>
<p>这里也包含了关于<a href="/zh/docs/setup/release/version-skew-policy/">最大支持 2 个发布版本的版本偏差</a>
的约定。</p>
<!--
Until [#52185](https://github.com/kubernetes/kubernetes/issues/52185) is
resolved, no API versions that have been persisted to storage may be removed.
Serving REST endpoints for those versions may be disabled (subject to the
deprecation timelines in this document), but the API server must remain capable
of decoding/converting previously persisted data from storage.
-->
<blockquote class="note callout">
  <div><strong>说明：</strong> 在 <a href="https://github.com/kubernetes/kubernetes/issues/52185">#52185</a> 被解决之前，
已经被保存到持久性存储中的 API 版本都不可以被去除。
你可以禁止这些版本所对应的 REST 末端（在符合本文中弃用时间线的前提下），
但是 API 服务器必须仍能解析和转换存储中以前写入的数据。</div>
</blockquote>
<!--
**Rule #4b: The "preferred" API version and the "storage version" for a given
group may not advance until after a release has been made that supports both the
new version and the previous version**
-->
<p><strong>规则 #4b：标记为“preferred（优选的）” API 版本和给定 API 组的
“storage version（存储版本）”在既支持老版本也支持新版本的 Kubernetes 发布
版本出来以前不可以提升其版本号。</strong></p>
<!--
Users must be able to upgrade to a new release of Kubernetes and then roll back
to a previous release, without converting anything to the new API version or
suffering breakages (unless they explicitly used features only available in the
newer version).  This is particularly evident in the stored representation of
objects.

All of this is best illustrated by examples.  Imagine a Kubernetes release,
version X, which introduces a new API group.  A new Kubernetes release is made
every approximately 3 months (4 per year).  The following table describes which
API versions are supported in a series of subsequent releases.
-->
<p>用户必须能够升级到 Kubernetes 新的发行版本，之后再回滚到前一个发行版本，且
整个过程中无需针对新的 API 版本做任何转换，也不允许出现功能损坏的情况，
除非用户显式地使用了仅在较新版本中才存在的功能特性。
就对象的存储表示而言，这一点尤其是不言自明的。</p>
<p>以上所有规则最好通过例子来说明。假定现有 Kubernetes 发行版本为 X，其中引入了
新的 API 组。大约每隔 3 个月会有一个新的 Kubernetes 版本被发布（每年 4 个版本）。
下面的表格描述了在一系列后续的发布版本中哪些 API 版本是受支持的。</p>
<table>
  <thead>
    <tr>
      <!-- th>Release</th>
      <th>API Versions</th>
      <th>Preferred/Storage Version</th>
      <th>Notes</th -->
      <th>发布版本</th>
      <th>API 版本</th>
      <th>优选/存储版本</th>
      <th>注释</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>X</td>
      <td>v1alpha1</td>
      <td>v1alpha1</td>
      <td></td>
    </tr>
    <tr>
      <td>X+1</td>
      <td>v1alpha2</td>
      <td>v1alpha2</td>
      <td>
        <ul>
           <!-- li>v1alpha1 is removed, "action required" relnote</li -->
           <li>v1alpha1 被去除，发布说明中会包含 "action required（采取行动）" 说明</li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>X+2</td>
      <td>v1beta1</td>
      <td>v1beta1</td>
      <td>
        <ul>
          <!-- li>v1alpha2 is removed, "action required" relnote</li -->
          <li>v1alpha2 被去除，发布说明中包含对应的 "action required（采取行动）" 说明</li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>X+3</td>
      <!-- td>v1beta2, v1beta1 (deprecated)</td -->
      <td>v1beta2、v1beta1（已弃用）</td>
      <td>v1beta1</td>
      <td>
        <ul>
          <!-- li>v1beta1 is deprecated, "action required" relnote</li -->
          <li>v1beta1 被弃用，发布说明中包含对应的 "action required（采取行动）" 说明</li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>X+4</td>
      <!-- td>v1beta2, v1beta1 (deprecated)</td -->
      <td>v1beta2、v1beta1（已弃用）</td>
      <td>v1beta2</td>
      <td></td>
    </tr>
    <tr>
      <td>X+5</td>
      <!-- td>v1, v1beta1 (deprecated), v1beta2 (deprecated)</td -->
      <td>v1、v1beta1（已弃用）、v1beta2（已弃用）</td>
      <td>v1beta2</td>
      <td>
        <ul>
          <!-- li>v1beta2 is deprecated, "action required" relnote</li -->
          <li>v1beta2 被弃用，发布说明中包含对应的 "action required（采取行动）" 说明</li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>X+6</td>
      <!-- td>v1, v1beta2 (deprecated)</td -->
      <td>v1、v1beta2（已弃用）</td>
      <td>v1</td>
      <td>
        <ul>
          <!-- li>v1beta1 is removed, "action required" relnote</li -->
          <li>v1beta1 被去除，发布说明中包含对应的 "action required（采取行动）" 说明</li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>X+7</td>
      <!-- td>v1, v1beta2 (deprecated)</td -->
      <td>v1、v1beta2（已弃用）</td>
      <td>v1</td>
      <td></td>
    </tr>
    <tr>
      <td>X+8</td>
      <td>v2alpha1、v1</td>
      <td>v1</td>
      <td>
        <ul>
          <!-- li>v1beta2 is removed, "action required" relnote</li -->
          <li>v1beta2 被去除，发布说明中包含对应的 "action required（采取行动）" 说明</li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>X+9</td>
      <td>v2alpha2、v1</td>
      <td>v1</td>
      <td>
        <ul>
           <!-- li>v2alpha1 is removed, "action required" relnote</li -->
           <li>v2alpha1 被删除，发布说明中包含对应的 "action required（采取行动）" 说明</li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>X+10</td>
      <td>v2beta1、v1</td>
      <td>v1</td>
      <td>
        <ul>
          <!-- li>v2alpha2 is removed, "action required" relnote</li -->
          <li>v2alpha2 被删除，发布说明中包含对应的 "action required（采取行动）" 说明</li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>X+11</td>
      <!-- td>v2beta2, v2beta1 (deprecated), v1</td -->
      <td>v2beta2、v2beta1（已弃用）、v1</td>
      <td>v1</td>
      <td>
        <ul>
          <!-- li>v2beta1 is deprecated, "action required" relnote</li -->
          <li>v2beta1 被弃用，发布说明中包含对应的 "action required（采取行动）" 说明</li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>X+12</td>
      <!-- td>v2, v2beta2 (deprecated), v2beta1 (deprecated), v1 (deprecated)</td -->
      <td>v2、v2beta2（已弃用）、v2beta1（已弃用）、v1（已弃用）</td>
      <td>v1</td>
      <td>
        <ul>
          <!-- li>v2beta2 is deprecated, "action required" relnote</li>
          <li>v1 is deprecated, "action required" relnote</li -->
          <li>v2beta2 已被弃用，发布说明中包含对应的 "action required（采取行动）" 说明</li>
          <li>v1 已被弃用，发布说明中包含对应的 "action required（采取行动）" 说明</li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>X+13</td>
      <!-- td>v2, v2beta1 (deprecated), v2beta2 (deprecated), v1 (deprecated)</td -->
      <td>v2、v2beta1（已弃用）、v2beta2（已弃用）、v1（已弃用）</td>
      <td>v2</td>
      <td></td>
    </tr>
    <tr>
      <td>X+14</td>
      <!-- td>v2, v2beta2 (deprecated), v1 (deprecated)</td -->
      <td>v2、v2beta2（已弃用）、v1（已弃用）</td>
      <td>v2</td>
      <td>
        <ul>
          <!-- li>v2beta1 is removed, "action required" relnote</li -->
          <li>v2beta1 被删除，发布说明中包含对应的 "action required（采取行动）" 说明</li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>X+15</td>
      <!-- td>v2, v1 (deprecated)</td -->
      <td>v2、v1（已弃用）</td>
      <td>v2</td>
      <td>
        <ul>
          <!-- li>v2beta2 is removed, "action required" relnote</li -->
          <li>v2beta2 被删除，发布说明中包含对应的 "action required（采取行动）" 说明</li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>X+16</td>
      <!-- td>v2, v1 (deprecated)</td -->
      <td>v2、v1（已弃用）</td>
      <td>v2</td>
      <td></td>
    </tr>
    <tr>
      <td>X+17</td>
      <td>v2</td>
      <td>v2</td>
      <td>
        <ul>
          <li>v1 被删除，发布说明中包含对应的 "action required（采取行动）" 说明</li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>
<!--
### REST resources (aka API objects)

Consider a hypothetical REST resource named Widget, which was present in API v1
in the above timeline, and which needs to be deprecated.  We document and
[announce](https://groups.google.com/forum/#!forum/kubernetes-announce) the
deprecation in sync with release X+1.  The Widget resource still exists in API
version v1 (deprecated) but not in v2alpha1.  The Widget resource continues to
exist and function in releases up to and including X+8.  Only in release X+9,
when API v1 has aged out, does the Widget resource cease to exist, and the
behavior get removed.
-->
<h3 id="rest-resources-aka-api-objects">REST 资源（也即 API 对象） </h3>
<p>考虑一个假想的名为 Widget 的 REST 资源，在上述时间线中位于 API v1，
而现在打算将其弃用。
我们会在文档和
<a href="https://groups.google.com/forum/#!forum/kubernetes-announce">声明</a>
中与 X+1 版本的发布同步记述此弃用决定。
Wdiget 资源仍会在 API 版本 v1（已弃用）中存在，但不会出现在 v2alpha1 中。
Widget 资源会 X+8 发布版本之前（含 X+8）一直存在并可用。
只有在发布版本 X+9 中，API v1 寿终正寝时，Widget
才彻底消失，相应的资源行为也被移除。</p>
<!--
Starting in Kubernetes v1.19, making an API request to a deprecated REST API endpoint:

1. Returns a `Warning` header (as defined in [RFC7234, Section 5.5](https://tools.ietf.org/html/rfc7234#section-5.5)) in the API response.
2. Adds a `"k8s.io/deprecated":"true"` annotation to the [audit event](/docs/tasks/debug-application-cluster/audit/) recorded for the request.
3. Sets an `apiserver_requested_deprecated_apis` gauge metric to `1` in the `kube-apiserver`
   process. The metric has labels for `group`, `version`, `resource`, `subresource` that can be joined
   to the `apiserver_request_total` metric, and a `removed_release` label that indicates the
   Kubernetes release in which the API will no longer be served. The following Prometheus query
   returns information about requests made to deprecated APIs which will be removed in v1.22:

   ```promql
   apiserver_requested_deprecated_apis{removed_release="1.22"} * on(group,version,resource,subresource) group_right() apiserver_request_total
   ```
-->
<p>从 Kubernetes v1.19 开始，当 API 请求被发送到一个已弃用的 REST API 末端时：</p>
<ol>
<li>
<p>API 响应中会包含一个 <code>Warning</code> 头部字段（如 <a href="https://tools.ietf.org/html/rfc7234#section-5.5">RFC7234 5.5 节</a>所定义）；</p>
</li>
<li>
<p>该请求会导致对应的
<a href="/zh/docs/tasks/debug-application-cluster/audit/">审计事件</a>
中会增加一个注解 <code>&quot;k8s.io/deprecated&quot;:&quot;true&quot;</code>。</p>
</li>
<li>
<p><code>kube-apiserver</code> 进程的 <code>apiserver_requested_deprecated_apis</code> 度量值会被
设置为 <code>1</code>。
该度量值还附带 <code>group</code>、<code>version</code>、<code>resource</code> 和 <code>subresource</code> 标签
（可供添加到度量值 <code>apiserver_request_total</code> 上），
和一个 <code>removed_release</code> 标签，标明该 API 将消失的 Kubernetes 发布版本。
下面的 Prometheus 查询会返回对 v1.22 中将移除的、已弃用的 API
的请求的信息：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-promql" data-lang="promql"><span style="color:#b8860b">apiserver_requested_deprecated_apis</span>{<span style="color:#a0a000">removed_release</span><span style="color:#666">=</span>&#34;<span style="color:#b44">1.22</span>&#34;}<span style="color:#bbb"> </span><span style="color:#666">*</span><span style="color:#bbb"> </span><span style="color:#a2f;font-weight:bold">on</span><span style="color:#666">(</span><span style="color:#a2f;font-weight:bold">group</span>,<span style="color:#b8860b">version</span>,<span style="color:#b8860b">resource</span>,<span style="color:#b8860b">subresource</span><span style="color:#666">)</span><span style="color:#bbb"> </span><span style="color:#a2f;font-weight:bold">group_right</span><span style="color:#666">()</span><span style="color:#bbb"> </span><span style="color:#b8860b">apiserver_request_total</span><span style="color:#bbb">
</span></code></pre></div></li>
</ol>
<!--
### Fields of REST resources

As with whole REST resources, an individual field which was present in API v1
must exist and function until API v1 is removed.  Unlike whole resources, the
v2 APIs may choose a different representation for the field, as long as it can
be round-tripped.  For example a v1 field named "magnitude" which was
deprecated might be named "deprecatedMagnitude" in API v2.  When v1 is
eventually removed, the deprecated field can be removed from v2.
-->
<h3 id="fields-of-rest-resources">REST 资源的字段   </h3>
<p>就像整个 REST 资源一样，在 API v1 中曾经存在的各个字段在 API v1 被移除
之前必须一直存在且起作用。
与整个资源上的规定不同，v2 API 可以选择为字段提供不同的表示方式，
只要对应的资源对象可在不同版本之间来回转换即可。
例如，v1 版本中一个名为 &quot;magnitude&quot; 的已弃用字段可能在 API v2 中被命名
为 &quot;deprecatedMagnitude&quot;。当 v1 最终被移除时，废弃的字段也可以从 v2
中移除。</p>
<!--
### Enumerated or constant values

As with whole REST resources and fields thereof, a constant value which was
supported in API v1 must exist and function until API v1 is removed.
-->
<h3 id="enumerated-or-constant-values">枚举值或常数值</h3>
<p>就像前文讲述的 REST 资源及其中的单个字段一样，API v1 中所支持的常数值
必须在 API v1 被移除之前一直存在且起作用。</p>
<!--
### Component config structures

Component configs are versioned and managed similar to REST resources.
-->
<h3 id="component-config-structures">组件配置结构 </h3>
<p>组件的配置也是有版本的，并且按 REST 资源的方式来管理。</p>
<!--
### Future work

Over time, Kubernetes will introduce more fine-grained API versions, at which
point these rules will be adjusted as needed.
-->
<h3 id="future-work">将来的工作   </h3>
<p>随着时间推移，Kubernetes 会引入粒度更细的 API 版本。
到那时，这里的规则会根据需要进行调整。</p>
<!--
## Deprecating a flag or CLI

The Kubernetes system is comprised of several different programs cooperating.
Sometimes, a Kubernetes release might remove flags or CLI commands
(collectively "CLI elements") in these programs.  The individual programs
naturally sort into two main groups - user-facing and admin-facing programs,
which vary slightly in their deprecation policies.  Unless a flag is explicitly
prefixed or documented as "alpha" or "beta", it is considered GA.
-->
<h2 id="弃用一个标志或-cli-命令">弃用一个标志或 CLI 命令</h2>
<p>Kubernetes 系统中包含若干不同的、相互协作的程序。
有时，Kubernetes 可能会删除这些程序的某些标志或 CLI 命令（统称“命令行元素”）。
这些程序可以天然地划分到两个大组中：面向用户的和面向管理员的程序。
二者之间的弃用策略略有不同。
除非某个标志显示地通过前缀或文档来标明其为“alpha”或“beta”，
该标志要被视作正式发布的（GA）。</p>
<!--
CLI elements are effectively part of the API to the system, but since they are
not versioned in the same way as the REST API, the rules for deprecation are as
follows:
-->
<p>命令行元素相当于系统的 API 的一部分，不过因为它们并没有采用 REST API
一样的方式来管理版本，其弃用规则规定如下：</p>
<!--
**Rule #5a: CLI elements of user-facing components (e.g. kubectl) must function
after their announced deprecation for no less than:**

   * **GA: 12 months or 2 releases (whichever is longer)**
   * **Beta: 3 months or 1 release (whichever is longer)**
   * **Alpha: 0 releases**
-->
<p><strong>规则 #5a：面向用户的命令行元素（例如，kubectl）必须在其宣布被弃用其
在以下时长内仍能使用：</strong></p>
<ul>
<li><strong>GA：12 个月或者 2 个发布版本（取其较长者）</strong></li>
<li><strong>Beta：3 个月或者 1 个发布版本（取其较长者）</strong></li>
<li><strong>Alpha：0 发布版本</strong></li>
</ul>
<!--
**Rule #5b: CLI elements of admin-facing components (e.g. kubelet) must function
after their announced deprecation for no less than:**

   * **GA: 6 months or 1 release (whichever is longer)**
   * **Beta: 3 months or 1 release (whichever is longer)**
   * **Alpha: 0 releases**
-->
<p><strong>规则 #5b：面向管理员的命令行元素（例如，kubelet）必须在其被宣布弃用
之后以下时长内保持可用：</strong></p>
<ul>
<li><strong>GA：6 个月或 1 个发行版本（取其较长者）</strong></li>
<li><strong>Beta: 3 个月或 1 个发行版本（取其较长者）</strong></li>
<li><strong>Alpha: 0 个发布版本</strong></li>
</ul>
<!--
**Rule #6: Deprecated CLI elements must emit warnings (optionally disable)
when used.**
-->
<p><strong>规则 #6：被弃用的 CLI 元素在被用到时必须能够产生警告，而警告的
产生是可以被禁止的。</strong></p>
<!--
## Deprecating a feature or behavior

Occasionally a Kubernetes release needs to deprecate some feature or behavior
of the system that is not controlled by the API or CLI.  In this case, the
rules for deprecation are as follows:
-->
<h2 id="deprecating-a-feature-or-behavior">弃用某功能特性或行为 </h2>
<p>在一些较偶然的情形下，某 Kubernetes 发行版本需要弃用系统的某项功能
特性或者行为，而对应的功能特性或行为并不受 API 或 CLI 控制。在这种情况下，
其弃用规则如下：</p>
<!--
**Rule #7: Deprecated behaviors must function for no less than 1 year after their
announced deprecation.**
-->
<p><strong>规则 #7：被弃用的行为必须在被宣布弃用之后至少 1 年时间内必须保持能用。</strong></p>
<!--
This does not imply that all changes to the system are governed by this policy.
This applies only to significant, user-visible behaviors which impact the
correctness of applications running on Kubernetes or that impact the
administration of Kubernetes clusters, and which are being removed entirely.
-->
<p>这并不意味着对系统的所有更改都受此策略约束。
此规则仅适用于重大的、用户可见的行为；这些行为会影响到在 Kubernetes
中运行的应用的正确性，或者影响到 Kubernetes 集群的管理。
此规则也适用于那些被整个移除的功能特性或行为。</p>
<!--
An exception to the above rule is _feature gates_. Feature gates are key=value
pairs that allow for users to enable/disable experimental features.

Feature gates are intended to cover the development life cycle of a feature - they
are not intended to be long-term APIs. As such, they are expected to be deprecated
and removed after a feature becomes GA or is dropped.
-->
<p>上述规则的一个例外是 <em>特性门控（Feature Gates）</em>。特性门控是一些键值偶对，
允许用户启用或禁用一些试验性的功能特性。</p>
<p>特性门控意在覆盖功能特性的整个开发周期，它们无意成为长期的 API。
因此，它们会在某功能特性正式发布或被抛弃之后被弃用和删除。</p>
<!--
As a feature moves through the stages, the associated feature gate evolves.
The feature life cycle matched to its corresponding feature gate is:

  * Alpha: the feature gate is disabled by default and can be enabled by the user.
  * Beta: the feature gate is enabled by default and can be disabled by the user.
  * GA: the feature gate is deprecated (see ["Deprecation"](#deprecation)) and becomes
  non-operational.
  * GA, deprecation window complete: the feature gate is removed and calls to it are
  no longer accepted.
-->
<p>随着一个功能特性经过不同的成熟阶段，相关的特性门控也会演化。
与功能特性生命周期对应的特性门控状态为：</p>
<ul>
<li>Alpha：特性门控默认被禁用，只能由用户显式启用。</li>
<li>Beta：特性门控默认被弃用，可被用户显式禁用。</li>
<li>GA: 特性门控被弃用（参见<a href="#deprecation">弃用</a>），并且不再起作用。</li>
<li>GA，弃用窗口期结束：特性门控被删除，不再接受调用。</li>
</ul>
<!--
### Deprecation

Features can be removed at any point in the life cycle prior to GA. When features are
removed prior to GA, their associated feature gates are also deprecated.

When an invocation tries to disable a non-operational feature gate, the call fails in order
to avoid unsupported scenarios that might otherwise run silently.
-->
<h3 id="deprecation">弃用  </h3>
<p>功能特性在正式发布之前的生命周期内任何时间点都可被移除。
当未正式发布的功能特性被移除时，它们对应的特性门控也被弃用。</p>
<p>当尝试禁用一个不再起作用的特性门控时，该调用会失败，这样可以避免
毫无迹象地执行一些不受支持的场景。</p>
<!--
In some cases, removing pre-GA features requires considerable time. Feature gates can remain
operational until their associated feature is fully removed, at which point the feature gate
itself can be deprecated.

When removing a feature gate for a GA feature also requires considerable time, calls to
feature gates may remain operational if the feature gate has no effect on the feature,
and if the feature gate causes no errors.
-->
<p>在某些场合，移除一个即将正式发布的功能特性需要很长时间。特性门控
可以保持其功能，直到对应的功能特性被彻底去除，直到那时特性门控
自身才可被弃用。</p>
<p>由于移除一个已经正式发布的功能特性对应的特性门控也需要一定时间，对特性
门控的调用可能一直被允许，前提是特性门控对功能本身无影响且特性门控不会
引发任何错误。</p>
<!--
Features intended to be disabled by users should include a mechanism for disabling the
feature in the associated feature gate.

Versioning for feature gates is different from the previously discussed components,
therefore the rules for deprecation are as follows:
-->
<p>意在允许用户禁用的功能特性应该包含一个在相关联的特性门控中禁用该功能的机制。</p>
<p>特性门控的版本管理与之前讨论的组件版本管理不同，因此其对应的弃用策略如下：</p>
<!--
**Rule #8: Feature gates must be deprecated when the corresponding feature they control
transitions a lifecycle stage as follows. Feature gates must function for no less than:**

   * **Beta feature to GA: 6 months or 2 releases (whichever is longer)**
   * **Beta feature to EOL: 3 months or 1 release (whichever is longer)**
   * **Alpha feature to EOL: 0 releases**
-->
<p><strong>规则 #8：特性门控所对应的功能特性经历下面所列的成熟性阶段转换时，特性门控
必须被弃用。特性门控弃用时必须在以下时长内保持其功能可用：</strong></p>
<ul>
<li><strong>Beta 特性转为 GA：6 个月或者 2 个发布版本（取其较长者）</strong></li>
<li><strong>Beta 特性转为丢弃：3 个月或者 1 个发布版本（取其较长者）</strong></li>
<li><strong>Alpha 特性转为丢弃：0 个发布版本</strong></li>
</ul>
<!--
**Rule #9: Deprecated feature gates must respond with a warning when used. When a feature gate
is deprecated it must be documented in both in the release notes and the corresponding CLI help.
Both warnings and documentation must indicate whether a feature gate is non-operational.**
-->
<p><strong>规则 #9：已弃用的特色门控再被使用时必须给出警告回应。当特性门控被
弃用时，必须在发布说明和对应的 CLI 帮助信息中通过文档宣布。
警告信息和文档都要标明是否某特性门控不再起作用。</strong></p>
<!--
## Deprecating a metric

Each component of the Kubernetes control-plane exposes metrics (usually the
`/metrics` endpoint), which are typically ingested by cluster administrators.
Not all metrics are the same: some metrics are commonly used as SLIs or used
to determine SLOs, these tend to have greater import. Other metrics are more
experimental in nature or are used primarily in the Kubernetes development
process.

Accordingly, metrics fall under two stability classes (`ALPHA` and `STABLE`);
this impacts removal of a metric during a Kubernetes release. These classes
are determined by the perceived importance of the metric. The rules for
deprecating and removing a metric are as follows:
-->
<h3 id="deprecating-a-metric">弃用度量值   </h3>
<p>Kubernetes 控制平面的每个组件都公开度量值（通常是 <code>/metrics</code> 端点），它们通常由集群管理员使用。
并不是所有的度量值都是同样重要的：一些度量值通常用作 SLIs 或被使用来确定 SLOs，这些往往比较重要。
其他度量值在本质上带有实验性，或者主要用于 Kubernetes 开发过程。</p>
<p>因此，度量值分为两个稳定性类别（<code>ALPHA</code> 和 <code>STABLE</code>）;
此分类会影响在 Kubernetes 发布版本中移除某度量值。
所对应的分类取决于对该度量值重要性的预期。
弃用和移除度量值的规则如下：</p>
<!--
**Rule #9a: Metrics, for the corresponding stability class, must function for no less than:**

   * **STABLE: 4 releases or 12 months (whichever is longer)**
   * **ALPHA: 0 releases**

**Rule #9b: Metrics, after their _announced deprecation_, must function for no less than:**

   * **STABLE: 3 releases or 9 months (whichever is longer)**
   * **ALPHA: 0 releases**
-->
<p><strong>规则 #9a: 对于相应的稳定性类别，度量值起作用的周期必须不小于：</strong></p>
<ul>
<li><strong>STABLE: 4 个发布版本或者 12 个月 (取其较长者)</strong></li>
<li><strong>ALPHA: 0 个发布版本</strong></li>
</ul>
<p><strong>规则 #9b: 在度量值被宣布启用之后，它起作用的周期必须不小于：</strong></p>
<ul>
<li><strong>STABLE: 3 个发布版本或者 9 个月 (取其较长者)</strong></li>
<li><strong>ALPHA: 0 个发布版本</strong></li>
</ul>
<!--
Deprecated metrics will have their description text prefixed with a deprecation notice
string '(Deprecated from x.y)' and a warning log will be emitted during metric
registration. Like their stable undeprecated counterparts, deprecated metrics will
be automatically registered to the metrics endpoint and therefore visible.
-->
<p>已弃用的度量值将在其描述文本前加上一个已弃用通知字符串 '(Deprecated from x.y)'，
并将在度量值被记录期间发出警告日志。就像稳定的、未被弃用的度量指标一样，
被弃用的度量值将自动注册到 metrics 端点，因此被弃用的度量值也是可见的。</p>
<!--
On a subsequent release (when the metric's `deprecatedVersion` is equal to
_current_kubernetes_version - 3_)), a deprecated metric will become a _hidden_ metric.
**_Unlike_** their deprecated counterparts, hidden metrics will _no longer_ be
automatically registered to the metrics endpoint (hence hidden). However, they
can be explicitly enabled through a command line flag on the binary
(`--show-hidden-metrics-for-version=`). This provides cluster admins an
escape hatch to properly migrate off of a deprecated metric, if they were not
able to react to the earlier deprecation warnings. Hidden metrics should be
deleted after one release.
-->
<p>在随后的版本中（当度量值 <code>deprecatedVersion</code> 等于_当前 Kubernetes 版本 - 3_），
被弃用的度量值将变成 _隐藏（Hidden）_ metric 度量值。
与被弃用的度量值不同，隐藏的度量值将不再被自动注册到 metrics 端点（因此被隐藏）。
但是，它们可以通过可执行文件的命令行标志显式启用
（<code>--show-hidden-metrics-for-version=</code>）。
如果集群管理员不能对早期的弃用警告作出反应，这一设计就为他们提供了抓紧迁移弃用度量值的途径。
隐藏的度量值应该在再过一个发行版本后被删除。</p>
<!--
## Exceptions

No policy can cover every possible situation.  This policy is a living
document, and will evolve over time.  In practice, there will be situations
that do not fit neatly into this policy, or for which this policy becomes a
serious impediment.  Such situations should be discussed with SIGs and project
leaders to find the best solutions for those specific cases, always bearing in
mind that Kubernetes is committed to being a stable system that, as much as
possible, never breaks users. Exceptions will always be announced in all
relevant release notes.
-->
<h2 id="exceptions">例外  </h2>
<p>没有策略可以覆盖所有情况。此策略文档是一个随时被更新的文档，会随着时间
推移演化。在实践中，会有一些情况无法很好地匹配到这里的弃用策略，或者
这里的策略变成了很严重的羁绊。这类情形要与 SIG 和项目牵头人讨论，
寻求对应场景的最佳解决方案。请一直铭记，Kubernetes 承诺要成为一个
稳定的系统，至少会尽力做到不会影响到其用户。此弃用策略的任何例外情况
都会在所有相关的发布说明中公布。</p>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-e4dbb59f8f23854d7b7d574e169923c4">2.5 - Kubernetes API 健康端点</h1>
    
	<!-- 
title: Kubernetes API health endpoints
reviewers:
- logicalhan
content_type: concept
weight: 50
 -->
<!-- overview -->
<!-- 
The Kubernetes <a class='glossary-tooltip' title='提供 Kubernetes API 服务的控制面组件。' data-toggle='tooltip' data-placement='top' href='/zh/docs/reference/command-line-tools-reference/kube-apiserver/' target='_blank' aria-label='API server'>API server</a> provides API endpoints to indicate the current status of the API server.
This page describes these API endpoints and explains how you can use them. 
-->
<p>Kubernetes <a class='glossary-tooltip' title='提供 Kubernetes API 服务的控制面组件。' data-toggle='tooltip' data-placement='top' href='/zh/docs/reference/command-line-tools-reference/kube-apiserver/' target='_blank' aria-label='API 服务器'>API 服务器</a> 提供 API 端点以指示 API 服务器的当前状态。
本文描述了这些 API 端点，并说明如何使用。</p>
<!-- body -->
<!-- ## API endpoints for health -->
<h2 id="api-endpoints-for-health">API 健康端点 </h2>
<!-- 
The Kubernetes API server provides 3 API endpoints (`healthz`, `livez` and `readyz`) to indicate the current status of the API server.
The `healthz` endpoint is deprecated (since Kubernetes v1.16), and you should use the more specific `livez` and `readyz` endpoints instead.
The `livez` endpoint can be used with the `--livez-grace-period` [flag](/docs/reference/command-line-tools-reference/kube-apiserver) to specify the startup duration.
For a graceful shutdown you can specify the `--shutdown-delay-duration` [flag](/docs/reference/command-line-tools-reference/kube-apiserver) with the `/readyz` endpoint.
Machines that check the `health`/`livez`/`readyz` of the API server should rely on the HTTP status code.
A status code `200` indicates the API server is `healthy`/`live`/`ready`, depending of the called endpoint.
The more verbose options shown below are intended to be used by human operators to debug their cluster or specially the state of the API server.
-->
<p>Kubernetes API 服务器提供 3 个 API 端点（<code>healthz</code>、<code>livez</code> 和 <code>readyz</code>）来表明 API 服务器的当前状态。
<code>healthz</code> 端点已被弃用（自 Kubernetes v1.16 起），你应该使用更为明确的 <code>livez</code> 和 <code>readyz</code> 端点。
<code>livez</code> 端点可与 <code>--livez-grace-period</code> <a href="/zh/docs/reference/command-line-tools-reference/kube-apiserver">标志</a>一起使用，来指定启动持续时间。
为了正常关机，你可以使用 <code>/readyz</code> 端点并指定 <code>--shutdown-delay-duration</code> <a href="/zh/docs/reference/command-line-tools-reference/kube-apiserver">标志</a>。
检查 API 服务器的 <code>health</code>/<code>livez</code>/<code>readyz</code> 端点的机器应依赖于 HTTP 状态代码。
状态码 <code>200</code> 表示 API 服务器是 <code>healthy</code>、<code>live</code> 还是 <code>ready</code>，具体取决于所调用的端点。
以下更详细的选项供操作人员使用，用来调试其集群或专门调试 API 服务器的状态。</p>
<!-- The following examples will show how you can interact with the health API endpoints. -->
<p>以下示例将显示如何与运行状况 API 端点进行交互。</p>
<!-- 
For all endpoints you can use the `verbose` parameter to print out the checks and their status.
This can be useful for a human operator to debug the current status of the Api server, it is not intended to be consumed by a machine:
-->
<p>对于所有端点，都可以使用 <code>verbose</code> 参数来打印检查项以及检查状态。
这对于操作人员调试 API 服务器的当前状态很有用，这些不打算给机器使用：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">curl -k https://localhost:6443/livez?verbose
</code></pre></div><!-- or from a remote host with authentication: -->
<p>或从具有身份验证的远程主机：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl get --raw<span style="color:#666">=</span><span style="color:#b44">&#39;/readyz?verbose&#39;</span>
</code></pre></div><!-- The output will look like this: -->
<p>输出将如下所示：</p>
<pre tabindex="0"><code>[+]ping ok
[+]log ok
[+]etcd ok
[+]poststarthook/start-kube-apiserver-admission-initializer ok
[+]poststarthook/generic-apiserver-start-informers ok
[+]poststarthook/start-apiextensions-informers ok
[+]poststarthook/start-apiextensions-controllers ok
[+]poststarthook/crd-informer-synced ok
[+]poststarthook/bootstrap-controller ok
[+]poststarthook/rbac/bootstrap-roles ok
[+]poststarthook/scheduling/bootstrap-system-priority-classes ok
[+]poststarthook/start-cluster-authentication-info-controller ok
[+]poststarthook/start-kube-aggregator-informers ok
[+]poststarthook/apiservice-registration-controller ok
[+]poststarthook/apiservice-status-available-controller ok
[+]poststarthook/kube-apiserver-autoregistration ok
[+]autoregister-completion ok
[+]poststarthook/apiservice-openapi-controller ok
healthz check passed
</code></pre><!-- 
The Kubernetes API server also supports to exclude specific checks.
The query parameters can also be combined like in this example:
-->
<p>Kubernetes API 服务器也支持排除特定的检查项。
查询参数也可以像以下示例一样进行组合：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">curl -k <span style="color:#b44">&#39;https://localhost:6443/readyz?verbose&amp;exclude=etcd&#39;</span>
</code></pre></div><!-- The output show that the `etcd` check is excluded: -->
<p>输出显示排除了 <code>etcd</code> 检查：</p>
<pre tabindex="0"><code>[+]ping ok
[+]log ok
[+]etcd excluded: ok
[+]poststarthook/start-kube-apiserver-admission-initializer ok
[+]poststarthook/generic-apiserver-start-informers ok
[+]poststarthook/start-apiextensions-informers ok
[+]poststarthook/start-apiextensions-controllers ok
[+]poststarthook/crd-informer-synced ok
[+]poststarthook/bootstrap-controller ok
[+]poststarthook/rbac/bootstrap-roles ok
[+]poststarthook/scheduling/bootstrap-system-priority-classes ok
[+]poststarthook/start-cluster-authentication-info-controller ok
[+]poststarthook/start-kube-aggregator-informers ok
[+]poststarthook/apiservice-registration-controller ok
[+]poststarthook/apiservice-status-available-controller ok
[+]poststarthook/kube-apiserver-autoregistration ok
[+]autoregister-completion ok
[+]poststarthook/apiservice-openapi-controller ok
[+]shutdown ok
healthz check passed
</code></pre><!-- ## Individual health checks -->
<h2 id="individual-health-check">独立健康检查 </h2>





<div style="margin-top: 10px; margin-bottom: 10px;">
<b>FEATURE STATE:</b> <code>Kubernetes v1.22 [alpha]</code>
</div>

<!-- 
Each individual health check exposes an http endpoint and could can be checked individually.
The schema for the individual health checks is `/livez/<healthcheck-name>` where `livez` and `readyz` and be used to indicate if you want to check the liveness or the readiness of the API server.
The `<healthcheck-name>` path can be discovered using the `verbose` flag from above and take the path between `[+]` and `ok`.
These individual health checks should not be consumed by machines but can be helpful for a human operator to debug a system:
-->
<p>每个单独的健康检查都会公开一个 http 端点，并且可以单独检查。
单个运行状况检查的模式为 <code>/livez/&lt;healthcheck-name&gt;</code>，其中 <code>livez</code> 和 <code>readyz</code> 表明你要检查的是 API 服务器是否存活或就绪。
<code>&lt;healthcheck-name&gt;</code> 的路径可以通过上面的 <code>verbose</code> 参数发现 ，并采用 <code>[+]</code> 和 <code>ok</code> 之间的路径。
这些单独的健康检查不应由机器使用，但对于操作人员调试系统而言，是有帮助的：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">curl -k https://localhost:6443/livez/etcd
</code></pre></div>
</div>



    
	
  

    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-232c8c895125744f56a31038ab6fa4e9">3 - 常见的标签、注解和污点</h1>
    
	<!-- 
---
title: Well-Known Labels, Annotations and Taints
content_type: concept
weight: 20
---
-->
<!-- overview -->
<!-- 
Kubernetes reserves all labels and annotations in the kubernetes.io namespace.

This document serves both as a reference to the values and as a coordination point for assigning values.
-->
<p>Kubernetes 预留命名空间 kubernetes.io 用于所有的标签和注解。</p>
<p>本文档有两个作用，一是作为可用值的参考，二是作为赋值的协调点。</p>
<!-- body -->
<h2 id="kubernetes-io-arch">kubernetes.io/arch</h2>
<p>示例：<code>kubernetes.io/arch=amd64</code></p>
<p>用于：Node</p>
<!-- 
The Kubelet populates this with `runtime.GOARCH` as defined by Go. This can be handy if you are mixing arm and x86 nodes.
-->
<p>Kubelet 用 Go 定义的 <code>runtime.GOARCH</code> 生成该标签的键值。在混合使用 arm 和 x86 节点的场景中，此键值可以带来极大便利。</p>
<h2 id="kubernetes-io-os">kubernetes.io/os</h2>
<p>示例：<code>kubernetes.io/os=linux</code></p>
<p>用于：Node</p>
<!-- 
The Kubelet populates this with `runtime.GOOS` as defined by Go. This can be handy if you are mixing operating systems in your cluster (for example: mixing Linux and Windows nodes).
-->
<p>Kubelet 用 Go 定义的 <code>runtime.GOOS</code> 生成该标签的键值。在混合使用异构操作系统场景下（例如：混合使用 Linux 和 Windows 节点），此键值可以带来极大便利。</p>
<h2 id="kubernetes-io-metadata-name">kubernetes.io/metadata.name</h2>
<p>示例：<code>kubernetes.io/metadata.name=mynamespace</code></p>
<p>用于：Namespaces</p>
<!--
When the `NamespaceDefaultLabelName`
[feature gate](/docs/reference/command-line-tools-reference/feature-gates/) is enabled,
the Kubernetes API server sets this label on all namespaces. The label value is set to
the name of the namespace.

This is useful if you want to target a specific namespace with a label
<a class='glossary-tooltip' title='选择算符允许用户通过标签对一组资源对象进行筛选过滤。' data-toggle='tooltip' data-placement='top' href='/zh/docs/concepts/overview/working-with-objects/labels/' target='_blank' aria-label='selector'>selector</a>.
-->
<p>当 <code>NamespaceDefaultLabelName</code> <a href="/zh/docs/reference/command-line-tools-reference/feature-gates/">特性门控</a>
被启用时，Kubernetes API 服务器会在所有命名空间上设置此标签。标签值被设置为命名空间的名称。</p>
<p>如果你想使用标签 <a class='glossary-tooltip' title='选择算符允许用户通过标签对一组资源对象进行筛选过滤。' data-toggle='tooltip' data-placement='top' href='/zh/docs/concepts/overview/working-with-objects/labels/' target='_blank' aria-label='选择器'>选择器</a> 来指向特定的命名空间，这很有用。</p>
<h2 id="beta-kubernetes-io-arch-deprecated">beta.kubernetes.io/arch (deprecated)</h2>
<!-- 
This label has been deprecated. Please use `kubernetes.io/arch` instead.
-->
<p>此标签已被弃用，取而代之的是 <code>kubernetes.io/arch</code>.</p>
<h2 id="beta-kubernetes-io-os-deprecated">beta.kubernetes.io/os (deprecated)</h2>
<!-- 
This label has been deprecated. Please use `kubernetes.io/os` instead.
-->
<p>此标签已被弃用，取而代之的是 <code>kubernetes.io/os</code>.</p>
<h2 id="kubernetesiohostname">kubernetes.io/hostname</h2>
<p>示例：<code>kubernetes.io/hostname=ip-172-20-114-199.ec2.internal</code></p>
<p>用于：Node</p>
<!-- 
The Kubelet populates this label with the hostname. Note that the hostname can be changed from the "actual" hostname by passing the `--hostname-override` flag to the `kubelet`.

This label is also used as part of the topology hierarchy.  See [topology.kubernetes.io/zone](#topologykubernetesiozone) for more information.
-->
<p>Kubelet 用主机名生成此标签。需要注意的是主机名可修改，这是把“实际的”主机名通过参数 <code>--hostname-override</code> 传给 <code>kubelet</code> 实现的。</p>
<p>此标签也可用做拓扑层次的一个部分。更多信息参见<a href="#topologykubernetesiozone">topology.kubernetes.io/zone</a>。</p>
<h2 id="pod-deletion-cost">controller.kubernetes.io/pod-deletion-cost</h2>
<p>示例：<code>controller.kubernetes.io/pod-deletion-cost=10</code></p>
<p>用于：Pod</p>
<!--
This annotation is used to set [Pod Deletion Cost](/docs/concepts/workloads/controllers/replicaset/#pod-deletion-cost)
which allows users to influence ReplicaSet downscaling order. The annotation parses into an `int32` type.
-->
<p>该注解用于设置 <a href="/zh/docs/concepts/workloads/controllers/replicaset/#pod-deletion-cost">Pod 删除开销</a>，
允许用户影响 ReplicaSet 的缩减顺序。该注解解析为 <code>int32</code> 类型。</p>
<h2 id="beta-kubernetes-io-instance-type-deprecated">beta.kubernetes.io/instance-type (deprecated)</h2>
<blockquote class="note callout">
  <div><strong>说明：</strong> <!-- 
Starting in v1.17, this label is deprecated in favor of [node.kubernetes.io/instance-type](#nodekubernetesioinstance-type).
-->
<p>从 v1.17 起，此标签被弃用，取而代之的是 <a href="#nodekubernetesioinstance-type">node.kubernetes.io/instance-type</a>.</div>
</blockquote>
<h2 id="nodekubernetesioinstance-type">node.kubernetes.io/instance-type</h2>
<p>示例：<code>node.kubernetes.io/instance-type=m3.medium</code></p>
<p>用于：Node</p>
<!-- 
The Kubelet populates this with the instance type as defined by the `cloudprovider`.
This will be set only if you are using a `cloudprovider`. This setting is handy
if you want to target certain workloads to certain instance types, but typically you want
to rely on the Kubernetes scheduler to perform resource-based scheduling. You should aim to schedule based on properties rather than on instance types (for example: require a GPU, instead of requiring a `g2.2xlarge`).
-->
<p>Kubelet 用 <code>cloudprovider</code> 定义的实例类型生成此标签。
所以只有用到 <code>cloudprovider</code> 的场合，才会设置此标签。
此标签非常有用，特别是在你希望把特定工作负载打到特定实例类型的时候，但更常见的调度方法是基于 Kubernetes 调度器来执行基于资源的调度。
你应该聚焦于使用基于属性的调度方式，而尽量不要依赖实例类型（例如：应该申请一个 GPU，而不是 <code>g2.2xlarge</code>）。</p>
<h2 id="failure-domainbetakubernetesioregion">failure-domain.beta.kubernetes.io/region (deprecated)</h2>
<p>参见 <a href="#topologykubernetesioregion">topology.kubernetes.io/region</a>.</p>
<blockquote class="note callout">
  <div><strong>说明：</strong> <!-- 
Starting in v1.17, this label is deprecated in favor of [topology.kubernetes.io/region](#topologykubernetesioregion). 
-->
<p>从 v1.17 开始，此标签被弃用，取而代之的是 <a href="#topologykubernetesioregion">topology.kubernetes.io/region</a>.</div>
</blockquote>
<h2 id="failure-domainbetakubernetesiozone">failure-domain.beta.kubernetes.io/zone (deprecated)</h2>
<p>参见 <a href="#topologykubernetesiozone">topology.kubernetes.io/zone</a>.</p>
<blockquote class="note callout">
  <div><strong>说明：</strong> <!-- 
Starting in v1.17, this label is deprecated in favor of [topology.kubernetes.io/zone](#topologykubernetesiozone). 
-->
<p>从 v1.17 开始，此标签被弃用，取而代之的是 <a href="#topologykubernetesiozone">topology.kubernetes.io/zone</a>.</div>
</blockquote>
<h2 id="statefulsetkubernetesiopod-name">statefulset.kubernetes.io/pod-name</h2>
<p>示例：<code>statefulset.kubernetes.io/pod-name=mystatefulset-7</code></p>
<!--
When a StatefulSet controller creates a Pod for the StatefulSet, the control plane
sets this label on that Pod. The value of the label is the name of the Pod being created.

See [Pod Name Label](/docs/concepts/workloads/controllers/statefulset/#pod-name-label) in the
StatefulSet topic for more details.
-->
<p>当 StatefulSet 控制器为 StatefulSet 创建 Pod 时，控制平面会在该 Pod 上设置此标签。
标签的值是正在创建的 Pod 的名称。</p>
<p>更多细节请参见 StatefulSet 文章中的 <a href="/zh/docs/concepts/workloads/controllers/statefulset/#pod-name-label">Pod 名称标签</a>。</p>
<h2 id="topologykubernetesioregion">topology.kubernetes.io/region</h2>
<p>示例</p>
<p><code>topology.kubernetes.io/region=us-east-1</code></p>
<p>参见 <a href="#topologykubernetesiozone">topology.kubernetes.io/zone</a>.</p>
<h2 id="topologykubernetesiozone">topology.kubernetes.io/zone</h2>
<p>示例:</p>
<p><code>topology.kubernetes.io/zone=us-east-1c</code></p>
<p>用于：Node, PersistentVolume</p>
<!-- 
On Node: The `kubelet` or the external `cloud-controller-manager` populates this with the information as provided by the `cloudprovider`.  This will be set only if you are using a `cloudprovider`. However, you should consider setting this on nodes if it makes sense in your topology.

On PersistentVolume: topology-aware volume provisioners will automatically set node affinity constraints on `PersistentVolumes`.
-->
<p>Node 场景：<code>kubelet</code> 或外部的 <code>cloud-controller-manager</code> 用 <code>cloudprovider</code> 提供的信息生成此标签。
所以只有在用到 <code>cloudprovider</code> 的场景下，此标签才会被设置。
但如果此标签在你的拓扑中有意义，你也可以考虑在 node 上设置它。</p>
<p>PersistentVolume 场景：拓扑自感知的卷制备程序将在 <code>PersistentVolumes</code> 上自动设置节点亲和性限制。</p>
<!-- 
A zone represents a logical failure domain.  It is common for Kubernetes clusters to span multiple zones for increased availability.  While the exact definition of a zone is left to infrastructure implementations, common properties of a zone include very low network latency within a zone, no-cost network traffic within a zone, and failure independence from other zones.  For example, nodes within a zone might share a network switch, but nodes in different zones should not.
-->
<p>一个可用区（zone）表示一个逻辑故障域。Kubernetes 集群通常会跨越多个可用区以提高可用性。
虽然可用区的确切定义留给基础设施来决定，但可用区常见的属性包括：可用区内的网络延迟非常低，可用区内的网络通讯没成本，独立于其他可用区的故障域。
例如，一个可用区中的节点可以共享交换机，但不同可用区则不会。</p>
<!-- 
A region represents a larger domain, made up of one or more zones.  It is uncommon for Kubernetes clusters to span multiple regions,  While the exact definition of a zone or region is left to infrastructure implementations, common properties of a region include higher network latency between them than within them, non-zero cost for network traffic between them, and failure independence from other zones or regions.  For example, nodes within a region might share power infrastructure (e.g. a UPS or generator), but nodes in different regions typically would not.
-->
<p>一个地区（region）表示一个更大的域，由一个到多个可用区组成。对于 Kubernetes 来说，跨越多个地区的集群很罕见。
虽然可用区和地区的确切定义留给基础设施来决定，但地区的常见属性包括：地区间比地区内更高的网络延迟，地区间网络流量更高的成本，独立于其他可用区或是地区的故障域。例如，一个地区内的节点可以共享电力基础设施（例如 UPS 或发电机），但不同地区内的节点显然不会。</p>
<!-- 
Kubernetes makes a few assumptions about the structure of zones and regions:
1) regions and zones are hierarchical: zones are strict subsets of regions and no zone can be in 2 regions
2) zone names are unique across regions; for example region "africa-east-1" might be comprised of zones "africa-east-1a" and "africa-east-1b"
-->
<p>Kubernetes 对可用区和地区的结构做出一些假设：
1）地区和可用区是层次化的：可用区是地区的严格子集，任何可用区都不能再 2 个地区中出现。
2）可用区名字在地区中独一无二：例如地区 &quot;africa-east-1&quot; 可由可用区 &quot;africa-east-1a&quot; 和 &quot;africa-east-1b&quot; 构成。</p>
<!-- 
It should be safe to assume that topology labels do not change.  Even though labels are strictly mutable, consumers of them can assume that a given node is not going to be moved between zones without being destroyed and recreated.
-->
<p>你可以安全的假定拓扑类的标签是固定不变的。即使标签严格来说是可变的，但使用者依然可以假定一个节点只有通过销毁、重建的方式，才能在可用区间移动。</p>
<!-- 
Kubernetes can use this information in various ways.  For example, the scheduler automatically tries to spread the Pods in a ReplicaSet across nodes in a single-zone cluster (to reduce the impact of node failures, see [kubernetes.io/hostname](#kubernetesiohostname)). With multiple-zone clusters, this spreading behavior also applies to zones (to reduce the impact of zone failures). This is achieved via _SelectorSpreadPriority_.
-->
<p>Kubernetes 能以多种方式使用这些信息。
例如，调度器自动地尝试将 ReplicaSet 中的 Pod 打散在单可用区集群的不同节点上（以减少节点故障的影响，参见<a href="#kubernetesiohostname">kubernetes.io/hostname</a>）。
在多可用区的集群中，这类打散分布的行为也会应用到可用区（以减少可用区故障的影响）。
做到这一点靠的是 <em>SelectorSpreadPriority</em>。</p>
<!-- 
_SelectorSpreadPriority_ is a best effort placement. If the zones in your cluster are heterogeneous (for example: different numbers of nodes, different types of nodes, or different pod resource requirements), this placement might prevent equal spreading of your Pods across zones. If desired, you can use homogenous zones (same number and types of nodes) to reduce the probability of unequal spreading.
-->
<p><em>SelectorSpreadPriority</em> 是一种最大能力分配方法（best effort）。如果集群中的可用区是异构的（例如：不同数量的节点，不同类型的节点，或不同的 Pod 资源需求），这种分配方法可以防止平均分配 Pod 到可用区。如果需要，你可以用同构的可用区（相同数量和类型的节点）来减少潜在的不平衡分布。</p>
<!-- 
The scheduler (through the _VolumeZonePredicate_ predicate) also will ensure that Pods, that claim a given volume, are only placed into the same zone as that volume. Volumes cannot be attached across zones.
-->
<p>调度器（通过 <em>VolumeZonePredicate</em> 的预测）也会保障声明了某卷的 Pod 只能分配到该卷相同的可用区。
卷不支持跨可用区挂载。</p>
<!-- 
If `PersistentVolumeLabel` does not support automatic labeling of your PersistentVolumes, you should consider
adding the labels manually (or adding support for `PersistentVolumeLabel`). With `PersistentVolumeLabel`, the scheduler prevents Pods from mounting volumes in a different zone. If your infrastructure doesn't have this constraint, you don't need to add the zone labels to the volumes at all.
-->
<p>如果 <code>PersistentVolumeLabel</code> 不支持给 PersistentVolume 自动打标签，你可以考虑手动加标签（或增加 <code>PersistentVolumeLabel</code> 支持）。
有了 <code>PersistentVolumeLabel</code>，调度器可以防止 Pod 挂载不同可用区中的卷。
如果你的基础架构没有此限制，那你根本就没有必要给卷增加 zone 标签。</p>
<h2 id="nodekubernetesiowindows-build">node.kubernetes.io/windows-build</h2>
<p>示例: <code>node.kubernetes.io/windows-build=10.0.17763</code></p>
<p>用于：Node</p>
<!-- 
When the kubelet is running on Microsoft Windows, it automatically labels its node to record the version of Windows Server in use.

The label's value is in the format "MajorVersion.MinorVersion.BuildNumber".
-->
<p>当 kubelet 运行于 Microsoft Windows，它给节点自动打标签，以记录 Windows Server 的版本。</p>
<p>标签值的格式为 &quot;主版本.次版本.构建号&quot;</p>
<h2 id="servicekubernetesioheadless">service.kubernetes.io/headless</h2>
<p>示例：<code>service.kubernetes.io/headless=&quot;&quot;</code></p>
<p>用于：Service</p>
<!-- 
The control plane adds this label to an Endpoints object when the owning Service is headless.
-->
<p>在无头（headless）服务的场景下，控制平面为 Endpoint 对象添加此标签。</p>
<h2 id="kubernetesioservice-name">kubernetes.io/service-name</h2>
<p>示例：<code>kubernetes.io/service-name=&quot;nginx&quot;</code></p>
<p>用于：Service</p>
<!-- 
Kubernetes uses this label to differentiate multiple Services. Used currently for `ELB`(Elastic Load Balancer) only.
-->
<p>Kubernetes 用此标签区分多个服务。当前仅用于 <code>ELB</code>(Elastic Load Balancer)。</p>
<h2 id="endpointslicekubernetesiomanaged-by">endpointslice.kubernetes.io/managed-by</h2>
<p>示例：<code>endpointslice.kubernetes.io/managed-by=&quot;controller&quot;</code></p>
<p>用于：EndpointSlices</p>
<!-- 
The label is used to indicate the controller or entity that manages an EndpointSlice. This label aims to enable different EndpointSlice objects to be managed by different controllers or entities within the same cluster.
-->
<p>此标签用来指向管理 EndpointSlice 的控制器或实体。
此标签的目的是用集群中不同的控制器或实体来管理不同的 EndpointSlice。</p>
<h2 id="endpointslicekubernetesioskip-mirror">endpointslice.kubernetes.io/skip-mirror</h2>
<p>示例：<code>endpointslice.kubernetes.io/skip-mirror=&quot;true&quot;</code></p>
<p>用于：Endpoints</p>
<!-- 
The label can be set to `"true"` on an Endpoints resource to indicate that the EndpointSliceMirroring controller should not mirror this resource with EndpointSlices.
-->
<p>此标签在 Endpoints 资源上设为 <code>&quot;true&quot;</code> 指示 EndpointSliceMirroring 控制器不要镜像此 EndpointSlices 资源。</p>
<h2 id="servicekubernetesioservice-proxy-name">service.kubernetes.io/service-proxy-name</h2>
<p>示例：<code>service.kubernetes.io/service-proxy-name=&quot;foo-bar&quot;</code></p>
<p>用于：Service</p>
<!-- 
The kube-proxy has this label for custom proxy, which delegates service control to custom proxy.
-->
<p>kube-proxy 把此标签用于客户代理，将服务控制委托给客户代理。</p>
<h2 id="experimental-windows-kubernetes-io-isolation-type">experimental.windows.kubernetes.io/isolation-type</h2>
<p>示例：<code>experimental.windows.kubernetes.io/isolation-type: &quot;hyperv&quot;</code></p>
<p>用于：Pod</p>
<!-- 
The annotation is used to run Windows containers with Hyper-V isolation. To use Hyper-V isolation feature and create a Hyper-V isolated container, the kubelet should be started with feature gates HyperVContainer=true and the Pod should include the annotation experimental.windows.kubernetes.io/isolation-type=hyperv.

< note >
You can only set this annotation on Pods that have a single container.
< /note >
-->
<p>此注解用于运行 Hyper-V 隔离的 Windows 容器。
要使用 Hyper-V 隔离特性，并创建  Hyper-V 隔离容器，kubelet 应该用特性门控 HyperVContainer=true 来启动，并且 Pod 应该包含注解 <code>experimental.windows.kubernetes.io/isolation-type=hyperv</code>。</p>
<blockquote class="note callout">
  <div><strong>说明：</strong> 你只能在单容器 Pod 上设置此注解。</div>
</blockquote>
<h2 id="ingressclass-kubernetes-io-is-default-class">ingressclass.kubernetes.io/is-default-class</h2>
<p>示例：<code>ingressclass.kubernetes.io/is-default-class: &quot;true&quot;</code></p>
<p>用于：IngressClass</p>
<!-- 
When a single IngressClass resource has this annotation set to `"true"`, new Ingress resource without a class specified will be assigned this default class.
-->
<p>当唯一的 IngressClass 资源将此注解的值设为 &quot;true&quot;，没有指定类型的新 Ingress 资源将使用此默认类型。</p>
<h2 id="kubernetes-io-ingress-class-deprecated">kubernetes.io/ingress.class (deprecated)</h2>
<blockquote class="note callout">
  <div><strong>说明：</strong> <!-- 
Starting in v1.18, this annotation is deprecated in favor of `spec.ingressClassName`.
-->
<p>从 v1.18 开始，此注解被弃用，取而代之的是 <code>spec.ingressClassName</code>。</div>
</blockquote>
<h2 id="storageclass-kubernetes-io-is-default-class">storageclass.kubernetes.io/is-default-class</h2>
<p>示例：<code>storageclass.kubernetes.io/is-default-class=true</code></p>
<p>用于：StorageClass</p>
<!--
When a single StorageClass resource has this annotation set to `"true"`, new Physical Volume Claim resource without a class specified will be assigned this default class.
-->
<p>当单个的 StorageClass 资源将这个注解设置为 <code>&quot;true&quot;</code> 时，新的持久卷申领（PVC）
资源若未指定类别，将被设定为此默认类别。</p>
<h2 id="alpha-kubernetes-io-provided-node-ip">alpha.kubernetes.io/provided-node-ip</h2>
<p>示例：<code>alpha.kubernetes.io/provided-node-ip: &quot;10.0.0.1&quot;</code></p>
<p>用于：Node</p>
<!-- 
The kubelet can set this annotation on a Node to denote its configured IPv4 address.

When kubelet is started with the "external" cloud provider, it sets this annotation on the Node to denote an IP address set from the command line flag (`--node-ip`). This IP is verified with the cloud provider as valid by the cloud-controller-manager.
-->
<p>kubectl 在 Node 上设置此注解，表示它的 IPv4 地址。</p>
<p>当 kubectl 由外部的云供应商启动时，在 Node 上设置此注解，表示由命令行标记(<code>--node-ip</code>)设置的 IP 地址。
cloud-controller-manager 向云供应商验证此 IP 是否有效。</p>
<h2 id="batch-kubernetes-io-job-completion-index">batch.kubernetes.io/job-completion-index</h2>
<p>示例：<code>batch.kubernetes.io/job-completion-index: &quot;3&quot;</code></p>
<p>用于：Pod</p>
<!--
The Job controller in the kube-controller-manager sets this annotation for Pods
created with Indexed [completion mode](/docs/concepts/workloads/controllers/job/#completion-mode).
-->
<p>kube-controller-manager 中的 Job 控制器给创建使用索引
<a href="/zh/docs/concepts/workloads/controllers/job/#completion-mode">完成模式</a>
的 Pod 设置此注解。</p>
<h2 id="kubectl-kubernetes-io-default-container">kubectl.kubernetes.io/default-container</h2>
<p>示例：<code>kubectl.kubernetes.io/default-container: &quot;front-end-app&quot;</code></p>
<!--
The value of the annotation is the container name that is default for this Pod. For example, `kubectl logs` or `kubectl exec` without `-c` or `--container` flag will use this default container.
-->
<p>注解的值是此 Pod 的默认容器名称。
例如，<code>kubectl logs</code> 或 <code>kubectl exec</code> 没有 <code>-c</code> 或 <code>--container</code> 参数时，将使用这个默认的容器。</p>
<h2 id="endpoints-kubernetes-io-over-capacity">endpoints.kubernetes.io/over-capacity</h2>
<p>示例：<code>endpoints.kubernetes.io/over-capacity:warning</code></p>
<p>用于：Endpoints</p>
<!-- 
In Kubernetes clusters v1.21 (or later), the Endpoints controller adds this annotation to an Endpoints resource if it has more than 1000 endpoints. The annotation indicates that the Endpoints resource is over capacity.

**The taints listed below are always used on Nodes**
-->
<p>在 Kubernetes 集群 v1.21（或更高版本）中，如果 Endpoint 超过 1000 个，Endpoint 控制器
就会向其添加这个注解。该注解表示 Endpoint 资源已超过容量。</p>
<p><strong>以下列出的污点只能用于 Node</strong></p>
<h2 id="node-kubernetes-io-not-ready">node.kubernetes.io/not-ready</h2>
<p>示例：<code>node.kubernetes.io/not-ready:NoExecute</code></p>
<!-- 
The node controller detects whether a node is ready by monitoring its health and adds or removes this taint accordingly.
-->
<p>节点控制器通过健康监控来检测节点是否就绪，并据此添加/删除此污点。</p>
<h2 id="node-kubernetes-io-unreachable">node.kubernetes.io/unreachable</h2>
<p>示例：<code>node.kubernetes.io/unreachable:NoExecute</code></p>
<!-- 
The node controller adds the taint to a node corresponding to the [NodeCondition](/docs/concepts/architecture/nodes/#condition) `Ready` being `Unknown`.
-->
<p>如果 <a href="/docs/concepts/architecture/nodes/#condition">NodeCondition</a> 的 <code>Ready</code> 键值为 <code>Unknown</code>，节点控制器将添加污点到 node。</p>
<h2 id="node-kubernetes-io-unschedulable">node.kubernetes.io/unschedulable</h2>
<p>示例：<code>node.kubernetes.io/unschedulable:NoSchedule</code></p>
<!-- 
The taint will be added to a node when initializing the node to avoid race condition.
-->
<p>当初始化节点时，添加此污点，来避免竟态的发生。</p>
<h2 id="node-kubernetes-io-memory-pressure">node.kubernetes.io/memory-pressure</h2>
<p>示例：<code>node.kubernetes.io/memory-pressure:NoSchedule</code></p>
<!-- 
The kubelet detects memory pressure based on `memory.available` and `allocatableMemory.available` observed on a Node. The observed values are then compared to the corresponding thresholds that can be set on the kubelet to determine if the Node condition and taint should be added/removed.
-->
<p>kubelet 依据节点上观测到的 <code>memory.available</code> 和 <code>allocatableMemory.available</code> 来检测内存压力。
用观测值对比 kubelet 设置的阈值，以判断节点状态和污点是否可以被添加/移除。</p>
<h2 id="node-kubernetes-io-disk-pressure">node.kubernetes.io/disk-pressure</h2>
<p>示例：<code>node.kubernetes.io/disk-pressure:NoSchedule</code></p>
<!-- 
The kubelet detects disk pressure based on `imagefs.available`, `imagefs.inodesFree`, `nodefs.available` and `nodefs.inodesFree`(Linux only) observed on a Node. The observed values are then compared to the corresponding thresholds that can be set on the kubelet to determine if the Node condition and taint should be added/removed.
-->
<p>kubelet 依据节点上观测到的 <code>imagefs.available</code>、<code>imagefs.inodesFree</code>、<code>nodefs.available</code> 和 <code>nodefs.inodesFree</code>(仅 Linux) 来判断磁盘压力。
用观测值对比 kubelet 设置的阈值，以确定节点状态和污点是否可以被添加/移除。</p>
<h2 id="node-kubernetes-io-network-unavailable">node.kubernetes.io/network-unavailable</h2>
<p>示例：<code>node.kubernetes.io/network-unavailable:NoSchedule</code></p>
<!-- 
This is initially set by the kubelet when the cloud provider used indicates a requirement for additional network configuration. Only when the route on the cloud is configured properly will the taint be removed by the cloud provider.
-->
<p>它初始由 kubectl 设置，云供应商用它来指示对额外网络配置的需求。
仅当云中的路由器配置妥当后，云供应商才会移除此污点。</p>
<h2 id="node-kubernetes-io-pid-pressure">node.kubernetes.io/pid-pressure</h2>
<p>示例：<code>node.kubernetes.io/pid-pressure:NoSchedule</code></p>
<!-- 
The kubelet checks D-value of the size of `/proc/sys/kernel/pid_max` and the PIDs consumed by Kubernetes on a node to get the number of available PIDs that referred to as the `pid.available` metric. The metric is then compared to the corresponding threshold that can be set on the kubelet to determine if the node condition and taint should be added/removed.
-->
<p>kubelet 检查 <code>/proc/sys/kernel/pid_max</code> 尺寸的 D 值（D-value），以及节点上 Kubernetes 消耗掉的 PID，以获取可用的 PID 数量，此数量可通过指标 <code>pid.available</code> 得到。
然后用此指标对比 kubelet 设置的阈值，以确定节点状态和污点是否可以被添加/移除。</p>
<h2 id="node-cloudprovider-kubernetes-io-uninitialized">node.cloudprovider.kubernetes.io/uninitialized</h2>
<p>示例：<code>node.cloudprovider.kubernetes.io/uninitialized:NoSchedule</code></p>
<!-- 
Sets this taint on a node to mark it as unusable, when kubelet is started with the "external" cloud provider, until a controller from the cloud-controller-manager initializes this node, and then removes the taint.
-->
<p>当 kubelet 由外部云供应商启动时，在节点上设置此污点以标记节点不可用，直到一个 cloud-controller-manager 控制器初始化此节点之后，才会移除此污点。</p>
<h2 id="node-cloudprovider-kubernetes-io-shutdown">node.cloudprovider.kubernetes.io/shutdown</h2>
<p>示例：<code>node.cloudprovider.kubernetes.io/shutdown:NoSchedule</code></p>
<!-- 
If a Node is in a cloud provider specified shutdown state, the Node gets tainted accordingly with `node.cloudprovider.kubernetes.io/shutdown` and the taint effect of `NoSchedule`.
-->
<p>如果一个云供应商的节点被指定为关机状态，节点被打上污点 <code>node.cloudprovider.kubernetes.io/shutdown</code>，污点的影响为 <code>NoSchedule</code>。</p>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-99b26586d8a33ec06996dcf7892a9683">4 - 访问 API</h1>
    
	<!--
title: API Access Control
weight: 20
no_list: true
-->
<!--
For an introduction to how Kubernetes implements and controls API access,
read [Controlling Access to the Kubernetes API](/docs/concepts/security/controlling-access/).

Reference documentation:
-->
<p>关于 Kubernetes 如何实现和控制 API 访问的介绍性材料，可阅读
<a href="/zh/docs/concepts/security/controlling-access/">控制 Kubernetes API 的访问</a>。</p>
<p>参考文档：</p>
<!--
- [Authenticating](/docs/reference/access-authn-authz/authentication/)
   - [Authenticating with Bootstrap Tokens](/docs/reference/access-authn-authz/bootstrap-tokens/)
- [Admission Controllers](/docs/reference/access-authn-authz/admission-controllers/)
   - [Dynamic Admission Control](/docs/reference/access-authn-authz/extensible-admission-controllers/)
- [Authorization](/docs/reference/access-authn-authz/authorization/)
   - [Role Based Access Control](/docs/reference/access-authn-authz/rbac/)
   - [Attribute Based Access Control](/docs/reference/access-authn-authz/abac/)
   - [Node Authorization](/docs/reference/access-authn-authz/node/)
   - [Webhook Authorization](/docs/reference/access-authn-authz/webhook/)
- [Certificate Signing Requests](/docs/reference/access-authn-authz/certificate-signing-requests/)
   - including [CSR approval](/docs/reference/access-authn-authz/certificate-signing-requests/#approval-rejection)
     and [certificate signing](/docs/reference/access-authn-authz/certificate-signing-requests/#signing)
- Service accounts
  - [Developer guide](/docs/tasks/configure-pod-container/configure-service-account/)
  - [Administration](/docs/reference/access-authn-authz/service-accounts-admin/)
-->
<ul>
<li><a href="/zh/docs/reference/access-authn-authz/authentication/">身份认证</a>
<ul>
<li><a href="/zh/docs/reference/access-authn-authz/bootstrap-tokens/">使用启动引导令牌来执行身份认证</a></li>
</ul>
</li>
<li><a href="/zh/docs/reference/access-authn-authz/admission-controllers/">准入控制器</a>
<ul>
<li><a href="/zh/docs/reference/access-authn-authz/extensible-admission-controllers/">动态准入控制</a></li>
</ul>
</li>
<li><a href="/zh/docs/reference/access-authn-authz/authorization/">鉴权与授权</a>
<ul>
<li><a href="/zh/docs/reference/access-authn-authz/rbac/">基于角色的访问控制</a></li>
<li><a href="/zh/docs/reference/access-authn-authz/abac/">基于属性的访问控制</a></li>
<li><a href="/zh/docs/reference/access-authn-authz/node/">节点鉴权</a></li>
<li><a href="/zh/docs/reference/access-authn-authz/webhook/">Webhook 鉴权</a></li>
</ul>
</li>
<li><a href="/zh/docs/reference/access-authn-authz/certificate-signing-requests/">证书签名请求</a>
<ul>
<li>包含 <a href="/zh/docs/reference/access-authn-authz/certificate-signing-requests/#approval-rejection">CSR 的批复</a>
和<a href="/zh/docs/reference/access-authn-authz/certificate-signing-requests/#signing">证书签名</a></li>
</ul>
</li>
<li>服务账号
<ul>
<li><a href="/zh/docs/tasks/configure-pod-container/configure-service-account/">开发者指南</a></li>
<li><a href="/zh/docs/reference/access-authn-authz/service-accounts-admin/">管理文档</a></li>
</ul>
</li>
</ul>

</div>



    
      
  
  
  
  

  
  

  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-a6264859a5ad6e2f4a6e4cff9ce4fa8b">4.1 - 用户认证</h1>
    
	<!--
reviewers:
- erictune
- lavalamp
- ericchiang
- deads2k
- liggitt
title: Authenticating
content_type: concept
weight: 10
-->
<!-- overview -->
<!--
This page provides an overview of authenticating.
-->
<p>本页提供身份认证有关的概述。</p>
<!-- body -->
<!--
## Users in Kubernetes

All Kubernetes clusters have two categories of users: service accounts managed
by Kubernetes, and normal users.

It is assumed that a cluster-independent service manages normal users in the following ways:

- an administrator distributing private keys
- a user store like Keystone or Google Accounts
- a file with a list of usernames and passwords

In this regard, _Kubernetes does not have objects which represent normal user
accounts._ Normal users cannot be added to a cluster through an API call.
-->
<h2 id="users-in-kubernetes">Kubernetes 中的用户 </h2>
<p>所有 Kubernetes 集群都有两类用户：由 Kubernetes 管理的服务账号和普通用户。</p>
<p>Kubernetes 假定普通用户是由一个与集群无关的服务通过以下方式之一进行管理的：</p>
<ul>
<li>负责分发私钥的管理员</li>
<li>类似 Keystone 或者 Google Accounts 这类用户数据库</li>
<li>包含用户名和密码列表的文件</li>
</ul>
<p>有鉴于此，<em>Kubernetes 并不包含用来代表普通用户账号的对象</em>。
普通用户的信息无法通过 API 调用添加到集群中。</p>
<!--
Even though normal user cannot be added via an API call, but any user that
presents a valid certificate signed by the cluster’s certificate authority
(CA) is considered authenticated. In this configuration, Kubernetes determines
the username from the common name field in the ‘subject’ of the cert (e.g.,
“/CN=bob”). From there, the role based access control (RBAC) sub-system would
determine whether the user is authorized to perform a specific operation on a
resource. For more details, refer to the normal users topic in
[certificate request](/docs/reference/access-authn-authz/certificate-signing-requests/#normal-user)
for more details about this.
-->
<p>尽管无法通过 API 调用来添加普通用户，Kubernetes 仍然认为能够提供由集群的证书
机构签名的合法证书的用户是通过身份认证的用户。基于这样的配置，Kubernetes
使用证书中的 'subject' 的通用名称（Common Name）字段（例如，&quot;/CN=bob&quot;）来
确定用户名。接下来，基于角色访问控制（RBAC）子系统会确定用户是否有权针对
某资源执行特定的操作。进一步的细节可参阅
<a href="/zh/docs/reference/access-authn-authz/certificate-signing-requests/#normal-user">证书请求</a>
下普通用户主题。</p>
<!--
In contrast, service accounts are users managed by the Kubernetes API. They are
bound to specific namespaces, and created automatically by the API server or
manually through API calls. Service accounts are tied to a set of credentials
stored as `Secrets`, which are mounted into pods allowing in-cluster processes
to talk to the Kubernetes API.

API requests are tied to either a normal user or a service account, or are treated
as [anonymous requests](#anonymous-requests). This means every process inside or outside the cluster, from
a human user typing `kubectl` on a workstation, to `kubelets` on nodes, to members
of the control plane, must authenticate when making requests to the API server,
or be treated as an anonymous user.
-->
<p>与此不同，服务账号是 Kubernetes API 所管理的用户。它们被绑定到特定的名字空间，
或者由 API 服务器自动创建，或者通过 API 调用创建。服务账号与一组以 Secret 保存
的凭据相关，这些凭据会被挂载到 Pod 中，从而允许集群内的进程访问 Kubernetes
API。</p>
<p>API 请求则或者与某普通用户相关联，或者与某服务账号相关联，亦或者被视作
<a href="#anonymous-requests">匿名请求</a>。这意味着集群内外的每个进程在向 API 服务器发起
请求时都必须通过身份认证，否则会被视作匿名用户。这里的进程可以是在某工作站上
输入 <code>kubectl</code> 命令的操作人员，也可以是节点上的 <code>kubelet</code> 组件，还可以是控制面
的成员。</p>
<!--
## Authentication strategies

Kubernetes uses client certificates, bearer tokens, an authenticating proxy, or HTTP basic auth to
authenticate API requests through authentication plugins. As HTTP requests are
made to the API server, plugins attempt to associate the following attributes
with the request:
-->
<h2 id="authentication-strategies">身份认证策略 </h2>
<p>Kubernetes 使用身份认证插件利用客户端证书、持有者令牌（Bearer Token）、身份认证代理（Proxy）
或者 HTTP 基本认证机制来认证 API 请求的身份。HTTP 请求发给 API 服务器时，
插件会将以下属性关联到请求本身：</p>
<!--
* Username: a string which identifies the end user. Common values might be `kube-admin` or `jane@example.com`.
* UID: a string which identifies the end user and attempts to be more consistent and unique than username.
* Groups: a set of strings, each of which indicates the user's membership in a named logical collection of users. Common values might be `system:masters` or `devops-team`.
* Extra fields: a map of strings to list of strings which holds additional information authorizers may find useful.
-->
<ul>
<li>用户名：用来辩识最终用户的字符串。常见的值可以是 <code>kube-admin</code> 或 <code>jane@example.com</code>。</li>
<li>用户 ID：用来辩识最终用户的字符串，旨在比用户名有更好的一致性和唯一性。</li>
<li>用户组：取值为一组字符串，其中各个字符串用来标明用户是某个命名的用户逻辑集合的成员。
常见的值可能是 <code>system:masters</code> 或者 <code>devops-team</code> 等。</li>
<li>附加字段：一组额外的键-值映射，键是字符串，值是一组字符串；用来保存一些鉴权组件可能
觉得有用的额外信息。</li>
</ul>
<!--
All values are opaque to the authentication system and only hold significance
when interpreted by an [authorizer](/docs/reference/access-authn-authz/authorization/).

You can enable multiple authentication methods at once. You should usually use at least two methods:

 - service account tokens for service accounts
 - at least one other method for user authentication.
-->
<p>所有（属性）值对于身份认证系统而言都是不透明的，只有被
<a href="/zh/docs/reference/access-authn-authz/authorization/">鉴权组件</a>
解释过之后才有意义。</p>
<p>你可以同时启用多种身份认证方法，并且你通常会至少使用两种方法：</p>
<ul>
<li>针对服务账号使用服务账号令牌</li>
<li>至少另外一种方法对用户的身份进行认证</li>
</ul>
<!--
When multiple authenticator modules are enabled, the first module
to successfully authenticate the request short-circuits evaluation.
The API server does not guarantee the order authenticators run in.

The `system:authenticated` group is included in the list of groups for all authenticated users.

Integrations with other authentication protocols (LDAP, SAML, Kerberos, alternate x509 schemes, etc)
can be accomplished using an [authenticating proxy](#authenticating-proxy) or the
[authentication webhook](#webhook-token-authentication).
-->
<p>当集群中启用了多个身份认证模块时，第一个成功地对请求完成身份认证的模块会
直接做出评估决定。API 服务器并不保证身份认证模块的运行顺序。</p>
<p>对于所有通过身份认证的用户，<code>system:authenticated</code> 组都会被添加到其组列表中。</p>
<p>与其它身份认证协议（LDAP、SAML、Kerberos、X509 的替代模式等等）都可以通过
使用一个<a href="#authenticating-proxy">身份认证代理</a>或
<a href="#webhook-token-authentication">身份认证 Webhoook</a>来实现。</p>
<!--
### X509 Client Certs

Client certificate authentication is enabled by passing the `-client-ca-file=SOMEFILE`
option to API server. The referenced file must contain one or more certificate authorities
to use to validate client certificates presented to the API server. If a client certificate
is presented and verified, the common name of the subject is used as the user name for the
request. As of Kubernetes 1.4, client certificates can also indicate a user's group memberships
using the certificate's organization fields. To include multiple group memberships for a user,
include multiple organization fields in the certificate.

For example, using the `openssl` command line tool to generate a certificate signing request:
-->
<h3 id="x509-client-certs">X509 客户证书  </h3>
<p>通过给 API 服务器传递 <code>--client-ca-file=SOMEFILE</code> 选项，就可以启动客户端证书身份认证。
所引用的文件必须包含一个或者多个证书机构，用来验证向 API 服务器提供的客户端证书。
如果提供了客户端证书并且证书被验证通过，则 subject 中的公共名称（Common Name）就被
作为请求的用户名。
自 Kubernetes 1.4 开始，客户端证书还可以通过证书的 organization 字段标明用户的组成员信息。
要包含用户的多个组成员信息，可以在证书种包含多个 organization 字段。</p>
<p>例如，使用 <code>openssl</code> 命令行工具生成一个证书签名请求：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">openssl req -new -key jbeda.pem -out jbeda-csr.pem -subj <span style="color:#b44">&#34;/CN=jbeda/O=app1/O=app2&#34;</span>
</code></pre></div><!--
This would create a CSR for the username "jbeda", belonging to two groups, "app1" and "app2".

See [Managing Certificates](/docs/concepts/cluster-administration/certificates/) for how to generate a client cert.
-->
<p>此命令将使用用户名 <code>jbeda</code> 生成一个证书签名请求（CSR），且该用户属于 &quot;app&quot; 和
&quot;app2&quot; 两个用户组。</p>
<p>参阅<a href="/zh/docs/concepts/cluster-administration/certificates/">管理证书</a>了解如何生成客户端证书。</p>
<!--
### Static Token File

The API server reads bearer tokens from a file when given the `-token-auth-file=SOMEFILE` option on the command line.  Currently, tokens last indefinitely, and the token list cannot be
changed without restarting API server.

The token file is a csv file with a minimum of 3 columns: token, user name, user uid,
followed by optional group names.
-->
<h3 id="static-token-file">静态令牌文件 </h3>
<p>当 API 服务器的命令行设置了 <code>--token-auth-file=SOMEFILE</code> 选项时，会从文件中
读取持有者令牌。目前，令牌会长期有效，并且在不重启 API 服务器的情况下
无法更改令牌列表。</p>
<p>令牌文件是一个 CSV 文件，包含至少 3 个列：令牌、用户名和用户的 UID。
其余列被视为可选的组名。</p>
<!--
If you have more than one group the column must be double quoted e.g.

```conf
token,user,uid,"group1,group2,group3"
```
-->
<blockquote class="note callout">
  <div><strong>说明：</strong> <p>如果要设置的组名不止一个，则对应的列必须用双引号括起来，例如</p>
<pre tabindex="0"><code class="language-conf" data-lang="conf">token,user,uid,&quot;group1,group2,group3&quot;
</code></pre></div>
</blockquote>
<!--
#### Putting a Bearer Token in a Request

When using bearer token authentication from an http client, the API
server expects an `Authorization` header with a value of `Bearer
THETOKEN`.  The bearer token must be a character sequence that can be
put in an HTTP header value using no more than the encoding and
quoting facilities of HTTP.  For example: if the bearer token is
`31ada4fd-adec-460c-809a-9e56ceb75269` then it would appear in an HTTP
header as shown below.
-->
<h4 id="putting-a-bearer-token-in-a-request">在请求中放入持有者令牌  </h4>
<p>当使用持有者令牌来对某 HTTP 客户端执行身份认证时，API 服务器希望看到
一个名为 <code>Authorization</code> 的 HTTP 头，其值格式为 <code>Bearer THETOKEN</code>。
持有者令牌必须是一个可以放入 HTTP 头部值字段的字符序列，至多可使用
HTTP 的编码和引用机制。
例如：如果持有者令牌为 <code>31ada4fd-adec-460c-809a-9e56ceb75269</code>，则其
出现在 HTTP 头部时如下所示：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-http" data-lang="http"><span style="">Authorization: Bearer 31ada4fd-adec-460c-809a-9e56ceb75269
</span></code></pre></div><!--
### Bootstrap Tokens
-->
<h3 id="bootstrap-tokens">启动引导令牌   </h3>





<div style="margin-top: 10px; margin-bottom: 10px;">
<b>FEATURE STATE:</b> <code>Kubernetes v1.18 [stable]</code>
</div>

<!--
To allow for streamlined bootstrapping for new clusters, Kubernetes includes a
dynamically-managed Bearer token type called a *Bootstrap Token*. These tokens
are stored as Secrets in the `kube-system` namespace, where they can be
dynamically managed and created. Controller Manager contains a TokenCleaner
controller that deletes bootstrap tokens as they expire.
-->
<p>为了支持平滑地启动引导新的集群，Kubernetes 包含了一种动态管理的持有者令牌类型，
称作 <em>启动引导令牌（Bootstrap Token）</em>。
这些令牌以 Secret 的形式保存在 <code>kube-system</code> 名字空间中，可以被动态管理和创建。
控制器管理器包含的 <code>TokenCleaner</code> 控制器能够在启动引导令牌过期时将其删除。</p>
<!--
The tokens are of the form `[a-z0-9]{6}.[a-z0-9]{16}`.  The first component is a
Token ID and the second component is the Token Secret.  You specify the token
in an HTTP header as follows:
-->
<p>这些令牌的格式为 <code>[a-z0-9]{6}.[a-z0-9]{16}</code>。第一个部分是令牌的 ID；第二个部分
是令牌的 Secret。你可以用如下所示的方式来在 HTTP 头部设置令牌：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-http" data-lang="http"><span style="">Authorization: Bearer 781292.db7bc3a58fc5f07e
</span></code></pre></div><!--
You must enable the Bootstrap Token Authenticator with the
`-enable-bootstrap-token-auth` flag on the API Server.  You must enable
the TokenCleaner controller via the `-controllers` flag on the Controller
Manager.  This is done with something like `-controllers=*,tokencleaner`.
`kubeadm` will do this for you if you are using it to bootstrap a cluster.
-->
<p>你必须在 API 服务器上设置 <code>--enable-bootstrap-token-auth</code> 标志来启用基于启动
引导令牌的身份认证组件。
你必须通过控制器管理器的 <code>--controllers</code> 标志来启用 TokenCleaner 控制器；
这可以通过类似 <code>--controllers=*,tokencleaner</code> 这种设置来做到。
如果你使用 <code>kubeadm</code> 来启动引导新的集群，该工具会帮你完成这些设置。</p>
<!--
The authenticator authenticates as `system:bootstrap:<Token ID>`.  It is
included in the `system:bootstrappers` group.  The naming and groups are
intentionally limited to discourage users from using these tokens past
bootstrapping.  The user names and group can be used (and are used by `kubeadm`)
to craft the appropriate authorization policies to support bootstrapping a
cluster.
-->
<p>身份认证组件的认证结果为 <code>system:bootstrap:&lt;令牌 ID&gt;</code>，该用户属于
<code>system:bootstrappers</code> 用户组。
这里的用户名和组设置都是有意设计成这样，其目的是阻止用户在启动引导集群之后
继续使用这些令牌。
这里的用户名和组名可以用来（并且已经被 <code>kubeadm</code> 用来）构造合适的鉴权
策略，以完成启动引导新集群的工作。</p>
<!--
Please see [Bootstrap Tokens](/docs/reference/access-authn-authz/bootstrap-tokens/) for in depth
documentation on the Bootstrap Token authenticator and controllers along with
how to manage these tokens with `kubeadm`.
-->
<p>请参阅<a href="/zh/docs/reference/access-authn-authz/bootstrap-tokens/">启动引导令牌</a>
以了解关于启动引导令牌身份认证组件与控制器的更深入的信息，以及如何使用
<code>kubeadm</code> 来管理这些令牌。</p>
<!--
### Service Account Tokens

A service account is an automatically enabled authenticator that uses signed
bearer tokens to verify requests. The plugin takes two optional flags:

* `--service-account-key-file` A file containing a PEM encoded key for signing bearer tokens.
If unspecified, the API server's TLS private key will be used.
* `--service-account-lookup` If enabled, tokens which are deleted from the API will be revoked.
-->
<h3 id="service-account-tokens">服务账号令牌  </h3>
<p>服务账号（Service Account）是一种自动被启用的用户认证机制，使用经过签名的
持有者令牌来验证请求。该插件可接受两个可选参数：</p>
<ul>
<li><code>--service-account-key-file</code> 一个包含用来为持有者令牌签名的 PEM 编码密钥。
若未指定，则使用 API 服务器的 TLS 私钥。</li>
<li><code>--service-account-lookup</code> 如果启用，则从 API 删除的令牌会被回收。</li>
</ul>
<!--
Service accounts are usually created automatically by the API server and
associated with pods running in the cluster through the `ServiceAccount`
[Admission Controller](/docs/reference/access-authn-authz/admission-controllers/). Bearer tokens are
mounted into pods at well-known locations, and allow in-cluster processes to
talk to the API server. Accounts may be explicitly associated with pods using the
`serviceAccountName` field of a `PodSpec`.
-->
<p>服务账号通常由 API 服务器自动创建并通过 <code>ServiceAccount</code>
<a href="/zh/docs/reference/access-authn-authz/admission-controllers/">准入控制器</a>
关联到集群中运行的 Pod 上。
持有者令牌会挂载到 Pod 中可预知的位置，允许集群内进程与 API 服务器通信。
服务账号也可以使用 Pod 规约的 <code>serviceAccountName</code> 字段显式地关联到 Pod 上。</p>
<!--
`serviceAccountName` is usually omitted because this is done automatically.
-->
<blockquote class="note callout">
  <div><strong>说明：</strong> <code>serviceAccountName</code> 通常会被忽略，因为关联关系是自动建立的。</div>
</blockquote>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>apps/v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>Deployment<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>nginx-deployment<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">namespace</span>:<span style="color:#bbb"> </span>default<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">spec</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">replicas</span>:<span style="color:#bbb"> </span><span style="color:#666">3</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">template</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#080;font-style:italic"># ...</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">spec</span>:<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">serviceAccountName</span>:<span style="color:#bbb"> </span>bob-the-bot<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">containers</span>:<span style="color:#bbb">
</span><span style="color:#bbb">      </span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>nginx<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#008000;font-weight:bold">image</span>:<span style="color:#bbb"> </span>nginx:1.14.2<span style="color:#bbb">
</span></code></pre></div><!--
Service account bearer tokens are perfectly valid to use outside the cluster and
can be used to create identities for long standing jobs that wish to talk to the
Kubernetes API. To manually create a service account, simply use the `kubectl
create serviceaccount (NAME)` command. This creates a service account in the
current namespace and an associated secret.
-->
<p>在集群外部使用服务账号持有者令牌也是完全合法的，且可用来为长时间运行的、需要与
Kubernetes  API 服务器通信的任务创建标识。要手动创建服务账号，可以使用
<code>kubectl create serviceaccount &lt;名称&gt;</code> 命令。此命令会在当前的名字空间中生成一个
服务账号和一个与之关联的 Secret。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">kubectl create serviceaccount jenkins
</code></pre></div><pre tabindex="0"><code>serviceaccount/jenkins created
</code></pre><!--
Check an associated secret:
-->
<p>查验相关联的 Secret：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">kubectl get serviceaccounts jenkins -o yaml
</code></pre></div><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>ServiceAccount<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#080;font-style:italic"># ...</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">secrets</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>jenkins-token-1yvwg<span style="color:#bbb">
</span></code></pre></div><!--
The created secret holds the public CA of the API server and a signed JSON Web
Token (JWT).
-->
<p>所创建的 Secret 中会保存 API 服务器的公开的 CA 证书和一个已签名的 JSON Web
令牌（JWT）。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">kubectl get secret jenkins-token-1yvwg -o yaml
</code></pre></div><!--
```yaml
apiVersion: v1
data:
  ca.crt: (APISERVER'S CA BASE64 ENCODED)
  namespace: ZGVmYXVsdA==
  token: (BEARER TOKEN BASE64 ENCODED)
kind: Secret
metadata:
  # ...
type: kubernetes.io/service-account-token
```
-->
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">data</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">ca.crt</span>:<span style="color:#bbb"> </span>&lt;Base64 编码的 API 服务器 CA&gt;<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">namespace</span>:<span style="color:#bbb"> </span>ZGVmYXVsdA==<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">token</span>:<span style="color:#bbb"> </span>&lt;Base64 编码的持有者令牌&gt;<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>Secret<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#080;font-style:italic"># ...</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">type</span>:<span style="color:#bbb"> </span>kubernetes.io/service-account-token<span style="color:#bbb">
</span></code></pre></div><!--
Values are base64 encoded because secrets are always base64 encoded.
-->
<blockquote class="note callout">
  <div><strong>说明：</strong> 字段值是按 Base64 编码的，这是因为 Secret 数据总是采用 Base64 编码来存储。</div>
</blockquote>
<!--
The signed JWT can be used as a bearer token to authenticate as the given service
account. See [above](#putting-a-bearer-token-in-a-request) for how the token is included
in a request.  Normally these secrets are mounted into pods for in-cluster access to
the API server, but can be used from outside the cluster as well.
-->
<p>已签名的 JWT 可以用作持有者令牌，并将被认证为所给的服务账号。
关于如何在请求中包含令牌，请参阅<a href="#putting-a-bearer-token-in-a-request">前文</a>。
通常，这些 Secret 数据会被挂载到 Pod 中以便集群内访问 API 服务器时使用，
不过也可以在集群外部使用。</p>
<!--
Service accounts authenticate with the username `system:serviceaccount:(NAMESPACE):(SERVICEACCOUNT)`,
and are assigned to the groups `system:serviceaccounts` and `system:serviceaccounts:(NAMESPACE)`.

WARNING: Because service account tokens are stored in secrets, any user with
read access to those secrets can authenticate as the service account. Be cautious
when granting permissions to service accounts and read capabilities for secrets.
-->
<p>服务账号被身份认证后，所确定的用户名为 <code>system:serviceaccount:&lt;名字空间&gt;:&lt;服务账号&gt;</code>，
并被分配到用户组 <code>system:serviceaccounts</code> 和 <code>system:serviceaccounts:&lt;名字空间&gt;</code>。</p>
<p>警告：由于服务账号令牌保存在 Secret 对象中，任何能够读取这些 Secret 的用户
都可以被认证为对应的服务账号。在为用户授予访问服务账号的权限时，以及对 Secret
的读权限时，要格外小心。</p>
<!--
### OpenID Connect Tokens

[OpenID Connect](https://openid.net/connect/) is a flavor of OAuth2 supported by
some OAuth2 providers, notably Azure Active Directory, Salesforce, and Google.
The protocol's main extension of OAuth2 is an additional field returned with
the access token called an [ID Token](https://openid.net/specs/openid-connect-core-1_0.html#IDToken).
This token is a JSON Web Token (JWT) with well known fields, such as a user's
email, signed by the server.
-->
<h3 id="openid-connect-tokens">OpenID Connect（OIDC）令牌  </h3>
<p><a href="https://openid.net/connect/">OpenID Connect</a> 是一种 OAuth2  认证方式，
被某些 OAuth2 提供者支持，例如 Azure 活动目录、Salesforce 和 Google。
协议对 OAuth2 的主要扩充体现在有一个附加字段会和访问令牌一起返回，
这一字段称作 <a href="https://openid.net/specs/openid-connect-core-1_0.html#IDToken">ID Token（ID 令牌）</a>。
ID 令牌是一种由服务器签名的 JSON Web 令牌（JWT），其中包含一些可预知的字段，
例如用户的邮箱地址，</p>
<!--
To identify the user, the authenticator uses the `id_token` (not the `access_token`)
from the OAuth2 [token response](https://openid.net/specs/openid-connect-core-1_0.html#TokenResponse)
as a bearer token.  See [above](#putting-a-bearer-token-in-a-request) for how the token
is included in a request.
-->
<p>要识别用户，身份认证组件使用 OAuth2
<a href="https://openid.net/specs/openid-connect-core-1_0.html#TokenResponse">令牌响应</a>
中的 <code>id_token</code>（而非 <code>access_token</code>）作为持有者令牌。
关于如何在请求中设置令牌，可参见<a href="#putting-a-bearer-token-in-a-request">前文</a>。</p>
<div class="mermaid">
    
sequenceDiagram
    participant user as 用户
    participant idp as 身份提供者 
    participant kube as Kubectl
    participant api as API 服务器

    user ->> idp: 1. 登录到 IdP
    activate idp
    idp -->> user: 2. 提供 access_token,<br>id_token, 和 refresh_token
    deactivate idp
    activate user
    user ->> kube: 3. 调用 Kubectl 并<br>设置 --token 为 id_token<br>或者将令牌添加到 .kube/config
    deactivate user
    activate kube
    kube ->> api: 4. Authorization: Bearer...
    deactivate kube
    activate api
    api ->> api: 5. JWT 签名合法么？
    api ->> api: 6. JWT 是否已过期？(iat+exp)
    api ->> api: 7. 用户被授权了么？
    api -->> kube: 8. 已授权：执行<br>操作并返回结果
    deactivate api
    activate kube
    kube --x user: 9. 返回结果
    deactivate kube

</div>

<noscript>
    <style type="text/css">
    .mermaid { display:none; }
    </style>
    <h4>[JavaScript must be <a href="https://www.enable-javascript.com/">enabled</a> to view content]</h4>
</noscript>
<!--
1.  Login to your identity provider
2.  Your identity provider will provide you with an `access_token`, `id_token` and a `refresh_token`
3.  When using `kubectl`, use your `id_token` with the `-token` flag or add it directly to your `kubeconfig`
4.  `kubectl` sends your `id_token` in a header called Authorization to the API server
5.  The API server will make sure the JWT signature is valid by checking against the certificate named in the configuration
6.  Check to make sure the `id_token` hasn't expired
7.  Make sure the user is authorized
8.  Once authorized the API server returns a response to `kubectl`
9.  `kubectl` provides feedback to the user
-->
<ol>
<li>登录到你的身份服务（Identity Provider）</li>
<li>你的身份服务将为你提供 <code>access_token</code>、<code>id_token</code> 和 <code>refresh_token</code></li>
<li>在使用 <code>kubectl</code> 时，将 <code>id_token</code> 设置为 <code>--token</code> 标志值，或者将其直接添加到
<code>kubeconfig</code> 中</li>
<li><code>kubectl</code> 将你的 <code>id_token</code> 放到一个称作 <code>Authorization</code> 的头部，发送给 API 服务器</li>
<li>API 服务器将负责通过检查配置中引用的证书来确认 JWT 的签名是合法的</li>
<li>检查确认 <code>id_token</code> 尚未过期</li>
<li>确认用户有权限执行操作</li>
<li>鉴权成功之后，API 服务器向 <code>kubectl</code> 返回响应</li>
<li><code>kubectl</code> 向用户提供反馈信息</li>
</ol>
<!--
Since all of the data needed to validate who you are is in the `id_token`, Kubernetes doesn't need to
"phone home" to the identity provider.  In a model where every request is stateless this provides a very scalable
solution for authentication.  It does offer a few challenges:
-->
<p>由于用来验证你是谁的所有数据都在 <code>id_token</code> 中，Kubernetes 不需要再去联系
身份服务。在一个所有请求都是无状态请求的模型中，这一工作方式可以使得身份认证
的解决方案更容易处理大规模请求。不过，此访问也有一些挑战：</p>
<!--
1.  Kubernetes has no "web interface" to trigger the authentication process.  There is no browser or interface to collect credentials which is why you need to authenticate to your identity provider first.
2.  The `id_token` can't be revoked, it's like a certificate so it should be short-lived (only a few minutes) so it can be very annoying to have to get a new token every few minutes.
3.  There's no easy way to authenticate to the Kubernetes dashboard without using the `kubectl proxy` command or a reverse proxy that injects the `id_token`.
-->
<ol>
<li>Kubernetes 没有提供用来触发身份认证过程的 &quot;Web 界面&quot;。
因为不存在用来收集用户凭据的浏览器或用户接口，你必须自己先行完成
对身份服务的认证过程。</li>
<li><code>id_token</code> 令牌不可收回。因其属性类似于证书，其生命期一般很短（只有几分钟），
所以，每隔几分钟就要获得一个新的令牌这件事可能很让人头疼。</li>
<li>如果不使用 <code>kubectl proxy</code> 命令或者一个能够注入 <code>id_token</code> 的反向代理，
向 Kubernetes 控制面板执行身份认证是很困难的。</li>
</ol>
<!--
#### Configuring the API Server

To enable the plugin, configure the following flags on the API server:
-->
<h4 id="configuring-the-api-server">配置 API 服务器   </h4>
<p>要启用此插件，须在 API 服务器上配置以下标志：</p>
<!--
| Parameter | Description | Example | Required |
| --------- | ----------- | ------- | ------- |
| `--oidc-issuer-url` | URL of the provider which allows the API server to discover public signing keys. Only URLs which use the `https://` scheme are accepted.  This is typically the provider's discovery URL without a path, for example "https://accounts.google.com" or "https://login.salesforce.com".  This URL should point to the level below .well-known/openid-configuration | If the discovery URL is `https://accounts.google.com/.well-known/openid-configuration`, the value should be `https://accounts.google.com` | Yes |
| `--oidc-client-id` |  A client id that all tokens must be issued for. | kubernetes | Yes |
| `--oidc-username-claim` | JWT claim to use as the user name. By default `sub`, which is expected to be a unique identifier of the end user. Admins can choose other claims, such as `email` or `name`, depending on their provider. However, claims other than `email` will be prefixed with the issuer URL to prevent naming clashes with other plugins. | sub | No |
| `--oidc-username-prefix` | Prefix prepended to username claims to prevent clashes with existing names (such as `system:` users). For example, the value `oidc:` will create usernames like `oidc:jane.doe`. If this flag isn't provided and `--oidc-username-claim` is a value other than `email` the prefix defaults to `( Issuer URL )#` where `( Issuer URL )` is the value of `--oidc-issuer-url`. The value `-` can be used to disable all prefixing. | `oidc:` | No |
| `--oidc-groups-claim` | JWT claim to use as the user's group. If the claim is present it must be an array of strings. | groups | No |
| `--oidc-groups-prefix` | Prefix prepended to group claims to prevent clashes with existing names (such as `system:` groups). For example, the value `oidc:` will create group names like `oidc:engineering` and `oidc:infra`. | `oidc:` | No |
| `--oidc-required-claim` | A key=value pair that describes a required claim in the ID Token. If set, the claim is verified to be present in the ID Token with a matching value. Repeat this flag to specify multiple claims. | `claim=value` | No |
| `--oidc-ca-file` | The path to the certificate for the CA that signed your identity provider's web certificate.  Defaults to the host's root CAs. | `/etc/kubernetes/ssl/kc-ca.pem` | No |
-->
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
<th>示例</th>
<th>必需？</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>--oidc-issuer-url</code></td>
<td>允许 API 服务器发现公开的签名密钥的服务的 URL。只接受模式为 <code>https://</code> 的 URL。此值通常设置为服务的发现 URL，不含路径。例如：&quot;https://accounts.google.com&quot; 或 &quot;https://login.salesforce.com&quot;。此 URL 应指向 .well-known/openid-configuration 下一层的路径。</td>
<td>如果发现 URL 是 <code>https://accounts.google.com/.well-known/openid-configuration</code>，则此值应为 <code>https://accounts.google.com</code></td>
<td>是</td>
</tr>
<tr>
<td><code>--oidc-client-id</code></td>
<td>所有令牌都应发放给此客户 ID。</td>
<td>kubernetes</td>
<td>是</td>
</tr>
<tr>
<td><code>--oidc-username-claim</code></td>
<td>用作用户名的 JWT 申领（JWT Claim）。默认情况下使用 <code>sub</code> 值，即最终用户的一个唯一的标识符。管理员也可以选择其他申领，例如 <code>email</code> 或者 <code>name</code>，取决于所用的身份服务。不过，除了 <code>email</code> 之外的申领都会被添加令牌发放者的 URL 作为前缀，以免与其他插件产生命名冲突。</td>
<td>sub</td>
<td>否</td>
</tr>
<tr>
<td><code>--oidc-username-prefix</code></td>
<td>要添加到用户名申领之前的前缀，用来避免与现有用户名发生冲突（例如：<code>system:</code> 用户）。例如，此标志值为 <code>oidc:</code> 时将创建形如 <code>oidc:jane.doe</code> 的用户名。如果此标志未设置，且 <code>--oidc-username-claim</code> 标志值不是 <code>email</code>，则默认前缀为 <code>&lt;令牌发放者的 URL&gt;#</code>，其中 <code>&lt;令牌发放者 URL &gt;</code> 的值取自 <code>--oidc-issuer-url</code> 标志的设定。此标志值为 <code>-</code> 时，意味着禁止添加用户名前缀。</td>
<td><code>oidc:</code></td>
<td>否</td>
</tr>
<tr>
<td><code>--oidc-groups-claim</code></td>
<td>用作用户组名的 JWT 申领。如果所指定的申领确实存在，则其值必须是一个字符串数组。</td>
<td>groups</td>
<td>否</td>
</tr>
<tr>
<td><code>--oidc-groups-prefix</code></td>
<td>添加到组申领的前缀，用来避免与现有用户组名（如：<code>system:</code> 组）发生冲突。例如，此标志值为 <code>oidc:</code> 时，所得到的用户组名形如 <code>oidc:engineering</code> 和 <code>oidc:infra</code>。</td>
<td><code>oidc:</code></td>
<td>否</td>
</tr>
<tr>
<td><code>--oidc-required-claim</code></td>
<td>取值为一个 key=value 偶对，意为 ID 令牌中必须存在的申领。如果设置了此标志，则 ID 令牌会被检查以确定是否包含取值匹配的申领。此标志可多次重复，以指定多个申领。</td>
<td><code>claim=value</code></td>
<td>否</td>
</tr>
<tr>
<td><code>--oidc-ca-file</code></td>
<td>指向一个 CA 证书的路径，该 CA 负责对你的身份服务的 Web 证书提供签名。默认值为宿主系统的根 CA。</td>
<td><code>/etc/kubernetes/ssl/kc-ca.pem</code></td>
<td>否</td>
</tr>
</tbody>
</table>
<!--
Importantly, the API server is not an OAuth2 client, rather it can only be
configured to trust a single issuer. This allows the use of public providers,
such as Google, without trusting credentials issued to third parties. Admins who
wish to utilize multiple OAuth clients should explore providers which support the
`azp` (authorized party) claim, a mechanism for allowing one client to issue
tokens on behalf of another.
-->
<p>很重要的一点是，API 服务器并非一个 OAuth2 客户端，相反，它只能被配置为
信任某一个令牌发放者。这使得使用公共服务（如 Google）的用户可以不信任发放给
第三方的凭据。
如果管理员希望使用多个 OAuth 客户端，他们应该研究一下那些支持 <code>azp</code>
（Authorized Party，被授权方）申领的服务。
<code>azp</code> 是一种允许某客户端代替另一客户端发放令牌的机制。</p>
<!--
Kubernetes does not provide an OpenID Connect Identity Provider.
You can use an existing public OpenID Connect Identity Provider (such as Google, or
[others](https://connect2id.com/products/nimbus-oauth-openid-connect-sdk/openid-connect-providers)).
Or, you can run your own Identity Provider, such as CoreOS [dex](https://github.com/coreos/dex),
[Keycloak](https://github.com/keycloak/keycloak),
CloudFoundry [UAA](https://github.com/cloudfoundry/uaa), or
Tremolo Security's [OpenUnison](https://github.com/tremolosecurity/openunison).
-->
<p>Kubernetes 并未提供 OpenID Connect 的身份服务。
你可以使用现有的公共的 OpenID Connect 身份服务（例如 Google 或者
<a href="https://connect2id.com/products/nimbus-oauth-openid-connect-sdk/openid-connect-providers">其他服务</a>）。
或者，你也可以选择自己运行一个身份服务，例如
CoreOS <a href="https://github.com/coreos/dex">dex</a>、
<a href="https://github.com/keycloak/keycloak">Keycloak</a>、
CloudFoundry <a href="https://github.com/cloudfoundry/uaa">UAA</a> 或者
Tremolo Security 的
<a href="https://github.com/tremolosecurity/openunison">OpenUnison</a>。</p>
<!--
For an identity provider to work with Kubernetes it must:

1.  Support [OpenID connect discovery](https://openid.net/specs/openid-connect-discovery-1_0.html); not all do.
2.  Run in TLS with non-obsolete ciphers
3.  Have a CA signed certificate (even if the CA is not a commercial CA or is self signed)
-->
<p>要在 Kubernetes 环境中使用某身份服务，该服务必须：</p>
<ol>
<li>支持 <a href="https://openid.net/specs/openid-connect-discovery-1_0.html">OpenID connect 发现</a>；
但事实上并非所有服务都具备此能力</li>
<li>运行 TLS 协议且所使用的加密组件都未过时</li>
<li>拥有由 CA 签名的证书（即使 CA 不是商业 CA 或者是自签名的 CA 也可以）</li>
</ol>
<!--
A note about requirement #3 above, requiring a CA signed certificate.  If you deploy your own identity provider (as opposed to one of the cloud providers like Google or Microsoft) you MUST have your identity provider's web server certificate signed by a certificate with the `CA` flag set to `TRUE`, even if it is self signed.  This is due to GoLang's TLS client implementation being very strict to the standards around certificate validation.  If you don't have a CA handy, you can use [this script](https://github.com/dexidp/dex/blob/master/examples/k8s/gencert.sh) from the Dex team to create a simple CA and a signed certificate and key pair.
Or you can use [this similar script](https://raw.githubusercontent.com/TremoloSecurity/openunison-qs-kubernetes/master/src/main/bash/makessl.sh) that generates SHA256 certs with a longer life and larger key size.
-->
<p>关于上述第三条需求，即要求具备 CA 签名的证书，有一些额外的注意事项。
如果你部署了自己的身份服务，而不是使用云厂商（如 Google 或 Microsoft）所提供的服务，
你必须对身份服务的 Web 服务器证书进行签名，签名所用证书的 <code>CA</code> 标志要设置为
<code>TRUE</code>，即使用的是自签名证书。这是因为 GoLang 的 TLS 客户端实现对证书验证
标准方面有非常严格的要求。如果你手头没有现成的 CA 证书，可以使用 CoreOS
团队所开发的<a href="https://github.com/dexidp/dex/blob/master/examples/k8s/gencert.sh">这个脚本</a>
来创建一个简单的 CA 和被签了名的证书与密钥对。
或者你也可以使用
<a href="https://raw.githubusercontent.com/TremoloSecurity/openunison-qs-kubernetes/master/src/main/bash/makessl.sh">这个类似的脚本</a>，
生成一个合法期更长、密钥尺寸更大的 SHA256 证书。</p>
<!--
Setup instructions for specific systems:
-->
<p>特定系统的安装指令：</p>
<ul>
<li><a href="https://docs.cloudfoundry.org/concepts/architecture/uaa.html">UAA</a></li>
<li><a href="https://dexidp.io/docs/kubernetes/">Dex</a></li>
<li><a href="https://www.tremolosecurity.com/orchestra-k8s/">OpenUnison</a></li>
</ul>
<!--
#### Using kubectl

##### Option 1 - OIDC Authenticator

The first option is to use the kubectl `oidc` authenticator, which sets the `id_token` as a bearer token for all requests and refreshes the token once it expires. After you've logged into your provider, use kubectl to add your `id_token`, `refresh_token`, `client_id`, and `client_secret` to configure the plugin.

Providers that don't return an `id_token` as part of their refresh token response aren't supported by this plugin and should use "Option 2" below.
-->
<h4 id="using-kubectl">使用 kubectl  </h4>
<h5 id="选项一-oidc-身份认证组件">选项一 - OIDC 身份认证组件</h5>
<p>第一种方案是使用 kubectl 的 <code>oidc</code> 身份认证组件，该组件将 <code>id_token</code> 设置
为所有请求的持有者令牌，并且在令牌过期时自动刷新。在你登录到你的身份服务之后，
可以使用 kubectl 来添加你的 <code>id_token</code>、<code>refresh_token</code>、<code>client_id</code> 和
<code>client_secret</code>，以配置该插件。</p>
<p>如果服务在其刷新令牌响应中不包含 <code>id_token</code>，则此插件无法支持该服务。
这时你应该考虑下面的选项二。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">kubectl config set-credentials USER_NAME <span style="color:#b62;font-weight:bold">\
</span><span style="color:#b62;font-weight:bold"></span>   --auth-provider<span style="color:#666">=</span>oidc <span style="color:#b62;font-weight:bold">\
</span><span style="color:#b62;font-weight:bold"></span>   --auth-provider-arg<span style="color:#666">=</span>idp-issuer-url<span style="color:#666">=(</span> issuer url <span style="color:#666">)</span> <span style="color:#b62;font-weight:bold">\
</span><span style="color:#b62;font-weight:bold"></span>   --auth-provider-arg<span style="color:#666">=</span>client-id<span style="color:#666">=(</span> your client id <span style="color:#666">)</span> <span style="color:#b62;font-weight:bold">\
</span><span style="color:#b62;font-weight:bold"></span>   --auth-provider-arg<span style="color:#666">=</span>client-secret<span style="color:#666">=(</span> your client secret <span style="color:#666">)</span> <span style="color:#b62;font-weight:bold">\
</span><span style="color:#b62;font-weight:bold"></span>   --auth-provider-arg<span style="color:#666">=</span>refresh-token<span style="color:#666">=(</span> your refresh token <span style="color:#666">)</span> <span style="color:#b62;font-weight:bold">\
</span><span style="color:#b62;font-weight:bold"></span>   --auth-provider-arg<span style="color:#666">=</span>idp-certificate-authority<span style="color:#666">=(</span> path to your ca certificate <span style="color:#666">)</span> <span style="color:#b62;font-weight:bold">\
</span><span style="color:#b62;font-weight:bold"></span>   --auth-provider-arg<span style="color:#666">=</span>id-token<span style="color:#666">=(</span> your id_token <span style="color:#666">)</span>
</code></pre></div><!--
As an example, running the below command after authenticating to your identity provider:
-->
<p>作为示例，在完成对你的身份服务的身份认证之后，运行下面的命令：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">kubectl config set-credentials mmosley  <span style="color:#b62;font-weight:bold">\
</span><span style="color:#b62;font-weight:bold"></span>        --auth-provider<span style="color:#666">=</span>oidc  <span style="color:#b62;font-weight:bold">\
</span><span style="color:#b62;font-weight:bold"></span>        --auth-provider-arg<span style="color:#666">=</span>idp-issuer-url<span style="color:#666">=</span>https://oidcidp.tremolo.lan:8443/auth/idp/OidcIdP  <span style="color:#b62;font-weight:bold">\
</span><span style="color:#b62;font-weight:bold"></span>        --auth-provider-arg<span style="color:#666">=</span>client-id<span style="color:#666">=</span>kubernetes  <span style="color:#b62;font-weight:bold">\
</span><span style="color:#b62;font-weight:bold"></span>        --auth-provider-arg<span style="color:#666">=</span>client-secret<span style="color:#666">=</span>1db158f6-177d-4d9c-8a8b-d36869918ec5  <span style="color:#b62;font-weight:bold">\
</span><span style="color:#b62;font-weight:bold"></span>        --auth-provider-arg<span style="color:#666">=</span>refresh-token<span style="color:#666">=</span>q1bKLFOyUiosTfawzA93TzZIDzH2TNa2SMm0zEiPKTUwME6BkEo6Sql5yUWVBSWpKUGphaWpxSVAfekBOZbBhaEW+VlFUeVRGcluyVF5JT4+haZmPsluFoFu5XkpXk5BXqHega4GAXlF+ma+vmYpFcHe5eZR+slBFpZKtQA<span style="color:#666">=</span> <span style="color:#b62;font-weight:bold">\
</span><span style="color:#b62;font-weight:bold"></span>        --auth-provider-arg<span style="color:#666">=</span>idp-certificate-authority<span style="color:#666">=</span>/root/ca.pem <span style="color:#b62;font-weight:bold">\
</span><span style="color:#b62;font-weight:bold"></span>        --auth-provider-arg<span style="color:#666">=</span>id-token<span style="color:#666">=</span>eyJraWQiOiJDTj1vaWRjaWRwLnRyZW1vbG8ubGFuLCBPVT1EZW1vLCBPPVRybWVvbG8gU2VjdXJpdHksIEw9QXJsaW5ndG9uLCBTVD1WaXJnaW5pYSwgQz1VUy1DTj1rdWJlLWNhLTEyMDIxNDc5MjEwMzYwNzMyMTUyIiwiYWxnIjoiUlMyNTYifQ.eyJpc3MiOiJodHRwczovL29pZGNpZHAudHJlbW9sby5sYW46ODQ0My9hdXRoL2lkcC9PaWRjSWRQIiwiYXVkIjoia3ViZXJuZXRlcyIsImV4cCI6MTQ4MzU0OTUxMSwianRpIjoiMm96US15TXdFcHV4WDlHZUhQdy1hZyIsImlhdCI6MTQ4MzU0OTQ1MSwibmJmIjoxNDgzNTQ5MzMxLCJzdWIiOiI0YWViMzdiYS1iNjQ1LTQ4ZmQtYWIzMC0xYTAxZWU0MWUyMTgifQ.w6p4J_6qQ1HzTG9nrEOrubxIMb9K5hzcMPxc9IxPx2K4xO9l-oFiUw93daH3m5pluP6K7eOE6txBuRVfEcpJSwlelsOsW8gb8VJcnzMS9EnZpeA0tW_p-mnkFc3VcfyXuhe5R3G7aa5d8uHv70yJ9Y3-UhjiN9EhpMdfPAoEB9fYKKkJRzF7utTTIPGrSaSU6d2pcpfYKaxIwePzEkT4DfcQthoZdy9ucNvvLoi1DIC-UocFD8HLs8LYKEqSxQvOcvnThbObJ9af71EwmuE21fO5KzMW20KtAeget1gnldOosPtz1G5EwvaQ401-RPQzPGMVBld0_zMCAwZttJ4knw
</code></pre></div><!--
Which would produce the below configuration:
-->
<p>此操作会生成以下配置：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">users</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>mmosley<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">user</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">auth-provider</span>:<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">config</span>:<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#008000;font-weight:bold">client-id</span>:<span style="color:#bbb"> </span>kubernetes<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#008000;font-weight:bold">client-secret</span>:<span style="color:#bbb"> </span>1db158f6-177d-4d9c-8a8b-d36869918ec5<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#008000;font-weight:bold">id-token</span>:<span style="color:#bbb"> </span>eyJraWQiOiJDTj1vaWRjaWRwLnRyZW1vbG8ubGFuLCBPVT1EZW1vLCBPPVRybWVvbG8gU2VjdXJpdHksIEw9QXJsaW5ndG9uLCBTVD1WaXJnaW5pYSwgQz1VUy1DTj1rdWJlLWNhLTEyMDIxNDc5MjEwMzYwNzMyMTUyIiwiYWxnIjoiUlMyNTYifQ.eyJpc3MiOiJodHRwczovL29pZGNpZHAudHJlbW9sby5sYW46ODQ0My9hdXRoL2lkcC9PaWRjSWRQIiwiYXVkIjoia3ViZXJuZXRlcyIsImV4cCI6MTQ4MzU0OTUxMSwianRpIjoiMm96US15TXdFcHV4WDlHZUhQdy1hZyIsImlhdCI6MTQ4MzU0OTQ1MSwibmJmIjoxNDgzNTQ5MzMxLCJzdWIiOiI0YWViMzdiYS1iNjQ1LTQ4ZmQtYWIzMC0xYTAxZWU0MWUyMTgifQ.w6p4J_6qQ1HzTG9nrEOrubxIMb9K5hzcMPxc9IxPx2K4xO9l-oFiUw93daH3m5pluP6K7eOE6txBuRVfEcpJSwlelsOsW8gb8VJcnzMS9EnZpeA0tW_p-mnkFc3VcfyXuhe5R3G7aa5d8uHv70yJ9Y3-UhjiN9EhpMdfPAoEB9fYKKkJRzF7utTTIPGrSaSU6d2pcpfYKaxIwePzEkT4DfcQthoZdy9ucNvvLoi1DIC-UocFD8HLs8LYKEqSxQvOcvnThbObJ9af71EwmuE21fO5KzMW20KtAeget1gnldOosPtz1G5EwvaQ401-RPQzPGMVBld0_zMCAwZttJ4knw<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#008000;font-weight:bold">idp-certificate-authority</span>:<span style="color:#bbb"> </span>/root/ca.pem<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#008000;font-weight:bold">idp-issuer-url</span>:<span style="color:#bbb"> </span>https://oidcidp.tremolo.lan:8443/auth/idp/OidcIdP<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#008000;font-weight:bold">refresh-token</span>:<span style="color:#bbb"> </span>q1bKLFOyUiosTfawzA93TzZIDzH2TNa2SMm0zEiPKTUwME6BkEo6Sql5yUWVBSWpKUGphaWpxSVAfekBOZbBhaEW+VlFUeVRGcluyVF5JT4+haZmPsluFoFu5XkpXk5BXq<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>oidc<span style="color:#bbb">
</span></code></pre></div><!--
Once your `id_token` expires, `kubectl` will attempt to refresh your `id_token` using your `refresh_token` and `client_secret` storing the new values for the `refresh_token` and `id_token` in your `.kube/config`.
-->
<p>当你的 <code>id_token</code> 过期时，<code>kubectl</code> 会尝试使用你的 <code>refresh_token</code> 来刷新你的
<code>id_token</code>，并且在 <code>client_secret</code> 中存放 <code>refresh_token</code> 的新值，同时把
<code>id_token</code> 的新值写入到 <code>.kube/config</code> 文件中。</p>
<!--
##### Option 2 - Use the `--token` Option

The `kubectl` command lets you pass in a token using the `--token` option.  Simply copy and paste the `id_token` into this option:
-->
<h5 id="选项二-使用-token-选项">选项二 - 使用 <code>--token</code> 选项</h5>
<p><code>kubectl</code> 命令允许你使用 <code>--token</code> 选项传递一个令牌。
你可以将 <code>id_token</code> 的内容复制粘贴过来，作为此标志的取值：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">kubectl --token<span style="color:#666">=</span>eyJhbGciOiJSUzI1NiJ9.eyJpc3MiOiJodHRwczovL21sYi50cmVtb2xvLmxhbjo4MDQzL2F1dGgvaWRwL29pZGMiLCJhdWQiOiJrdWJlcm5ldGVzIiwiZXhwIjoxNDc0NTk2NjY5LCJqdGkiOiI2RDUzNXoxUEpFNjJOR3QxaWVyYm9RIiwiaWF0IjoxNDc0NTk2MzY5LCJuYmYiOjE0NzQ1OTYyNDksInN1YiI6Im13aW5kdSIsInVzZXJfcm9sZSI6WyJ1c2VycyIsIm5ldy1uYW1lc3BhY2Utdmlld2VyIl0sImVtYWlsIjoibXdpbmR1QG5vbW9yZWplZGkuY29tIn0.f2As579n9VNoaKzoF-dOQGmXkFKf1FMyNV0-va_B63jn-_n9LGSCca_6IVMP8pO-Zb4KvRqGyTP0r3HkHxYy5c81AnIh8ijarruczl-TK_yF5akjSTHFZD-0gRzlevBDiH8Q79NAr-ky0P4iIXS8lY9Vnjch5MF74Zx0c3alKJHJUnnpjIACByfF2SCaYzbWFMUNat-K1PaUk5-ujMBG7yYnr95xD-63n8CO8teGUAAEMx6zRjzfhnhbzX-ajwZLGwGUBT4WqjMs70-6a7_8gZmLZb2az1cZynkFRj2BaCkVT3A2RrjeEwZEtGXlMqKJ1_I2ulrOVsYx01_yD35-rw get nodes
</code></pre></div><!--
### Webhook Token Authentication

Webhook authentication is a hook for verifying bearer tokens.

* `--authentication-token-webhook-config-file` a configuration file describing how to access the remote webhook service.
* `--authentication-token-webhook-cache-ttl` how long to cache authentication decisions. Defaults to two minutes.
-->
<h3 id="webhook-token-authentication">Webhook 令牌身份认证  </h3>
<p>Webhook 身份认证是一种用来验证持有者令牌的回调机制。</p>
<ul>
<li><code>--authentication-token-webhook-config-file</code> 指向一个配置文件，其中描述
如何访问远程的 Webhook 服务。</li>
<li><code>--authentication-token-webhook-cache-ttl</code> 用来设定身份认证决定的缓存时间。
默认时长为 2 分钟。</li>
</ul>
<!--
The configuration file uses the [kubeconfig](/docs/concepts/configuration/organize-cluster-access-kubeconfig/)
file format. Within the file, `clusters` refers to the remote service and
`users` refers to the API server webhook. An example would be:
-->
<p>配置文件使用 <a href="/zh/docs/concepts/configuration/organize-cluster-access-kubeconfig/">kubeconfig</a>
文件的格式。文件中，<code>clusters</code> 指代远程服务，<code>users</code> 指代远程 API 服务
Webhook。下面是一个例子：</p>
<!--
```yaml
# Kubernetes API version
apiVersion: v1
# kind of the API object
kind: Config
# clusters refers to the remote service.
clusters:
  - name: name-of-remote-authn-service
    cluster:
      certificate-authority: /path/to/ca.pem         # CA for verifying the remote service.
      server: https://authn.example.com/authenticate # URL of remote service to query. Must use 'https'.

# users refers to the API server's webhook configuration.
users:
  - name: name-of-api-server
    user:
      client-certificate: /path/to/cert.pem # cert for the webhook plugin to use
      client-key: /path/to/key.pem          # key matching the cert

# kubeconfig files require a context. Provide one for the API server.
current-context: webhook
contexts:
- context:
    cluster: name-of-remote-authn-service
    user: name-of-api-sever
  name: webhook
```
-->
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#080;font-style:italic"># Kubernetes API 版本</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#080;font-style:italic"># API 对象类别</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>Config<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#080;font-style:italic"># clusters 指代远程服务</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">clusters</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>name-of-remote-authn-service<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">cluster</span>:<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">certificate-authority</span>:<span style="color:#bbb"> </span>/path/to/ca.pem        <span style="color:#bbb"> </span><span style="color:#080;font-style:italic"># 用来验证远程服务的 CA</span><span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">server</span>:<span style="color:#bbb"> </span>https://authn.example.com/authenticate<span style="color:#bbb"> </span><span style="color:#080;font-style:italic"># 要查询的远程服务 URL。必须使用 &#39;https&#39;。</span><span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#080;font-style:italic"># users 指代 API 服务的 Webhook 配置</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">users</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>name-of-api-server<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">user</span>:<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">client-certificate</span>:<span style="color:#bbb"> </span>/path/to/cert.pem<span style="color:#bbb"> </span><span style="color:#080;font-style:italic"># Webhook 插件要使用的证书</span><span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">client-key</span>:<span style="color:#bbb"> </span>/path/to/key.pem         <span style="color:#bbb"> </span><span style="color:#080;font-style:italic"># 与证书匹配的密钥</span><span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#080;font-style:italic"># kubeconfig 文件需要一个上下文（Context），此上下文用于本 API 服务器</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">current-context</span>:<span style="color:#bbb"> </span>webhook<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">contexts</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">context</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">cluster</span>:<span style="color:#bbb"> </span>name-of-remote-authn-service<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">user</span>:<span style="color:#bbb"> </span>name-of-api-sever<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>webhook<span style="color:#bbb">
</span></code></pre></div><!--
When a client attempts to authenticate with the API server using a bearer token
as discussed [above](#putting-a-bearer-token-in-a-request),
the authentication webhook POSTs a JSON-serialized `authentication.k8s.io/v1beta1` `TokenReview` object containing the token
to the remote service. Kubernetes will not challenge a request that lacks such a header.
-->
<p>当客户端尝试在 API 服务器上使用持有者令牌完成身份认证（
如<a href="#putting-a-bearer-token-in-a-request">前</a>所述）时，
身份认证 Webhook 会用 POST 请求发送一个 JSON 序列化的对象到远程服务。
该对象是 <code>authentication.k8s.io/v1beta1</code> 组的 <code>TokenReview</code> 对象，
其中包含持有者令牌。
Kubernetes 不会强制请求提供此 HTTP 头部。</p>
<!--
Note that webhook API objects are subject to the same [versioning compatibility rules](/docs/concepts/overview/kubernetes-api/)
as other Kubernetes API objects. Implementers should be aware of looser
compatibility promises for beta objects and check the "apiVersion" field of the
request to ensure correct deserialization. Additionally, the API server must
enable the `authentication.k8s.io/v1beta1` API extensions group (`--runtime-config=authentication.k8s.io/v1beta1=true`).

The POST body will be of the following format:
-->
<p>要注意的是，Webhook API 对象和其他 Kubernetes API 对象一样，也要受到同一
<a href="/zh/docs/concepts/overview/kubernetes-api/">版本兼容规则</a>约束。
实现者要了解对 Beta 阶段对象的兼容性承诺，并检查请求的 <code>apiVersion</code> 字段，
以确保数据结构能够正常反序列化解析。此外，API 服务器必须启用
<code>authentication.k8s.io/v1beta1</code> API 扩展组
（<code>--runtime-config=authentication.k8s.io/v1beta1=true</code>）。</p>
<p>POST 请求的 Body 部分将是如下格式：</p>
<!--
```json
{
  "apiVersion": "authentication.k8s.io/v1beta1",
  "kind": "TokenReview",
  "spec": {
    "token": "(BEARERTOKEN)"
  }
}
```
-->
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-json" data-lang="json">{
  <span style="color:#008000;font-weight:bold">&#34;apiVersion&#34;</span>: <span style="color:#b44">&#34;authentication.k8s.io/v1beta1&#34;</span>,
  <span style="color:#008000;font-weight:bold">&#34;kind&#34;</span>: <span style="color:#b44">&#34;TokenReview&#34;</span>,
  <span style="color:#008000;font-weight:bold">&#34;spec&#34;</span>: {
    <span style="color:#008000;font-weight:bold">&#34;token&#34;</span>: <span style="color:#b44">&#34;&lt;持有者令牌&gt;&#34;</span>
  }
}
</code></pre></div><!--
The remote service is expected to fill the `status` field of
the request to indicate the success of the login. The response body's `spec`
field is ignored and may be omitted. A successful validation of the bearer
token would return:
-->
<p>远程服务应该会填充请求的 <code>status</code> 字段，以标明登录操作是否成功。
响应的 Body 中的 <code>spec</code> 字段会被忽略，因此可以省略。
如果持有者令牌验证成功，应该返回如下所示的响应：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-json" data-lang="json">{
  <span style="color:#008000;font-weight:bold">&#34;apiVersion&#34;</span>: <span style="color:#b44">&#34;authentication.k8s.io/v1beta1&#34;</span>,
  <span style="color:#008000;font-weight:bold">&#34;kind&#34;</span>: <span style="color:#b44">&#34;TokenReview&#34;</span>,
  <span style="color:#008000;font-weight:bold">&#34;status&#34;</span>: {
    <span style="color:#008000;font-weight:bold">&#34;authenticated&#34;</span>: <span style="color:#a2f;font-weight:bold">true</span>,
    <span style="color:#008000;font-weight:bold">&#34;user&#34;</span>: {
      <span style="color:#008000;font-weight:bold">&#34;username&#34;</span>: <span style="color:#b44">&#34;janedoe@example.com&#34;</span>,
      <span style="color:#008000;font-weight:bold">&#34;uid&#34;</span>: <span style="color:#b44">&#34;42&#34;</span>,
      <span style="color:#008000;font-weight:bold">&#34;groups&#34;</span>: [
        <span style="color:#b44">&#34;developers&#34;</span>,
        <span style="color:#b44">&#34;qa&#34;</span>
      ],
      <span style="color:#008000;font-weight:bold">&#34;extra&#34;</span>: {
        <span style="color:#008000;font-weight:bold">&#34;extrafield1&#34;</span>: [
          <span style="color:#b44">&#34;extravalue1&#34;</span>,
          <span style="color:#b44">&#34;extravalue2&#34;</span>
        ]
      }
    }
  }
}
</code></pre></div><!--
An unsuccessful request would return:
-->
<p>而不成功的请求会返回：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-json" data-lang="json">{
  <span style="color:#008000;font-weight:bold">&#34;apiVersion&#34;</span>: <span style="color:#b44">&#34;authentication.k8s.io/v1beta1&#34;</span>,
  <span style="color:#008000;font-weight:bold">&#34;kind&#34;</span>: <span style="color:#b44">&#34;TokenReview&#34;</span>,
  <span style="color:#008000;font-weight:bold">&#34;status&#34;</span>: {
    <span style="color:#008000;font-weight:bold">&#34;authenticated&#34;</span>: <span style="color:#a2f;font-weight:bold">false</span>
  }
}
</code></pre></div><!--
HTTP status codes can be used to supply additional error context.
-->
<p>HTTP 状态码可用来提供进一步的错误语境信息。</p>
<!--
### Authenticating Proxy

The API server can be configured to identify users from request header values, such as `X-Remote-User`.
It is designed for use in combination with an authenticating proxy, which sets the request header value.
-->
<h3 id="authenticating-proxy">身份认证代理  </h3>
<p>API 服务器可以配置成从请求的头部字段值（如 <code>X-Remote-User</code>）中辩识用户。
这一设计是用来与某身份认证代理一起使用 API 服务器，代理负责设置请求的头部字段值。</p>
<!--
* `--requestheader-username-headers` Required, case-insensitive. Header names to check, in order, for the user identity. The first header containing a value is used as the username.
* `--requestheader-group-headers` 1.6+. Optional, case-insensitive. "X-Remote-Group" is suggested. Header names to check, in order, for the user's groups. All values in all specified headers are used as group names.
* `-requestheader-extra-headers-prefix` 1.6+. Optional, case-insensitive. "X-Remote-Extra-" is suggested. Header prefixes to look for to determine extra information about the user (typically used by the configured authorization plugin). Any headers beginning with any of the specified prefixes have the prefix removed. The remainder of the header name is lowercased and [percent-decoded](https://tools.ietf.org/html/rfc3986#section-2.1) and becomes the extra key, and the header value is the extra value.
-->
<ul>
<li><code>--requestheader-username-headers</code> 必需字段，大小写不敏感。用来设置要获得用户身份所要检查的头部字段名称列表（有序）。第一个包含数值的字段会被用来提取用户名。</li>
<li><code>--requestheader-group-headers</code> 可选字段，在 Kubernetes 1.6 版本以后支持，大小写不敏感。
建议设置为 &quot;X-Remote-Group&quot;。用来指定一组头部字段名称列表，以供检查用户所属的组名称。
所找到的全部头部字段的取值都会被用作用户组名。</li>
<li><code>--requestheader-extra-headers-prefix</code> 可选字段，在 Kubernetes 1.6 版本以后支持，大小写不敏感。
建议设置为 &quot;X-Remote-Extra-&quot;。用来设置一个头部字段的前缀字符串，API 服务器会基于所给
前缀来查找与用户有关的一些额外信息。这些额外信息通常用于所配置的鉴权插件。
API 服务器会将与所给前缀匹配的头部字段过滤出来，去掉其前缀部分，将剩余部分
转换为小写字符串并在必要时执行<a href="https://tools.ietf.org/html/rfc3986#section-2.1">百分号解码</a>
后，构造新的附加信息字段键名。原来的头部字段值直接作为附加信息字段的值。</li>
</ul>
<!--
Prior to 1.11.3 (and 1.10.7, 1.9.11), the extra key could only contain characters which were [legal in HTTP header labels](https://tools.ietf.org/html/rfc7230#section-3.2.6).
For example, with this configuration:
-->
<blockquote class="note callout">
  <div><strong>说明：</strong> 在 1.13.3 版本之前（包括 1.10.7、1.9.11），附加字段的键名只能包含
<a href="https://tools.ietf.org/html/rfc7230#section-3.2.6">HTTP 头部标签的合法字符</a>。</div>
</blockquote>
<p>例如，使用下面的配置：</p>
<pre tabindex="0"><code>--requestheader-username-headers=X-Remote-User
--requestheader-group-headers=X-Remote-Group
--requestheader-extra-headers-prefix=X-Remote-Extra-
</code></pre><!--
this request:
-->
<p>针对所收到的如下请求：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-http" data-lang="http"><span style="color:#00a000">GET</span> <span style="color:#00f;font-weight:bold">/</span> <span style="color:#a2f;font-weight:bold">HTTP</span><span style="color:#666">/</span><span style="color:#666">1.1</span>
X-Remote-User<span style="color:#666">:</span> fido
X-Remote-Group<span style="color:#666">:</span> dogs
X-Remote-Group<span style="color:#666">:</span> dachshunds
X-Remote-Extra-Acme.com%2Fproject<span style="color:#666">:</span> some-project
X-Remote-Extra-Scopes<span style="color:#666">:</span> openid
X-Remote-Extra-Scopes<span style="color:#666">:</span> profile
</code></pre></div><!--
would result in this user info:
-->
<p>会生成下面的用户信息：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>fido<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">groups</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- dogs<span style="color:#bbb">
</span><span style="color:#bbb"></span>- dachshunds<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">extra</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">acme.com/project</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- some-project<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">scopes</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- openid<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- profile<span style="color:#bbb">
</span></code></pre></div><!--
In order to prevent header spoofing, the authenticating proxy is required to present a valid client
certificate to the API server for validation against the specified CA before the request headers are
checked. WARNING: do **not** reuse a CA that is used in a different context unless you understand
the risks and the mechanisms to protect the CA's usage.

* `--requestheader-client-ca-file` Required. PEM-encoded certificate bundle. A valid client certificate must be presented and validated against the certificate authorities in the specified file before the request headers are checked for user names.
* `--requestheader-allowed-names` Optional. List of Common Name values (CNs). If set, a valid client certificate with a CN in the specified list must be presented before the request headers are checked for user names. If empty, any CN is allowed.
-->
<p>为了防范头部信息侦听，在请求中的头部字段被检视之前，
身份认证代理需要向 API 服务器提供一份合法的客户端证书，
供后者使用所给的 CA 来执行验证。
警告：<em>不要</em> 在不同的上下文中复用 CA 证书，除非你清楚这样做的风险是什么以及
应如何保护 CA 用法的机制。</p>
<ul>
<li><code>--requestheader-client-ca-file</code> 必需字段，给出 PEM 编码的证书包。
在检查请求的头部字段以提取用户名信息之前，必须提供一个合法的客户端证书，
且该证书要能够被所给文件中的机构所验证。</li>
<li><code>--requestheader-allowed-names</code> 可选字段，用来给出一组公共名称（CN）。
如果此标志被设置，则在检视请求中的头部以提取用户信息之前，必须提供
包含此列表中所给的 CN 名的、合法的客户端证书。</li>
</ul>
<!--
## Anonymous requests

When enabled, requests that are not rejected by other configured authentication methods are
treated as anonymous requests, and given a username of `system:anonymous` and a group of
`system:unauthenticated`.
-->
<h2 id="anonymous-requests">匿名请求  </h2>
<p>启用匿名请求支持之后，如果请求没有被已配置的其他身份认证方法拒绝，则被视作
匿名请求（Anonymous Requests）。这类请求获得用户名 <code>system:anonymous</code> 和
对应的用户组 <code>system:unauthenticated</code>。</p>
<!--
For example, on a server with token authentication configured, and anonymous access enabled,
a request providing an invalid bearer token would receive a `401 Unauthorized` error.
A request providing no bearer token would be treated as an anonymous request.

In 1.5.1-1.5.x, anonymous access is disabled by default, and can be enabled by
passing the `--anonymous-auth=true` option to the API server.
-->
<p>例如，在一个配置了令牌身份认证且启用了匿名访问的服务器上，如果请求提供了非法的
持有者令牌，则会返回 <code>401 Unauthorized</code> 错误。
如果请求没有提供持有者令牌，则被视为匿名请求。</p>
<p>在 1.5.1-1.5.x 版本中，匿名访问默认情况下是被禁用的，可以通过为 API 服务器设定
<code>--anonymous-auth=true</code> 来启用。</p>
<!--
In 1.6+, anonymous access is enabled by default if an authorization mode other than `AlwaysAllow`
is used, and can be disabled by passing the `-anonymous-auth=false` option to the API server.
Starting in 1.6, the ABAC and RBAC authorizers require explicit authorization of the
`system:anonymous` user or the `system:unauthenticated` group, so legacy policy rules
that grant access to the `*` user or `*` group do not include anonymous users.
-->
<p>在 1.6 及之后版本中，如果所使用的鉴权模式不是 <code>AlwaysAllow</code>，则匿名访问默认是被启用的。
从 1.6 版本开始，ABAC 和 RBAC 鉴权模块要求对 <code>system:anonymous</code> 用户或者
<code>system:unauthenticated</code> 用户组执行显式的权限判定，所以之前的为 <code>*</code> 用户或
<code>*</code> 用户组赋予访问权限的策略规则都不再包含匿名用户。</p>
<!--
## User impersonation

A user can act as another user through impersonation headers. These let requests
manually override the user info a request authenticates as. For example, an admin
could use this feature to debug an authorization policy by temporarily
impersonating another user and seeing if a request was denied.
-->
<h2 id="user-impersonation">用户伪装 </h2>
<p>一个用户可以通过伪装（Impersonation）头部字段来以另一个用户的身份执行操作。
使用这一能力，你可以手动重载请求被身份认证所识别出来的用户信息。
例如，管理员可以使用这一功能特性来临时伪装成另一个用户，查看请求是否被拒绝，
从而调试鉴权策略中的问题，</p>
<!--
Impersonation requests first authenticate as the requesting user, then switch
to the impersonated user info.

* A user makes an API call with their credentials _and_ impersonation headers.
* API server authenticates the user.
* API server ensures the authenticated users have impersonation privileges.
* Request user info is replaced with impersonation values.
* Request is evaluated, authorization acts on impersonated user info.
-->
<p>带伪装的请求首先会被身份认证识别为发出请求的用户，之后会切换到使用被伪装的用户
的用户信息。</p>
<ul>
<li>用户发起 API 调用时 <em>同时</em> 提供自身的凭据和伪装头部字段信息</li>
<li>API 服务器对用户执行身份认证</li>
<li>API 服务器确认通过认证的用户具有伪装特权</li>
<li>请求用户的信息被替换成伪装字段的值</li>
<li>评估请求，鉴权组件针对所伪装的用户信息执行操作</li>
</ul>
<!--
The following HTTP headers can be used to performing an impersonation request:

* `Impersonate-User`: The username to act as.
* `Impersonate-Group`: A group name to act as. Can be provided multiple times to set multiple groups. Optional. Requires "Impersonate-User"
* `Impersonate-Extra-( extra name )`: A dynamic header used to associate extra fields with the user. Optional. Requires "Impersonate-User". In order to be preserved consistently, `( extra name )` should be lower-case, and any characters which aren't [legal in HTTP header labels](https://tools.ietf.org/html/rfc7230#section-3.2.6) MUST be utf8 and [percent-encoded](https://tools.ietf.org/html/rfc3986#section-2.1).
-->
<p>以下 HTTP 头部字段可用来执行伪装请求：</p>
<ul>
<li><code>Impersonate-User</code>：要伪装成的用户名</li>
<li><code>Impersonate-Group</code>：要伪装成的用户组名。可以多次指定以设置多个用户组。
可选字段；要求 &quot;Impersonate-User&quot; 必须被设置。</li>
<li><code>Impersonate-Extra-&lt;附加名称&gt;</code>：一个动态的头部字段，用来设置与用户相关的附加字段。
此字段可选；要求 &quot;Impersonate-User&quot; 被设置。为了能够以一致的形式保留，
<code>&lt;附加名称&gt;</code>部分必须是小写字符，如果有任何字符不是
<a href="https://tools.ietf.org/html/rfc7230#section-3.2.6">合法的 HTTP 头部标签字符</a>，
则必须是 utf8 字符，且转换为<a href="https://tools.ietf.org/html/rfc3986#section-2.1">百分号编码</a>。</li>
</ul>
<!--
Prior to 1.11.3 (and 1.10.7, 1.9.11), `( extra name )` could only contain characters which were [legal in HTTP header labels](https://tools.ietf.org/html/rfc7230#section-3.2.6).
-->
<blockquote class="note callout">
  <div><strong>说明：</strong> 在 1.11.3 版本之前（以及 1.10.7、1.9.11），<code>&lt;附加名称&gt;</code> 只能包含
合法的 HTTP 标签字符。</div>
</blockquote>
<!--
An example set of headers:
-->
<p>头部字段集合的示例：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-http" data-lang="http"><span style="">Impersonate-User: jane.doe@example.com
</span><span style="">Impersonate-Group: developers
</span><span style="">Impersonate-Group: admins
</span><span style="">Impersonate-Extra-dn: cn=jane,ou=engineers,dc=example,dc=com
</span><span style="">Impersonate-Extra-acme.com%2Fproject: some-project
</span><span style="">Impersonate-Extra-scopes: view
</span><span style="">Impersonate-Extra-scopes: development
</span></code></pre></div><!--
When using `kubectl` set the `--as` flag to configure the `Impersonate-User`
header, set the `--as-group` flag to configure the `Impersonate-Group` header.
-->
<p>在使用 <code>kubectl</code> 时，可以使用 <code>--as</code> 标志来配置 <code>Impersonate-User</code> 头部字段值，
使用 <code>--as-group</code> 标志配置 <code>Impersonate-Group</code> 头部字段值。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">kubectl drain mynode
</code></pre></div><pre tabindex="0"><code class="language-none" data-lang="none">Error from server (Forbidden): User &quot;clark&quot; cannot get nodes at the cluster scope. (get nodes mynode)
</code></pre><!--
Set the `--as` and `--as-group` flag:
-->
<p>设置 <code>--as</code> 和 <code>--as-group</code> 标志：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">kubectl drain mynode --as<span style="color:#666">=</span>superman --as-group<span style="color:#666">=</span>system:masters
</code></pre></div><pre tabindex="0"><code class="language-none" data-lang="none">node/mynode cordoned
node/mynode drained
</code></pre><!--
To impersonate a user, group, or set extra fields, the impersonating user must
have the ability to perform the "impersonate" verb on the kind of attribute
being impersonated ("user", "group", etc.). For clusters that enable the RBAC
authorization plugin, the following ClusterRole encompasses the rules needed to
set user and group impersonation headers:
-->
<p>要伪装成某个用户、某个组或者设置附加字段，执行伪装操作的用户必须具有对所伪装的
类别（“user”、“group” 等）执行 “impersonate” 动词操作的能力。
对于启用了 RBAC 鉴权插件的集群，下面的 ClusterRole 封装了设置用户和组伪装字段
所需的规则：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>rbac.authorization.k8s.io/v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>ClusterRole<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>impersonator<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">rules</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">apiGroups</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">resources</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;users&#34;</span>,<span style="color:#bbb"> </span><span style="color:#b44">&#34;groups&#34;</span>,<span style="color:#bbb"> </span><span style="color:#b44">&#34;serviceaccounts&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">verbs</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;impersonate&#34;</span>]<span style="color:#bbb">
</span></code></pre></div><!--
Extra fields are evaluated as sub-resources of the resource "userextras". To
allow a user to use impersonation headers for the extra field "scopes", a user
should be granted the following role:
-->
<p>附加字段会被作为 <code>userextras</code> 资源的子资源来执行权限评估。
如果要允许用户为附加字段 “scopes” 设置伪装头部，该用户需要被授予以下规则：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>rbac.authorization.k8s.io/v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>ClusterRole<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>scopes-impersonator<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">rules</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#080;font-style:italic"># 可以设置 &#34;Impersonate-Extra-scopes&#34; 头部</span><span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">apiGroups</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;authentication.k8s.io&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">resources</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;userextras/scopes&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">verbs</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;impersonate&#34;</span>]<span style="color:#bbb">
</span></code></pre></div><!--
The values of impersonation headers can also be restricted by limiting the set
of `resourceNames` a resource can take.
-->
<p>你也可以通过约束资源可能对应的 <code>resourceNames</code> 限制伪装头部的取值：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>rbac.authorization.k8s.io/v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>ClusterRole<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>limited-impersonator<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">rules</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#080;font-style:italic"># 可以伪装成用户 &#34;jane.doe@example.com&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">apiGroups</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">resources</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;users&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">verbs</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;impersonate&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">resourceNames</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;jane.doe@example.com&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#080;font-style:italic"># 可以伪装成用户组 &#34;developers&#34; 和 &#34;admins&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">apiGroups</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">resources</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;groups&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">verbs</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;impersonate&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">resourceNames</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;developers&#34;</span>,<span style="color:#b44">&#34;admins&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#080;font-style:italic"># 可以将附加字段 &#34;scopes&#34; 伪装成 &#34;view&#34; 和 &#34;development&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">apiGroups</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;authentication.k8s.io&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">resources</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;userextras/scopes&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">verbs</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;impersonate&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">resourceNames</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;view&#34;</span>,<span style="color:#bbb"> </span><span style="color:#b44">&#34;development&#34;</span>]<span style="color:#bbb">
</span></code></pre></div><!--
## client-go credential plugins
-->
<h2 id="client-go-credential-plugins">client-go 凭据插件 </h2>





<div style="margin-top: 10px; margin-bottom: 10px;">
<b>FEATURE STATE:</b> <code>Kubernetes v1.11 [beta]</code>
</div>

<!--
`k8s.io/client-go` and tools using it such as `kubectl` and `kubelet` are able to execute an
external command to receive user credentials.

This feature is intended for client side integrations with authentication protocols not natively
supported by `k8s.io/client-go` (LDAP, Kerberos, OAuth2, SAML, etc.). The plugin implements the
protocol specific logic, then returns opaque credentials to use. Almost all credential plugin
use cases require a server side component with support for the [webhook token authenticator](#webhook-token-authentication)
to interpret the credential format produced by the client plugin.
-->
<p><code>k8s.io/client-go</code> 及使用它的工具（如 <code>kubectl</code> 和 <code>kubelet</code>）可以执行某个外部
命令来获得用户的凭据信息。</p>
<p>这一特性的目的是便于客户端与 <code>k8s.io/client-go</code> 并不支持的身份认证协议（LDAP、
Kerberos、OAuth2、SAML 等）继承。
插件实现特定于协议的逻辑，之后返回不透明的凭据以供使用。
几乎所有的凭据插件使用场景中都需要在服务器端存在一个支持
<a href="#webhook-token-authentication">Webhook 令牌身份认证组件</a>的模块，
负责解析客户端插件所生成的凭据格式。</p>
<!--
### Example use case

In a hypothetical use case, an organization would run an external service that exchanges LDAP credentials
for user specific, signed tokens. The service would also be capable of responding to [webhook token
authenticator](#webhook-token-authentication) requests to validate the tokens. Users would be required
to install a credential plugin on their workstation.
-->
<h3 id="example-use-case">示例应用场景  </h3>
<p>在一个假想的应用场景中，某组织运行这一个外部的服务，能够将特定用户的已签名的
令牌转换成 LDAP 凭据。此服务还能够对
<a href="#webhook-token-authentication">Webhook 令牌身份认证组件</a>的请求做出响应以
验证所提供的令牌。用户需要在自己的工作站上安装一个凭据插件。</p>
<!--
To authenticate against the API:

* The user issues a `kubectl` command.
* Credential plugin prompts the user for LDAP credentials, exchanges credentials with external service for a token.
* Credential plugin returns token to client-go, which uses it as a bearer token against the API server.
* API server uses the [webhook token authenticator](#webhook-token-authentication) to submit a `TokenReview` to the external service.
* External service verifies the signature on the token and returns the user's username and groups.
-->
<p>要对 API 服务器认证身份时：</p>
<ul>
<li>用户发出 <code>kubectl</code> 命令。</li>
<li>凭据插件提示用户输入 LDAP 凭据，并与外部服务交互，获得令牌。</li>
<li>凭据插件将令牌返回该 client-go，后者将其用作持有者令牌提交给 API 服务器。</li>
<li>API 服务器使用<a href="#webhook-token-authentication">Webhook 令牌身份认证组件</a>向
外部服务发出 <code>TokenReview</code> 请求。</li>
<li>外部服务检查令牌上的签名，返回用户的用户名和用户组信息。</li>
</ul>
<!--
### Configuration

Credential plugins are configured through [kubectl config files](/docs/tasks/access-application-cluster/configure-access-multiple-clusters/)
as part of the user fields.
-->
<h3 id="configuration">配置 </h3>
<p>凭据插件通过 <a href="/zh/docs/tasks/access-application-cluster/configure-access-multiple-clusters/">kubectl 配置文件</a>
来作为 user 字段的一部分设置。</p>
<!--
```yaml
apiVersion: v1
kind: Config
users:
- name: my-user
  user:
    exec:
      # Command to execute. Required.
      command: "example-client-go-exec-plugin"

      # API version to use when decoding the ExecCredentials resource. Required.
      #
      # The API version returned by the plugin MUST match the version listed here.
      #
      # To integrate with tools that support multiple versions (such as client.authentication.k8s.io/v1alpha1),
      # set an environment variable or pass an argument to the tool that indicates which version the exec plugin expects.
      apiVersion: "client.authentication.k8s.io/v1beta1"

      # Environment variables to set when executing the plugin. Optional.
      env:
      - name: "FOO"
        value: "bar"

      # Arguments to pass when executing the plugin. Optional.
      args:
      - "arg1"
      - "arg2"

      # Text shown to the user when the executable doesn't seem to be present. Optional.
      installHint: |
        example-client-go-exec-plugin is required to authenticate
        to the current cluster.  It can be installed:

        On macOS: brew install example-client-go-exec-plugin

        On Ubuntu: apt-get install example-client-go-exec-plugin

        On Fedora: dnf install example-client-go-exec-plugin

        ...

      # Whether or not to provide cluster information, which could potentially contain
      # very large CA data, to this exec plugin as a part of the KUBERNETES_EXEC_INFO
      # environment variable.
      provideClusterInfo: true
clusters:
- name: my-cluster
  cluster:
    server: "https://172.17.4.100:6443"
    certificate-authority: "/etc/kubernetes/ca.pem"
    extensions:
    - name: client.authentication.k8s.io/exec # reserved extension name for per cluster exec config
      extension:
        arbitrary: config
        this: can be provided via the KUBERNETES_EXEC_INFO environment variable upon setting provideClusterInfo
        you: ["can", "put", "anything", "here"]
contexts:
- name: my-cluster
  context:
    cluster: my-cluster
    user: my-user
current-context: my-cluster
```
-->
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>Config<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">users</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>my-user<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">user</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">exec</span>:<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#080;font-style:italic"># 要执行的命令。必需。</span><span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">command</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;example-client-go-exec-plugin&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#080;font-style:italic"># 解析 ExecCredentials 资源时使用的 API 版本。必需。</span><span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#080;font-style:italic">#</span><span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#080;font-style:italic"># 插件返回的 API 版本必需与这里列出的版本匹配。</span><span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#080;font-style:italic">#</span><span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#080;font-style:italic"># 要与支持多个版本的工具（如 client.authentication.k8sio/v1alpha1）集成，</span><span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#080;font-style:italic"># 可以设置一个环境变量或者向工具传递一个参数标明 exec 插件所期望的版本。</span><span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;client.authentication.k8s.io/v1beta1&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#080;font-style:italic"># 执行此插件时要设置的环境变量。可选字段。</span><span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">env</span>:<span style="color:#bbb">
</span><span style="color:#bbb">      </span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;FOO&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#008000;font-weight:bold">value</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;bar&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#080;font-style:italic"># 执行插件时要传递的参数。可选字段。</span><span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">args</span>:<span style="color:#bbb">
</span><span style="color:#bbb">      </span>- <span style="color:#b44">&#34;arg1&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">      </span>- <span style="color:#b44">&#34;arg2&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#080;font-style:italic"># 当可执行文件不存在时显示给用户的文本。可选的。</span><span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">installHint</span>:<span style="color:#bbb"> </span>|<span style="color:#b44;font-style:italic">
</span><span style="color:#b44;font-style:italic">        需要 example-client-go-exec-plugin 来在当前集群上执行身份认证。可以通过以下命令安装：
</span><span style="color:#b44;font-style:italic">
</span><span style="color:#b44;font-style:italic">        MacOS: brew install example-client-go-exec-plugin
</span><span style="color:#b44;font-style:italic">
</span><span style="color:#b44;font-style:italic">        Ubuntu: apt-get install example-client-go-exec-plugin
</span><span style="color:#b44;font-style:italic">
</span><span style="color:#b44;font-style:italic">        Fedora: dnf install example-client-go-exec-plugin
</span><span style="color:#b44;font-style:italic">
</span><span style="color:#b44;font-style:italic">        ...</span><span style="color:#bbb">        
</span><span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#080;font-style:italic"># 是否使用 KUBERNETES_EXEC_INFO 环境变量的一部分向这个 exec 插件</span><span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#080;font-style:italic"># 提供集群信息（可能包含非常大的 CA 数据）</span><span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">provideClusterInfo</span>:<span style="color:#bbb"> </span><span style="color:#a2f;font-weight:bold">true</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">clusters</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>my-cluster<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">cluster</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">server</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;https://172.17.4.100:6443&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">certificate-authority</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;/etc/kubernetes/ca.pem&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">extensions</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>client.authentication.k8s.io/exec<span style="color:#bbb"> </span><span style="color:#080;font-style:italic"># 为每个集群 exec 配置保留的扩展名</span><span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">extension</span>:<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#008000;font-weight:bold">arbitrary</span>:<span style="color:#bbb"> </span>config<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#008000;font-weight:bold">this</span>:<span style="color:#bbb"> </span>在设置 provideClusterInfo 时可通过环境变量 KUBERNETES_EXEC_INFO 指定<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#008000;font-weight:bold">you</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;can&#34;</span>,<span style="color:#bbb"> </span><span style="color:#b44">&#34;put&#34;</span>,<span style="color:#bbb"> </span><span style="color:#b44">&#34;anything&#34;</span>,<span style="color:#bbb"> </span><span style="color:#b44">&#34;here&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">contexts</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>my-cluster<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">context</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">cluster</span>:<span style="color:#bbb"> </span>my-cluster<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">user</span>:<span style="color:#bbb"> </span>my-user<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">current-context</span>:<span style="color:#bbb"> </span>my-cluster<span style="color:#bbb">
</span></code></pre></div><!--
Relative command paths are interpreted as relative to the directory of the config file. If
KUBECONFIG is set to `/home/jane/kubeconfig` and the exec command is `./bin/example-client-go-exec-plugin`,
the binary `/home/jane/bin/example-client-go-exec-plugin` is executed.
-->
<p>解析相对命令路径时，kubectl 将其视为与配置文件比较而言的相对路径。
如果 KUBECONFIG 被设置为 <code>/home/jane/kubeconfig</code>，而 exec 命令为
<code>./bin/example-client-go-exec-plugin</code>，则要执行的可执行文件为
<code>/home/jane/bin/example-client-go-exec-plugin</code>。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml">- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>my-user<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">user</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">exec</span>:<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#080;font-style:italic"># 对 kubeconfig 目录而言的相对路径</span><span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">command</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;./bin/example-client-go-exec-plugin&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;client.authentication.k8s.io/v1beta1&#34;</span><span style="color:#bbb">
</span></code></pre></div><!--
### Input and output formats

The executed command prints an `ExecCredential` object to `stdout`. `k8s.io/client-go`
authenticates against the Kubernetes API using the returned credentials in the `status`.

When run from an interactive session, `stdin` is exposed directly to the plugin. Plugins should use a
[TTY check](https://godoc.org/golang.org/x/crypto/ssh/terminal#IsTerminal) to determine if it's
appropriate to prompt a user interactively.

To use bearer token credentials, the plugin returns a token in the status of the `ExecCredential`.
-->
<h3 id="input-and-output-formats">输出和输出格式  </h3>
<p>所执行的命令会在 <code>stdout</code> 打印 <code>ExecCredential</code> 对象。
<code>k8s.io/client-go</code> 使用 <code>status</code> 中返回的凭据信息向 Kubernetes API 服务器
执行身份认证。</p>
<p>在交互式会话中运行时，<code>stdin</code> 是直接暴露给插件使用的。
插件应该使用
<a href="https://godoc.org/golang.org/x/crypto/ssh/terminal#IsTerminal">TTY check</a>
来确定是否适合用交互方式请求用户输入。</p>
<p>与使用持有者令牌凭据，插件在 <code>ExecCredential</code> 的状态中返回一个令牌：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-json" data-lang="json">{
  <span style="color:#008000;font-weight:bold">&#34;apiVersion&#34;</span>: <span style="color:#b44">&#34;client.authentication.k8s.io/v1beta1&#34;</span>,
  <span style="color:#008000;font-weight:bold">&#34;kind&#34;</span>: <span style="color:#b44">&#34;ExecCredential&#34;</span>,
  <span style="color:#008000;font-weight:bold">&#34;status&#34;</span>: {
    <span style="color:#008000;font-weight:bold">&#34;token&#34;</span>: <span style="color:#b44">&#34;my-bearer-token&#34;</span>
  }
}
</code></pre></div><!--
Alternatively, a PEM-encoded client certificate and key can be returned to use TLS client auth.
If the plugin returns a different certificate and key on a subsequent call, `k8s.io/client-go`
will close existing connections with the server to force a new TLS handshake.

If specified, `clientKeyData` and `clientCertificateData` must both must be present.

`clientCertificateData` may contain additional intermediate certificates to send to the server.
-->
<p>另一种方案是，返回 PEM 编码的客户端证书和密钥，以便执行 TLS 客户端身份认证。
如果插件在后续调用中返回了不同的证书或密钥，<code>k8s.io/client-go</code>
会终止其与服务器的连接，从而强制执行新的 TLS 握手过程。</p>
<p>如果指定了这种方式，则 <code>clientKeyData</code> 和 <code>clientCertificateData</code> 字段都必需存在。</p>
<p><code>clientCertificateData</code> 字段可能包含一些要发送给服务器的中间证书（Intermediate
Certificates）。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-json" data-lang="json">{
  <span style="color:#008000;font-weight:bold">&#34;apiVersion&#34;</span>: <span style="color:#b44">&#34;client.authentication.k8s.io/v1beta1&#34;</span>,
  <span style="color:#008000;font-weight:bold">&#34;kind&#34;</span>: <span style="color:#b44">&#34;ExecCredential&#34;</span>,
  <span style="color:#008000;font-weight:bold">&#34;status&#34;</span>: {
    <span style="color:#008000;font-weight:bold">&#34;clientCertificateData&#34;</span>: <span style="color:#b44">&#34;-----BEGIN CERTIFICATE-----\n...\n-----END CERTIFICATE-----&#34;</span>,
    <span style="color:#008000;font-weight:bold">&#34;clientKeyData&#34;</span>: <span style="color:#b44">&#34;-----BEGIN RSA PRIVATE KEY-----\n...\n-----END RSA PRIVATE KEY-----&#34;</span>
  }
}
</code></pre></div><!--
Optionally, the response can include the expiry of the credential formatted as a
RFC3339 timestamp. Presence or absence of an expiry has the following impact:

- If an expiry is included, the bearer token and TLS credentials are cached until
  the expiry time is reached, or if the server responds with a 401 HTTP status code,
  or when the process exits.
- If an expiry is omitted, the bearer token and TLS credentials are cached until
  the server responds with a 401 HTTP status code or until the process exits.
-->
<p>作为一种可选方案，响应中还可以包含以 RFC3339 时间戳格式给出的证书到期时间。
证书到期时间的有无会有如下影响：</p>
<ul>
<li>如果响应中包含了到期时间，持有者令牌和 TLS 凭据会被缓存，直到到期期限到来、
或者服务器返回 401 HTTP 状态码，或者进程退出。</li>
<li>如果未指定到期时间，则持有者令牌和 TLS 凭据会被缓存，直到服务器返回 401
HTTP 状态码或者进程退出。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-json" data-lang="json">{
  <span style="color:#008000;font-weight:bold">&#34;apiVersion&#34;</span>: <span style="color:#b44">&#34;client.authentication.k8s.io/v1beta1&#34;</span>,
  <span style="color:#008000;font-weight:bold">&#34;kind&#34;</span>: <span style="color:#b44">&#34;ExecCredential&#34;</span>,
  <span style="color:#008000;font-weight:bold">&#34;status&#34;</span>: {
    <span style="color:#008000;font-weight:bold">&#34;token&#34;</span>: <span style="color:#b44">&#34;my-bearer-token&#34;</span>,
    <span style="color:#008000;font-weight:bold">&#34;expirationTimestamp&#34;</span>: <span style="color:#b44">&#34;2018-03-05T17:30:20-08:00&#34;</span>
  }
}
</code></pre></div><!--
The plugin can optionally be called with an environment variable, `KUBERNETES_EXEC_INFO`,
that contains information about the cluster for which this plugin is obtaining
credentials. This information can be used to perform cluster-specific credential
acquisition logic. In order to enable this behavior, the `provideClusterInfo` field must
be set on the exec user field in the
[kubeconfig](/docs/concepts/configuration/organize-cluster-access-kubeconfig/). Here is an
example of the aforementioned `KUBERNETES_EXEC_INFO` environment variable.
-->
<p>调用此插件时可以选择性地设置环境变量 <code>KUBERNETES_EXEC_INFO</code>。
该变量包含了此插件获取凭据所针对的集群信息。此信息可用于执行群集特定的凭据获取逻辑。
为了启用此行为，必须在 <a href="/zh/docs/concepts/configuration/organize-cluster-access-kubeconfig/">kubeconfig</a>
中的 exec user 字段上设置<code>provideClusterInfo</code>字段。
下面是上述 <code>KUBERNETES_EXEC_INFO</code> 环境变量的示例。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-json" data-lang="json">{
  <span style="color:#008000;font-weight:bold">&#34;apiVersion&#34;</span>: <span style="color:#b44">&#34;client.authentication.k8s.io/v1beta1&#34;</span>,
  <span style="color:#008000;font-weight:bold">&#34;kind&#34;</span>: <span style="color:#b44">&#34;ExecCredential&#34;</span>,
  <span style="color:#008000;font-weight:bold">&#34;spec&#34;</span>: {
    <span style="color:#008000;font-weight:bold">&#34;cluster&#34;</span>: {
      <span style="color:#008000;font-weight:bold">&#34;server&#34;</span>: <span style="color:#b44">&#34;https://172.17.4.100:6443&#34;</span>,
      <span style="color:#008000;font-weight:bold">&#34;certificate-authority-data&#34;</span>: <span style="color:#b44">&#34;LS0t...&#34;</span>,
      <span style="color:#008000;font-weight:bold">&#34;config&#34;</span>: {
        <span style="color:#008000;font-weight:bold">&#34;arbitrary&#34;</span>: <span style="color:#b44">&#34;config&#34;</span>,
        <span style="color:#008000;font-weight:bold">&#34;this&#34;</span>: <span style="color:#b44">&#34;在设置 provideClusterInfo 时可通过环境变量 KUBERNETES_EXEC_INFO 指定&#34;</span>,
        <span style="color:#008000;font-weight:bold">&#34;you&#34;</span>: [<span style="color:#b44">&#34;can&#34;</span>, <span style="color:#b44">&#34;put&#34;</span>, <span style="color:#b44">&#34;anything&#34;</span>, <span style="color:#b44">&#34;here&#34;</span>]
      }
    }
  }
}
</code></pre></div>
</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-de45b6ca7419a0e308044425b2ac52bb">4.2 - 使用启动引导令牌（Bootstrap Tokens）认证</h1>
    
	<!--
reviewers:
- jbeda
title: Authenticating with Bootstrap Tokens
content_type: concept
weight: 20
-->
<!-- overview -->





<div style="margin-top: 10px; margin-bottom: 10px;">
<b>FEATURE STATE:</b> <code>Kubernetes v1.18 [stable]</code>
</div>

<!--
Bootstrap tokens are a simple bearer token that is meant to be used when
creating new clusters or joining new nodes to an existing cluster.  It was built
to support [kubeadm](/docs/reference/setup-tools/kubeadm/), but can be used in other contexts
for users that wish to start clusters without `kubeadm`. It is also built to
work, via RBAC policy, with the
[Kubelet TLS Bootstrapping](/docs/reference/command-line-tools-reference/kubelet-tls-bootstrapping/) system.
-->
<p>启动引导令牌是一种简单的持有者令牌（Bearer Token），这种令牌是在新建集群
或者在现有集群中添加新节点时使用的。
它被设计成能够支持 <a href="/zh/docs/reference/setup-tools/kubeadm/"><code>kubeadm</code></a>，
但是也可以被用在其他的案例中以便用户在不使用 <code>kubeadm</code> 的情况下启动集群。
它也被设计成可以通过 RBAC 策略，结合
<a href="/zh/docs/reference/command-line-tools-reference/kubelet-tls-bootstrapping/">Kubelet TLS 启动引导</a>
系统进行工作。</p>
<!-- body -->
<!--
## Bootstrap Tokens Overview

Bootstrap Tokens are defined with a specific type
(`bootstrap.kubernetes.io/token`) of secrets that lives in the `kube-system`
namespace.  These Secrets are then read by the Bootstrap Authenticator in the
API Server.  Expired tokens are removed with the TokenCleaner controller in the
Controller Manager.  The tokens are also used to create a signature for a
specific ConfigMap used in a "discovery" process through a BootstrapSigner
controller.
-->
<p>启动引导令牌被定义成一个特定类型的 Secret（<code>bootstrap.kubernetes.io/token</code>），
并存在于 <code>kube-system</code> 名字空间中。
这些 Secret 会被 API 服务器上的启动引导认证组件（Bootstrap Authenticator）读取。
控制器管理器中的控制器 TokenCleaner 能够删除过期的令牌。
这些令牌也被用来在节点发现的过程中会使用的一个特殊的 ConfigMap 对象。
BootstrapSigner 控制器也会使用这一 ConfigMap。</p>
<!--
## Token Format

Bootstrap Tokens take the form of `abcdef.0123456789abcdef`.  More formally,
they must match the regular expression `[a-z0-9]{6}\.[a-z0-9]{16}`.

The first part of the token is the "Token ID" and is considered public
information.  It is used when referring to a token without leaking the secret
part used for authentication. The second part is the "Token Secret" and should
only be shared with trusted parties.
-->
<h2 id="令牌格式">令牌格式</h2>
<p>启动引导令牌使用 <code>abcdef.0123456789abcdef</code> 的形式。
更加规范地说，它们必须符合正则表达式 <code>[a-z0-9]{6}\.[a-z0-9]{16}</code>。</p>
<p>令牌的第一部分是 “Token ID”，它是一种公开信息，用于引用令牌并确保不会
泄露认证所使用的秘密信息。
第二部分是“令牌秘密（Token Secret）”，它应该被共享给受信的第三方。</p>
<h2 id="启用启动引导令牌">启用启动引导令牌</h2>
<!--
## Enabling Bootstrap Token Authentication

The Bootstrap Token authenticator can be enabled using the following flag on the
API server:
-->
<h2 id="enabling-bootstrap-token-authentication">启用启动引导令牌身份认证  </h2>
<p>启动引导令牌认证组件可以通过 API 服务器上的如下标志启用：</p>
<pre tabindex="0"><code>--enable-bootstrap-token-auth
</code></pre><!--
When enabled, bootstrapping tokens can be used as bearer token credentials to
authenticate requests against the API server.
-->
<p>启动引导令牌被启用后，可以作为持有者令牌的凭据，用于 API 服务器请求的身份认证。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-http" data-lang="http"><span style="">Authorization: Bearer 07401b.f395accd246ae52d
</span></code></pre></div><!--
Tokens authenticate as the username `system:bootstrap:<token id>` and are members
of the group `system:bootstrappers`.  Additional groups may be specified in the
token's Secret.

Expired tokens can be deleted automatically by enabling the `tokencleaner`
controller on the controller manager.
-->
<p>令牌认证为用户名 <code>system:bootstrap:&lt;token id&gt;</code> 并且是组 <code>system:bootstrappers</code>
的成员。额外的组信息可以通过令牌的 Secret 来设置。</p>
<p>过期的令牌可以通过启用控制器管理器中的 <code>tokencleaner</code> 控制器来删除。</p>
<!--
## Bootstrap Token Secret Format

Each valid token is backed by a secret in the `kube-system` namespace.  You can
find the full design doc
[here](https://github.com/kubernetes/community/blob/main/contributors/design-proposals/cluster-lifecycle/bootstrap-discovery.md).

Here is what the secret looks like.
-->
<h2 id="bootstrap-token-secret-format">启动引导令牌的 Secret 格式 </h2>
<p>每个合法的令牌背后对应着 <code>kube-system</code> 名字空间中的某个 Secret 对象。
你可以从
<a href="https://github.com/kubernetes/community/blob/main/contributors/design-proposals/cluster-lifecycle/bootstrap-discovery.md">这里</a>.
找到完整设计文档。</p>
<p>这是 Secret 看起来的样子。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>Secret<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#080;font-style:italic"># name 必须是 &#34;bootstrap-token-&lt;token id&gt;&#34; 格式的</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>bootstrap-token-07401b<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">namespace</span>:<span style="color:#bbb"> </span>kube-system<span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#080;font-style:italic"># type 必须是 &#39;bootstrap.kubernetes.io/token&#39;</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">type</span>:<span style="color:#bbb"> </span>bootstrap.kubernetes.io/token<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">stringData</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#080;font-style:italic"># 供人阅读的描述，可选。</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">description</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;The default bootstrap token generated by &#39;kubeadm init&#39;.&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#080;font-style:italic"># 令牌 ID 和秘密信息，必需。</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">token-id</span>:<span style="color:#bbb"> </span>07401b<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">token-secret</span>:<span style="color:#bbb"> </span>base64(f395accd246ae52d)<span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#080;font-style:italic"># 可选的过期时间字段</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">expiration</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;2017-03-10T03:22:11Z&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#080;font-style:italic"># 允许的用法</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">usage-bootstrap-authentication</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;true&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">usage-bootstrap-signing</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;true&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#080;font-style:italic"># 令牌要认证为的额外组，必须以 &#34;system:bootstrappers:&#34; 开头</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">auth-extra-groups</span>:<span style="color:#bbb"> </span>system:bootstrappers:worker,system:bootstrappers:ingress<span style="color:#bbb">
</span></code></pre></div><!--
The type of the secret must be `bootstrap.kubernetes.io/token` and the name must
be `bootstrap-token-<token id>`.  It must also exist in the `kube-system`
namespace.

The `usage-bootstrap-*` members indicate what this secret is intended to be used
for.  A value must be set to `true` to be enabled.
-->
<p>Secret 的类型必须是 <code>bootstrap.kubernetes.io/token</code>，而且名字必须是 <code>bootstrap-token-&lt;token id&gt;</code>。
令牌必须存在于 <code>kube-system</code> 名字空间中。</p>
<p><code>usage-bootstrap-*</code> 成员表明这个 Secret 的用途。启用时，值必须设置为 <code>true</code>。</p>
<!--
* `usage-bootstrap-authentication` indicates that the token can be used to
authenticate to the API server as a bearer token.
* `usage-bootstrap-signing` indicates that the token may be used to sign the
`cluster-info` ConfigMap as described below.
-->
<ul>
<li><code>usage-bootstrap-authentication</code> 表示令牌可以作为持有者令牌用于 API 服务器的身份认证。</li>
<li><code>usage-bootstrap-signing</code> 表示令牌可被用于 <code>cluster-info</code> ConfigMap 的签名，
就像下面描述的那样。</li>
</ul>
<!--
The `expiration` field controls the expiry of the token.  Expired tokens are
rejected when used for authentication and ignored during ConfigMap signing.
The expiry value is encoded as an absolute UTC time using RFC3339.  Enable the
`tokencleaner` controller to automatically delete expired tokens.
-->
<p><code>expiration</code> 字段控制令牌的失效期。过期的令牌在用于身份认证时会被拒绝，在用于
ConfigMap 签名时会被忽略。
过期时间值是遵循 RFC3339 进行编码的 UTC 时间。
启用 TokenCleaner 控制器会自动删除过期的令牌。</p>
<!--
## Token Management with kubeadm

You can use the `kubeadm` tool to manage tokens on a running cluster. See the
[kubeadm token docs](/docs/reference/setup-tools/kubeadm/kubeadm-token/) for details.
-->
<h2 id="token-management-with-kubeadm">使用 <code>kubeadm</code> 管理令牌  </h2>
<p>你可以使用 <code>kubeadm</code> 工具管理运行中集群上的令牌。
参见 <a href="/zh/docs/reference/setup-tools/kubeadm/kubeadm-token/">kubeadm token 文档</a>
以了解详细信息。</p>
<!--
## ConfigMap Signing

In addition to authentication, the tokens can be used to sign a ConfigMap.  This
is used early in a cluster bootstrap process before the client trusts the API
server.  The signed ConfigMap can be authenticated by the shared token.

Enable ConfigMap signing by enabling the `bootstrapsigner` controller on the
Controller Manager.
-->
<h3 id="configmap-signing">ConfigMap 签名 </h3>
<p>除了身份认证，令牌还可以用于签名 ConfigMap。
这一用法发生在集群启动过程的早期，在客户端信任 API 服务器之前。
被签名的 ConfigMap 可以被共享令牌完成身份认证。</p>
<p>通过在控制器管理器上启用 <code>bootstrapsigner</code> 控制器可以启用 ConfigMap 签名特性。</p>
<pre tabindex="0"><code>--controllers=*,bootstrapsigner
</code></pre><!--
The ConfigMap that is signed is `cluster-info` in the `kube-public` namespace.
The typical flow is that a client reads this ConfigMap while unauthenticated and
ignoring TLS errors.  It then validates the payload of the ConfigMap by looking
at a signature embedded in the ConfigMap.

The ConfigMap may look like this:
-->
<p>被签名的 ConfigMap 是 <code>kube-public</code> 名字空间中的 <code>cluster-info</code>。
典型的工作流中，客户端在未经认证和忽略 TLS 报错的状态下读取这个 ConfigMap。
通过检查 ConfigMap 中嵌入的签名校验 ConfigMap 的载荷。</p>
<p>ConfigMap 会是这个样子的：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>ConfigMap<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>cluster-info<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">namespace</span>:<span style="color:#bbb"> </span>kube-public<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">data</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">jws-kubeconfig-07401b</span>:<span style="color:#bbb"> </span>eyJhbGciOiJIUzI1NiIsImtpZCI6IjA3NDAxYiJ9..tYEfbo6zDNo40MQE07aZcQX2m3EB2rO3NuXtxVMYm9U<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">kubeconfig</span>:<span style="color:#bbb"> </span>|<span style="color:#b44;font-style:italic">
</span><span style="color:#b44;font-style:italic">    apiVersion: v1
</span><span style="color:#b44;font-style:italic">    clusters:
</span><span style="color:#b44;font-style:italic">    - cluster:
</span><span style="color:#b44;font-style:italic">        certificate-authority-data: &lt;非常长的证书数据&gt;
</span><span style="color:#b44;font-style:italic">        server: https://10.138.0.2:6443
</span><span style="color:#b44;font-style:italic">      name: &#34;&#34;
</span><span style="color:#b44;font-style:italic">    contexts: []
</span><span style="color:#b44;font-style:italic">    current-context: &#34;&#34;
</span><span style="color:#b44;font-style:italic">    kind: Config
</span><span style="color:#b44;font-style:italic">    preferences: {}
</span><span style="color:#b44;font-style:italic">    users: []</span><span style="color:#bbb">    
</span></code></pre></div><!--
The `kubeconfig` member of the ConfigMap is a config file with just the cluster
information filled out.  The key thing being communicated here is the
`certificate-authority-data`.  This may be expanded in the future.
-->
<p>ConfigMap 的 <code>kubeconfig</code> 成员是一个填好了集群信息的配置文件。
这里主要交换的信息是 <code>certificate-authority-data</code>。在将来可能会有扩展。</p>
<!--
The signature is a JWS signature using the "detached" mode.  To validate the
signature, the user should encode the `kubeconfig` payload according to JWS
rules (base64 encoded while discarding any trailing `=`).  That encoded payload
is then used to form a whole JWS by inserting it between the 2 dots.  You can
verify the JWS using the `HS256` scheme (HMAC-SHA256) with the full token (e.g.
`07401b.f395accd246ae52d`) as the shared secret.  Users _must_ verify that HS256
is used.
-->
<p>签名是一个使用 “detached” 模式生成的 JWS 签名。
为了检验签名，用户应该按照 JWS 规则（base64 编码且丢掉结尾的 <code>=</code>）对
<code>kubeconfig</code> 的载荷进行编码。完成编码的载荷会被插入到两个句点中间，形成完整的
JWS。你可以使用完整的令牌（比如 <code>07401b.f395accd246ae52d</code>）作为共享密钥，
通过 <code>HS256</code> 方式 (HMAC-SHA256) 对 JWS 进行校验。
用户 <em>必须</em> 确保使用了 HS256。</p>
<blockquote class="warning callout">
  <div><strong>警告：</strong> <!--
Any party with a bootstrapping token can create a valid signature for that
token. When using ConfigMap signing it's discouraged to share the same token with
many clients, since a compromised client can potentially man-in-the middle another
client relying on the signature to bootstrap TLS trust.
-->
<p>任何拥有了启动引导令牌的主体都可以为该令牌生成一个合法的签名。
当使用 ConfigMap 签名时，非常不建议针对很多客户使用相同的令牌，因为某个被攻击的
客户可能对另一个一来签名来开启 TLS 信任的客户发起中间人攻击。</div>
</blockquote>

<!--
Consult the [kubeadm implementation details](/docs/reference/setup-tools/kubeadm/implementation-details/)
section for more information.
-->
<p>参考 <a href="/zh/docs/reference/setup-tools/kubeadm/implementation-details/">kubeadm 实现细节</a>
了解更多信息。</p>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-3d0c14d1e3cfade38febc343cd044c73">4.3 - 证书签名请求</h1>
    
	<!-- 
reviewers:
- liggitt
- mikedanese
- munnerz
title: Certificate Signing Requests
content_type: concept
weight: 20
-->
<!-- overview -->





<div style="margin-top: 10px; margin-bottom: 10px;">
<b>FEATURE STATE:</b> <code>Kubernetes v1.19 [stable]</code>
</div>

<!-- 
The Certificates API enables automation of
[X.509](https://www.itu.int/rec/T-REC-X.509) credential provisioning by providing
a programmatic interface for clients of the Kubernetes API to request and obtain
X.509 <a class='glossary-tooltip' title='证书是个安全加密文件，用来确认对 Kubernetes 集群访问的合法性。' data-toggle='tooltip' data-placement='top' href='/zh/docs/tasks/tls/managing-tls-in-a-cluster/' target='_blank' aria-label='certificates'>certificates</a> 
from a Certificate Authority (CA).

A CertificateSigningRequest (CSR) resource is used to request that a certificate be signed
by a denoted signer, after which the request may be approved or denied before
finally being signed.
-->
<p>证书 API 支持
<a href="https://www.itu.int/rec/T-REC-X.509">X.509</a>
的自动化配置，
它为 Kubernetes API 的客户端提供一个编程接口，
用于从证书颁发机构（CA）请求并获取 X.509
<a class='glossary-tooltip' title='证书是个安全加密文件，用来确认对 Kubernetes 集群访问的合法性。' data-toggle='tooltip' data-placement='top' href='/zh/docs/tasks/tls/managing-tls-in-a-cluster/' target='_blank' aria-label='证书'>证书</a>。</p>
<p>CertificateSigningRequest（CSR）资源用来向指定的签名者申请证书签名，
在最终签名之前，申请可能被批准，也可能被拒绝。</p>
<!-- body -->
<!-- 
## Request signing process

The CertificateSigningRequest resource type allows a client to ask for an X.509 certificate
be issued, based on a signing request.

The CertificateSigningRequest object includes a PEM-encoded PKCS#10 signing request in
the `spec.request` field. The CertificateSigningRequest denotes the _signer_ (the
recipient that the request is being made to) using the `spec.signerName` field.
Note that `spec.signerName` is a required key after api version `certificates.k8s.io/v1`.
-->
<h2 id="request-signing-process">请求签名流程</h2>
<p>CertificateSigningRequest 资源类型允许客户使用它申请发放 X.509 证书。
CertificateSigningRequest 对象 在 <code>spec.request</code> 中包含一个 PEM 编码的 PKCS#10 签名请求。
CertificateSigningRequest 使用 <code>spec.signerName</code> 字段标示 <em>签名者</em>（请求的接收方）。
注意，<code>spec.signerName</code> 在 <code>certificates.k8s.io/v1</code> 之后的 API 版本是必填项。</p>
<!-- 
Once created, a CertificateSigningRequest must be approved before it can be signed.
Depending on the signer selected, a CertificateSigningRequest may be automatically approved
by a <a class='glossary-tooltip' title='控制器通过 apiserver 监控集群的公共状态，并致力于将当前状态转变为期望的状态。' data-toggle='tooltip' data-placement='top' href='/zh/docs/concepts/architecture/controller/' target='_blank' aria-label='controller'>controller</a>.
Otherwise, a CertificateSigningRequest must be manually approved 
either via the REST API (or client-go)
or by running `kubectl certificate approve`. 
Likewise, a CertificateSigningRequest may also be denied,
which tells the configured signer that it must not sign the request.
-->
<p>创建完成的 CertificateSigningRequest，要先通过批准，然后才能签名。
根据所选的签名者，CertificateSigningRequest 可能会被
<a class='glossary-tooltip' title='控制器通过 apiserver 监控集群的公共状态，并致力于将当前状态转变为期望的状态。' data-toggle='tooltip' data-placement='top' href='/zh/docs/concepts/architecture/controller/' target='_blank' aria-label='控制器'>控制器</a>自动批准。
否则，就必须人工批准，
人工批准可以使用 REST API（或 go 客户端），也可以执行 <code>kubectl certificate approve</code> 命令。
同样，CertificateSigningRequest 也可能被驳回，
这就相当于通知了指定的签名者，这个证书不能签名。</p>
<!--  
For certificates that have been approved, the next step is signing. 
The relevant signing controller
first validates that the signing conditions are met and then creates a certificate.
The signing controller then updates the CertificateSigningRequest, 
storing the new certificate into
the `status.certificate` field of the existing CertificateSigningRequest object. The
`status.certificate` field is either empty or contains a X.509 certificate, 
encoded in PEM format.
The CertificateSigningRequest `status.certificate` field is empty until the signer does this.
-->
<p>对于已批准的证书，下一步是签名。
对应的签名控制器首先验证签名条件是否满足，然后才创建证书。
签名控制器然后更新 CertificateSigningRequest，
将新证书保存到现有 CertificateSigningRequest 对象的 <code>status.certificate</code> 字段中。
此时，字段 <code>status.certificate</code> 要么为空，要么包含一个用 PEM 编码的 X.509 证书。
直到签名完成前，CertificateSigningRequest 的字段 <code>status.certificate</code> 都为空。</p>
<!-- 
Once the `status.certificate` field has been populated, 
the request has been completed and clients can now
fetch the signed certificate PEM data from the CertificateSigningRequest resource.
The signers can instead deny certificate signing if the approval conditions are not met.
-->
<p>一旦 <code>status.certificate</code> 字段完成填充，请求既算完成，
客户端现在可以从 CertificateSigningRequest 资源中获取已签名的证书的 PEM 数据。
当然如果不满足签名条件，签名者可以拒签。</p>
<!-- 
In order to reduce the number of old CertificateSigningRequest resources left 
in a cluster, a garbage collection
controller runs periodically. 
The garbage collection removes CertificateSigningRequests that have not changed
state for some duration:

* Approved requests: automatically deleted after 1 hour
* Denied requests: automatically deleted after 1 hour
* Pending requests: automatically deleted after 1 hour
-->
<p>为了减少集群中遗留的过时的 CertificateSigningRequest 资源的数量，
一个垃圾收集控制器将会周期性地运行。
此垃圾收集器会清除在一段时间内没有改变过状态的 CertificateSigningRequests：</p>
<ul>
<li>已批准的请求：1小时后自动删除</li>
<li>已拒绝的请求：1小时后自动删除</li>
<li>挂起的请求：1小时后自动删除</li>
</ul>
<!-- 
## Signers

Custom signerNames can also be specified. All signers should provide information about how they work 
so that clients can predict what will happen to their CSRs.
This includes:
-->
<h2 id="signers">签名者</h2>
<p>也可以指定自定义 signerName。
所有签名者都应该提供自己工作方式的信息，
以便客户端可以预期到他们的 CSR 将发生什么。
此类信息包括：</p>
<!-- 
1. **Trust distribution**: how trust (CA bundles) are distributed.
2.  **Permitted subjects**: any restrictions on and behavior 
   when a disallowed subject is requested.
3. **Permitted x509 extensions**: including IP subjectAltNames, DNS subjectAltNames, 
   Email subjectAltNames, URI subjectAltNames etc, 
   and behavior when a disallowed extension is requested.
4. **Permitted key usages / extended key usages**: any restrictions on and behavior 
   when usages different than the signer-determined usages are specified in the CSR.
5. **Expiration/certificate lifetime**: whether it is fixed by the signer, 
   configurable by the admin, determined by the CSR object etc and the behavior 
   when an expiration is different than the signer-determined expiration 
   that is specified in the CSR.
6. **CA bit allowed/disallowed**: and behavior if a CSR contains a request 
   a for a CA certificate when the signer does not permit it.
-->
<ol>
<li><strong>信任分发</strong>：信任（CA 证书包）是如何分发的。</li>
<li><strong>许可的主体</strong>：当一个受限制的主体（subject）发送请求时，相应的限制和应对手段。</li>
<li><strong>许可的 x509 扩展</strong>：包括 IP subjectAltNames、DNS subjectAltNames、
Email subjectAltNames、URI subjectAltNames 等，请求一个受限制的扩展项时的应对手段。</li>
<li><strong>许可的密钥用途/扩展的密钥用途</strong>：当用途和签名者在 CSR 中指定的用途不同时，
相应的限制和应对手段。</li>
<li><strong>过期时间/证书有效期</strong>：过期时间由签名者确定、由管理员配置，还是由 CSR 对象指定等，
以及过期时间与签名者在 CSR 中指定过期时间不同时的应对手段。</li>
<li><strong>允许/不允许 CA 位</strong>：当 CSR 包含一个签名者并不允许的 CA 证书的请求时，相应的应对手段。</li>
</ol>
<!-- 
Commonly, the `status.certificate` field contains a single PEM-encoded X.509
certificate once the CSR is approved and the certificate is issued. Some
signers store multiple certificates into the `status.certificate` field. In
that case, the documentation for the signer should specify the meaning of
additional certificates; for example, this might be the certificate plus
intermediates to be presented during TLS handshakes.
-->
<p>一般来说，当 CSR 被批准通过，且证书被签名后，<code>status.certificate</code> 字段
将包含一个 PEM 编码的 X.509 证书。
有些签名者在 <code>status.certificate</code> 字段中存储多个证书。
在这种情况下，签名者的说明文档应当指明附加证书的含义。
例如，这是要在 TLS 握手时提供的证书和中继证书。</p>
<!--
The PKCS#10 signing request format doesn't allow to specify a certificate
expiration or lifetime. The expiration or lifetime therefore has to be set
through e.g. an annotation on the CSR object. While it's theoretically
possible for a signer to use that expiration date, there is currently no
known implementation that does. (The built-in signers all use the same
`ClusterSigningDuration` configuration option, which defaults to 1 year,
and can be changed with the `--cluster-signing-duration` command-line
flag of the kube-controller-manager.)
-->
<p>PKCS#10 签名请求格式不允许设置证书的过期时间或者生命期。因此，证书的过期
时间或者生命期必须通过类似 CSR 对象的注解字段这种形式来设置。
尽管让签名者使用过期日期从理论上来讲也是可行的，目前还不存在哪个实现这样做了。
（内置的签名者都是用相同的 <code>ClusterSigningDuration</code> 配置选项，而该选项
中将生命期的默认值设为 1 年，且可通过 kube-controller-manager 的命令行选项
<code>--cluster-signing-duration</code> 来更改。）</p>
<!-- 
### Kubernetes signers

Kubernetes provides built-in signers that each have a well-known `signerName`:
-->
<h3 id="kubernetes-signers">Kubernetes 签名者</h3>
<p>Kubernetes提供了内置的签名者，每个签名者都有一个众所周知的 <code>signerName</code>:</p>
<!-- 
1. `kubernetes.io/kube-apiserver-client`: signs certificates that will be honored as client certificates by the API server.
  Never auto-approved by <a class='glossary-tooltip' title='主节点上运行控制器的组件。' data-toggle='tooltip' data-placement='top' href='/docs/reference/generated/kube-controller-manager/' target='_blank' aria-label='kube-controller-manager'>kube-controller-manager</a>.
    1. Trust distribution: signed certificates must be honored as client-certificates by the kube-apiserver. The CA bundle is not distributed by any other means.
    1. Permitted subjects - no subject restrictions, but approvers and signers may choose not to approve or sign.
       Certain subjects like cluster-admin level users or groups vary between distributions and installations,
       but deserve additional scrutiny before approval and signing.
       The `CertificateSubjectRestriction` admission plugin is enabled by default to restrict `system:masters`,
       but it is often not the only cluster-admin subject in a cluster.
    1. Permitted x509 extensions - honors subjectAltName and key usage extensions and discards other extensions.
    1. Permitted key usages - must include `["client auth"]`. Must not include key usages beyond `["digital signature", "key encipherment", "client auth"]`.
    1. Expiration/certificate lifetime - set by the `--cluster-signing-duration` option for the
       kube-controller-manager implementation of this signer.
    1. CA bit allowed/disallowed - not allowed.
-->
<ol>
<li><code>kubernetes.io/kube-apiserver-client</code>：签名的证书将被 API 服务器视为客户证书。
<a class='glossary-tooltip' title='主节点上运行控制器的组件。' data-toggle='tooltip' data-placement='top' href='/docs/reference/generated/kube-controller-manager/' target='_blank' aria-label='kube-controller-manager'>kube-controller-manager</a> 不会自动批准它。
<ol>
<li>信任分发：签名的证书将被 API 服务器视为客户端证书。CA 证书包不通过任何其他方式分发。</li>
<li>许可的主体：没有主体限制，但审核人和签名者可以选择不批准或不签署。
某些主体，比如集群管理员级别的用户或组因部署和安装方式不同而不同，
所以批准和签署之前需要进行额外仔细审查。
用来限制 <code>system:masters</code> 的 CertificateSubjectRestriction 准入插件默认处于启用状态，
但它通常不是集群中唯一的集群管理员主体。</li>
<li>许可的 x509 扩展：允许 subjectAltName 和 key usage 扩展，弃用其他扩展。</li>
<li>许可的密钥用途：必须包含 <code>[&quot;client auth&quot;]</code>，但不能包含
<code>[&quot;digital signature&quot;, &quot;key encipherment&quot;, &quot;client auth&quot;]</code> 之外的键。</li>
<li>过期时间/证书有效期：通过 kube-controller-manager 中 <code>--cluster-signing-duration</code>
标志来设置，由其中的签名者实施。</li>
<li>允许/不允许 CA 位：不允许。</li>
</ol>
</li>
</ol>
<!-- 
1. `kubernetes.io/kube-apiserver-client-kubelet`: signs client certificates that will be honored as client certificates by the
   API server.
   May be auto-approved by <a class='glossary-tooltip' title='主节点上运行控制器的组件。' data-toggle='tooltip' data-placement='top' href='/docs/reference/generated/kube-controller-manager/' target='_blank' aria-label='kube-controller-manager'>kube-controller-manager</a>.
   1. Trust distribution: signed certificates must be honored as client certificates by the API server. The CA bundle
      is not distributed by any other means.
   1. Permitted subjects - organizations are exactly `["system:nodes"]`, common name starts with "`system:node:`".
   1. Permitted x509 extensions - honors key usage extensions, forbids subjectAltName extensions and drops other extensions.
   1. Permitted key usages - exactly `["key encipherment", "digital signature", "client auth"]`.
   1. Expiration/certificate lifetime - set by the `--cluster-signing-duration` option for the
      kube-controller-manager implementation of this signer.
   1. CA bit allowed/disallowed - not allowed.
-->
<ol start="2">
<li>
<p><code>kubernetes.io/kube-apiserver-client-kubelet</code>: 签名的证书将被 kube-apiserver 视为客户证书。
<a class='glossary-tooltip' title='主节点上运行控制器的组件。' data-toggle='tooltip' data-placement='top' href='/docs/reference/generated/kube-controller-manager/' target='_blank' aria-label='kube-controller-manager'>kube-controller-manager</a> 可以自动批准它。</p>
<ol>
<li>信任分发：签名的证书将被 API 服务器视为客户端证书。CA 证书包不通过任何其他方式分发。</li>
<li>许可的主体：组织名必须是 <code>[&quot;system:nodes&quot;]</code>，用户名以 &quot;<code>system:node:</code>&quot; 开头</li>
<li>许可的 x509 扩展：允许 key usage 扩展，禁用 subjectAltName 扩展，并删除其他扩展。</li>
<li>许可的密钥用途：必须是 <code>[&quot;key encipherment&quot;, &quot;digital signature&quot;, &quot;client auth&quot;]</code></li>
<li>过期时间/证书有效期：通过 kube-controller-manager 中签名者的实现所对应的标志
<code>--cluster-signing-duration</code> 来设置。</li>
<li>允许/不允许 CA 位：不允许。</li>
</ol>
</li>
</ol>
<!-- 
1. `kubernetes.io/kubelet-serving`: signs serving certificates that are honored as a valid kubelet serving certificate
   by the API server, but has no other guarantees.
   Never auto-approved by <a class='glossary-tooltip' title='主节点上运行控制器的组件。' data-toggle='tooltip' data-placement='top' href='/docs/reference/generated/kube-controller-manager/' target='_blank' aria-label='kube-controller-manager'>kube-controller-manager</a>.
   1. Trust distribution: signed certificates must be honored by the kube-apiserver as valid to terminate connections to a kubelet. The CA bundle is not distributed by any other means.
   1. Permitted subjects - organizations are exactly `["system:nodes"]`, common name starts with "`system:node:`".
   1. Permitted x509 extensions - honors key usage and DNSName/IPAddress subjectAltName extensions, forbids EmailAddress and
      URI subjectAltName extensions, drops other extensions. At least one DNS or IP subjectAltName must be present.
   1. Permitted key usages - exactly `["key encipherment", "digital signature", "server auth"]`.
   1. Expiration/certificate lifetime - minimum of CSR signer or request.
   1. CA bit allowed/disallowed - not allowed.
-->
<ol start="3">
<li><code>kubernetes.io/kubelet-serving</code>: 签名服务证书，该服务证书被 API 服务器视为有效的 kubelet 服务证书，
但没有其他保证。<a class='glossary-tooltip' title='主节点上运行控制器的组件。' data-toggle='tooltip' data-placement='top' href='/docs/reference/generated/kube-controller-manager/' target='_blank' aria-label='kube-controller-manager'>kube-controller-manager</a> 不会自动批准它。
<ol>
<li>信任分发：签名的证书必须被 kube-apiserver 认可，可有效的中止 kubelet 连接。CA 证书包不通过任何其他方式分发。</li>
<li>许可的主体：组织名必须是 <code>[&quot;system:nodes&quot;]</code>，用户名以 &quot;<code>system:node:</code>&quot; 开头</li>
<li>许可的 x509 扩展：允许 key usage、DNSName/IPAddress subjectAltName 等扩展，
禁止  EmailAddress、URI subjectAltName 等扩展，并丢弃其他扩展。
至少有一个 DNS 或 IP 的 SubjectAltName 存在。</li>
<li>许可的密钥用途：必须是 <code>[&quot;key encipherment&quot;, &quot;digital signature&quot;, &quot;client auth&quot;]</code></li>
<li>过期日期/证书生命期：通过 kube-controller-manager 中签名者的实现所对应的标志
<code>--cluster-signing-duration</code> 来设置。</li>
<li>允许/不允许 CA 位：不允许。</li>
</ol>
</li>
</ol>
<!-- 
1. `kubernetes.io/legacy-unknown`:  has no guarantees for trust at all. Some third-party distributions of Kubernetes
   may honor client certificates signed by it. The stable CertificateSigningRequest API (version `certificates.k8s.io/v1` and later)
   does not allow to set the `signerName` as `kubernetes.io/legacy-unknown`.
   Never auto-approved by <a class='glossary-tooltip' title='主节点上运行控制器的组件。' data-toggle='tooltip' data-placement='top' href='/docs/reference/generated/kube-controller-manager/' target='_blank' aria-label='kube-controller-manager'>kube-controller-manager</a>.
   1. Trust distribution: None.  There is no standard trust or distribution for this signer in a Kubernetes cluster.
   1. Permitted subjects - any
   1. Permitted x509 extensions - honors subjectAltName and key usage extensions and discards other extensions.
   1. Permitted key usages - any
   1. Expiration/certificate lifetime - set by the `--cluster-signing-duration` option for the
       kube-controller-manager implementation of this signer.
   1. CA bit allowed/disallowed - not allowed.
-->
<ol start="4">
<li><code>kubernetes.io/legacy-unknown</code>: 不保证信任。Kubernetes 的一些第三方发行版可能会使用它签署的客户端证书。
稳定版的 CertificateSigningRequest API（<code>certificates.k8s.io/v1</code> 以及之后的版本）不允许将
<code>signerName</code> 设置为 <code>kubernetes.io/legacy-unknown</code>。
<a class='glossary-tooltip' title='主节点上运行控制器的组件。' data-toggle='tooltip' data-placement='top' href='/docs/reference/generated/kube-controller-manager/' target='_blank' aria-label='kube-controller-manager'>kube-controller-manager</a> 不会自动批准这类请求。
<ol>
<li>信任分发：没有。这个签名者在 Kubernetes 集群中没有标准的信任或分发。</li>
<li>许可的主体：全部。</li>
<li>许可的 x509 扩展：允许 subjectAltName 和 key usage 等扩展，并弃用其他扩展。</li>
<li>许可的密钥用途：全部。</li>
<li>过期日期/证书生命期：通过 kube-controller-manager 中签名者的实现所对应的标志
<code>--cluster-signing-duration</code> 来设置。</li>
<li>允许/不允许 CA 位 - 不允许。</li>
</ol>
</li>
</ol>
<blockquote class="note callout">
  <div><strong>说明：</strong> <!--
Failures for all of these are only reported in kube-controller-manager logs.
-->
<p>注意：所有这些故障仅在 kube-controller-manager 日志中报告。</div>
</blockquote>
<!-- 
Distribution of trust happens out of band for these signers.  Any trust outside of those described above are strictly
coincidental. For instance, some distributions may honor `kubernetes.io/legacy-unknown` as client certificates for the
kube-apiserver, but this is not a standard.
None of these usages are related to ServiceAccount token secrets `.data[ca.crt]` in any way.  That CA bundle is only
guaranteed to verify a connection to the API server using the default service (`kubernetes.default.svc`).
-->
<p>对于这些签名者，信任的分发发生在带外（out of band）。上述信任之外的任何信任都是完全巧合的。
例如，一些发行版可能会将 <code>kubernetes.io/legacy-unknown</code> 作为 kube-apiserver 的客户端证书，
但这个做法并不标准。
这些用途都没有以任何方式涉及到 ServiceAccount 中的 Secrets <code>.data[ca.crt]</code>。
此 CA 证书包只保证使用默认的服务（<code>kubernetes.default.svc</code>）来验证到 API 服务器的连接。</p>
<!-- 
## Authorization

To allow creating a CertificateSigningRequest and retrieving any CertificateSigningRequest:

* Verbs: `create`, `get`, `list`, `watch`, group: `certificates.k8s.io`, resource: `certificatesigningrequests`

For example:
-->
<h2 id="authorization">鉴权</h2>
<p>授权创建 CertificateSigningRequest 和检索 CertificateSigningRequest:</p>
<ul>
<li>verbs（动词）: <code>create</code>、<code>get</code>、<code>list</code>、<code>watch</code>,
group（组）：<code>certificates.k8s.io</code>，
resources：<code>certificatesigningrequests</code></li>
</ul>
<p>例如：</p>


 













<div class="highlight">
    <div class="copy-code-icon" style="text-align:right">
    <a href="https://raw.githubusercontent.com/kubernetes/website/main/content/zh/examples/access/certificate-signing-request/clusterrole-create.yaml" download="access/certificate-signing-request/clusterrole-create.yaml"><code>access/certificate-signing-request/clusterrole-create.yaml</code>
    </a>
    <img src="/images/copycode.svg" style="max-height:24px; cursor: pointer" onclick="copyCode('access-certificate-signing-request-clusterrole-create-yaml')" title="Copy access/certificate-signing-request/clusterrole-create.yaml to clipboard">
    </img>
    </div>
    <div class="includecode" id="access-certificate-signing-request-clusterrole-create-yaml">
    <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>rbac.authorization.k8s.io/v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>ClusterRole<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>csr-creator<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">rules</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">apiGroups</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- certificates.k8s.io<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">resources</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- certificatesigningrequests<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">verbs</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- create<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- get<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- list<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- watch<span style="color:#bbb">
</span></code></pre></div>
    </div>
</div>


<!-- 
To allow approving a CertificateSigningRequest:

* Verbs: `get`, `list`, `watch`, group: `certificates.k8s.io`, resource: `certificatesigningrequests`
* Verbs: `update`, group: `certificates.k8s.io`, resource: `certificatesigningrequests/approval`
* Verbs: `approve`, group: `certificates.k8s.io`, resource: `signers`, resourceName: `<signerNameDomain>/<signerNamePath>` or `<signerNameDomain>/*`

For example:
-->
<p>授权批准 CertificateSigningRequest：</p>
<ul>
<li>verbs（动词）: <code>get</code>、<code>list</code>、<code>watch</code>，
group（组）：<code>certificates.k8s.io</code>，
resources（资源）：<code>certificatesigningrequests</code></li>
<li>verbs（动词）: <code>update</code>，
group（组）：<code>certificates.k8s.io</code>，
resources（资源）：<code>certificatesigningrequests/approval</code></li>
<li>verbs（动词）：<code>approve</code>，
group（组）：<code>certificates.k8s.io</code>，
resources（资源）：<code>signers</code>，
resourceName：<code>&lt;signerNameDomain&gt;/&lt;signerNamePath&gt;</code> 或 <code>&lt;signerNameDomain&gt;/*</code></li>
</ul>
<p>例如：</p>


 













<div class="highlight">
    <div class="copy-code-icon" style="text-align:right">
    <a href="https://raw.githubusercontent.com/kubernetes/website/main/content/zh/examples/access/certificate-signing-request/clusterrole-approve.yaml" download="access/certificate-signing-request/clusterrole-approve.yaml"><code>access/certificate-signing-request/clusterrole-approve.yaml</code>
    </a>
    <img src="/images/copycode.svg" style="max-height:24px; cursor: pointer" onclick="copyCode('access-certificate-signing-request-clusterrole-approve-yaml')" title="Copy access/certificate-signing-request/clusterrole-approve.yaml to clipboard">
    </img>
    </div>
    <div class="includecode" id="access-certificate-signing-request-clusterrole-approve-yaml">
    <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>rbac.authorization.k8s.io/v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>ClusterRole<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>csr-approver<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">rules</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">apiGroups</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- certificates.k8s.io<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">resources</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- certificatesigningrequests<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">verbs</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- get<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- list<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- watch<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">apiGroups</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- certificates.k8s.io<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">resources</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- certificatesigningrequests/approval<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">verbs</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- update<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">apiGroups</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- certificates.k8s.io<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">resources</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- signers<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">resourceNames</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- example.com/my-signer-name<span style="color:#bbb"> </span><span style="color:#080;font-style:italic"># example.com/* can be used to authorize for all signers in the &#39;example.com&#39; domain</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">verbs</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- approve<span style="color:#bbb">
</span><span style="color:#bbb">
</span></code></pre></div>
    </div>
</div>


<!-- 
To allow signing a CertificateSigningRequest:

* Verbs: `get`, `list`, `watch`, group: `certificates.k8s.io`, resource: `certificatesigningrequests`
* Verbs: `update`, group: `certificates.k8s.io`, resource: `certificatesigningrequests/status`
* Verbs: `sign`, group: `certificates.k8s.io`, resource: `signers`, resourceName: `<signerNameDomain>/<signerNamePath>` or `<signerNameDomain>/*`
-->
<p>授权签名 CertificateSigningRequest：</p>
<ul>
<li>verbs（动词）：<code>get</code>、<code>list</code>、<code>watch</code>，
group（组）：<code>certificates.k8s.io</code>，
resources（资源）：<code>certificatesigningrequests</code></li>
<li>verbs（动词）：<code>update</code>，
group（组）：<code>certificates.k8s.io</code>，
resources（资源）：<code>certificatesigningrequests/status</code></li>
<li>verbs（动词）：<code>sign</code>，
group（组）：<code>certificates.k8s.io</code>，
resources（资源）：<code>signers</code>，
resourceName：<code>&lt;signerNameDomain&gt;/&lt;signerNamePath&gt;</code> 或 <code>&lt;signerNameDomain&gt;/*</code></li>
</ul>


 













<div class="highlight">
    <div class="copy-code-icon" style="text-align:right">
    <a href="https://raw.githubusercontent.com/kubernetes/website/main/content/zh/examples/access/certificate-signing-request/clusterrole-sign.yaml" download="access/certificate-signing-request/clusterrole-sign.yaml"><code>access/certificate-signing-request/clusterrole-sign.yaml</code>
    </a>
    <img src="/images/copycode.svg" style="max-height:24px; cursor: pointer" onclick="copyCode('access-certificate-signing-request-clusterrole-sign-yaml')" title="Copy access/certificate-signing-request/clusterrole-sign.yaml to clipboard">
    </img>
    </div>
    <div class="includecode" id="access-certificate-signing-request-clusterrole-sign-yaml">
    <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>rbac.authorization.k8s.io/v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>ClusterRole<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>csr-signer<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">rules</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">apiGroups</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- certificates.k8s.io<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">resources</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- certificatesigningrequests<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">verbs</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- get<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- list<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- watch<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">apiGroups</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- certificates.k8s.io<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">resources</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- certificatesigningrequests/status<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">verbs</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- update<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">apiGroups</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- certificates.k8s.io<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">resources</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- signers<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">resourceNames</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- example.com/my-signer-name<span style="color:#bbb"> </span><span style="color:#080;font-style:italic"># example.com/* can be used to authorize for all signers in the &#39;example.com&#39; domain</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">verbs</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- sign<span style="color:#bbb">
</span></code></pre></div>
    </div>
</div>


<!-- 
## Normal User

A few steps are required in order to get a normal user to be able to
authenticate and invoke an API. First, this user must have certificate issued
by the Kubernetes cluster, and then present that Certificate to the API call
as the Certificate Header or through the kubectl.
-->
<h2 id="normal-user">普通用户</h2>
<p>为了让普通用户能够通过认证并调用 API，需要执行几个步骤。
首先，该用户必须拥有 Kubernetes 集群签发的证书，
然后将该证书作为 API 调用的 Certificate 头或通过 kubectl 提供。</p>
<!-- 
### Create private key

The following scripts show how to generate PKI private key and CSR. It is
important to set CN and O attribute of the CSR. CN is the name of the user and
O is the group that this user will belong to. You can refer to
[RBAC](/docs/reference/access-authn-authz/rbac/) for standard groups.
-->
<h3 id="create-private-key">创建私钥</h3>
<p>下面的脚本展示了如何生成 PKI 私钥和 CSR。
设置 CSR 的 CN 和 O 属性很重要。CN 是用户名，O 是该用户归属的组。
你可以参考 <a href="/zh/docs/reference/access-authn-authz/rbac/">RBAC</a> 了解标准组的信息。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">openssl genrsa -out myuser.key <span style="color:#666">2048</span>
openssl req -new -key myuser.key -out myuser.csr
</code></pre></div><!-- 
### Create CertificateSigningRequest

Create a CertificateSigningRequest and submit it to a Kubernetes Cluster via kubectl. 
Below is a script to generate the CertificateSigningRequest.
-->
<h3 id="create-certificatesigningrequest">创建 CertificateSigningRequest</h3>
<p>创建一个 CertificateSigningRequest，并通过 kubectl 将其提交到 Kubernetes 集群。
下面是生成 CertificateSigningRequest 的脚本。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">cat <span style="color:#b44">&lt;&lt;EOF | kubectl apply -f -
</span><span style="color:#b44">apiVersion: certificates.k8s.io/v1
</span><span style="color:#b44">kind: CertificateSigningRequest
</span><span style="color:#b44">metadata:
</span><span style="color:#b44">  name: myuser
</span><span style="color:#b44">spec:
</span><span style="color:#b44">  groups:
</span><span style="color:#b44">  - system:authenticated
</span><span style="color:#b44">  request: LS0tLS1CRUdJTiBDRVJUSUZJQ0FURSBSRVFVRVNULS0tLS0KTUlJQ1ZqQ0NBVDRDQVFBd0VURVBNQTBHQTFVRUF3d0dZVzVuWld4aE1JSUJJakFOQmdrcWhraUc5dzBCQVFFRgpBQU9DQVE4QU1JSUJDZ0tDQVFFQTByczhJTHRHdTYxakx2dHhWTTJSVlRWMDNHWlJTWWw0dWluVWo4RElaWjBOCnR2MUZtRVFSd3VoaUZsOFEzcWl0Qm0wMUFSMkNJVXBGd2ZzSjZ4MXF3ckJzVkhZbGlBNVhwRVpZM3ExcGswSDQKM3Z3aGJlK1o2MVNrVHF5SVBYUUwrTWM5T1Nsbm0xb0R2N0NtSkZNMUlMRVI3QTVGZnZKOEdFRjJ6dHBoaUlFMwpub1dtdHNZb3JuT2wzc2lHQ2ZGZzR4Zmd4eW8ybmlneFNVekl1bXNnVm9PM2ttT0x1RVF6cXpkakJ3TFJXbWlECklmMXBMWnoyalVnald4UkhCM1gyWnVVV1d1T09PZnpXM01LaE8ybHEvZi9DdS8wYk83c0x0MCt3U2ZMSU91TFcKcW90blZtRmxMMytqTy82WDNDKzBERHk5aUtwbXJjVDBnWGZLemE1dHJRSURBUUFCb0FBd0RRWUpLb1pJaHZjTgpBUUVMQlFBRGdnRUJBR05WdmVIOGR4ZzNvK21VeVRkbmFjVmQ1N24zSkExdnZEU1JWREkyQTZ1eXN3ZFp1L1BVCkkwZXpZWFV0RVNnSk1IRmQycVVNMjNuNVJsSXJ3R0xuUXFISUh5VStWWHhsdnZsRnpNOVpEWllSTmU3QlJvYXgKQVlEdUI5STZXT3FYbkFvczFqRmxNUG5NbFpqdU5kSGxpT1BjTU1oNndLaTZzZFhpVStHYTJ2RUVLY01jSVUyRgpvU2djUWdMYTk0aEpacGk3ZnNMdm1OQUxoT045UHdNMGM1dVJVejV4T0dGMUtCbWRSeEgvbUNOS2JKYjFRQm1HCkkwYitEUEdaTktXTU0xMzhIQXdoV0tkNjVoVHdYOWl4V3ZHMkh4TG1WQzg0L1BHT0tWQW9FNkpsYWFHdTlQVmkKdjlOSjVaZlZrcXdCd0hKbzZXdk9xVlA3SVFjZmg3d0drWm89Ci0tLS0tRU5EIENFUlRJRklDQVRFIFJFUVVFU1QtLS0tLQo=
</span><span style="color:#b44">  signerName: kubernetes.io/kube-apiserver-client
</span><span style="color:#b44">  usages:
</span><span style="color:#b44">  - client auth
</span><span style="color:#b44">EOF</span>
</code></pre></div><!-- 
Some points to note:

- `usages` has to be '`client auth`'
- `request` is the base64 encoded value of the CSR file content.
  You can get the content using this command: ```cat myuser.csr | base64 | tr -d "\n"```
-->
<p>需要注意的几点:</p>
<ul>
<li><code>usage</code> 字段必须是 '<code>client auth</code>'</li>
<li><code>request</code> 字段是 CSR 文件内容的 base64 编码值。
要得到该值，可以执行命令 <code>cat myuser.csr | base64 | tr -d &quot;\n&quot;</code>。</li>
</ul>
<!-- 
### Approve certificate signing request

Use kubectl to create a CSR and approve it.

Get the list of CSRs:
-->
<h3 id="approve-certificate-signing-request">批准证书签名请求</h3>
<p>使用 kubectl 创建 CSR 并批准。</p>
<p>获取 CSR 列表：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl get csr
</code></pre></div><!-- 
Approve the CSR:
-->
<p>批准 CSR：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl certificate approve myuser
</code></pre></div><!-- 
### Get the certificate

Retrieve the certificate from the CSR.
-->
<h3 id="get-the-certificate">取得证书</h3>
<p>从 CSR 取得证书：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl get csr/myuser -o yaml
</code></pre></div><!-- 
The Certificate value is in Base64-encoded format under `status.certificate`.

Export the issued certificate from the CertificateSigningRequest.

-->
<p>证书的内容使用 base64 编码，存放在字段 <code>status.certificate</code>。</p>
<p>从 CertificateSigningRequest 导出颁发的证书。</p>
<pre tabindex="0"><code>kubectl get csr myuser -o jsonpath='{.status.certificate}'| base64 -d &gt; myuser.crt
</code></pre><!--
### Create Role and Role Binding

With the certificate created. it is time to define the Role and RoleBinding for
this user to access Kubernetes cluster resources.

This is a sample script to create Role for this new user
-->
<h3 id="create-role-and-role-binding">创建角色和角色绑定</h3>
<p>创建了证书之后，为了让这个用户能访问 Kubernetes 集群资源，现在就要创建
Role 和 RoleBinding 了。</p>
<p>下面是为这个新用户创建 Role 的示例脚本：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl create role developer --verb<span style="color:#666">=</span>create --verb<span style="color:#666">=</span>get --verb<span style="color:#666">=</span>list --verb<span style="color:#666">=</span>update --verb<span style="color:#666">=</span>delete --resource<span style="color:#666">=</span>pods
</code></pre></div><!-- 
This is a sample command to create a RoleBinding for this new user:
-->
<p>下面是为这个新用户创建 RoleBinding 的示例命令：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl create rolebinding developer-binding-myuser --role<span style="color:#666">=</span>developer --user<span style="color:#666">=</span>myuser
</code></pre></div><!-- 
### Add to kubeconfig

The last step is to add this user into the kubeconfig file.

First, we need to add new credentials:
-->
<h3 id="add-to-kubeconfig">添加到 kubeconfig  </h3>
<p>最后一步是将这个用户添加到 kubeconfig 文件。
我们假设私钥和证书文件存放在 “/home/vagrant/work/” 目录中。</p>
<p>首先，我们需要添加新的凭据：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl config set-credentials myuser --client-key<span style="color:#666">=</span>myuser.key --client-certificate<span style="color:#666">=</span>myuser.crt --embed-certs<span style="color:#666">=</span><span style="color:#a2f">true</span>

</code></pre></div><!-- 
Then, you need to add the context:
-->
<p>然后，你需要添加上下文：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl config set-context myuser --cluster<span style="color:#666">=</span>kubernetes --user<span style="color:#666">=</span>myuser
</code></pre></div><!-- 
To test it, change the context to `myuser`:
-->
<p>来测试一下，把上下文切换为 <code>myuser</code>：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl config use-context myuser
</code></pre></div><!-- 
## Approval or rejection   {#approval-rejection}

### Control plane automated approval {#approval-rejection-control-plane}

The kube-controller-manager ships with a built-in approver for certificates with
a signerName of `kubernetes.io/kube-apiserver-client-kubelet` that delegates various
permissions on CSRs for node credentials to authorization.
The kube-controller-manager POSTs SubjectAccessReview resources to the API server
in order to check authorization for certificate approval.
-->
<h2 id="approval-rejection">批准和驳回</h2>
<h3 id="approval-rejection-control-plane">控制平面的自动化批准</h3>
<p>kube-controller-manager 内建了一个证书批准者，其 signerName 为
<code>kubernetes.io/kube-apiserver-client-kubelet</code>，
该批准者将 CSR 上用于节点凭据的各种权限委托给权威认证机构。
kube-controller-manager 将 SubjectAccessReview 资源发送（POST）到 API 服务器，
以便检验批准证书的授权。</p>
<!-- 
### Approval or rejection using `kubectl` {#approval-rejection-kubectl}

A Kubernetes administrator (with appropriate permissions) can manually approve
(or deny) CertificateSigningRequests by using the `kubectl certificate
approve` and `kubectl certificate deny` commands.

To approve a CSR with kubectl:
-->
<h3 id="approval-rejection-kubectl">使用 <code>kubectl</code> 批准或驳回  </h3>
<p>Kubernetes 管理员（拥有足够的权限）可以手工批准（或驳回）CertificateSigningRequests，
此操作使用 <code>kubectl certificate approve</code> 和 <code>kubectl certificate deny</code> 命令实现。</p>
<p>使用 kubectl 批准一个 CSR：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl certificate approve &lt;certificate-signing-request-name&gt;
</code></pre></div><!-- 
Likewise, to deny a CSR: 
-->
<p>同样地，驳回一个 CSR：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl certificate deny &lt;certificate-signing-request-name&gt;
</code></pre></div><!-- 
### Approval or rejection using the Kubernetes API {#approval-rejection-api-client}

Users of the REST API can approve CSRs by submitting an UPDATE request to the `approval`
subresource of the CSR to be approved. For example, you could write an
<a class='glossary-tooltip' title='一种用于管理自定义资源的专用控制器' data-toggle='tooltip' data-placement='top' href='/zh/docs/concepts/extend-kubernetes/operator/' target='_blank' aria-label='operator'>operator</a> that watches for a particular
kind of CSR and then sends an UPDATE to approve them.

When you make an approval or rejection request, set either the `Approved` or `Denied`
status condition based on the state you determine:

For `Approved` CSRs:
-->
<h3 id="approval-rejection-api-client">使用 Kubernetes API 批准或驳回 </h3>
<p>REST API 的用户可以通过向待批准的 CSR 的 <code>approval</code> 子资源提交更新请求来批准 CSR。
例如，你可以编写一个
<a class='glossary-tooltip' title='一种用于管理自定义资源的专用控制器' data-toggle='tooltip' data-placement='top' href='/zh/docs/concepts/extend-kubernetes/operator/' target='_blank' aria-label='operator'>operator</a>
来监视特定类型的 CSR，然后发送一个更新来批准它。</p>
<p>当你发出批准或驳回的指令时，根据你期望的状态来选择设置 <code>Approved</code> 或 <code>Denied</code>。</p>
<p>批准（<code>Approved</code>） 的 CSR：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>certificates.k8s.io/v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>CertificateSigningRequest<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#00f;font-weight:bold">...</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">status</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">conditions</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- <span style="color:#008000;font-weight:bold">lastUpdateTime</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;2020-02-08T11:37:35Z&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">lastTransitionTime</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;2020-02-08T11:37:35Z&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">message</span>:<span style="color:#bbb"> </span>Approved by my custom approver controller<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">reason</span>:<span style="color:#bbb"> </span>ApprovedByMyPolicy<span style="color:#bbb"> </span><span style="color:#080;font-style:italic"># You can set this to any string</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">type</span>:<span style="color:#bbb"> </span>Approved<span style="color:#bbb">
</span></code></pre></div><!-- 
For `Denied` CSRs:
-->
<p>驳回（<code>Denied</code>）的 CRS：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>certificates.k8s.io/v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>CertificateSigningRequest<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#00f;font-weight:bold">...</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">status</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">conditions</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- <span style="color:#008000;font-weight:bold">lastUpdateTime</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;2020-02-08T11:37:35Z&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">lastTransitionTime</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;2020-02-08T11:37:35Z&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">message</span>:<span style="color:#bbb"> </span>Denied by my custom approver controller<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">reason</span>:<span style="color:#bbb"> </span>DeniedByMyPolicy<span style="color:#bbb"> </span><span style="color:#080;font-style:italic"># You can set this to any string</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">type</span>:<span style="color:#bbb"> </span>Denied<span style="color:#bbb">
</span></code></pre></div><!-- 
It's usual to set `status.conditions.reason` to a machine-friendly reason
code using TitleCase; this is a convention but you can set it to anything
you like. If you want to add a note for human consumption, use the
`status.conditions.message` field.
-->
<p><code>status.conditions.reason</code> 字段通常设置为一个首字母大写的对机器友好的原因码;
这是一个命名约定，但你也可以随你的个人喜好设置。
如果你想添加一个供人类使用的注释，那就用 <code>status.conditions.message</code>  字段。</p>
<!-- 
## Signing

### Control plane signer {#signer-control-plane}

The Kubernetes control plane implements each of the
[Kubernetes signers](/docs/reference/access-authn-authz/certificate-signing-requests/#kubernetes-signers),
as part of the kube-controller-manager.

Prior to Kubernetes v1.18, the kube-controller-manager would sign any CSRs that
were marked as approved.
-->
<h2 id="signing">签名  </h2>
<h3 id="signer-control-plane">控制平面签名者   </h3>
<p>Kubernetes 控制平面实现了每一个
<a href="/zh/docs/reference/access-authn-authz/certificate-signing-requests/#kubernetes-signers">Kubernetes 签名者</a>，
每个签名者的实现都是 kube-controller-manager 的一部分。</p>
<blockquote class="note callout">
  <div><strong>说明：</strong> 在Kubernetes v1.18 之前，
kube-controller-manager 签名所有标记为 approved  的 CSR。</div>
</blockquote>
<!-- 
### API-based signers {#signer-api}

Users of the REST API can sign CSRs by submitting an UPDATE request to the `status`
subresource of the CSR to be signed.

As part of this request, the `status.certificate` field should be set to contain the
signed certificate. This field contains one or more PEM-encoded certificates.

All PEM blocks must have the "CERTIFICATE" label, contain no headers,
and the encoded data must be a BER-encoded ASN.1 Certificate structure
as described in [section 4 of RFC5280](https://tools.ietf.org/html/rfc5280#section-4.1).

Example certificate content:
-->
<h3 id="signer-api">基于 API 的签名者  </h3>
<p>REST API 的用户可以通过向待签名的 CSR 的 <code>status</code> 子资源提交更新请求来对 CSR 进行签名。</p>
<p>作为这个请求的一部分， <code>status.certificate</code> 字段应设置为已签名的证书。
此字段可包含一个或多个 PEM 编码的证书。</p>
<p>所有的 PEM 块必须具备 &quot;CERTIFICATE&quot; 标签，且不包含文件头，且编码的数据必须是
<a href="https://tools.ietf.org/html/rfc5280#section-4.1">RFC5280 第 4 节</a>
中描述的 BER 编码的 ASN.1 证书结构。</p>
<pre tabindex="0"><code>-----BEGIN CERTIFICATE-----
MIIDgjCCAmqgAwIBAgIUC1N1EJ4Qnsd322BhDPRwmg3b/oAwDQYJKoZIhvcNAQEL
BQAwXDELMAkGA1UEBhMCeHgxCjAIBgNVBAgMAXgxCjAIBgNVBAcMAXgxCjAIBgNV
BAoMAXgxCjAIBgNVBAsMAXgxCzAJBgNVBAMMAmNhMRAwDgYJKoZIhvcNAQkBFgF4
MB4XDTIwMDcwNjIyMDcwMFoXDTI1MDcwNTIyMDcwMFowNzEVMBMGA1UEChMMc3lz
dGVtOm5vZGVzMR4wHAYDVQQDExVzeXN0ZW06bm9kZToxMjcuMC4wLjEwggEiMA0G
CSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDne5X2eQ1JcLZkKvhzCR4Hxl9+ZmU3
+e1zfOywLdoQxrPi+o4hVsUH3q0y52BMa7u1yehHDRSaq9u62cmi5ekgXhXHzGmm
kmW5n0itRECv3SFsSm2DSghRKf0mm6iTYHWDHzUXKdm9lPPWoSOxoR5oqOsm3JEh
Q7Et13wrvTJqBMJo1GTwQuF+HYOku0NF/DLqbZIcpI08yQKyrBgYz2uO51/oNp8a
sTCsV4OUfyHhx2BBLUo4g4SptHFySTBwlpRWBnSjZPOhmN74JcpTLB4J5f4iEeA7
2QytZfADckG4wVkhH3C2EJUmRtFIBVirwDn39GXkSGlnvnMgF3uLZ6zNAgMBAAGj
YTBfMA4GA1UdDwEB/wQEAwIFoDATBgNVHSUEDDAKBggrBgEFBQcDAjAMBgNVHRMB
Af8EAjAAMB0GA1UdDgQWBBTREl2hW54lkQBDeVCcd2f2VSlB1DALBgNVHREEBDAC
ggAwDQYJKoZIhvcNAQELBQADggEBABpZjuIKTq8pCaX8dMEGPWtAykgLsTcD2jYr
L0/TCrqmuaaliUa42jQTt2OVsVP/L8ofFunj/KjpQU0bvKJPLMRKtmxbhXuQCQi1
qCRkp8o93mHvEz3mTUN+D1cfQ2fpsBENLnpS0F4G/JyY2Vrh19/X8+mImMEK5eOy
o0BMby7byUj98WmcUvNCiXbC6F45QTmkwEhMqWns0JZQY+/XeDhEcg+lJvz9Eyo2
aGgPsye1o3DpyXnyfJWAWMhOz7cikS5X2adesbgI86PhEHBXPIJ1v13ZdfCExmdd
M1fLPhLyR54fGaY+7/X8P9AZzPefAkwizeXwe9ii6/a08vWoiE4=
-----END CERTIFICATE-----
</code></pre><!-- 
Non-PEM content may appear before or after the CERTIFICATE PEM blocks and is unvalidated,
to allow for explanatory text as described in section 5.2 of RFC7468.

When encoded in JSON or YAML, this field is base-64 encoded.
A CertificateSigningRequest containing the example certificate above would look like this:
-->
<p>非 PEM 内容可能会出现在证书 PEM 块前后的位置，且未经验证，
以允许使用 RFC7468 第5.2节 中描述的解释性文本。</p>
<p>当使用 JSON 或 YAML 格式时，此字段是 base-64 编码。
包含上述示例证书的 CertificateSigningRequest 如下所示：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>certificates.k8s.io/v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>CertificateSigningRequest<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#00f;font-weight:bold">...</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">status</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">certificate</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JS...&#34;</span><span style="color:#bbb">
</span></code></pre></div><h2 id="接下来">接下来</h2>
<!-- 
* Read [Manage TLS Certificates in a Cluster](/docs/tasks/tls/managing-tls-in-a-cluster/)
* View the source code for the kube-controller-manager built in [signer](https://github.com/kubernetes/kubernetes/blob/32ec6c212ec9415f604ffc1f4c1f29b782968ff1/pkg/controller/certificates/signer/cfssl_signer.go)
* View the source code for the kube-controller-manager built in [approver](https://github.com/kubernetes/kubernetes/blob/32ec6c212ec9415f604ffc1f4c1f29b782968ff1/pkg/controller/certificates/approver/sarapprove.go)
* For details of X.509 itself, refer to [RFC 5280](https://tools.ietf.org/html/rfc5280#section-3.1) section 3.1
* For information on the syntax of PKCS#10 certificate signing requests, refer to [RFC 2986](https://tools.ietf.org/html/rfc2986)
-->
<ul>
<li>参阅 <a href="/zh/docs/tasks/tls/managing-tls-in-a-cluster/">管理集群中的 TLS 认证</a></li>
<li>查看 kube-controller-manager 中<a href="https://github.com/kubernetes/kubernetes/blob/32ec6c212ec9415f604ffc1f4c1f29b782968ff1/pkg/controller/certificates/signer/cfssl_signer.go">签名者</a>部分的源代码</li>
<li>查看 kube-controller-manager 中<a href="https://github.com/kubernetes/kubernetes/blob/32ec6c212ec9415f604ffc1f4c1f29b782968ff1/pkg/controller/certificates/approver/sarapprove.go">批准者</a>部分的源代码</li>
<li>有关 X.509 本身的详细信息，请参阅 <a href="https://tools.ietf.org/html/rfc5280#section-3.1">RFC 5280</a> 第3.1节</li>
<li>有关 PKCS#10 证书签名请求语法的信息，请参阅 <a href="https://tools.ietf.org/html/rfc2986">RFC 2986</a></li>
</ul>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-518807b9b00bda46d7c7e6e0b17c18f8">4.4 - 使用准入控制器</h1>
    
	<!--
reviewers:
- lavalamp
- davidopp
- derekwaynecarr
- erictune
- janetkuo
- thockin
title: Using Admission Controllers
content_type: concept
weight: 30
-->
<!-- overview -->
<!--
This page provides an overview of Admission Controllers.
-->
<p>此页面概述了准入控制器。</p>
<!-- body -->
<!--
## What are they?
-->
<h2 id="什么是准入控制插件">什么是准入控制插件？</h2>
<!--
An admission controller is a piece of code that intercepts requests to the
Kubernetes API server prior to persistence of the object, but after the request
is authenticated and authorized.  The controllers consist of the
[list](#what-does-each-admission-controller-do) below, are compiled into the
`kube-apiserver` binary, and may only be configured by the cluster
administrator. In that list, there are two special controllers:
MutatingAdmissionWebhook and ValidatingAdmissionWebhook.  These execute the
mutating and validating (respectively) [admission control
webhooks](/docs/reference/access-authn-authz/extensible-admission-controllers/#admission-webhooks)
which are configured in the API.
-->
<p>准入控制器是一段代码，它会在请求通过认证和授权之后、对象被持久化之前拦截到达 API
服务器的请求。控制器由下面的<a href="#what-does-each-admission-controller-do">列表</a>组成，
并编译进 <code>kube-apiserver</code> 二进制文件，并且只能由集群管理员配置。
在该列表中，有两个特殊的控制器：MutatingAdmissionWebhook 和 ValidatingAdmissionWebhook。
它们根据 API 中的配置，分别执行变更和验证
<a href="/zh/docs/reference/access-authn-authz/extensible-admission-controllers/#admission-webhooks">准入控制 webhook</a>。</p>
<!--
Admission controllers may be "validating", "mutating", or both. Mutating
controllers may modify the objects they admit; validating controllers may not.

The admission control process proceeds in two phases. In the first phase,
mutating admission controllers are run. In the second phase, validating
admission controllers are run. Note again that some of the controllers are
both.

If any of the controllers in either phase reject the request, the entire
request is rejected immediately and an error is returned to the end-user.
-->
<p>准入控制器可以执行 “验证（Validating）” 和/或 “变更（Mutating）” 操作。
变更（mutating）控制器可以修改被其接受的对象；验证（validating）控制器则不行。</p>
<p>准入控制过程分为两个阶段。第一阶段，运行变更准入控制器。第二阶段，运行验证准入控制器。
再次提醒，某些控制器既是变更准入控制器又是验证准入控制器。</p>
<p>如果任何一个阶段的任何控制器拒绝了该请求，则整个请求将立即被拒绝，并向终端用户返回一个错误。</p>
<!--
Finally, in addition to sometimes mutating the object in question, admission
controllers may sometimes have side effects, that is, mutate related
resources as part of request processing. Incrementing quota usage is the
canonical example of why this is necessary. Any such side-effect needs a
corresponding reclamation or reconciliation process, as a given admission
controller does not know for sure that a given request will pass all of the
other admission controllers.
-->
<p>最后，除了对对象进行变更外，准入控制器还可以有其它作用：将相关资源作为请求处理的一部分进行变更。
增加使用配额就是一个典型的示例，说明了这样做的必要性。
此类用法都需要相应的回收或回调过程，因为任一准入控制器都无法确定某个请求能否通过所有其它准入控制器。</p>
<!--
## Why do I need them?
-->
<h2 id="为什么需要准入控制器">为什么需要准入控制器？</h2>
<!--
Many advanced features in Kubernetes require an admission controller to be enabled in order
to properly support the feature.  As a result, a Kubernetes API server that is not properly
configured with the right set of admission controllers is an incomplete server and will not
support all the features you expect.
-->
<p>Kubernetes 的许多高级功能都要求启用一个准入控制器，以便正确地支持该特性。
因此，没有正确配置准入控制器的 Kubernetes API 服务器是不完整的，它无法支持你期望的所有特性。</p>
<!--
## How do I turn on an admission controller?
-->
<h2 id="如何启用一个准入控制器">如何启用一个准入控制器？</h2>
<!--
The Kubernetes API server flag `enable-admission-plugins` takes a comma-delimited list of admission control plugins to invoke prior to modifying objects in the cluster.
For example, the following command line enables the `NamespaceLifecycle` and the `LimitRanger`
admission control plugins:
-->
<p>Kubernetes API 服务器的 <code>enable-admission-plugins</code> 标志接受一个用于在集群修改对象之前
调用的（以逗号分隔的）准入控制插件顺序列表。</p>
<p>例如，下面的命令就启用了 <code>NamespaceLifecycle</code> 和 <code>LimitRanger</code> 准入控制插件：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kube-apiserver --enable-admission-plugins<span style="color:#666">=</span>NamespaceLifecycle,LimitRanger ...
</code></pre></div><blockquote class="note callout">
  <div><strong>说明：</strong> <!--
Depending on the way your Kubernetes cluster is deployed and how the API server is
started, you may need to apply the settings in different ways. For example, you may
have to modify the systemd unit file if the API server is deployed as a systemd
service, you may modify the manifest file for the API server if Kubernetes is deployed
in a self-hosted way.
-->
<p>根据你 Kubernetes 集群的部署方式以及 API 服务器的启动方式的不同，你可能需要以不同的方式应用设置。
例如，如果将 API 服务器部署为 systemd 服务，你可能需要修改 systemd 单元文件；
如果以自托管方式部署 Kubernetes，你可能需要修改 API 服务器的清单文件。</div>
</blockquote>
<!--
## How do I turn off an admission controller?

The Kubernetes API server flag `disable-admission-plugins` takes a comma-delimited list of admission control plugins to be disabled, even if they are in the list of plugins enabled by default.
-->
<h2 id="怎么关闭准入控制器">怎么关闭准入控制器？</h2>
<p>Kubernetes API 服务器的 <code>disable-admission-plugins</code> 标志，会将传入的（以逗号分隔的）
准入控制插件列表禁用，即使是默认启用的插件也会被禁用。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kube-apiserver --disable-admission-plugins<span style="color:#666">=</span>PodNodeSelector,AlwaysDeny ...
</code></pre></div><!--
## Which plugins are enabled by default?

To see which admission plugins are enabled:
-->
<h2 id="哪些插件是默认启用的">哪些插件是默认启用的？</h2>
<p>下面的命令可以查看哪些插件是默认启用的：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kube-apiserver -h | grep enable-admission-plugins
</code></pre></div><!--
In the current version, the default ones are:
-->
<p>在目前版本中，它们是：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">CertificateApproval, CertificateSigning, CertificateSubjectRestriction, DefaultIngressClass, DefaultStorageClass, DefaultTolerationSeconds, LimitRanger, MutatingAdmissionWebhook, NamespaceLifecycle, PersistentVolumeClaimResize, Priority, ResourceQuota, RuntimeClass, ServiceAccount, StorageObjectInUseProtection, TaintNodesByCondition, ValidatingAdmissionWebhook
</code></pre></div><!--
## What does each admission controller do?

### AlwaysAdmit {#alwaysadmit} 




<div style="margin-top: 10px; margin-bottom: 10px;">
<b>FEATURE STATE:</b> <code>Kubernetes v1.13 [deprecated]</code>
</div>


This admission controller allows all pods into the cluster. It is deprecated because its behavior is the same as if there were no admission controller at all.
-->
<h2 id="每个准入控制器的作用是什么">每个准入控制器的作用是什么？</h2>
<h3 id="alwaysadmit">AlwaysAdmit</h3>





<div style="margin-top: 10px; margin-bottom: 10px;">
<b>FEATURE STATE:</b> <code>Kubernetes v1.13 [deprecated]</code>
</div>

<p>该准入控制器会允许所有的 pod 接入集群。已废弃，因为它的行为根本就和没有准入控制器一样。</p>
<h3 id="alwaysdeny">AlwaysDeny</h3>





<div style="margin-top: 10px; margin-bottom: 10px;">
<b>FEATURE STATE:</b> <code>Kubernetes v1.13 [deprecated]</code>
</div>

<!--
Rejects all requests. AlwaysDeny is DEPRECATED as it has no real meaning.
-->
<p>拒绝所有的请求。由于它没有实际意义，已废弃。</p>
<h3 id="alwayspullimages">AlwaysPullImages</h3>
<!--
This admission controller modifies every new Pod to force the image pull policy to Always. This is useful in a
multitenant cluster so that users can be assured that their private images can only be used by those
who have the credentials to pull them. Without this admission controller, once an image has been pulled to a
node, any pod from any user can use it by knowing the image's name (assuming the Pod is
scheduled onto the right node), without any authorization check against the image. When this admission controller
is enabled, images are always pulled prior to starting containers, which means valid credentials are
required.
-->
<p>该准入控制器会修改每一个新创建的 Pod 的镜像拉取策略为 Always 。
这在多租户集群中是有用的，这样用户就可以放心，他们的私有镜像只能被那些有凭证的人使用。
如果没有这个准入控制器，一旦镜像被拉取到节点上，任何用户的 Pod 都可以通过已了解到的镜像
的名称（假设 Pod 被调度到正确的节点上）来使用它，而不需要对镜像进行任何授权检查。
当启用这个准入控制器时，总是在启动容器之前拉取镜像，这意味着需要有效的凭证。</p>
<h3 id="certificateapproval">CertificateApproval</h3>
<!--
This admission controller observes requests to 'approve' CertificateSigningRequest resources
and performs additional authorization checks to ensure the approving user has permission 
to approve certificate requests with the spec.signerName requested on the CertificateSigningRequest resource.
-->
<p>此准入控制器获取“审批” CertificateSigningRequest 资源的请求并执行额外的授权检查，
以确保审批请求的用户有权限审批 <code>spec.signerName</code> 请求 CertificateSigningRequest 资源的证书请求。</p>
<!--
See Certificate Signing Requests for more information on the permissions required 
to perform different actions on CertificateSigningRequest resources.
-->
<p>有关对证书签名请求资源执行不同操作所需权限的详细信息，
请参阅<a href="/zh/docs/reference/access-authn-authz/certificate-signing-requests/">证书签名请求</a></p>
<h3 id="certificatesigning">CertificateSigning</h3>
<!--
This admission controller observes updates to the status.certificate field of CertificateSigningRequest resources 
and performs an additional authorization checks to ensure the signing user has permission 
to sign certificate requests with the spec.signerName requested on the CertificateSigningRequest resource.
-->
<p>此准入控制器获取 CertificateSigningRequest 资源的 <code>status.certificate</code> 字段更新请求并执行额外的授权检查，
以确保签发证书的用户有权限为 <code>spec.signerName</code> 请求 CertificateSigningRequest 资源的证书请求<code>签发</code>证书。</p>
<!--
See Certificate Signing Requests for more information on the permissions required 
to perform different actions on CertificateSigningRequest resources.
-->
<p>有关对证书签名请求资源执行不同操作所需权限的详细信息，
请参阅<a href="/zh/docs/reference/access-authn-authz/certificate-signing-requests/">证书签名请求</a></p>
<h3 id="certificatesubjectrestrictions">CertificateSubjectRestrictions</h3>
<!--
This admission controller observes creation of CertificateSigningRequest resources 
that have a spec.signerName of kubernetes.io/kube-apiserver-client. It rejects any request 
that specifies a 'group' (or 'organization attribute') of system:masters.
-->
<p>此准入控制器获取具有 <code>kubernetes.io/kube-apiserver-client</code> 的 <code>spec.signerName</code> 的
CertificateSigningRequest 资源创建请求，
它拒绝任何包含了 <code>system:masters</code> 一个“组”（或者“组织”）的请求。</p>
<h3 id="defaultingressclass">DefaultIngressClass</h3>
<!--
This admission controller observes creation of `Ingress` objects that do not request any specific
ingress class and automatically adds a default ingress class to them.  This way, users that do not
request any special ingress class do not need to care about them at all and they will get the
default one.
-->
<p>该准入控制器监测没有请求任何特定 Ingress 类的 <code>Ingress</code> 对象的创建，并自动向其添加默认 Ingress 类。
这样，没有任何特殊 Ingress 类需求的用户根本不需要关心它们，它们将获得默认 Ingress 类。</p>
<!--
This admission controller does not do anything when no default ingress class is configured. When more than one ingress
class is marked as default, it rejects any creation of `Ingress` with an error and an administrator
must revisit their `IngressClass` objects and mark only one as default (with the annotation
"ingressclass.kubernetes.io/is-default-class").  This admission controller ignores any `Ingress`
updates; it acts only on creation.
-->
<p>当未配置默认 Ingress 类时，此准入控制器不执行任何操作。如果将多个 Ingress 类标记为默认 Ingress 类，
它将拒绝任何创建 <code>Ingress</code> 的操作，并显示错误。
要修复此错误，管理员必须重新检查其 <code>IngressClass</code> 对象，并仅将其中一个标记为默认（通过注解
&quot;ingressclass.kubernetes.io/is-default-class&quot;）。
此准入控制器会忽略所有 <code>Ingress</code> 更新操作，仅响应创建操作。</p>
<!--
See the [ingress](/docs/concepts/services-networking/ingress/) documentation for more about ingress
classes and how to mark one as default.
-->
<p>关于 Ingress 类以及如何将 Ingress 类标记为默认的更多信息，请参见
<a href="/zh/docs/concepts/services-networking/ingress/">ingress</a>。</p>
<h3 id="defaultstorageclass">DefaultStorageClass</h3>
<!--
This admission controller observes creation of `PersistentVolumeClaim` objects that do not request any specific storage class
and automatically adds a default storage class to them.
This way, users that do not request any special storage class do not need to care about them at all and they
will get the default one.
-->
<p>该准入控制器监测没有请求任何特定存储类的 <code>PersistentVolumeClaim</code> 对象的创建，
并自动向其添加默认存储类。
这样，没有任何特殊存储类需求的用户根本不需要关心它们，它们将获得默认存储类。</p>
<!--
This admission controller does not do anything when no default storage class is configured. When more than one storage
class is marked as default, it rejects any creation of `PersistentVolumeClaim` with an error and an administrator
must revisit their `StorageClass` objects and mark only one as default.
This admission controller ignores any `PersistentVolumeClaim` updates; it acts only on creation.
-->
<p>当未配置默认存储类时，此准入控制器不执行任何操作。如果将多个存储类标记为默认存储类，
它将拒绝任何创建 <code>PersistentVolumeClaim</code> 的操作，并显示错误。
要修复此错误，管理员必须重新访问其 <code>StorageClass</code> 对象，并仅将其中一个标记为默认。
此准入控制器会忽略所有 <code>PersistentVolumeClaim</code> 更新操作，仅响应创建操作。</p>
<!--
See [persistent volume](/docs/concepts/storage/persistent-volumes/) documentation about persistent volume claims and
storage classes and how to mark a storage class as default.
-->
<p>关于持久化卷和存储类，以及如何将存储类标记为默认，请参见
<a href="/zh/docs/concepts/storage/persistent-volumes/">持久化卷</a>。</p>
<h3 id="defaulttolerationseconds">DefaultTolerationSeconds</h3>
<!--
This admission controller sets the default forgiveness toleration for pods to tolerate
the taints `notready:NoExecute` and `unreachable:NoExecute` based on the k8s-apiserver input parameters
`default-not-ready-toleration-seconds` and `default-unreachable-toleration-seconds` if the pods don't already
have toleration for taints `node.kubernetes.io/not-ready:NoExecute` or
`node.kubernetes.io/unreachable:NoExecute`.
The default value for `default-not-ready-toleration-seconds` and `default-unreachable-toleration-seconds` is 5 minutes.
-->
<p>该准入控制器基于 k8s-apiserver 输入参数 <code>default-not-ready-toleration-seconds</code> 和
<code>default-unreachable-toleration-seconds</code> 为 Pod 设置默认的容忍度，以容忍 <code>notready:NoExecute</code> 和
<code>unreachable:NoExecute</code> 污点。
（如果 Pod 尚未容忍 <code>node.kubernetes.io/not-ready：NoExecute</code> 和
<code>node.kubernetes.io/unreachable：NoExecute</code> 污点的话）
<code>default-not-ready-toleration-seconds</code> 和 <code>default-unreachable-toleration-seconds</code> 的默认值是 5 分钟。</p>
<h3 id="denyescalatingexec">DenyEscalatingExec</h3>





<div style="margin-top: 10px; margin-bottom: 10px;">
<b>FEATURE STATE:</b> <code>Kubernetes v1.13 [deprecated]</code>
</div>

<!--
This admission controller will deny exec and attach commands to pods that run with escalated privileges that
allow host access.  This includes pods that run as privileged, have access to the host IPC namespace, and
have access to the host PID namespace.
-->
<p>该准入控制器将拒绝在由于拥有升级特权，而具备访问宿主机能力的 Pod 中执行 exec 和
attach 命令。这包括在特权模式运行的 Pod，可以访问主机 IPC 名字空间的 Pod，
和访问主机 PID 名字空间的 Pod 。</p>
<!--
The DenyEscalatingExec admission plugin is deprecated.

Use of a policy-based admission plugin (like [PodSecurityPolicy](#podsecuritypolicy) or a custom admission plugin)
which can be targeted at specific users or Namespaces and also protects against creation of overly privileged Pods
is recommended instead.
-->
<p>DenyExecOnPrivileged 准入插件已被废弃。</p>
<p>建议使用基于策略的准入插件（例如 <a href="#podsecuritypolicy">PodSecurityPolicy</a> 和自定义准入插件），
该插件可以针对特定用户或名字空间，还可以防止创建权限过高的 Pod。</p>
<h3 id="denyexeconprivileged">DenyExecOnPrivileged</h3>





<div style="margin-top: 10px; margin-bottom: 10px;">
<b>FEATURE STATE:</b> <code>Kubernetes v1.13 [deprecated]</code>
</div>

<!--
This admission controller will intercept all requests to exec a command in a pod if that pod has a privileged container.
-->
<p>如果一个 pod 拥有一个特权容器，该准入控制器将拦截所有在该 pod 中执行 exec 命令的请求。</p>
<!--
This functionality has been merged into [DenyEscalatingExec](#denyescalatingexec).
The DenyExecOnPrivileged admission plugin is deprecated.
-->
<p>此功能已合并至 <a href="#denyescalatingexec">DenyEscalatingExec</a>。
而 DenyExecOnPrivileged 准入插件已被废弃。</p>
<!--
Use of a policy-based admission plugin (like [PodSecurityPolicy](#podsecuritypolicy) or a custom admission plugin)
which can be targeted at specific users or Namespaces and also protects against creation of overly privileged Pods
is recommended instead.
-->
<p>建议使用基于策略的准入插件（例如 <a href="#podsecuritypolicy">PodSecurityPolicy</a> 和自定义准入插件），
该插件可以针对特定用户或名字空间，还可以防止创建权限过高的 Pod。</p>
<h3 id="denyserviceexternalips">DenyServiceExternalIPs</h3>
<!--
This admission controller rejects all net-new usage of the `Service` field `externalIPs`.  This
feature is very powerful (allows network traffic interception) and not well
controlled by policy.  When enabled, users of the cluster may not create new
Services which use `externalIPs` and may not add new values to `externalIPs` on
existing `Service` objects.  Existing uses of `externalIPs` are not affected,
and users may remove values from `externalIPs` on existing `Service` objects.
-->
<p>该准入控制器拒绝 <code>Service</code> 字段 <code>externalIPs</code> 的所有新规使用。 此功能非常强大（允许网络流量拦截），
并且无法很好地受策略控制。 启用后，群集用户将无法创建使用 <code>externalIPs</code> 的新服务，也无法在现有
<code>Service</code> 对象上向 <code>externalIPs</code> 添加新值。 <code>externalIPs</code> 的现有使用不受影响，用户可以从现有
<code>Service</code> 对象上的 <code>externalIPs</code> 中删除值。</p>
<!--
Most users do not need this feature at all, and cluster admins should consider disabling it.
Clusters that do need to use this feature should consider using some custom policy to manage usage
of it.
-->
<p>大多数用户根本不需要此功能，集群管理员应考虑将其禁用。
确实需要使用此功能的集群应考虑使用一些自定义策略来管理其的使用。</p>
<h3 id="eventratelimit">EventRateLimit</h3>





<div style="margin-top: 10px; margin-bottom: 10px;">
<b>FEATURE STATE:</b> <code>Kubernetes v1.13 [alpha]</code>
</div>

<!--
This admission controller mitigates the problem where the API server gets flooded by
event requests. The cluster admin can specify event rate limits by:
-->
<p>该准入控制器缓解了事件请求淹没 API 服务器的问题。集群管理员可以通过以下方式指定事件速率限制：</p>
<!--
 * Enabling the `EventRateLimit` admission controller;
 * Referencing an `EventRateLimit` configuration file from the file provided to the API
   server's command line flag `--admission-control-config-file`:
-->
<ul>
<li>启用 <code>EventRateLimit</code> 准入控制器；</li>
<li>从文件中引用 <code>EventRateLimit</code> 配置文件，并提供给 API 服务器命令的
<code>--admission-control-config-file</code> 标志：</li>
</ul>
<ul class="nav nav-tabs" id="eventratelimit-example" role="tablist"><li class="nav-item"><a data-toggle="tab" class="nav-link active" href="#eventratelimit-example-0" role="tab" aria-controls="eventratelimit-example-0" aria-selected="true">apiserver.config.k8s.io/v1</a></li>
	  
		<li class="nav-item"><a data-toggle="tab" class="nav-link" href="#eventratelimit-example-1" role="tab" aria-controls="eventratelimit-example-1">apiserver.k8s.io/v1alpha1</a></li></ul>
<div class="tab-content" id="eventratelimit-example"><div id="eventratelimit-example-0" class="tab-pane show active" role="tabpanel" aria-labelledby="eventratelimit-example-0">

<p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>apiserver.config.k8s.io/v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>AdmissionConfiguration<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">plugins</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>EventRateLimit<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">path</span>:<span style="color:#bbb"> </span>eventconfig.yaml<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#00f;font-weight:bold">...</span><span style="color:#bbb">
</span></code></pre></div></div>
  <div id="eventratelimit-example-1" class="tab-pane" role="tabpanel" aria-labelledby="eventratelimit-example-1">

<p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#080;font-style:italic"># Deprecated in v1.17 in favor of apiserver.config.k8s.io/v1</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>apiserver.k8s.io/v1alpha1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>AdmissionConfiguration<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">plugins</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>EventRateLimit<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">path</span>:<span style="color:#bbb"> </span>eventconfig.yaml<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#00f;font-weight:bold">...</span><span style="color:#bbb">
</span></code></pre></div></div></div>

<!--
There are four types of limits that can be specified in the configuration:
-->
<p>可以在配置中指定四种类型的限制：</p>
<!--
 * `Server`: All event requests received by the API server share a single bucket.
 * `Namespace`: Each namespace has a dedicated bucket.
 * `User`: Each user is allocated a bucket.
 * `SourceAndObject`: A bucket is assigned by each combination of source and
   involved object of the event.
-->
<ul>
<li><code>Server</code>: API 服务器收到的所有事件请求共享一个桶。</li>
<li><code>Namespace</code>: 每个名字空间都有一个专用的桶。</li>
<li><code>User</code>: 给每个用户都分配一个桶。</li>
<li><code>SourceAndObject</code>: 根据事件的源和涉及对象的每种组合分配桶。</li>
</ul>
<!--
Below is a sample `eventconfig.yaml` for such a configuration:
-->
<p>下面是一个配置示例 <code>eventconfig.yaml</code>：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>eventratelimit.admission.k8s.io/v1alpha1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>Configuration<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">limits</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">type</span>:<span style="color:#bbb"> </span>Namespace<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">qps</span>:<span style="color:#bbb"> </span><span style="color:#666">50</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">burst</span>:<span style="color:#bbb"> </span><span style="color:#666">100</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">cacheSize</span>:<span style="color:#bbb"> </span><span style="color:#666">2000</span><span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">type</span>:<span style="color:#bbb"> </span>User<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">qps</span>:<span style="color:#bbb"> </span><span style="color:#666">10</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">burst</span>:<span style="color:#bbb"> </span><span style="color:#666">50</span><span style="color:#bbb">
</span></code></pre></div><!--
See the [EventRateLimit proposal](https://git.k8s.io/community/contributors/design-proposals/api-machinery/admission_control_event_rate_limit.md)
for more details.
-->
<p>详情请参见
<a href="https://git.k8s.io/community/contributors/design-proposals/api-machinery/admission_control_event_rate_limit.md">事件速率限制提案</a>。</p>
<h3 id="extendedresourcetoleration">ExtendedResourceToleration</h3>
<!--
This plug-in facilitates creation of dedicated nodes with extended resources.
If operators want to create dedicated nodes with extended resources (like GPUs, FPGAs etc.), they are expected to
[taint the node](/docs/concepts/scheduling-eviction/taint-and-toleration/#example-use-cases) with the extended resource
name as the key. This admission controller, if enabled, automatically
adds tolerations for such taints to pods requesting extended resources, so users don't have to manually
add these tolerations.
-->
<p>该插件有助于创建可扩展资源的专用节点。
如果运营商想创建可扩展资源的专用节点（如 GPU、FPGA 等），
那他们应该以扩展资源名称作为键名，
<a href="/zh/docs/concepts/scheduling-eviction/taint-and-toleration/">为节点设置污点</a>。
如果启用了该准入控制器，会将此类污点的容忍自动添加到请求扩展资源的 Pod 中，
用户不必再手动添加这些容忍。</p>
<h3 id="imagepolicywebhook">ImagePolicyWebhook</h3>
<!--
The ImagePolicyWebhook admission controller allows a backend webhook to make admission decisions.
-->
<p>ImagePolicyWebhook 准入控制器允许使用一个后端的 webhook 做出准入决策。</p>
<!--
#### Configuration File Format
-->
<h4 id="配置文件格式">配置文件格式</h4>
<!--
ImagePolicyWebhook uses a configuration file to set options for the behavior of the backend.
This file may be json or yaml and has the following format:
-->
<p>ImagePolicyWebhook 使用配置文件来为后端行为设置配置选项。该文件可以是 JSON 或 YAML，
并具有以下格式:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">imagePolicy</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">kubeConfigFile</span>:<span style="color:#bbb"> </span>/path/to/kubeconfig/for/backend<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#080;font-style:italic"># 以秒计的时长，控制批准请求的缓存时间</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">allowTTL</span>:<span style="color:#bbb"> </span><span style="color:#666">50</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#080;font-style:italic"># 以秒计的时长，控制批准请求的缓存时间</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">denyTTL</span>:<span style="color:#bbb"> </span><span style="color:#666">50</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#080;font-style:italic"># 以毫秒计的时长，控制重试间隔</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">retryBackoff</span>:<span style="color:#bbb"> </span><span style="color:#666">500</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#080;font-style:italic"># 确定 Webhook 后端失效时的行为</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">defaultAllow</span>:<span style="color:#bbb"> </span><span style="color:#a2f;font-weight:bold">true</span><span style="color:#bbb">
</span></code></pre></div><!--
Reference the ImagePolicyWebhook configuration file from the file provided to the API server's command line flag `--admission-control-config-file`:
-->
<p>从文件中引用 ImagePolicyWebhook 的配置文件，并将其提供给 API 服务器命令标志
<code>--admission-control-config-file</code>：</p>
<ul class="nav nav-tabs" id="imagepolicywebhook-example1" role="tablist"><li class="nav-item"><a data-toggle="tab" class="nav-link active" href="#imagepolicywebhook-example1-0" role="tab" aria-controls="imagepolicywebhook-example1-0" aria-selected="true">apiserver.config.k8s.io/v1</a></li>
	  
		<li class="nav-item"><a data-toggle="tab" class="nav-link" href="#imagepolicywebhook-example1-1" role="tab" aria-controls="imagepolicywebhook-example1-1">apiserver.k8s.io/v1alpha1</a></li></ul>
<div class="tab-content" id="imagepolicywebhook-example1"><div id="imagepolicywebhook-example1-0" class="tab-pane show active" role="tabpanel" aria-labelledby="imagepolicywebhook-example1-0">

<p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>apiserver.config.k8s.io/v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>AdmissionConfiguration<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">plugins</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>ImagePolicyWebhook<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">path</span>:<span style="color:#bbb"> </span>imagepolicyconfig.yaml<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#00f;font-weight:bold">...</span><span style="color:#bbb">
</span></code></pre></div></div>
  <div id="imagepolicywebhook-example1-1" class="tab-pane" role="tabpanel" aria-labelledby="imagepolicywebhook-example1-1">

<p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#080;font-style:italic"># v1.17 中已废弃以鼓励使用 apiserver.config.k8s.io/v1</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>apiserver.k8s.io/v1alpha1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>AdmissionConfiguration<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">plugins</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>ImagePolicyWebhook<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">path</span>:<span style="color:#bbb"> </span>imagepolicyconfig.yaml<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#00f;font-weight:bold">...</span><span style="color:#bbb">
</span></code></pre></div></div></div>

<!--
Alternatively, you can embed the configuration directly in the file:
-->
<p>或者，你也可以直接将配置嵌入到文件中：</p>
<ul class="nav nav-tabs" id="imagepolicywebhook-example2" role="tablist"><li class="nav-item"><a data-toggle="tab" class="nav-link active" href="#imagepolicywebhook-example2-0" role="tab" aria-controls="imagepolicywebhook-example2-0" aria-selected="true">apiserver.config.k8s.io/v1</a></li>
	  
		<li class="nav-item"><a data-toggle="tab" class="nav-link" href="#imagepolicywebhook-example2-1" role="tab" aria-controls="imagepolicywebhook-example2-1">apiserver.k8s.io/v1alpha1</a></li></ul>
<div class="tab-content" id="imagepolicywebhook-example2"><div id="imagepolicywebhook-example2-0" class="tab-pane show active" role="tabpanel" aria-labelledby="imagepolicywebhook-example2-0">

<p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>apiserver.config.k8s.io/v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>AdmissionConfiguration<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">plugins</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>ImagePolicyWebhook<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">configuration</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">imagePolicy</span>:<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">kubeConfigFile</span>:<span style="color:#bbb"> </span>&lt;kubeconfig 文件路径&gt;<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">allowTTL</span>:<span style="color:#bbb"> </span><span style="color:#666">50</span><span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">denyTTL</span>:<span style="color:#bbb"> </span><span style="color:#666">50</span><span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">retryBackoff</span>:<span style="color:#bbb"> </span><span style="color:#666">500</span><span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">defaultAllow</span>:<span style="color:#bbb"> </span><span style="color:#a2f;font-weight:bold">true</span><span style="color:#bbb">
</span></code></pre></div></div>
  <div id="imagepolicywebhook-example2-1" class="tab-pane" role="tabpanel" aria-labelledby="imagepolicywebhook-example2-1">

<p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#080;font-style:italic"># v1.17 中已废弃以鼓励使用 apiserver.config.k8s.io/v1</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>apiserver.k8s.io/v1alpha1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>AdmissionConfiguration<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">plugins</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>ImagePolicyWebhook<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">configuration</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">imagePolicy</span>:<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">kubeConfigFile</span>:<span style="color:#bbb"> </span>&lt;kubeconfig 文件路径&gt;<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">allowTTL</span>:<span style="color:#bbb"> </span><span style="color:#666">50</span><span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">denyTTL</span>:<span style="color:#bbb"> </span><span style="color:#666">50</span><span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">retryBackoff</span>:<span style="color:#bbb"> </span><span style="color:#666">500</span><span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">defaultAllow</span>:<span style="color:#bbb"> </span><span style="color:#a2f;font-weight:bold">true</span><span style="color:#bbb">
</span></code></pre></div></div></div>

<!--
The ImagePolicyWebhook config file must reference a
[kubeconfig](/docs/tasks/access-application-cluster/configure-access-multiple-clusters/)
formatted file which sets up the connection to the backend.
It is required that the backend communicate over TLS.
-->
<p>ImagePolicyWebhook 的配置文件必须引用
<a href="/zh/docs/tasks/access-application-cluster/configure-access-multiple-clusters/">kubeconfig</a>
格式的文件；该文件设置了到后端的连接参数。
要求后端使用 TLS 进行通信。</p>
<!--
The kubeconfig file's cluster field must point to the remote service, and the user field must contain the returned authorizer.
-->
<p>kubeconfig 文件的 cluster 字段需要指向远端服务，user 字段需要包含已返回的授权者。</p>
<!--
```yaml
# clusters refers to the remote service.
clusters:
- name: name-of-remote-imagepolicy-service
  cluster:
    certificate-authority: /path/to/ca.pem    # CA for verifying the remote service.
    server: https://images.example.com/policy # URL of remote service to query. Must use 'https'.

# users refers to the API server's webhook configuration.
users:
- name: name-of-api-server
  user:
    client-certificate: /path/to/cert.pem # cert for the webhook admission controller to use
    client-key: /path/to/key.pem          # key matching the cert
```
-->
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#080;font-style:italic"># clusters 指的是远程服务。</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">clusters</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>name-of-remote-imagepolicy-service<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">cluster</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">certificate-authority</span>:<span style="color:#bbb"> </span>/path/to/ca.pem   <span style="color:#bbb"> </span><span style="color:#080;font-style:italic"># CA 用于验证远程服务</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">server</span>:<span style="color:#bbb"> </span>https://images.example.com/policy<span style="color:#bbb"> </span><span style="color:#080;font-style:italic"># 要查询的远程服务的 URL。必须是 &#39;https&#39; 。</span><span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#080;font-style:italic"># users 指的是 API 服务器的 Webhook 配置。</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">users</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>name-of-api-server<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">user</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">client-certificate</span>:<span style="color:#bbb"> </span>/path/to/cert.pem<span style="color:#bbb"> </span><span style="color:#080;font-style:italic"># webhook 准入控制器使用的证书</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">client-key</span>:<span style="color:#bbb"> </span>/path/to/key.pem         <span style="color:#bbb"> </span><span style="color:#080;font-style:italic"># 证书匹配的密钥</span><span style="color:#bbb">
</span></code></pre></div><!--
For additional HTTP configuration, refer to the
[kubeconfig](/docs/tasks/access-application-cluster/configure-access-multiple-clusters/) documentation.
-->
<p>关于 HTTP 配置的更多信息，请参阅
<a href="/zh/docs/tasks/access-application-cluster/configure-access-multiple-clusters/">kubeconfig</a>
文档。</p>
<!--
#### Request Payloads
-->
<h4 id="请求载荷">请求载荷</h4>
<!--
When faced with an admission decision, the API Server POSTs a JSON serialized `imagepolicy.k8s.io/v1alpha1` `ImageReview` object describing the action. This object contains fields describing the containers being admitted, as well as any pod annotations that match `*.image-policy.k8s.io/*`.
-->
<p>当面对一个准入决策时，API 服务器发送一个描述操作的 JSON 序列化的
<code>imagepolicy.k8s.io/v1alpha1</code> <code>ImageReview</code> 对象。
该对象包含描述被审核容器的字段，以及所有匹配 <code>*.image-policy.k8s.io/*</code> 的
Pod 注解。</p>
<!--
Note that webhook API objects are subject to the same versioning compatibility rules as other Kubernetes API objects. Implementers should be aware of looser compatibility promises for alpha objects and check the "apiVersion" field of the request to ensure correct deserialization. Additionally, the API Server must enable the imagepolicy.k8s.io/v1alpha1 API extensions group (`--runtime-config=imagepolicy.k8s.io/v1alpha1=true`).
-->
<p>注意，Webhook API 对象与其他 Kubernetes API 对象一样受制于相同的版本控制兼容性规则。
实现者应该知道对 alpha 对象的更宽松的兼容性，并检查请求的 &quot;apiVersion&quot; 字段，
以确保正确的反序列化。
此外，API 服务器必须启用 <code>imagepolicy.k8s.io/v1alpha1</code> API 扩展组
（<code>--runtime-config=imagepolicy.k8s.io/v1alpha1=true</code>）。</p>
<!--
An example request body:
-->
<p>请求载荷示例：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-json" data-lang="json">{
  <span style="color:#008000;font-weight:bold">&#34;apiVersion&#34;</span>:<span style="color:#b44">&#34;imagepolicy.k8s.io/v1alpha1&#34;</span>,
  <span style="color:#008000;font-weight:bold">&#34;kind&#34;</span>:<span style="color:#b44">&#34;ImageReview&#34;</span>,
  <span style="color:#008000;font-weight:bold">&#34;spec&#34;</span>:{
    <span style="color:#008000;font-weight:bold">&#34;containers&#34;</span>:[
      {
        <span style="color:#008000;font-weight:bold">&#34;image&#34;</span>:<span style="color:#b44">&#34;myrepo/myimage:v1&#34;</span>
      },
      {
        <span style="color:#008000;font-weight:bold">&#34;image&#34;</span>:<span style="color:#b44">&#34;myrepo/myimage@sha256:beb6bd6a68f114c1dc2ea4b28db81bdf91de202a9014972bec5e4d9171d90ed&#34;</span>
      }
    ],
    <span style="color:#008000;font-weight:bold">&#34;annotations&#34;</span>:{
      <span style="color:#008000;font-weight:bold">&#34;mycluster.image-policy.k8s.io/ticket-1234&#34;</span>: <span style="color:#b44">&#34;break-glass&#34;</span>
    },
    <span style="color:#008000;font-weight:bold">&#34;namespace&#34;</span>:<span style="color:#b44">&#34;mynamespace&#34;</span>
  }
}
</code></pre></div><!--
The remote service is expected to fill the `ImageReviewStatus` field of the request and respond to either allow or disallow access. The response body's "spec" field is ignored and may be omitted. A permissive response would return:
-->
<p>远程服务将填充请求的 <code>ImageReviewStatus</code> 字段，并返回允许或不允许访问的响应。
响应体的 &quot;spec&quot; 字段会被忽略，并且可以省略。一个允许访问应答会返回：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-json" data-lang="json">{
  <span style="color:#008000;font-weight:bold">&#34;apiVersion&#34;</span>: <span style="color:#b44">&#34;imagepolicy.k8s.io/v1alpha1&#34;</span>,
  <span style="color:#008000;font-weight:bold">&#34;kind&#34;</span>: <span style="color:#b44">&#34;ImageReview&#34;</span>,
  <span style="color:#008000;font-weight:bold">&#34;status&#34;</span>: {
    <span style="color:#008000;font-weight:bold">&#34;allowed&#34;</span>: <span style="color:#a2f;font-weight:bold">true</span>
  }
}
</code></pre></div><!--
To disallow access, the service would return:
-->
<p>若不允许访问，服务将返回：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-json" data-lang="json">{
  <span style="color:#008000;font-weight:bold">&#34;apiVersion&#34;</span>: <span style="color:#b44">&#34;imagepolicy.k8s.io/v1alpha1&#34;</span>,
  <span style="color:#008000;font-weight:bold">&#34;kind&#34;</span>: <span style="color:#b44">&#34;ImageReview&#34;</span>,
  <span style="color:#008000;font-weight:bold">&#34;status&#34;</span>: {
    <span style="color:#008000;font-weight:bold">&#34;allowed&#34;</span>: <span style="color:#a2f;font-weight:bold">false</span>,
    <span style="color:#008000;font-weight:bold">&#34;reason&#34;</span>: <span style="color:#b44">&#34;image currently blacklisted&#34;</span>
  }
}
</code></pre></div><!--
For further documentation refer to the `imagepolicy.v1alpha1` API objects and `plugin/pkg/admission/imagepolicy/admission.go`.
-->
<p>更多的文档，请参阅 <code>imagepolicy.v1alpha1</code> API 对象和
<code>plugin/pkg/admission/imagepolicy/admission.go</code>。</p>
<!--
#### Extending with Annotations
-->
<h4 id="使用注解进行扩展">使用注解进行扩展</h4>
<!--
All annotations on a Pod that match `*.image-policy.k8s.io/*` are sent to the webhook. Sending annotations allows users who are aware of the image policy backend to send extra information to it, and for different backends implementations to accept different information.
-->
<p>一个 Pod 中匹配 <code>*.image-policy.k8s.io/*</code> 的注解都会被发送给 Webhook。
这样做使得了解后端镜像策略的用户可以向它发送额外的信息，并为不同的后端实现
接收不同的信息。</p>
<!--
Examples of information you might put here are:
-->
<p>你可以在这里输入的信息有：</p>
<!--
 * request to "break glass" to override a policy, in case of emergency.
 * a ticket number from a ticket system that documents the break-glass request
 * provide a hint to the policy server as to the imageID of the image being provided, to save it a lookup
-->
<ul>
<li>在紧急情况下，请求 &quot;break glass&quot; 覆盖一个策略。</li>
<li>从一个记录了 break-glass 的请求的 ticket 系统得到的一个 ticket 号码。</li>
<li>向策略服务器提供一个提示，用于提供镜像的 imageID，以方便它进行查找。</li>
</ul>
<!--
In any case, the annotations are provided by the user and are not validated by Kubernetes in any way. In the future, if an annotation is determined to be widely useful, it may be promoted to a named field of `ImageReviewSpec`.
-->
<p>在任何情况下，注解都是由用户提供的，并不会被 Kubernetes 以任何方式进行验证。
在将来，如果一个注解确定将被广泛使用，它可能会被提升为 ImageReviewSpec 的一个命名字段。</p>
<h3 id="limitpodhardantiaffinitytopology">LimitPodHardAntiAffinityTopology</h3>
<!--
This admission controller denies any pod that defines `AntiAffinity` topology key other than
`kubernetes.io/hostname` in `requiredDuringSchedulingRequiredDuringExecution`.
-->
<p>该准入控制器拒绝（定义了 <code>AntiAffinity</code> 拓扑键的）任何 Pod
（<code>requiredDuringSchedulingRequiredDuringExecution</code> 中的
<code>kubernetes.io/hostname</code> 除外）。</p>
<h3 id="limitranger">LimitRanger</h3>
<!--
This admission controller will observe the incoming request and ensure that it does not violate any of the constraints
enumerated in the `LimitRange` object in a `Namespace`.  If you are using `LimitRange` objects in
your Kubernetes deployment, you MUST use this admission controller to enforce those constraints. LimitRanger can also
be used to apply default resource requests to Pods that don't specify any; currently, the default LimitRanger
applies a 0.1 CPU requirement to all Pods in the `default` namespace.
-->
<p>该准入控制器会观察传入的请求，并确保它不会违反 <code>Namespace</code> 中 <code>LimitRange</code>
对象枚举的任何约束。
如果你在 Kubernetes 部署中使用了 <code>LimitRange</code> 对象，则必须使用此准入控制器来
执行这些约束。
LimitRanger 还可以用于将默认资源请求应用到没有指定任何内容的 Pod；
当前，默认的 LimitRanger 对 <code>default</code> 名字空间中的所有 Pod 都应用了
0.1 CPU 的需求。</p>
<!--
See the [limitRange design doc](https://git.k8s.io/community/contributors/design-proposals/resource-management/admission_control_limit_range.md)
and the [example of Limit Range](/docs/tasks/configure-pod-container/limit-range/) for more details.
-->
<p>请查看
<a href="https://git.k8s.io/community/contributors/design-proposals/resource-management/admission_control_limit_range.md">limitRange 设计文档</a>
和 <a href="/zh/docs/tasks/administer-cluster/manage-resources/memory-default-namespace/">LimitRange 例子</a>
以了解更多细节。</p>
<h3 id="mutatingadmissionwebhook">MutatingAdmissionWebhook</h3>
<!--
This admission controller calls any mutating webhooks which match the request. Matching
webhooks are called in serial; each one may modify the object if it desires.

This admission controller (as implied by the name) only runs in the mutating phase.
-->
<p>该准入控制器调用任何与请求匹配的变更 Webhook。匹配的 Webhook 将被串行调用。
每一个 Webhook 都可以根据需要修改对象。</p>
<p><code>MutatingAdmissionWebhook</code>，顾名思义，仅在变更阶段运行。</p>
<!--
If a webhook called by this has side effects (for example, decrementing quota) it
*must* have a reconciliation system, as it is not guaranteed that subsequent
webhooks or validating admission controllers will permit the request to finish.
-->
<p>如果由此准入控制器调用的 Webhook 有副作用（如降低配额），
则它 <em>必须</em> 具有协调系统，因为不能保证后续的 Webhook 和验证准入控制器都会允许完成请求。</p>
<!--
If you disable the MutatingAdmissionWebhook, you must also disable the
`MutatingWebhookConfiguration` object in the `admissionregistration.k8s.io/v1`
group/version via the `--runtime-config` flag (both are on by default in
versions >= 1.9).
-->
<p>如果你禁用了 MutatingAdmissionWebhook，那么还必须使用 <code>--runtime-config</code> 标志禁止
<code>admissionregistration.k8s.io/v1</code> 组/版本中的 <code>MutatingWebhookConfiguration</code>
对象（版本 &gt;=1.9 时，这两个对象都是默认启用的）。</p>
<!--
#### Use caution when authoring and installing mutating webhooks
-->
<h4 id="谨慎编写和安装变更-webhook">谨慎编写和安装变更 webhook</h4>
<!--
 * Users may be confused when the objects they try to create are different from
   what they get back.
 * Built in control loops may break when the objects they try to create are
   different when read back.
   * Setting originally unset fields is less likely to cause problems than
     overwriting fields set in the original request. Avoid doing the latter.
 * Future changes to control loops for built-in resources or third-party resources
   may break webhooks that work well today. Even when the webhook installation API
   is finalized, not all possible webhook behaviors will be guaranteed to be supported
   indefinitely.
-->
<ul>
<li>当用户尝试创建的对象与返回的对象不同时，用户可能会感到困惑。</li>
<li>当它们回读的对象与尝试创建的对象不同，内建的控制环可能会出问题。
<ul>
<li>与覆盖原始请求中设置的字段相比，使用原始请求未设置的字段会引起问题的可能性较小。
应尽量避免前面那种方式。</li>
</ul>
</li>
<li>内建资源和第三方资源的控制回路未来可能会受到破坏性的更改，使现在运行良好的 Webhook
无法再正常运行。即使完成了 Webhook API 安装，也不代表会为该 webhook 提供无限期的支持。</li>
</ul>
<h3 id="namespaceautoprovision">NamespaceAutoProvision</h3>
<!--
This admission controller examines all incoming requests on namespaced resources and checks
if the referenced namespace does exist.
It creates a namespace if it cannot be found.
This admission controller is useful in deployments that do not want to restrict creation of
a namespace prior to its usage.
-->
<p>该准入控制器会检查名字空间资源上的所有传入请求，并检查所引用的名字空间是否确实存在。
如果找不到，它将创建一个名字空间。
此准入控制器对于不想要求名字空间必须先创建后使用的集群部署中很有用。</p>
<h3 id="namespaceexists">NamespaceExists</h3>
<!--
This admission controller checks all requests on namespaced resources other than `Namespace` itself.
If the namespace referenced from a request doesn't exist, the request is rejected.
-->
<p>该准入控制器检查除 <code>Namespace</code> 以外的名字空间作用域资源上的所有请求。
如果请求引用的名字空间不存在，则拒绝该请求。</p>
<h3 id="namespacelifecycle">NamespaceLifecycle</h3>
<!--
This admission controller enforces that a `Namespace` that is undergoing termination cannot have new objects created in it,
and ensures that requests in a non-existent `Namespace` are rejected. This admission controller also prevents deletion of
three system reserved namespaces `default`, `kube-system`, `kube-public`.
-->
<p>该准入控制器禁止在一个正在被终止的 <code>Namespace</code> 中创建新对象，并确保
使用不存在的 <code>Namespace</code> 的请求被拒绝。
该准入控制器还会禁止删除三个系统保留的名字空间，即 <code>default</code>、
<code>kube-system</code> 和 <code>kube-public</code>。</p>
<!--
A `Namespace` deletion kicks off a sequence of operations that remove all objects (pods, services, etc.) in that
namespace.  In order to enforce integrity of that process, we strongly recommend running this admission controller.
-->
<p>删除 <code>Namespace</code> 会触发删除该名字空间中所有对象（Pod、Service 等）的一系列操作。
为了确保这个过程的完整性，我们强烈建议启用这个准入控制器。</p>
<h3 id="noderestriction">NodeRestriction</h3>
<!--
This admission controller limits the `Node` and `Pod` objects a kubelet can modify. In order to be limited by this admission controller,
kubelets must use credentials in the `system:nodes` group, with a username in the form `system:node:<nodeName>`.
Such kubelets will only be allowed to modify their own `Node` API object, and only modify `Pod` API objects that are bound to their node.
-->
<p>该准入控制器限制了 kubelet 可以修改的 <code>Node</code> 和 <code>Pod</code> 对象。
为了受到这个准入控制器的限制，kubelet 必须使用在 <code>system:nodes</code> 组中的凭证，
并使用 <code>system:node:&lt;nodeName&gt;</code> 形式的用户名。
这样，kubelet 只可修改自己的 <code>Node</code> API 对象，只能修改绑定到节点本身的 Pod 对象。</p>
<!--
In Kubernetes 1.11+, kubelets are not allowed to update or remove taints from their `Node` API object.

In Kubernetes 1.13+, the `NodeRestriction` admission plugin prevents kubelets from deleting their `Node` API object,
and enforces kubelet modification of labels under the `kubernetes.io/` or `k8s.io/` prefixes as follows:
-->
<p>在 Kubernetes 1.11+ 的版本中，不允许 kubelet 从 <code>Node</code> API 对象中更新或删除污点。</p>
<p>在 Kubernetes 1.13+ 的版本中，<code>NodeRestriction</code> 准入插件可防止 kubelet 删除
<code>Node</code> API 对象，并对 <code>kubernetes.io/</code> 或 <code>k8s.io/</code> 前缀标签的 kubelet
强制进行如下修改：</p>
<!--
* **Prevents** kubelets from adding/removing/updating labels with a `node-restriction.kubernetes.io/` prefix.
This label prefix is reserved for administrators to label their `Node` objects for workload isolation purposes,
and kubelets will not be allowed to modify labels with that prefix.
* **Allows** kubelets to add/remove/update these labels and label prefixes:
-->
<ul>
<li><strong>防止</strong> kubelet 添加/删除/更新带有 <code>node-restriction.kubernetes.io/</code> 前缀的标签。
保留此前缀的标签，供管理员用来标记 Node 对象以隔离工作负载，并且不允许 kubelet
修改带有该前缀的标签。</li>
<li><strong>允许</strong> kubelet 添加/删除/更新这些和这些前缀的标签：
<ul>
<li><code>kubernetes.io/hostname</code></li>
<li><code>kubernetes.io/arch</code></li>
<li><code>kubernetes.io/os</code></li>
<li><code>beta.kubernetes.io/instance-type</code></li>
<li><code>node.kubernetes.io/instance-type</code></li>
<li><code>failure-domain.beta.kubernetes.io/region</code> （已弃用）</li>
<li><code>failure-domain.beta.kubernetes.io/zone</code>  (已弃用）</li>
<li><code>topology.kubernetes.io/region</code></li>
<li><code>topology.kubernetes.io/zone</code></li>
<li><code>kubelet.kubernetes.io/</code>-prefixed labels</li>
<li><code>node.kubernetes.io/</code>-prefixed labels</li>
</ul>
</li>
</ul>
<!--
Use of any other labels under the `kubernetes.io` or `k8s.io` prefixes by kubelets is reserved, and may be disallowed or allowed by the `NodeRestriction` admission plugin in the future.

Future versions may add additional restrictions to ensure kubelets have the minimal set of permissions required to operate correctly.
-->
<p>kubelet 保留 <code>kubernetes.io</code> 或 <code>k8s.io</code> 前缀的所有标签，并且将来可能会被
<code>NodeRestriction</code> 准入插件允许或禁止。</p>
<p>将来的版本可能会增加其他限制，以确保 kubelet 具有正常运行所需的最小权限集。</p>
<h3 id="ownerreferencespermissionenforcement">OwnerReferencesPermissionEnforcement</h3>
<!--
This admission controller protects the access to the `metadata.ownerReferences` of an object
so that only users with "delete" permission to the object can change it.
This admission controller also protects the access to `metadata.ownerReferences[x].blockOwnerDeletion`
of an object, so that only users with "update" permission to the `finalizers`
subresource of the referenced *owner* can change it.
-->
<p>该准入控制器保护对 <code>metadata.ownerReferences</code> 对象的访问，以便只有对该对象具有
“删除” 权限的用户才能对其进行更改。
该准入控制器还保护对 <code>metadata.ownerReferences[x].blockOwnerDeletion</code> 对象的访问，
以便只有对所引用的 <strong>属主（owner）</strong> 的 <code>finalizers</code> 子资源具有 “更新”
权限的用户才能对其进行更改。</p>
<h3 id="persistentvolumeclaimresize">PersistentVolumeClaimResize</h3>
<!--
This admission controller implements additional validations for checking incoming `PersistentVolumeClaim` resize requests.
-->
<p>该准入控制器检查传入的 <code>PersistentVolumeClaim</code> 调整大小请求，对其执行额外的验证操作。</p>
<blockquote class="note callout">
  <div><strong>说明：</strong> <!--
Support for volume resizing is available as an alpha feature. Admins must set the feature gate `ExpandPersistentVolumes`
to `true` to enable resizing.
-->
<p>对调整卷大小的支持是一种 Alpha 特性。管理员必须将特性门控 <code>ExpandPersistentVolumes</code>
设置为 <code>true</code> 才能启用调整大小。</div>
</blockquote>
<!--
After enabling the `ExpandPersistentVolumes` feature gate, enabling the `PersistentVolumeClaimResize` admission
controller is recommended, too. This admission controller prevents resizing of all claims by default unless a claim's `StorageClass`
 explicitly enables resizing by setting `allowVolumeExpansion` to `true`.

For example: all `PersistentVolumeClaim`s created from the following `StorageClass` support volume expansion:
-->
<p>启用 <code>ExpandPersistentVolumes</code> 特性门控之后，建议将 <code>PersistentVolumeClaimResize</code>
准入控制器也启用。除非 PVC 的 <code>StorageClass</code> 明确地将 <code>allowVolumeExpansion</code> 设置为
<code>true</code> 来显式启用调整大小。否则，默认情况下该准入控制器会阻止所有对 PVC 大小的调整。</p>
<p>例如：由以下 <code>StorageClass</code> 创建的所有 <code>PersistentVolumeClaim</code> 都支持卷容量扩充：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>storage.k8s.io/v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>StorageClass<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>gluster-vol-default<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">provisioner</span>:<span style="color:#bbb"> </span>kubernetes.io/glusterfs<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">parameters</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">resturl</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;http://192.168.10.100:8080&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">restuser</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">secretNamespace</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">secretName</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">allowVolumeExpansion</span>:<span style="color:#bbb"> </span><span style="color:#a2f;font-weight:bold">true</span><span style="color:#bbb">
</span></code></pre></div><!--
For more information about persistent volume claims, see [PersistentVolumeClaims](/docs/concepts/storage/persistent-volumes/#persistentvolumeclaims).
-->
<p>关于持久化卷申领的更多信息，请参见
<a href="/zh/docs/concepts/storage/persistent-volumes/#persistentvolumeclaims">PersistentVolumeClaims</a>。</p>
<h3 id="persistentvolumelabel">PersistentVolumeLabel</h3>





<div style="margin-top: 10px; margin-bottom: 10px;">
<b>FEATURE STATE:</b> <code>Kubernetes v1.13 [deprecated]</code>
</div>

<!--
This admission controller automatically attaches region or zone labels to PersistentVolumes
as defined by the cloud provider (for example, GCE or AWS).
It helps ensure the Pods and the PersistentVolumes mounted are in the same
region and/or zone.
If the admission controller doesn't support automatic labelling your PersistentVolumes, you
may need to add the labels manually to prevent pods from mounting volumes from
a different zone. PersistentVolumeLabel is DEPRECATED and labeling persistent volumes has been taken over by
[cloud controller manager](/docs/tasks/administer-cluster/running-cloud-controller/).
Starting from 1.11, this admission controller is disabled by default.
-->
<p>该准入控制器会自动将区（region）或区域（zone）标签附加到由云提供商（如 GCE、AWS）
定义的 PersistentVolume。这有助于确保 Pod 和 PersistentVolume 位于相同的区或区域。
如果准入控制器不支持为 PersistentVolumes 自动添加标签，那你可能需要手动添加标签，
以防止 Pod 挂载其他区域的卷。
PersistentVolumeLabel 已被废弃，标记持久卷已由
<a href="/zh/docs/tasks/administer-cluster/running-cloud-controller/">云管理控制器</a>接管。
从 1.11 开始，默认情况下禁用此准入控制器。</p>
<h3 id="podnodeselector">PodNodeSelector</h3>





<div style="margin-top: 10px; margin-bottom: 10px;">
<b>FEATURE STATE:</b> <code>Kubernetes v1.5 [alpha]</code>
</div>

<!--
This admission controller defaults and limits what node selectors may be used within a namespace by reading a namespace annotation and a global configuration.
-->
<p>该准入控制器通过读取名字空间注解和全局配置，来为名字空间中可以使用的节点选择器
设置默认值并实施限制。</p>
<!--
#### Configuration File Format

`PodNodeSelector` uses a configuration file to set options for the behavior of the backend.
Note that the configuration file format will move to a versioned file in a future release.
This file may be json or yaml and has the following format:
-->
<h4 id="配置文件格式-1">配置文件格式</h4>
<p><code>PodNodeSelector</code> 使用配置文件来设置后端行为的选项。
请注意，配置文件格式将在将来某个版本中改为版本化文件。
该文件可以是 JSON 或 YAML，格式如下：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">podNodeSelectorPluginConfig</span>:<span style="color:#bbb">
</span><span style="color:#bbb"> </span><span style="color:#008000;font-weight:bold">clusterDefaultNodeSelector</span>:<span style="color:#bbb"> </span>name-of-node-selector<span style="color:#bbb">
</span><span style="color:#bbb"> </span><span style="color:#008000;font-weight:bold">namespace1</span>:<span style="color:#bbb"> </span>name-of-node-selector<span style="color:#bbb">
</span><span style="color:#bbb"> </span><span style="color:#008000;font-weight:bold">namespace2</span>:<span style="color:#bbb"> </span>name-of-node-selector<span style="color:#bbb">
</span></code></pre></div><!--
Reference the `PodNodeSelector` configuration file from the file provided to the API server's command line flag `--admission-control-config-file`:
-->
<p>基于提供给 API 服务器命令行标志 <code>--admission-control-config-file</code> 的文件名，
从文件中引用 <code>PodNodeSelector</code> 配置文件：</p>
<ul class="nav nav-tabs" id="podnodeselector-example1" role="tablist"><li class="nav-item"><a data-toggle="tab" class="nav-link active" href="#podnodeselector-example1-0" role="tab" aria-controls="podnodeselector-example1-0" aria-selected="true">apiserver.config.k8s.io/v1</a></li>
	  
		<li class="nav-item"><a data-toggle="tab" class="nav-link" href="#podnodeselector-example1-1" role="tab" aria-controls="podnodeselector-example1-1">apiserver.k8s.io/v1alpha1</a></li></ul>
<div class="tab-content" id="podnodeselector-example1"><div id="podnodeselector-example1-0" class="tab-pane show active" role="tabpanel" aria-labelledby="podnodeselector-example1-0">

<p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>apiserver.config.k8s.io/v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>AdmissionConfiguration<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">plugins</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>PodNodeSelector<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">path</span>:<span style="color:#bbb"> </span>podnodeselector.yaml<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#00f;font-weight:bold">...</span><span style="color:#bbb">
</span></code></pre></div></div>
  <div id="podnodeselector-example1-1" class="tab-pane" role="tabpanel" aria-labelledby="podnodeselector-example1-1">

<p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#080;font-style:italic"># 在 v1.17 中废弃，以鼓励使用 apiserver.config.k8s.io/v1</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>apiserver.k8s.io/v1alpha1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>AdmissionConfiguration<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">plugins</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>PodNodeSelector<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">path</span>:<span style="color:#bbb"> </span>podnodeselector.yaml<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#00f;font-weight:bold">...</span><span style="color:#bbb">
</span></code></pre></div></div></div>

<!--
#### Configuration Annotation Format

`PodNodeSelector` uses the annotation key `scheduler.alpha.kubernetes.io/node-selector` to assign node selectors to namespaces.
-->
<h4 id="配置注解格式">配置注解格式</h4>
<p><code>PodNodeSelector</code> 使用键为 <code>scheduler.alpha.kubernetes.io/node-selector</code> 的注解
为名字空间设置节点选择算符。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>Namespace<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">annotations</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">scheduler.alpha.kubernetes.io/node-selector</span>:<span style="color:#bbb"> </span>name-of-node-selector<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>namespace3<span style="color:#bbb">
</span></code></pre></div><!--
#### Internal Behavior
This admission controller has the following behavior:
-->
<h4 id="内部行为">内部行为</h4>
<p>该准入控制器行为如下：</p>
<!--
1. If the `Namespace` has an annotation with a key `scheduler.alpha.kubernetes.io/node-selector`, use its value as the
node selector.
2. If the namespace lacks such an annotation, use the `clusterDefaultNodeSelector` defined in the `PodNodeSelector`
plugin configuration file as the node selector.
3. Evaluate the pod's node selector against the namespace node selector for conflicts. Conflicts result in rejection.
4. Evaluate the pod's node selector against the namespace-specific allowed selector defined the plugin configuration file.
Conflicts result in rejection.
-->
<ol>
<li>如果 <code>Namespace</code> 的注解带有键 <code>scheduler.alpha.kubernetes.io/node-selector</code>，
则将其值用作节点选择算符。</li>
<li>如果名字空间缺少此类注解，则使用 <code>PodNodeSelector</code> 插件配置文件中定义的
<code>clusterDefaultNodeSelector</code> 作为节点选择算符。</li>
<li>评估 Pod 节点选择算符和名字空间节点选择算符是否存在冲突。存在冲突将导致拒绝。</li>
<li>评估 Pod 节点选择算符和特定于名字空间的被允许的选择算符所定义的插件配置文件是否存在冲突。
存在冲突将导致拒绝。</li>
</ol>
<blockquote class="note callout">
  <div><strong>说明：</strong> <!--
PodNodeSelector allows forcing pods to run on specifically labeled nodes. Also see the PodTolerationRestriction
admission plugin, which allows preventing pods from running on specifically tainted nodes.
-->
<p>PodNodeSelector 允许 Pod 强制在特定标签的节点上运行。
另请参阅 PodTolerationRestriction 准入插件，该插件可防止 Pod 在特定污点的节点上运行。</div>
</blockquote>
<h3 id="podsecuritypolicy">PodSecurityPolicy</h3>
<!--
This admission controller acts on creation and modification of the pod and determines if it should be admitted
based on the requested security context and the available Pod Security Policies.
-->
<p>此准入控制器负责在创建和修改 Pod 时根据请求的安全上下文和可用的 Pod
安全策略确定是否可以执行请求。</p>
<!--
See also [Pod Security Policy documentation](/docs/concepts/policy/pod-security-policy/)
for more information.
-->
<p>查看 <a href="/zh/docs/concepts/policy/pod-security-policy/">Pod 安全策略文档</a>
了解更多细节。</p>
<h3 id="podtolerationrestriction">PodTolerationRestriction</h3>





<div style="margin-top: 10px; margin-bottom: 10px;">
<b>FEATURE STATE:</b> <code>Kubernetes v1.7 [alpha]</code>
</div>

<!--
The PodTolerationRestriction admission controller verifies any conflict between tolerations of a pod and the tolerations of its namespace.
It rejects the pod request if there is a conflict.
It then merges the tolerations annotated on the namespace into the tolerations of the pod.
The resulting tolerations are checked against a list of allowed tolerations annotated to the namespace.
If the check succeeds, the pod request is admitted otherwise it is rejected.
-->
<p>准入控制器 PodTolerationRestriction 检查 Pod 的容忍度与其名字空间的容忍度之间
是否存在冲突。如果存在冲突，则拒绝 Pod 请求。
然后，它将名字空间的容忍度合并到 Pod 的容忍度中，之后根据名字空间的容忍度
白名单检查所得到的容忍度结果。如果检查成功，则将接受 Pod 请求，否则拒绝该请求。</p>
<!--
If the namespace of the pod does not have any associated default tolerations or allowed
tolerations annotated, the cluster-level default tolerations or cluster-level list of allowed tolerations are used
instead if they are specified.
-->
<p>如果 Pod 的名字空间没有任何关联的默认容忍度或容忍度白名单，则使用集群级别的
默认容忍度或容忍度白名单（如果有的话）。</p>
<!--
Tolerations to a namespace are assigned via the `scheduler.alpha.kubernetes.io/defaultTolerations` annotation key.
The list of allowed tolerations can be added via the `scheduler.alpha.kubernetes.io/tolerationsWhitelist` annotation key.

Example for namespace annotations:
-->
<p>名字空间的容忍度通过注解健 <code>scheduler.alpha.kubernetes.io/defaultTolerations</code>
来设置。可接受的容忍度可以通过 <code>scheduler.alpha.kubernetes.io/tolerationsWhitelist</code>
注解键来添加。</p>
<p>名字空间注解的示例：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>Namespace<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>apps-that-need-nodes-exclusively<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">annotations</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">scheduler.alpha.kubernetes.io/defaultTolerations</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#39;[{&#34;operator&#34;: &#34;Exists&#34;, &#34;effect&#34;: &#34;NoSchedule&#34;, &#34;key&#34;: &#34;dedicated-node&#34;}]&#39;</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">scheduler.alpha.kubernetes.io/tolerationsWhitelist</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#39;[{&#34;operator&#34;: &#34;Exists&#34;, &#34;effect&#34;: &#34;NoSchedule&#34;, &#34;key&#34;: &#34;dedicated-node&#34;}]&#39;</span><span style="color:#bbb">
</span></code></pre></div><!--
### Priority {#priority}

The priority admission controller uses the `priorityClassName` field and populates the integer value of the priority. If the priority class is not found, the Pod is rejected.
-->
<h3 id="priority">优先级</h3>
<p>优先级准入控制器使用 <code>priorityClassName</code> 字段并用整型值填充优先级。
如果找不到优先级，则拒绝 Pod。</p>
<h3 id="resourcequota">ResourceQuota</h3>
<!--
This admission controller will observe the incoming request and ensure that it does not violate any of the constraints
enumerated in the `ResourceQuota` object in a `Namespace`.  If you are using `ResourceQuota`
objects in your Kubernetes deployment, you MUST use this admission controller to enforce quota constraints.
-->
<p>该准入控制器会监测传入的请求，并确保它不违反任何一个 <code>Namespace</code> 中的 <code>ResourceQuota</code>
对象中枚举出来的约束。
如果你在 Kubernetes 部署中使用了 <code>ResourceQuota</code>，你必须使用这个准入控制器来强制
执行配额限制。</p>
<!--
See the [resourceQuota design doc](https://git.k8s.io/community/contributors/design-proposals/resource-management/admission_control_resource_quota.md) and the [example of Resource Quota](/docs/concepts/policy/resource-quotas/) for more details.
-->
<p>请查看
<a href="https://git.k8s.io/community/contributors/design-proposals/admission_control_resource_quota.md">resourceQuota 设计文档</a>和 <a href="/zh/docs/concepts/policy/resource-quotas/">Resource Quota 例子</a>
了解更多细节。</p>
<!--
### RuntimeClass {#runtimeclass}






<div style="margin-top: 10px; margin-bottom: 10px;">
<b>FEATURE STATE:</b> <code>Kubernetes v1.20 [stable]</code>
</div>


If you enable the `PodOverhead` [feature gate](/docs/reference/command-line-tools-reference/feature-gates/), and define a RuntimeClass with [Pod overhead](/docs/concepts/scheduling-eviction/pod-overhead/) configured, this admission controller checks incoming
Pods. When enabled, this admission controller rejects any Pod create requests that have the overhead already set.
For Pods that have a  RuntimeClass is configured and selected in their `.spec`, this admission controller sets `.spec.overhead` in the Pod based on the value defined in the corresponding RuntimeClass.

<blockquote class="note callout">
  <div><strong>说明：</strong> The <code>.spec.overhead</code> field for Pod and the <code>.overhead</code> field for RuntimeClass are both in beta. If you do not enable the <code>PodOverhead</code> feature gate, all Pods are treated as if <code>.spec.overhead</code> is unset.</div>
</blockquote>

See also [Pod Overhead](/docs/concepts/scheduling-eviction/pod-overhead/)
for more information.
-->
<h3 id="runtimeclass">RuntimeClass</h3>
<p>+




<div style="margin-top: 10px; margin-bottom: 10px;">
<b>FEATURE STATE:</b> <code>Kubernetes v1.20 [stable]</code>
</div>
</p>
<p>如果你开启 <code>PodOverhead</code>
<a href="/zh/docs/reference/command-line-tools-reference/feature-gates/">特性门控</a>,
并且通过 <a href="/zh/docs/concepts/scheduling-eviction/pod-overhead/">Pod 开销</a>
配置来定义一个 RuntimeClass，这个准入控制器会检查新的 Pod。
当启用的时候，这个准入控制器会拒绝任何 overhead 字段已经设置的 Pod。
对于配置了 RuntimeClass 并在其 <code>.spec</code> 中选定 RuntimeClass 的 Pod，
此准入控制器会根据相应 RuntimeClass 中定义的值为 Pod 设置 <code>.spec.overhead</code>。</p>
<blockquote class="note callout">
  <div><strong>说明：</strong> Pod 的 <code>.spec.overhead</code> 字段和 RuntimeClass 的 <code>.overhead</code> 字段均为处于 beta 版本。
如果你未启用 <code>PodOverhead</code> 特性门控，则所有 Pod 均被视为未设置 <code>.spec.overhead</code>。</div>
</blockquote>
<p>详情请参见 <a href="/zh/docs/concepts/scheduling-eviction/pod-overhead/">Pod 开销</a>。</p>
<h3 id="securitycontextdeny">SecurityContextDeny</h3>
<!--
This admission controller will deny any pod that attempts to set certain escalating
[SecurityContext](/docs/reference/generated/kubernetes-api/v1.22/#securitycontext-v1-core)
fields, as shown in the
[Configure a Security Context for a Pod or Container](/docs/tasks/configure-pod-container/security-context/)
task.
This should be enabled if a cluster doesn't utilize 
[pod security policies](/docs/concepts/policy/pod-security-policy/)
to restrict the set of values a security context can take.
-->
<p>该准入控制器将拒绝任何试图设置特定提升
<a href="/zh/docs/tasks/configure-pod-container/security-context/">SecurityContext</a>
字段的 Pod，正如任务
<a href="/zh/docs/tasks/configure-pod-container/security-context/">为 Pod 或 Container 配置安全上下文</a>
中所展示的那样。
如果集群没有使用 <a href="/zh/docs/concepts/policy/pod-security-policy/">Pod 安全策略</a>
来限制安全上下文所能获取的值集，那么应该启用这个功能。</p>
<h3 id="serviceaccount">ServiceAccount</h3>
<!--
This admission controller implements automation for
[serviceAccounts](/docs/tasks/configure-pod-container/configure-service-account/).
We strongly recommend using this admission controller if you intend to make use of Kubernetes `ServiceAccount` objects.
-->
<p>此准入控制器实现了
<a href="/zh/docs/tasks/configure-pod-container/configure-service-account/">ServiceAccount</a>
的自动化。
如果你打算使用 Kubernetes 的 ServiceAccount 对象，我们强烈建议你使用这个准入控制器。</p>
<h3 id="storageobjectinuseprotection">StorageObjectInUseProtection</h3>
<!--
The `StorageObjectInUseProtection` plugin adds the `kubernetes.io/pvc-protection` or `kubernetes.io/pv-protection`
finalizers to newly created Persistent Volume Claims (PVCs) or Persistent Volumes (PV).
In case a user deletes a PVC or PV the PVC or PV is not removed until the finalizer is removed
from the PVC or PV by PVC or PV Protection Controller.
Refer to the
[Storage Object in Use Protection](/docs/concepts/storage/persistent-volumes/#storage-object-in-use-protection)
for more detailed information.
-->
<p><code>StorageObjectInUseProtection</code> 插件将 <code>kubernetes.io/pvc-protection</code> 或
<code>kubernetes.io/pv-protection</code> finalizers 添加到新创建的持久化卷声明（PVC）
或持久化卷（PV）中。
如果用户尝试删除 PVC/PV，除非 PVC/PV 的保护控制器移除 finalizers，否则
PVC/PV 不会被删除。
有关更多详细信息，请参考
<a href="/zh/docs/concepts/storage/persistent-volumes/#storage-object-in-use-protection">保护使用中的存储对象</a>。</p>
<h3 id="taintnodesbycondition">TaintNodesByCondition</h3>





<div style="margin-top: 10px; margin-bottom: 10px;">
<b>FEATURE STATE:</b> <code>Kubernetes v1.17 [stable]</code>
</div>

<!--
This admission controller <a class='glossary-tooltip' title='污点是一种一个核心对象，包含三个必需的属性：key、value 和 effect。 污点会阻止在节点或节点组上调度 Pod。' data-toggle='tooltip' data-placement='top' href='/zh/docs/concepts/scheduling-eviction/taint-and-toleration/' target='_blank' aria-label='taints'>taints</a> newly created Nodes as `NotReady` and `NoSchedule`. That tainting avoids a race condition that could cause Pods to be scheduled on new Nodes before their taints were updated to accurately reflect their reported conditions.
-->
<p>该准入控制器为新创建的节点添加 <code>NotReady</code> 和 <code>NoSchedule</code>
<a class='glossary-tooltip' title='污点是一种一个核心对象，包含三个必需的属性：key、value 和 effect。 污点会阻止在节点或节点组上调度 Pod。' data-toggle='tooltip' data-placement='top' href='/zh/docs/concepts/scheduling-eviction/taint-and-toleration/' target='_blank' aria-label='污点'>污点</a>。
这些污点能够避免一些竞态条件的发生，这类静态条件可能导致 Pod 在更新节点污点以准确
反映其所报告状况之前，就被调度到新节点上。</p>
<h3 id="validatingadmissionwebhook">ValidatingAdmissionWebhook</h3>
<!--
This admission controller calls any validating webhooks which match the request. Matching
webhooks are called in parallel; if any of them rejects the request, the request
fails. This admission controller only runs in the validation phase; the webhooks it calls may not
mutate the object, as opposed to the webhooks called by the `MutatingAdmissionWebhook` admission controller.
-->
<p>该准入控制器调用与请求匹配的所有验证 Webhook。
匹配的 Webhook 将被并行调用。如果其中任何一个拒绝请求，则整个请求将失败。
该准入控制器仅在验证（Validating）阶段运行；与 <code>MutatingAdmissionWebhook</code> 准入控制器
所调用的 Webhook 相反，它调用的 Webhook 应该不会使对象出现变更。</p>
<!--
If a webhook called by this has side effects (for example, decrementing quota) it
*must* have a reconciliation system, as it is not guaranteed that subsequent
webhooks or other validating admission controllers will permit the request to finish.
-->
<p>如果以此方式调用的 Webhook 有其它作用（如，降低配额），则它必须具有协调机制。
这是因为无法保证后续的 Webhook 或其他有效的准入控制器都允许请求完成。</p>
<!--
If you disable the ValidatingAdmissionWebhook, you must also disable the
`ValidatingWebhookConfiguration` object in the `admissionregistration.k8s.io/v1`
group/version via the `--runtime-config` flag (both are on by default in
versions 1.9 and later).
-->
<p>如果你禁用了 ValidatingAdmissionWebhook，还必须通过 <code>--runtime-config</code> 标志来禁用
<code>admissionregistration.k8s.io/v1</code> 组/版本中的  <code>ValidatingWebhookConfiguration</code>
对象（默认情况下在 1.9 版和更高版本中均处于启用状态）。</p>
<!--
## Is there a recommended set of admission controllers to use?

Yes. The recommended admission controllers are enabled by default (shown [here](/docs/reference/command-line-tools-reference/kube-apiserver/#options)), so you do not need to explicitly specify them. You can enable additional admission controllers beyond the default set using the `--enable-admission-plugins` flag (**order doesn't matter**).
-->
<h2 id="有推荐的准入控制器吗">有推荐的准入控制器吗？</h2>
<p>有。推荐使用的准入控制器默认情况下都处于启用状态
（请查看<a href="/zh/docs/reference/command-line-tools-reference/kube-apiserver/#options">这里</a>）。
因此，你无需显式指定它们。
你可以使用 <code>--enable-admission-plugins</code> 标志（ <strong>顺序不重要</strong> ）来启用默认设置以外的其他准入控制器。</p>
<blockquote class="note callout">
  <div><strong>说明：</strong> <!--
`--admission-control` was deprecated in 1.10 and replaced with `--enable-admission-plugins`.
-->
<p><code>--admission-control</code> 在 1.10 中已废弃，由 <code>--enable-admission-plugins</code> 取代。</div>
</blockquote>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-d04751f776f1faa6a82bbb7f0a200950">4.5 - 动态准入控制</h1>
    
	<!--
title: Dynamic Admission Control
content_type: concept
weight: 40
-->
<!-- overview -->
<!--
In addition to [compiled-in admission plugins](/docs/reference/access-authn-authz/admission-controllers/),
admission plugins can be developed as extensions and run as webhooks configured at runtime.
This page describes how to build, configure, use, and monitor admission webhooks.
-->
<p>除了<a href="/zh/docs/reference/access-authn-authz/admission-controllers/">内置的 admission 插件</a>，
准入插件可以作为扩展独立开发，并以运行时所配置的 Webhook 的形式运行。
此页面描述了如何构建、配置、使用和监视准入 Webhook。</p>
<!-- body -->
<!--
## What are admission webhooks?
-->
<h2 id="什么是准入-webhook">什么是准入 Webhook？</h2>
<!--
Admission webhooks are HTTP callbacks that receive admission requests and do
something with them. You can define two types of admission webhooks,
[validating admission Webhook](/docs/reference/access-authn-authz/admission-controllers/#validatingadmissionwebhook)
and
[mutating admission webhook](/docs/reference/access-authn-authz/admission-controllers/#mutatingadmissionwebhook).
Mutating admission Webhooks are invoked first, and can modify objects sent to the API server to enforce custom defaults.
-->
<p>准入 Webhook 是一种用于接收准入请求并对其进行处理的 HTTP 回调机制。
可以定义两种类型的准入 webhook，即
<a href="/zh/docs/reference/access-authn-authz/admission-controllers/#validatingadmissionwebhook">验证性质的准入 Webhook</a> 和
<a href="/zh/docs/reference/access-authn-authz/admission-controllers/#mutatingadmissionwebhook">修改性质的准入 Webhook</a>。
修改性质的准入 Webhook 会先被调用。它们可以更改发送到 API
服务器的对象以执行自定义的设置默认值操作。</p>
<!--
After all object modifications are complete, and after the incoming object is validated by the API server,
validating admission webhooks are invoked and can reject requests to enforce custom policies.
-->
<p>在完成了所有对象修改并且 API 服务器也验证了所传入的对象之后，
验证性质的 Webhook 会被调用，并通过拒绝请求的方式来强制实施自定义的策略。</p>
<!--
Admission webhooks that need to guarantee they see the final state of the object in order to enforce policy
should use a validating admission webhook, since objects can be modified after being seen by mutating webhooks.
-->
<blockquote class="note callout">
  <div><strong>说明：</strong> 如果准入 Webhook 需要保证它们所看到的是对象的最终状态以实施某种策略。
则应使用验证性质的准入 Webhook，因为对象被修改性质 Webhook 看到之后仍然可能被修改。</div>
</blockquote>
<!--
### Experimenting with admission webhooks

Admission webhooks are essentially part of the cluster control-plane. You should
write and deploy them with great caution. Please read the [user
guides](/docs/reference/access-authn-authz/extensible-admission-controllers/#write-an-admission-webhook-server) for
instructions if you intend to write/deploy production-grade admission webhooks.
In the following, we describe how to quickly experiment with admission webhooks.
-->
<h3 id="尝试准入-webhook">尝试准入 Webhook</h3>
<p>准入 Webhook 本质上是集群控制平面的一部分。你应该非常谨慎地编写和部署它们。
如果你打算编写或者部署生产级准入 webhook，请阅读<a href="/zh/docs/reference/access-authn-authz/extensible-admission-controllers/#write-an-admission-webhook-server">用户指南</a>以获取相关说明。
在下文中，我们将介绍如何快速试验准入 Webhook。</p>
<!--
### Prerequisites

* Ensure that the Kubernetes cluster is at least as new as v1.16 (to use `admissionregistration.k8s.io/v1`),
  or v1.9 (to use `admissionregistration.k8s.io/v1beta1`).

* Ensure that MutatingAdmissionWebhook and ValidatingAdmissionWebhook
  admission controllers are enabled.
  [Here](/docs/reference/access-authn-authz/admission-controllers/#is-there-a-recommended-set-of-admission-controllers-to-use)
  is a recommended set of admission controllers to enable in general.

* Ensure that the admissionregistration.k8s.io/v1beta1 API is enabled.
-->
<h3 id="prerequisites">先决条件</h3>
<ul>
<li>
<p>确保 Kubernetes 集群版本至少为 v1.16（以便使用 <code>admissionregistration.k8s.io/v1</code> API） 或者 v1.9 （以便使用 <code>admissionregistration.k8s.io/v1beta1</code> API）。</p>
</li>
<li>
<p>确保启用 MutatingAdmissionWebhook 和 ValidatingAdmissionWebhook 控制器。
<a href="/zh/docs/reference/access-authn-authz/admission-controllers/#is-there-a-recommended-set-of-admission-controllers-to-use">这里</a>
是一组推荐的 admission 控制器，通常可以启用。</p>
</li>
<li>
<p>确保启用了 <code>admissionregistration.k8s.io/v1beta1</code> API。</p>
</li>
</ul>
<!--
### Write an admission webhook server
-->
<h3 id="编写一个准入-webhook-服务器">编写一个准入 Webhook 服务器</h3>
<!--
Please refer to the implementation of the [admission webhook
server](https://github.com/kubernetes/kubernetes/blob/v1.13.0/test/images/webhook/main.go)
that is validated in a Kubernetes e2e test. The webhook handles the
`AdmissionReview` request sent by the apiservers, and sends back its decision
as an `AdmissionReview` object in the same version it received.
-->
<p>请参阅 Kubernetes e2e 测试中的 <a href="https://github.com/kubernetes/kubernetes/blob/v1.13.0/test/images/webhook/main.go">admission webhook 服务器</a> 的实现。webhook 处理由 apiserver 发送的 <code>AdmissionReview</code> 请求，并且将其决定作为 <code>AdmissionReview</code> 对象以相同版本发送回去。</p>
<!--
See the [webhook request](#request) section for details on the data sent to webhooks.
-->
<p>有关发送到 webhook 的数据的详细信息，请参阅 <a href="#request">webhook 请求</a>。</p>
<!--
See the [webhook response](#response) section for the data expected from webhooks.
-->
<p>要获取来自 webhook 的预期数据，请参阅 <a href="#response">webhook 响应</a>。</p>
<!--
The example admission webhook server leaves the `ClientAuth` field
[empty](https://github.com/kubernetes/kubernetes/blob/v1.13.0/test/images/webhook/config.go#L47-L48),
which defaults to `NoClientCert`. This means that the webhook server does not
authenticate the identity of the clients, supposedly apiservers. If you need
mutual TLS or other ways to authenticate the clients, see
how to [authenticate apiservers](#authenticate-apiservers).
-->
<p>示例准入 Webhook 服务器置 <code>ClientAuth</code> 字段为<a href="https://github.com/kubernetes/kubernetes/blob/v1.13.0/test/images/webhook/config.go#L47-L48">空</a>，默认为 <code>NoClientCert</code> 。这意味着 webhook 服务器不会验证客户端的身份，认为其是 apiservers。
如果你需要双向 TLS 或其他方式来验证客户端，请参阅如何<a href="#authenticate-apiservers">对 apiservers 进行身份认证</a>。</p>
<!--
### Deploy the admission webhook service
-->
<h3 id="部署准入-webhook-服务">部署准入 Webhook 服务</h3>
<!--
The webhook server in the e2e test is deployed in the Kubernetes cluster, via
the [deployment API](/docs/reference/generated/kubernetes-api/v1.22/#deployment-v1-apps).
The test also creates a [service](/docs/reference/generated/kubernetes-api/v1.22/#service-v1-core)
as the front-end of the webhook server. See
[code](https://github.com/kubernetes/kubernetes/blob/v1.15.0/test/e2e/apimachinery/webhook.go#L301).
-->
<p>e2e 测试中的 webhook 服务器通过 <a href="/docs/reference/generated/kubernetes-api/v1.22/#deployment-v1-apps">deployment API</a> 部署在 Kubernetes 集群中。该测试还将创建一个 <a href="/docs/reference/generated/kubernetes-api/v1.22/#service-v1-core">service</a> 作为 webhook 服务器的前端。参见<a href="https://github.com/kubernetes/kubernetes/blob/v1.15.0/test/e2e/apimachinery/webhook.go#L301">相关代码</a>。</p>
<!--
You may also deploy your webhooks outside of the cluster. You will need to update
your webhook configurations accordingly.
-->
<p>你也可以在集群外部署 webhook。这样做需要相应地更新你的 webhook 配置。</p>
<!--
### Configure准入 Webhooks on the fly
-->
<h3 id="即时配置准入-webhook">即时配置准入 Webhook</h3>
<!--
You can dynamically configure what resources are subject to what admission
webhooks via
[ValidatingWebhookConfiguration](/docs/reference/generated/kubernetes-api/v1.22/#validatingwebhookconfiguration-v1-admissionregistration-k8s-io)
or
[MutatingWebhookConfiguration](/docs/reference/generated/kubernetes-api/v1.22/#mutatingwebhookconfiguration-v1-admissionregistration-k8s-io).
-->
<p>你可以通过 <a href="/docs/reference/generated/kubernetes-api/v1.22/#validatingwebhookconfiguration-v1-admissionregistration-k8s-io">ValidatingWebhookConfiguration</a> 或者 <a href="/docs/reference/generated/kubernetes-api/v1.22/#mutatingwebhookconfiguration-v1-admissionregistration-k8s-io">MutatingWebhookConfiguration</a> 动态配置哪些资源要被哪些准入 Webhook 处理。</p>
<!--
The following is an example `ValidatingWebhookConfiguration`, a mutating webhook configuration is similar.
See the [webhook configuration](#webhook-configuration) section for details about each config field.
-->
<p>以下是一个 <code>ValidatingWebhookConfiguration</code> 示例，mutating webhook 配置与此类似。有关每个配置字段的详细信息，请参阅 <a href="#webhook-configuration">webhook 配置</a> 部分。</p>
<ul class="nav nav-tabs" id="validatingwebhookconfiguration-example-1" role="tablist"><li class="nav-item"><a data-toggle="tab" class="nav-link active" href="#validatingwebhookconfiguration-example-1-0" role="tab" aria-controls="validatingwebhookconfiguration-example-1-0" aria-selected="true">admissionregistration.k8s.io/v1</a></li>
	  
		<li class="nav-item"><a data-toggle="tab" class="nav-link" href="#validatingwebhookconfiguration-example-1-1" role="tab" aria-controls="validatingwebhookconfiguration-example-1-1">admissionregistration.k8s.io/v1beta1</a></li></ul>
<div class="tab-content" id="validatingwebhookconfiguration-example-1"><div id="validatingwebhookconfiguration-example-1-0" class="tab-pane show active" role="tabpanel" aria-labelledby="validatingwebhookconfiguration-example-1-0">

<p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>admissionregistration.k8s.io/v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>ValidatingWebhookConfiguration<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;pod-policy.example.com&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">webhooks</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;pod-policy.example.com&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">rules</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- <span style="color:#008000;font-weight:bold">apiGroups</span>:<span style="color:#bbb">   </span>[<span style="color:#b44">&#34;&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">apiVersions</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;v1&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">operations</span>:<span style="color:#bbb">  </span>[<span style="color:#b44">&#34;CREATE&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">resources</span>:<span style="color:#bbb">   </span>[<span style="color:#b44">&#34;pods&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">scope</span>:<span style="color:#bbb">       </span><span style="color:#b44">&#34;Namespaced&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">clientConfig</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">service</span>:<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">namespace</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;example-namespace&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;example-service&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">caBundle</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;Ci0tLS0tQk...&lt;base64-encoded PEM bundle containing the CA that signed the webhook&#39;s serving certificate&gt;...tLS0K&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">admissionReviewVersions</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;v1&#34;</span>,<span style="color:#bbb"> </span><span style="color:#b44">&#34;v1beta1&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">sideEffects</span>:<span style="color:#bbb"> </span>None<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">timeoutSeconds</span>:<span style="color:#bbb"> </span><span style="color:#666">5</span><span style="color:#bbb">
</span></code></pre></div></div>
  <div id="validatingwebhookconfiguration-example-1-1" class="tab-pane" role="tabpanel" aria-labelledby="validatingwebhookconfiguration-example-1-1">

<p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#080;font-style:italic"># 1.16 中被淘汰，推荐使用 admissionregistration.k8s.io/v1</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>admissionregistration.k8s.io/v1beta1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>ValidatingWebhookConfiguration<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;pod-policy.example.com&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">webhooks</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;pod-policy.example.com&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">rules</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- <span style="color:#008000;font-weight:bold">apiGroups</span>:<span style="color:#bbb">   </span>[<span style="color:#b44">&#34;&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">apiVersions</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;v1&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">operations</span>:<span style="color:#bbb">  </span>[<span style="color:#b44">&#34;CREATE&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">resources</span>:<span style="color:#bbb">   </span>[<span style="color:#b44">&#34;pods&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">scope</span>:<span style="color:#bbb">       </span><span style="color:#b44">&#34;Namespaced&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">clientConfig</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">service</span>:<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">namespace</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;example-namespace&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;example-service&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">caBundle</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;Ci0tLS0tQk...&lt;base64-encoded PEM bundle containing the CA that signed the webhook&#39;s serving certificate&gt;...tLS0K&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">admissionReviewVersions</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;v1beta1&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">timeoutSeconds</span>:<span style="color:#bbb"> </span><span style="color:#666">5</span><span style="color:#bbb">
</span></code></pre></div></div></div>

<!--
The scope field specifies if only cluster-scoped resources ("Cluster") or namespace-scoped
resources ("Namespaced") will match this rule. "*" means that there are no scope restrictions.
-->
<p>scope 字段指定是仅集群范围的资源（Cluster）还是名字空间范围的资源资源（Namespaced）将与此规则匹配。<code>*</code> 表示没有范围限制。</p>
<!--
When using `clientConfig.service`, the server cert must be valid for
`<svc_name>.<svc_namespace>.svc`.
-->
<blockquote class="note callout">
  <div><strong>说明：</strong> 当使用 <code>clientConfig.service</code> 时，服务器证书必须对 <code>&lt;svc_name&gt;.&lt;svc_namespace&gt;.svc</code> 有效。</div>
</blockquote>
<!--
Default timeout for a webhook call is 10 seconds for webhooks registered created using `admissionregistration.k8s.io/v1`,
and 30 seconds for webhooks created using `admissionregistration.k8s.io/v1beta1`. Starting in kubernetes 1.14 you
can set the timeout and it is encouraged to use a small timeout for webhooks.
If the webhook call times out, the request is handled according to the webhook's
failure policy.
-->
<blockquote class="note callout">
  <div><strong>说明：</strong> 对于使用 <code>admissionregistration.k8s.io/v1</code> 创建的 webhook 而言，其 webhook 调用的默认超时是 10 秒；
对于使用 <code>admissionregistration.k8s.io/v1beta1</code> 创建的 webhook 而言，其默认超时是 30 秒。
从 kubernetes 1.14 开始，可以设置超时。建议对 webhooks 设置较短的超时时间。
如果 webhook 调用超时，则根据 webhook 的失败策略处理请求。</div>
</blockquote>
<!--
When an apiserver receives a request that matches one of the `rules`, the
apiserver sends an `admissionReview` request to webhook as specified in the
`clientConfig`.

After you create the webhook configuration, the system will take a few seconds
to honor the new configuration.
-->
<p>当 apiserver 收到与 <code>rules</code> 相匹配的请求时，apiserver 按照 <code>clientConfig</code> 中指定的方式向 webhook 发送一个 <code>admissionReview</code> 请求。</p>
<p>创建 webhook 配置后，系统将花费几秒钟使新配置生效。</p>
<!--
### Authenticate apiservers
-->
<h3 id="authenticate-apiservers">对 apiservers 进行身份认证</h3>
<!--
If your admission webhooks require authentication, you can configure the
apiservers to use basic auth, bearer token, or a cert to authenticate itself to
the webhooks. There are three steps to complete the configuration.
-->
<p>如果你的 webhook 需要身份验证，则可以将 apiserver 配置为使用基本身份验证、持有者令牌或证书来向 webhook 提供身份证明。完成此配置需要三个步骤。</p>
<!--
* When starting the apiserver, specify the location of the admission control
  configuration file via the `--admission-control-config-file` flag.

* In the admission control configuration file, specify where the
  MutatingAdmissionWebhook controller and ValidatingAdmissionWebhook controller
  should read the credentials. The credentials are stored in kubeConfig files
  (yes, the same schema that's used by kubectl), so the field name is
  `kubeConfigFile`. Here is an example admission control configuration file:
-->
<ul>
<li>
<p>启动 apiserver 时，通过 <code>--admission-control-config-file</code> 参数指定准入控制配置文件的位置。</p>
</li>
<li>
<p>在准入控制配置文件中，指定 MutatingAdmissionWebhook 控制器和 ValidatingAdmissionWebhook 控制器应该读取凭据的位置。
凭证存储在 kubeConfig 文件中（是​​的，与 kubectl 使用的模式相同），因此字段名称为 <code>kubeConfigFile</code>。
以下是一个准入控制配置文件示例：</p>
</li>
</ul>
<!--
# Deprecated in v1.17 in favor of apiserver.config.k8s.io/v1
# Deprecated in v1.17 in favor of apiserver.config.k8s.io/v1, kind=WebhookAdmissionConfiguration
# Deprecated in v1.17 in favor of apiserver.config.k8s.io/v1, kind=WebhookAdmissionConfiguration
-->
<ul class="nav nav-tabs" id="admissionconfiguration-example1" role="tablist"><li class="nav-item"><a data-toggle="tab" class="nav-link active" href="#admissionconfiguration-example1-0" role="tab" aria-controls="admissionconfiguration-example1-0" aria-selected="true">apiserver.config.k8s.io/v1</a></li>
	  
		<li class="nav-item"><a data-toggle="tab" class="nav-link" href="#admissionconfiguration-example1-1" role="tab" aria-controls="admissionconfiguration-example1-1">apiserver.k8s.io/v1alpha1</a></li></ul>
<div class="tab-content" id="admissionconfiguration-example1"><div id="admissionconfiguration-example1-0" class="tab-pane show active" role="tabpanel" aria-labelledby="admissionconfiguration-example1-0">

<p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>apiserver.config.k8s.io/v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>AdmissionConfiguration<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">plugins</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>ValidatingAdmissionWebhook<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">configuration</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>apiserver.config.k8s.io/v1<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>WebhookAdmissionConfiguration<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">kubeConfigFile</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;&lt;path-to-kubeconfig-file&gt;&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>MutatingAdmissionWebhook<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">configuration</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>apiserver.config.k8s.io/v1<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>WebhookAdmissionConfiguration<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">kubeConfigFile</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;&lt;path-to-kubeconfig-file&gt;&#34;</span><span style="color:#bbb">
</span></code></pre></div></div>
  <div id="admissionconfiguration-example1-1" class="tab-pane" role="tabpanel" aria-labelledby="admissionconfiguration-example1-1">

<p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#080;font-style:italic"># 1.17 中被淘汰，推荐使用 apiserver.config.k8s.io/v1</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>apiserver.k8s.io/v1alpha1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>AdmissionConfiguration<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">plugins</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>ValidatingAdmissionWebhook<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">configuration</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#080;font-style:italic"># 1.17 中被淘汰，推荐使用 apiserver.config.k8s.io/v1，kind = WebhookAdmissionConfiguration</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>apiserver.config.k8s.io/v1alpha1<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>WebhookAdmission<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">kubeConfigFile</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;&lt;path-to-kubeconfig-file&gt;&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>MutatingAdmissionWebhook<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">configuration</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#080;font-style:italic"># 1.17 中被淘汰，推荐使用 apiserver.config.k8s.io/v1，kind = WebhookAdmissionConfiguration</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>apiserver.config.k8s.io/v1alpha1<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>WebhookAdmission<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">kubeConfigFile</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;&lt;path-to-kubeconfig-file&gt;&#34;</span><span style="color:#bbb">
</span></code></pre></div></div></div>

<!--
For more information about `AdmissionConfiguration`, see the
[AdmissionConfiguration schema](https://github.com/kubernetes/kubernetes/blob/v1.17.0/staging/src/k8s.io/apiserver/pkg/apis/apiserver/v1/types.go#L27).
See the [webhook configuration](#webhook-configuration) section for details about each config field.

* In the kubeConfig file, provide the credentials:
-->
<p>有关 <code>AdmissionConfiguration</code> 的更多信息，请参见 <a href="https://github.com/kubernetes/kubernetes/blob/v1.17.0/staging/src/k8s.io/apiserver/pkg/apis/apiserver/v1/types.go#L27">AdmissionConfiguration schema</a>。
有关每个配置字段的详细信息，请参见 <a href="#webhook-%E9%85%8D%E7%BD%AE">webhook 配置</a>部分。</p>
<ul>
<li>
<p>在 kubeConfig 文件中，提供证书凭据：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>Config<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">users</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#080;font-style:italic"># 名称应设置为服务的 DNS 名称或配置了 Webhook 的 URL 的主机名（包括端口）。</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#080;font-style:italic"># 如果将非 443 端口用于服务，则在配置 1.16+ API 服务器时，该端口必须包含在名称中。</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#080;font-style:italic">#</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#080;font-style:italic"># 对于配置在默认端口（443）上与服务对话的 Webhook，请指定服务的 DNS 名称：</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#080;font-style:italic"># - name: webhook1.ns1.svc</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#080;font-style:italic">#   user: ...</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#080;font-style:italic">#</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#080;font-style:italic"># 对于配置在非默认端口（例如 8443）上与服务对话的 Webhook，请在 1.16+ 中指定服务的 DNS 名称和端口：</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#080;font-style:italic"># - name: webhook1.ns1.svc:8443</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#080;font-style:italic">#   user: ...</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#080;font-style:italic"># 并可以选择仅使用服务的 DNS 名称来创建第二节，以与 1.15 API 服务器版本兼容：</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#080;font-style:italic"># - name: webhook1.ns1.svc</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#080;font-style:italic">#   user: ...</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#080;font-style:italic">#</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#080;font-style:italic"># 对于配置为使用 URL 的 webhook，请匹配在 webhook 的 URL 中指定的主机（和端口）。</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#080;font-style:italic"># 带有 `url: https://www.example.com` 的 webhook：</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#080;font-style:italic"># - name: www.example.com</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#080;font-style:italic">#   user: ...</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#080;font-style:italic">#</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#080;font-style:italic"># 带有 `url: https://www.example.com:443` 的 webhook：</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#080;font-style:italic"># - name: www.example.com:443</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#080;font-style:italic">#   user: ...</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#080;font-style:italic">#</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#080;font-style:italic"># 带有 `url: https://www.example.com:8443` 的 webhook：</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#080;font-style:italic"># - name: www.example.com:8443</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#080;font-style:italic">#   user: ...</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#080;font-style:italic">#</span><span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#39;webhook1.ns1.svc&#39;</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">user</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">client-certificate-data</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;&lt;pem encoded certificate&gt;&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">client-key-data</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;&lt;pem encoded key&gt;&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#080;font-style:italic"># `name` 支持使用 * 通配符匹配前缀段。</span><span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#39;*.webhook-company.org&#39;</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">user</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">password</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;&lt;password&gt;&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">username</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;&lt;name&gt;&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#080;font-style:italic"># &#39;*&#39; 是默认匹配项。</span><span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#39;*&#39;</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">user</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">token</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;&lt;token&gt;&#34;</span><span style="color:#bbb">
</span></code></pre></div></li>
</ul>
<!--
Of course you need to set up the webhook server to handle these authentications.
-->
<p>当然，你需要设置 webhook 服务器来处理这些身份验证。</p>
<!--
### Request

Webhooks are sent a POST request, with `Content-Type: application/json`,
with an `AdmissionReview` API object in the `admission.k8s.io` API group
serialized to JSON as the body.

Webhooks can specify what versions of `AdmissionReview` objects they accept
with the `admissionReviewVersions` field in their configuration:
-->
<h3 id="request">请求</h3>
<p>向 Webhook 发送 POST 请求时，请设置 <code>Content-Type: application/json</code> 并对 <code>admission.k8s.io</code>  API 组中的 <code>AdmissionReview</code> 对象进行序列化，将所得到的 JSON 作为请求的主体。</p>
<p>Webhook 可以在配置中的 <code>admissionReviewVersions</code> 字段指定可接受的 <code>AdmissionReview</code> 对象版本：</p>
<ul class="nav nav-tabs" id="validatingwebhookconfiguration-admissionreviewversions" role="tablist"><li class="nav-item"><a data-toggle="tab" class="nav-link active" href="#validatingwebhookconfiguration-admissionreviewversions-0" role="tab" aria-controls="validatingwebhookconfiguration-admissionreviewversions-0" aria-selected="true">admissionregistration.k8s.io/v1</a></li>
	  
		<li class="nav-item"><a data-toggle="tab" class="nav-link" href="#validatingwebhookconfiguration-admissionreviewversions-1" role="tab" aria-controls="validatingwebhookconfiguration-admissionreviewversions-1">admissionregistration.k8s.io/v1beta1</a></li></ul>
<div class="tab-content" id="validatingwebhookconfiguration-admissionreviewversions"><div id="validatingwebhookconfiguration-admissionreviewversions-0" class="tab-pane show active" role="tabpanel" aria-labelledby="validatingwebhookconfiguration-admissionreviewversions-0">

<p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>admissionregistration.k8s.io/v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>ValidatingWebhookConfiguration<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#00f;font-weight:bold">...</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">webhooks</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>my-webhook.example.com<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">admissionReviewVersions</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;v1&#34;</span>,<span style="color:#bbb"> </span><span style="color:#b44">&#34;v1beta1&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">  </span>...<span style="color:#bbb">
</span></code></pre></div><!--
`admissionReviewVersions` is a required field when creating
`admissionregistration.k8s.io/v1` webhook configurations.
Webhooks are required to support at least one `AdmissionReview`
version understood by the current and previous API server.
-->
<p>创建 <code>admissionregistration.k8s.io/v1</code> webhook 配置时，<code>admissionReviewVersions</code> 是必填字段。
Webhook 必须支持至少一个当前和以前的 apiserver 都可以解析的 <code>AdmissionReview</code> 版本。</p>
</div>
  <div id="validatingwebhookconfiguration-admissionreviewversions-1" class="tab-pane" role="tabpanel" aria-labelledby="validatingwebhookconfiguration-admissionreviewversions-1">

<p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#080;font-style:italic"># v1.16 中被淘汰，推荐使用 admissionregistration.k8s.io/v1</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>admissionregistration.k8s.io/v1beta1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>ValidatingWebhookConfiguration<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#00f;font-weight:bold">...</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">webhooks</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>my-webhook.example.com<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">admissionReviewVersions</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;v1beta1&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">  </span>...<span style="color:#bbb">
</span></code></pre></div><!--
If no `admissionReviewVersions` are specified, the default when creating
`admissionregistration.k8s.io/v1beta1` webhook configurations is `v1beta1`.
-->
<p>如果未指定 <code>admissionReviewVersions</code>，则创建 <code>admissionregistration.k8s.io/v1beta1</code> Webhook 配置时的默认值为 <code>v1beta1</code>。</p>
</div></div>

<!--
API servers send the first `AdmissionReview` version in the `admissionReviewVersions` list they support.
If none of the versions in the list are supported by the API server, the configuration will not be allowed to be created.
If an API server encounters a webhook configuration that was previously created and does not support any of the `AdmissionReview`
versions the API server knows how to send, attempts to call to the webhook will fail and be subject to the [failure policy](#failure-policy).

This example shows the data contained in an `AdmissionReview` object
for a request to update the `scale` subresource of an `apps/v1` `Deployment`:
-->
<p>API 服务器将发送的是 <code>admissionReviewVersions</code> 列表中所支持的第一个 <code>AdmissionReview</code> 版本。如果 API 服务器不支持列表中的任何版本，则不允许创建配置。</p>
<p>如果 API 服务器遇到以前创建的 Webhook 配置，并且不支持该 API 服务器知道如何发送的任何 <code>AdmissionReview</code> 版本，则调用 Webhook 的尝试将失败，并依据<a href="#failure-policy">失败策略</a>进行处理。</p>
<p>此示例显示了 <code>AdmissionReview</code> 对象中包含的数据，该数据用于请求更新 <code>apps/v1</code> <code>Deployment</code> 的 <code>scale</code> 子资源：</p>
<ul class="nav nav-tabs" id="admissionreview-request" role="tablist"><li class="nav-item"><a data-toggle="tab" class="nav-link active" href="#admissionreview-request-0" role="tab" aria-controls="admissionreview-request-0" aria-selected="true">admission.k8s.io/v1</a></li>
	  
		<li class="nav-item"><a data-toggle="tab" class="nav-link" href="#admissionreview-request-1" role="tab" aria-controls="admissionreview-request-1">admission.k8s.io/v1beta1</a></li></ul>
<div class="tab-content" id="admissionreview-request"><div id="admissionreview-request-0" class="tab-pane show active" role="tabpanel" aria-labelledby="admissionreview-request-0">

<p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml">{<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">&#34;apiVersion&#34;: </span><span style="color:#b44">&#34;admission.k8s.io/v1&#34;</span>,<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">&#34;kind&#34;: </span><span style="color:#b44">&#34;AdmissionReview&#34;</span>,<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">&#34;request&#34;: </span>{<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#080;font-style:italic"># 唯一标识此准入回调的随机 uid</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">&#34;uid&#34;: </span><span style="color:#b44">&#34;705ab4f5-6393-11e8-b7cc-42010a800002&#34;</span>,<span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#080;font-style:italic"># 传入完全正确的 group/version/kind 对象</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">&#34;kind&#34;: </span>{<span style="color:#b44">&#34;group&#34;</span>:<span style="color:#b44">&#34;autoscaling&#34;</span>,<span style="color:#b44">&#34;version&#34;</span>:<span style="color:#b44">&#34;v1&#34;</span>,<span style="color:#b44">&#34;kind&#34;</span>:<span style="color:#b44">&#34;Scale&#34;</span>},<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#080;font-style:italic"># 修改 resource 的完全正确的的 group/version/kind</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">&#34;resource&#34;: </span>{<span style="color:#b44">&#34;group&#34;</span>:<span style="color:#b44">&#34;apps&#34;</span>,<span style="color:#b44">&#34;version&#34;</span>:<span style="color:#b44">&#34;v1&#34;</span>,<span style="color:#b44">&#34;resource&#34;</span>:<span style="color:#b44">&#34;deployments&#34;</span>},<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#080;font-style:italic"># subResource（如果请求是针对 subResource 的）</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">&#34;subResource&#34;: </span><span style="color:#b44">&#34;scale&#34;</span>,<span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#080;font-style:italic"># 在对 API 服务器的原始请求中，传入对象的标准 group/version/kind</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#080;font-style:italic"># 仅当 webhook 指定 `matchPolicy: Equivalent` 且将对 API 服务器的原始请求转换为 webhook 注册的版本时，这才与 `kind` 不同。</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">&#34;requestKind&#34;: </span>{<span style="color:#b44">&#34;group&#34;</span>:<span style="color:#b44">&#34;autoscaling&#34;</span>,<span style="color:#b44">&#34;version&#34;</span>:<span style="color:#b44">&#34;v1&#34;</span>,<span style="color:#b44">&#34;kind&#34;</span>:<span style="color:#b44">&#34;Scale&#34;</span>},<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#080;font-style:italic"># 在对 API 服务器的原始请求中正在修改的资源的标准 group/version/kind</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#080;font-style:italic"># 仅当 webhook 指定了 `matchPolicy：Equivalent` 并且将对 API 服务器的原始请求转换为 webhook 注册的版本时，这才与 `resource` 不同。</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">&#34;requestResource&#34;: </span>{<span style="color:#b44">&#34;group&#34;</span>:<span style="color:#b44">&#34;apps&#34;</span>,<span style="color:#b44">&#34;version&#34;</span>:<span style="color:#b44">&#34;v1&#34;</span>,<span style="color:#b44">&#34;resource&#34;</span>:<span style="color:#b44">&#34;deployments&#34;</span>},<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#080;font-style:italic"># subResource（如果请求是针对 subResource 的）</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#080;font-style:italic"># 仅当 webhook 指定了 `matchPolicy：Equivalent` 并且将对 API 服务器的原始请求转换为该 webhook 注册的版本时，这才与 `subResource` 不同。</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">&#34;requestSubResource&#34;: </span><span style="color:#b44">&#34;scale&#34;</span>,<span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#080;font-style:italic"># 被修改资源的名称</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">&#34;name&#34;: </span><span style="color:#b44">&#34;my-deployment&#34;</span>,<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#080;font-style:italic"># 如果资源是属于名字空间（或者是名字空间对象），则这是被修改的资源的名字空间</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">&#34;namespace&#34;: </span><span style="color:#b44">&#34;my-namespace&#34;</span>,<span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#080;font-style:italic"># 操作可以是 CREATE、UPDATE、DELETE 或 CONNECT</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">&#34;operation&#34;: </span><span style="color:#b44">&#34;UPDATE&#34;</span>,<span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">&#34;userInfo&#34;: </span>{<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#080;font-style:italic"># 向 API 服务器发出请求的经过身份验证的用户的用户名</span><span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">&#34;username&#34;: </span><span style="color:#b44">&#34;admin&#34;</span>,<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#080;font-style:italic"># 向 API 服务器发出请求的经过身份验证的用户的 UID</span><span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">&#34;uid&#34;: </span><span style="color:#b44">&#34;014fbff9a07c&#34;</span>,<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#080;font-style:italic"># 向 API 服务器发出请求的经过身份验证的用户的组成员身份</span><span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">&#34;groups&#34;: </span>[<span style="color:#b44">&#34;system:authenticated&#34;</span>,<span style="color:#b44">&#34;my-admin-group&#34;</span>],<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#080;font-style:italic"># 向 API 服务器发出请求的用户相关的任意附加信息</span><span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#080;font-style:italic"># 该字段由 API 服务器身份验证层填充，并且如果 webhook 执行了任何 SubjectAccessReview 检查，则应将其包括在内。</span><span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">&#34;extra&#34;: </span>{<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#b44">&#34;some-key&#34;</span>:[<span style="color:#b44">&#34;some-value1&#34;</span>,<span style="color:#bbb"> </span><span style="color:#b44">&#34;some-value2&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">      </span>}<span style="color:#bbb">
</span><span style="color:#bbb">    </span>},<span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#080;font-style:italic"># object 是被接纳的新对象。</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#080;font-style:italic"># 对于 DELETE 操作，它为 null。</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">&#34;object&#34;: </span>{<span style="color:#b44">&#34;apiVersion&#34;</span>:<span style="color:#b44">&#34;autoscaling/v1&#34;</span>,<span style="color:#b44">&#34;kind&#34;</span>:<span style="color:#b44">&#34;Scale&#34;</span>,...},<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#080;font-style:italic"># oldObject 是现有对象。</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#080;font-style:italic"># 对于 CREATE 和 CONNECT 操作，它为 null。</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">&#34;oldObject&#34;: </span>{<span style="color:#b44">&#34;apiVersion&#34;</span>:<span style="color:#b44">&#34;autoscaling/v1&#34;</span>,<span style="color:#b44">&#34;kind&#34;</span>:<span style="color:#b44">&#34;Scale&#34;</span>,...},<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#080;font-style:italic"># options 包含要接受的操作的选项，例如 meta.k8s.io/v CreateOptions、UpdateOptions 或 DeleteOptions。</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#080;font-style:italic"># 对于 CONNECT 操作，它为 null。</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">&#34;options&#34;: </span>{<span style="color:#b44">&#34;apiVersion&#34;</span>:<span style="color:#b44">&#34;meta.k8s.io/v1&#34;</span>,<span style="color:#b44">&#34;kind&#34;</span>:<span style="color:#b44">&#34;UpdateOptions&#34;</span>,...},<span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#080;font-style:italic"># dryRun 表示 API 请求正在以 `dryrun` 模式运行，并且将不会保留。</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#080;font-style:italic"># 带有副作用的 Webhook 应该避免在 dryRun 为 true 时激活这些副作用。</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#080;font-style:italic"># 有关更多详细信息，请参见 http://k8s.io/docs/reference/using-api/api-concepts/#make-a-dry-run-request</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">&#34;dryRun&#34;: </span><span style="color:#a2f;font-weight:bold">false</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span>}<span style="color:#bbb">
</span><span style="color:#bbb"></span>}<span style="color:#bbb">
</span></code></pre></div></div>
  <div id="admissionreview-request-1" class="tab-pane" role="tabpanel" aria-labelledby="admissionreview-request-1">

<p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml">{<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#080;font-style:italic"># v1.16 中被废弃，推荐使用 admission.k8s.io/v1</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">&#34;apiVersion&#34;: </span><span style="color:#b44">&#34;admission.k8s.io/v1beta1&#34;</span>,<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">&#34;kind&#34;: </span><span style="color:#b44">&#34;AdmissionReview&#34;</span>,<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">&#34;request&#34;: </span>{<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#080;font-style:italic"># 唯一标识此准入回调的随机 uid</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">&#34;uid&#34;: </span><span style="color:#b44">&#34;705ab4f5-6393-11e8-b7cc-42010a800002&#34;</span>,<span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#080;font-style:italic"># 传入完全正确的 group/version/kind 对象</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">&#34;kind&#34;: </span>{<span style="color:#b44">&#34;group&#34;</span>:<span style="color:#b44">&#34;autoscaling&#34;</span>,<span style="color:#b44">&#34;version&#34;</span>:<span style="color:#b44">&#34;v1&#34;</span>,<span style="color:#b44">&#34;kind&#34;</span>:<span style="color:#b44">&#34;Scale&#34;</span>},<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#080;font-style:italic"># 修改 resource 的完全正确的的 group/version/kind</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">&#34;resource&#34;: </span>{<span style="color:#b44">&#34;group&#34;</span>:<span style="color:#b44">&#34;apps&#34;</span>,<span style="color:#b44">&#34;version&#34;</span>:<span style="color:#b44">&#34;v1&#34;</span>,<span style="color:#b44">&#34;resource&#34;</span>:<span style="color:#b44">&#34;deployments&#34;</span>},<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#080;font-style:italic"># subResource（如果请求是针对 subResource 的）</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">&#34;subResource&#34;: </span><span style="color:#b44">&#34;scale&#34;</span>,<span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#080;font-style:italic"># 在对 API 服务器的原始请求中，传入对象的标准 group/version/kind。</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#080;font-style:italic"># 仅当 Webhook 指定了 `matchPolicy：Equivalent` 并且将对 API 服务器的原始请求转换为该 Webhook 注册的版本时，这与 `kind` 不同。</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#080;font-style:italic"># 仅由 v1.15+ API 服务器发送。</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">&#34;requestKind&#34;: </span>{<span style="color:#b44">&#34;group&#34;</span>:<span style="color:#b44">&#34;autoscaling&#34;</span>,<span style="color:#b44">&#34;version&#34;</span>:<span style="color:#b44">&#34;v1&#34;</span>,<span style="color:#b44">&#34;kind&#34;</span>:<span style="color:#b44">&#34;Scale&#34;</span>},<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#080;font-style:italic"># 在对 API 服务器的原始请求中正在修改的资源的标准 group/version/kind</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#080;font-style:italic"># 仅当 webhook 指定了 `matchPolicy：Equivalent` 并且将对 API 服务器的原始请求转换为 webhook 注册的版本时，这才与 `resource` 不同。</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#080;font-style:italic"># 仅由 v1.15+ API 服务器发送。</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">&#34;requestResource&#34;: </span>{<span style="color:#b44">&#34;group&#34;</span>:<span style="color:#b44">&#34;apps&#34;</span>,<span style="color:#b44">&#34;version&#34;</span>:<span style="color:#b44">&#34;v1&#34;</span>,<span style="color:#b44">&#34;resource&#34;</span>:<span style="color:#b44">&#34;deployments&#34;</span>},<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#080;font-style:italic"># subResource（如果请求是针对 subResource 的）</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#080;font-style:italic"># 仅当 webhook 指定了 `matchPolicy：Equivalent` 并且将对 API 服务器的原始请求转换为该 webhook 注册的版本时，这才与 `subResource` 不同。</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#080;font-style:italic"># 仅由 v1.15+ API 服务器发送。</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">&#34;requestSubResource&#34;: </span><span style="color:#b44">&#34;scale&#34;</span>,<span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#080;font-style:italic"># 被修改资源的名称</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">&#34;name&#34;: </span><span style="color:#b44">&#34;my-deployment&#34;</span>,<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#080;font-style:italic"># 如果资源是属于名字空间（或者是名字空间对象），则这是被修改的资源的名字空间</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">&#34;namespace&#34;: </span><span style="color:#b44">&#34;my-namespace&#34;</span>,<span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#080;font-style:italic"># 操作可以是 CREATE、UPDATE、DELETE 或 CONNECT</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">&#34;operation&#34;: </span><span style="color:#b44">&#34;UPDATE&#34;</span>,<span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">&#34;userInfo&#34;: </span>{<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#080;font-style:italic"># 向 API 服务器发出请求的经过身份验证的用户的用户名</span><span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">&#34;username&#34;: </span><span style="color:#b44">&#34;admin&#34;</span>,<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#080;font-style:italic"># 向 API 服务器发出请求的经过身份验证的用户的 UID</span><span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">&#34;uid&#34;: </span><span style="color:#b44">&#34;014fbff9a07c&#34;</span>,<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#080;font-style:italic"># 向 API 服务器发出请求的经过身份验证的用户的组成员身份</span><span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">&#34;groups&#34;: </span>[<span style="color:#b44">&#34;system:authenticated&#34;</span>,<span style="color:#b44">&#34;my-admin-group&#34;</span>],<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#080;font-style:italic"># 向 API 服务器发出请求的用户相关的任意附加信息</span><span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#080;font-style:italic"># 该字段由 API 服务器身份验证层填充，并且如果 webhook 执行了任何 SubjectAccessReview 检查，则应将其包括在内。</span><span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">&#34;extra&#34;: </span>{<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#b44">&#34;some-key&#34;</span>:[<span style="color:#b44">&#34;some-value1&#34;</span>,<span style="color:#bbb"> </span><span style="color:#b44">&#34;some-value2&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">      </span>}<span style="color:#bbb">
</span><span style="color:#bbb">    </span>},<span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#080;font-style:italic"># object 是被接纳的新对象。</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#080;font-style:italic"># 对于 DELETE 操作，它为 null。</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">&#34;object&#34;: </span>{<span style="color:#b44">&#34;apiVersion&#34;</span>:<span style="color:#b44">&#34;autoscaling/v1&#34;</span>,<span style="color:#b44">&#34;kind&#34;</span>:<span style="color:#b44">&#34;Scale&#34;</span>,...},<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#080;font-style:italic"># oldObject 是现有对象。</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#080;font-style:italic"># 对于 CREATE 和 CONNECT 操作（对于 v1.15.0 之前版本的 API 服务器中的 DELETE 操作），它为 null。</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">&#34;oldObject&#34;: </span>{<span style="color:#b44">&#34;apiVersion&#34;</span>:<span style="color:#b44">&#34;autoscaling/v1&#34;</span>,<span style="color:#b44">&#34;kind&#34;</span>:<span style="color:#b44">&#34;Scale&#34;</span>,...},<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#080;font-style:italic"># options 包含要接受的操作的选项，例如 meta.k8s.io/v CreateOptions、UpdateOptions 或 DeleteOptions。</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#080;font-style:italic"># 对于 CONNECT 操作，它为 null。</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#080;font-style:italic"># 仅由 v1.15+ API 服务器发送。</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">&#34;options&#34;: </span>{<span style="color:#b44">&#34;apiVersion&#34;</span>:<span style="color:#b44">&#34;meta.k8s.io/v1&#34;</span>,<span style="color:#b44">&#34;kind&#34;</span>:<span style="color:#b44">&#34;UpdateOptions&#34;</span>,...},<span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#080;font-style:italic"># dryRun 表示 API 请求正在以 `dryrun` 模式运行，并且将不会保留。</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#080;font-style:italic"># 带有副作用的 Webhook 应该避免在 dryRun 为 true 时激活这些副作用。</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#080;font-style:italic"># 有关更多详细信息，请参见 http://k8s.io/docs/reference/using-api/api-concepts/#make-a-dry-run-request</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">&#34;dryRun&#34;: </span><span style="color:#a2f;font-weight:bold">false</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span>}<span style="color:#bbb">
</span><span style="color:#bbb"></span>}<span style="color:#bbb">
</span></code></pre></div></div></div>

<!--
### Response
-->
<h3 id="response">响应</h3>
<!--
Webhooks respond with a 200 HTTP status code, `Content-Type: application/json`,
and a body containing an `AdmissionReview` object (in the same version they were sent),
with the `response` stanza populated, serialized to JSON.
-->
<p>Webhook 使用 HTTP 200 状态码、<code>Content-Type: application/json</code> 和一个包含 <code>AdmissionReview</code> 对象的 JSON 序列化格式来发送响应。该 <code>AdmissionReview</code> 对象与发送的版本相同，且其中包含的 <code>response</code> 字段已被有效填充。</p>
<!--
At a minimum, the `response` stanza must contain the following fields:

* `uid`, copied from the `request.uid` sent to the webhook
* `allowed`, either set to `true` or `false`

Example of a minimal response from a webhook to allow a request:
-->
<p><code>response</code> 至少必须包含以下字段：</p>
<ul>
<li><code>uid</code>，从发送到 webhook 的 <code>request.uid</code> 中复制而来</li>
<li><code>allowed</code>，设置为 <code>true</code> 或 <code>false</code></li>
</ul>
<!--
Example of a minimal response from a webhook to allow a request:
-->
<p>Webhook 允许请求的最简单响应示例：</p>
<ul class="nav nav-tabs" id="admissionreview-response-allow" role="tablist"><li class="nav-item"><a data-toggle="tab" class="nav-link active" href="#admissionreview-response-allow-0" role="tab" aria-controls="admissionreview-response-allow-0" aria-selected="true">admission.k8s.io/v1</a></li>
	  
		<li class="nav-item"><a data-toggle="tab" class="nav-link" href="#admissionreview-response-allow-1" role="tab" aria-controls="admissionreview-response-allow-1">admission.k8s.io/v1beta1</a></li></ul>
<div class="tab-content" id="admissionreview-response-allow"><div id="admissionreview-response-allow-0" class="tab-pane show active" role="tabpanel" aria-labelledby="admissionreview-response-allow-0">

<p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-json" data-lang="json">{
  <span style="color:#008000;font-weight:bold">&#34;apiVersion&#34;</span>: <span style="color:#b44">&#34;admission.k8s.io/v1&#34;</span>,
  <span style="color:#008000;font-weight:bold">&#34;kind&#34;</span>: <span style="color:#b44">&#34;AdmissionReview&#34;</span>,
  <span style="color:#008000;font-weight:bold">&#34;response&#34;</span>: {
    <span style="color:#008000;font-weight:bold">&#34;uid&#34;</span>: <span style="color:#b44">&#34;&lt;value from request.uid&gt;&#34;</span>,
    <span style="color:#008000;font-weight:bold">&#34;allowed&#34;</span>: <span style="color:#a2f;font-weight:bold">true</span>
  }
}
</code></pre></div></div>
  <div id="admissionreview-response-allow-1" class="tab-pane" role="tabpanel" aria-labelledby="admissionreview-response-allow-1">

<p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-json" data-lang="json">{
  <span style="color:#008000;font-weight:bold">&#34;apiVersion&#34;</span>: <span style="color:#b44">&#34;admission.k8s.io/v1beta1&#34;</span>,
  <span style="color:#008000;font-weight:bold">&#34;kind&#34;</span>: <span style="color:#b44">&#34;AdmissionReview&#34;</span>,
  <span style="color:#008000;font-weight:bold">&#34;response&#34;</span>: {
    <span style="color:#008000;font-weight:bold">&#34;uid&#34;</span>: <span style="color:#b44">&#34;&lt;value from request.uid&gt;&#34;</span>,
    <span style="color:#008000;font-weight:bold">&#34;allowed&#34;</span>: <span style="color:#a2f;font-weight:bold">true</span>
  }
}
</code></pre></div></div></div>

<!--
Example of a minimal response from a webhook to forbid a request:
-->
<p>Webhook 禁止请求的最简单响应示例：</p>
<ul class="nav nav-tabs" id="admissionreview-response-forbid-minimal" role="tablist"><li class="nav-item"><a data-toggle="tab" class="nav-link active" href="#admissionreview-response-forbid-minimal-0" role="tab" aria-controls="admissionreview-response-forbid-minimal-0" aria-selected="true">admission.k8s.io/v1</a></li>
	  
		<li class="nav-item"><a data-toggle="tab" class="nav-link" href="#admissionreview-response-forbid-minimal-1" role="tab" aria-controls="admissionreview-response-forbid-minimal-1">admission.k8s.io/v1beta1</a></li></ul>
<div class="tab-content" id="admissionreview-response-forbid-minimal"><div id="admissionreview-response-forbid-minimal-0" class="tab-pane show active" role="tabpanel" aria-labelledby="admissionreview-response-forbid-minimal-0">

<p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-json" data-lang="json">{
  <span style="color:#008000;font-weight:bold">&#34;apiVersion&#34;</span>: <span style="color:#b44">&#34;admission.k8s.io/v1&#34;</span>,
  <span style="color:#008000;font-weight:bold">&#34;kind&#34;</span>: <span style="color:#b44">&#34;AdmissionReview&#34;</span>,
  <span style="color:#008000;font-weight:bold">&#34;response&#34;</span>: {
    <span style="color:#008000;font-weight:bold">&#34;uid&#34;</span>: <span style="color:#b44">&#34;&lt;value from request.uid&gt;&#34;</span>,
    <span style="color:#008000;font-weight:bold">&#34;allowed&#34;</span>: <span style="color:#a2f;font-weight:bold">false</span>
  }
}
</code></pre></div></div>
  <div id="admissionreview-response-forbid-minimal-1" class="tab-pane" role="tabpanel" aria-labelledby="admissionreview-response-forbid-minimal-1">

<p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-json" data-lang="json">{
  <span style="color:#008000;font-weight:bold">&#34;apiVersion&#34;</span>: <span style="color:#b44">&#34;admission.k8s.io/v1beta1&#34;</span>,
  <span style="color:#008000;font-weight:bold">&#34;kind&#34;</span>: <span style="color:#b44">&#34;AdmissionReview&#34;</span>,
  <span style="color:#008000;font-weight:bold">&#34;response&#34;</span>: {
    <span style="color:#008000;font-weight:bold">&#34;uid&#34;</span>: <span style="color:#b44">&#34;&lt;value from request.uid&gt;&#34;</span>,
    <span style="color:#008000;font-weight:bold">&#34;allowed&#34;</span>: <span style="color:#a2f;font-weight:bold">false</span>
  }
}
</code></pre></div></div></div>

<!--
When rejecting a request, the webhook can customize the http code and message returned to the user using the `status` field.
The specified status object is returned to the user.
See the [API documentation](/docs/reference/generated/kubernetes-api/v1.14/#status-v1-meta) for details about the status type.
Example of a response to forbid a request, customizing the HTTP status code and message presented to the user:
-->
<p>当拒绝请求时，Webhook 可以使用 <code>status</code> 字段自定义 http 响应码和返回给用户的消息。
有关状态类型的详细信息，请参见
<a href="/docs/reference/generated/kubernetes-api/v1.22/#status-v1-meta">API 文档</a>。
禁止请求的响应示例，它定制了向用户显示的 HTTP 状态码和消息：</p>
<ul class="nav nav-tabs" id="admissionreview-response-forbid-details" role="tablist"><li class="nav-item"><a data-toggle="tab" class="nav-link active" href="#admissionreview-response-forbid-details-0" role="tab" aria-controls="admissionreview-response-forbid-details-0" aria-selected="true">admission.k8s.io/v1</a></li>
	  
		<li class="nav-item"><a data-toggle="tab" class="nav-link" href="#admissionreview-response-forbid-details-1" role="tab" aria-controls="admissionreview-response-forbid-details-1">admission.k8s.io/v1beta1</a></li></ul>
<div class="tab-content" id="admissionreview-response-forbid-details"><div id="admissionreview-response-forbid-details-0" class="tab-pane show active" role="tabpanel" aria-labelledby="admissionreview-response-forbid-details-0">

<p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-json" data-lang="json">{
  <span style="color:#008000;font-weight:bold">&#34;apiVersion&#34;</span>: <span style="color:#b44">&#34;admission.k8s.io/v1&#34;</span>,
  <span style="color:#008000;font-weight:bold">&#34;kind&#34;</span>: <span style="color:#b44">&#34;AdmissionReview&#34;</span>,
  <span style="color:#008000;font-weight:bold">&#34;response&#34;</span>: {
    <span style="color:#008000;font-weight:bold">&#34;uid&#34;</span>: <span style="color:#b44">&#34;&lt;value from request.uid&gt;&#34;</span>,
    <span style="color:#008000;font-weight:bold">&#34;allowed&#34;</span>: <span style="color:#a2f;font-weight:bold">false</span>,
    <span style="color:#008000;font-weight:bold">&#34;status&#34;</span>: {
      <span style="color:#008000;font-weight:bold">&#34;code&#34;</span>: <span style="color:#666">403</span>,
      <span style="color:#008000;font-weight:bold">&#34;message&#34;</span>: <span style="color:#b44">&#34;You cannot do this because it is Tuesday and your name starts with A&#34;</span>
    }
  }
}
</code></pre></div></div>
  <div id="admissionreview-response-forbid-details-1" class="tab-pane" role="tabpanel" aria-labelledby="admissionreview-response-forbid-details-1">

<p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-json" data-lang="json">{
  <span style="color:#008000;font-weight:bold">&#34;apiVersion&#34;</span>: <span style="color:#b44">&#34;admission.k8s.io/v1beta1&#34;</span>,
  <span style="color:#008000;font-weight:bold">&#34;kind&#34;</span>: <span style="color:#b44">&#34;AdmissionReview&#34;</span>,
  <span style="color:#008000;font-weight:bold">&#34;response&#34;</span>: {
    <span style="color:#008000;font-weight:bold">&#34;uid&#34;</span>: <span style="color:#b44">&#34;&lt;value from request.uid&gt;&#34;</span>,
    <span style="color:#008000;font-weight:bold">&#34;allowed&#34;</span>: <span style="color:#a2f;font-weight:bold">false</span>,
    <span style="color:#008000;font-weight:bold">&#34;status&#34;</span>: {
      <span style="color:#008000;font-weight:bold">&#34;code&#34;</span>: <span style="color:#666">403</span>,
      <span style="color:#008000;font-weight:bold">&#34;message&#34;</span>: <span style="color:#b44">&#34;You cannot do this because it is Tuesday and your name starts with A&#34;</span>
    }
  }
}
</code></pre></div></div></div>

<!--
When allowing a request, a mutating admission webhook may optionally modify the incoming object as well.
This is done using the `patch` and `patchType` fields in the response.
The only currently supported `patchType` is `JSONPatch`.
See [JSON patch](http://jsonpatch.com/) documentation for more details.
For `patchType: JSONPatch`, the `patch` field contains a base64-encoded array of JSON patch operations.
-->
<p>当允许请求时，mutating准入 Webhook 也可以选择修改传入的对象。
这是通过在响应中使用 <code>patch</code> 和 <code>patchType</code> 字段来完成的。
当前唯一支持的 <code>patchType</code> 是 <code>JSONPatch</code>。
有关更多详细信息，请参见 <a href="https://jsonpatch.com/">JSON patch</a>。
对于 <code>patchType: JSONPatch</code>，<code>patch</code> 字段包含一个以 base64 编码的 JSON patch 操作数组。</p>
<!--
As an example, a single patch operation that would set `spec.replicas` would be `[{"op": "add", "path": "/spec/replicas", "value": 3}]`

Base64-encoded, this would be `W3sib3AiOiAiYWRkIiwgInBhdGgiOiAiL3NwZWMvcmVwbGljYXMiLCAidmFsdWUiOiAzfV0=`
-->
<p>例如，设置 <code>spec.replicas</code> 的单个补丁操作将是
<code>[{&quot;op&quot;: &quot;add&quot;, &quot;path&quot;: &quot;/spec/replicas&quot;, &quot;value&quot;: 3}]</code>。</p>
<p>如果以 Base64 形式编码，结果将是
<code>W3sib3AiOiAiYWRkIiwgInBhdGgiOiAiL3NwZWMvcmVwbGljYXMiLCAidmFsdWUiOiAzfV0=</code></p>
<!--
So a webhook response to add that label would be:
-->
<p>因此，添加该标签的 webhook 响应为：
<ul class="nav nav-tabs" id="admissionreview-response-modify" role="tablist"><li class="nav-item"><a data-toggle="tab" class="nav-link active" href="#admissionreview-response-modify-0" role="tab" aria-controls="admissionreview-response-modify-0" aria-selected="true">admission.k8s.io/v1</a></li>
	  
		<li class="nav-item"><a data-toggle="tab" class="nav-link" href="#admissionreview-response-modify-1" role="tab" aria-controls="admissionreview-response-modify-1">admission.k8s.io/v1beta1</a></li></ul>
<div class="tab-content" id="admissionreview-response-modify"><div id="admissionreview-response-modify-0" class="tab-pane show active" role="tabpanel" aria-labelledby="admissionreview-response-modify-0">

<p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-json" data-lang="json">{
  <span style="color:#008000;font-weight:bold">&#34;apiVersion&#34;</span>: <span style="color:#b44">&#34;admission.k8s.io/v1&#34;</span>,
  <span style="color:#008000;font-weight:bold">&#34;kind&#34;</span>: <span style="color:#b44">&#34;AdmissionReview&#34;</span>,
  <span style="color:#008000;font-weight:bold">&#34;response&#34;</span>: {
    <span style="color:#008000;font-weight:bold">&#34;uid&#34;</span>: <span style="color:#b44">&#34;&lt;value from request.uid&gt;&#34;</span>,
    <span style="color:#008000;font-weight:bold">&#34;allowed&#34;</span>: <span style="color:#a2f;font-weight:bold">true</span>,
    <span style="color:#008000;font-weight:bold">&#34;patchType&#34;</span>: <span style="color:#b44">&#34;JSONPatch&#34;</span>,
    <span style="color:#008000;font-weight:bold">&#34;patch&#34;</span>: <span style="color:#b44">&#34;W3sib3AiOiAiYWRkIiwgInBhdGgiOiAiL3NwZWMvcmVwbGljYXMiLCAidmFsdWUiOiAzfV0=&#34;</span>
  }
}
</code></pre></div></div>
  <div id="admissionreview-response-modify-1" class="tab-pane" role="tabpanel" aria-labelledby="admissionreview-response-modify-1">

<p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-json" data-lang="json">{
  <span style="color:#008000;font-weight:bold">&#34;apiVersion&#34;</span>: <span style="color:#b44">&#34;admission.k8s.io/v1beta1&#34;</span>,
  <span style="color:#008000;font-weight:bold">&#34;kind&#34;</span>: <span style="color:#b44">&#34;AdmissionReview&#34;</span>,
  <span style="color:#008000;font-weight:bold">&#34;response&#34;</span>: {
    <span style="color:#008000;font-weight:bold">&#34;uid&#34;</span>: <span style="color:#b44">&#34;&lt;value from request.uid&gt;&#34;</span>,
    <span style="color:#008000;font-weight:bold">&#34;allowed&#34;</span>: <span style="color:#a2f;font-weight:bold">true</span>,
    <span style="color:#008000;font-weight:bold">&#34;patchType&#34;</span>: <span style="color:#b44">&#34;JSONPatch&#34;</span>,
    <span style="color:#008000;font-weight:bold">&#34;patch&#34;</span>: <span style="color:#b44">&#34;W3sib3AiOiAiYWRkIiwgInBhdGgiOiAiL3NwZWMvcmVwbGljYXMiLCAidmFsdWUiOiAzfV0=&#34;</span>
  }
}
</code></pre></div></div></div>
</p>
<!--
## Webhook configuration
-->
<h2 id="webhook-configuration">Webhook 配置</h2>
<!--
To register admission webhooks, create `MutatingWebhookConfiguration` or `ValidatingWebhookConfiguration` API objects.

Each configuration can contain one or more webhooks.
If multiple webhooks are specified in a single configuration, each should be given a unique name.
This is required in `admissionregistration.k8s.io/v1`, but strongly recommended when using `admissionregistration.k8s.io/v1beta1`,
in order to make resulting audit logs and metrics easier to match up to active configurations.

Each webhook defines the following things.
-->
<p>要注册准入 Webhook，请创建 <code>MutatingWebhookConfiguration</code> 或
<code>ValidatingWebhookConfiguration</code> API 对象。</p>
<p>每种配置可以包含一个或多个 Webhook。如果在单个配置中指定了多个
Webhook，则应为每个 webhook 赋予一个唯一的名称。
这在 <code>admissionregistration.k8s.io/v1</code> 中是必需的，但是在使用
<code>admissionregistration.k8s.io/v1beta1</code> 时强烈建议使用，
以使生成的审核日志和指标更易于与活动配置相匹配。</p>
<p>每个 Webhook 定义以下内容。</p>
<!--
### Matching requests: rules
-->
<h3 id="matching-requests-rules">匹配请求-规则</h3>
<!--
Each webhook must specify a list of rules used to determine if a request to the API server should be sent to the webhook.
Each rule specifies one or more operations, apiGroups, apiVersions, and resources, and a resource scope:
-->
<p>每个 webhook 必须指定用于确定是否应将对 apiserver 的请求发送到 webhook 的规则列表。
每个规则都指定一个或多个 operations、apiGroups、apiVersions 和 resources 以及资源的 scope：</p>
<!--
* `operations` lists one or more operations to match. Can be `"CREATE"`, `"UPDATE"`, `"DELETE"`, `"CONNECT"`, or `"*"` to match all.
* `apiGroups` lists one or more API groups to match. `""` is the core API group. `"*"` matches all API groups.
* `apiVersions` lists one or more API versions to match. `"*"` matches all API versions.
* `resources` lists one or more resources to match.
    * `"*"` matches all resources, but not subresources.
    * `"*/*"` matches all resources and subresources.
    * `"pods/*"` matches all subresources of pods.
    * `"*/status"` matches all status subresources.
* `scope` specifies a scope to match. Valid values are `"Cluster"`, `"Namespaced"`, and `"*"`. Subresources match the scope of their parent resource. Supported in v1.14+. Default is `"*"`, matching pre-1.14 behavior.
    * `"Cluster"` means that only cluster-scoped resources will match this rule (Namespace API objects are cluster-scoped).
    * `"Namespaced"` means that only namespaced resources will match this rule.
    * `"*"` means that there are no scope restrictions.
-->
<ul>
<li><code>operations</code> 列出一个或多个要匹配的操作。
可以是 <code>CREATE</code>、<code>UPDATE</code>、<code>DELETE</code>、<code>CONNECT</code> 或 <code>*</code> 以匹配所有内容。</li>
<li><code>apiGroups</code> 列出了一个或多个要匹配的 API 组。<code>&quot;&quot;</code> 是核心 API 组。<code>&quot;*&quot;</code> 匹配所有 API 组。</li>
<li><code>apiVersions</code> 列出了一个或多个要匹配的 API 版本。<code>&quot;*&quot;</code> 匹配所有 API 版本。</li>
<li><code>resources</code> 列出了一个或多个要匹配的资源。
<ul>
<li><code>&quot;*&quot;</code> 匹配所有资源，但不包括子资源。</li>
<li><code>&quot;*/*&quot;</code> 匹配所有资源，包括子资源。</li>
<li><code>&quot;pods/*&quot;</code> 匹配 pod 的所有子资源。</li>
<li><code>&quot;*/status&quot;</code> 匹配所有 status 子资源。</li>
</ul>
</li>
<li><code>scope</code> 指定要匹配的范围。有效值为 <code>&quot;Cluster&quot;</code>、<code>&quot;Namespaced&quot;</code> 和 <code>&quot;*&quot;</code>。
子资源匹配其父资源的范围。在 Kubernetes v1.14+ 版本中才被支持。
默认值为 <code>&quot;*&quot;</code>，对应 1.14 版本之前的行为。
<ul>
<li><code>&quot;Cluster&quot;</code> 表示只有集群作用域的资源才能匹配此规则（API 对象 Namespace 是集群作用域的）。</li>
<li><code>&quot;Namespaced&quot;</code> 意味着仅具有名字空间的资源才符合此规则。</li>
<li><code>&quot;*&quot;</code> 表示没有范围限制。</li>
</ul>
</li>
</ul>
<!--
If an incoming request matches one of the specified operations, groups, versions, resources, and scope for any of a webhook's rules, the request is sent to the webhook.

Here are other examples of rules that could be used to specify which resources should be intercepted.

Match `CREATE` or `UPDATE` requests to `apps/v1` and `apps/v1beta1` `deployments` and `replicasets`:
-->
<p>如果传入请求与任何 Webhook 规则的指定操作、组、版本、资源和范围匹配，则该请求将发送到 Webhook。</p>
<p>以下是可用于指定应拦截哪些资源的规则的其他示例。</p>
<p>匹配针对 <code>apps/v1</code> 和 <code>apps/v1beta1</code> 组中 <code>deployments</code> 和 <code>replicasets</code>
资源的 <code>CREATE</code> 或 <code>UPDATE</code> 请求：</p>
<ul class="nav nav-tabs" id="validatingwebhookconfiguration-rules-1" role="tablist"><li class="nav-item"><a data-toggle="tab" class="nav-link active" href="#validatingwebhookconfiguration-rules-1-0" role="tab" aria-controls="validatingwebhookconfiguration-rules-1-0" aria-selected="true">admissionregistration.k8s.io/v1</a></li>
	  
		<li class="nav-item"><a data-toggle="tab" class="nav-link" href="#validatingwebhookconfiguration-rules-1-1" role="tab" aria-controls="validatingwebhookconfiguration-rules-1-1">admissionregistration.k8s.io/v1beta1</a></li></ul>
<div class="tab-content" id="validatingwebhookconfiguration-rules-1"><div id="validatingwebhookconfiguration-rules-1-0" class="tab-pane show active" role="tabpanel" aria-labelledby="validatingwebhookconfiguration-rules-1-0">

<p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>admissionregistration.k8s.io/v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>ValidatingWebhookConfiguration<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#00f;font-weight:bold">...</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">webhooks</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>my-webhook.example.com<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">rules</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- <span style="color:#008000;font-weight:bold">operations</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;CREATE&#34;</span>,<span style="color:#bbb"> </span><span style="color:#b44">&#34;UPDATE&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">apiGroups</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;apps&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">apiVersions</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;v1&#34;</span>,<span style="color:#bbb"> </span><span style="color:#b44">&#34;v1beta1&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">resources</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;deployments&#34;</span>,<span style="color:#bbb"> </span><span style="color:#b44">&#34;replicasets&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">scope</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;Namespaced&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span>...<span style="color:#bbb">
</span></code></pre></div></div>
  <div id="validatingwebhookconfiguration-rules-1-1" class="tab-pane" role="tabpanel" aria-labelledby="validatingwebhookconfiguration-rules-1-1">

<p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#080;font-style:italic"># v1.16 中被废弃，推荐使用 admissionregistration.k8s.io/v1</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>admissionregistration.k8s.io/v1beta1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>ValidatingWebhookConfiguration<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#00f;font-weight:bold">...</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">webhooks</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>my-webhook.example.com<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">rules</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- <span style="color:#008000;font-weight:bold">operations</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;CREATE&#34;</span>,<span style="color:#bbb"> </span><span style="color:#b44">&#34;UPDATE&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">apiGroups</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;apps&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">apiVersions</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;v1&#34;</span>,<span style="color:#bbb"> </span><span style="color:#b44">&#34;v1beta1&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">resources</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;deployments&#34;</span>,<span style="color:#bbb"> </span><span style="color:#b44">&#34;replicasets&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">scope</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;Namespaced&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span>...<span style="color:#bbb">
</span></code></pre></div></div></div>

<!--
Match create requests for all resources (but not subresources) in all API groups and versions:
-->
<p>匹配所有 API 组和版本中的所有资源（但不包括子资源）的创建请求：</p>
<ul class="nav nav-tabs" id="validatingwebhookconfiguration-rules-2" role="tablist"><li class="nav-item"><a data-toggle="tab" class="nav-link active" href="#validatingwebhookconfiguration-rules-2-0" role="tab" aria-controls="validatingwebhookconfiguration-rules-2-0" aria-selected="true">admissionregistration.k8s.io/v1</a></li>
	  
		<li class="nav-item"><a data-toggle="tab" class="nav-link" href="#validatingwebhookconfiguration-rules-2-1" role="tab" aria-controls="validatingwebhookconfiguration-rules-2-1">admissionregistration.k8s.io/v1beta1</a></li></ul>
<div class="tab-content" id="validatingwebhookconfiguration-rules-2"><div id="validatingwebhookconfiguration-rules-2-0" class="tab-pane show active" role="tabpanel" aria-labelledby="validatingwebhookconfiguration-rules-2-0">

<p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>admissionregistration.k8s.io/v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>ValidatingWebhookConfiguration<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#00f;font-weight:bold">...</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">webhooks</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>my-webhook.example.com<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">rules</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- <span style="color:#008000;font-weight:bold">operations</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;CREATE&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">apiGroups</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;*&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">apiVersions</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;*&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">resources</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;*&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">scope</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;*&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span>...<span style="color:#bbb">
</span></code></pre></div></div>
  <div id="validatingwebhookconfiguration-rules-2-1" class="tab-pane" role="tabpanel" aria-labelledby="validatingwebhookconfiguration-rules-2-1">

<p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#080;font-style:italic"># v1.16 中被废弃，推荐使用 admissionregistration.k8s.io/v1</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>admissionregistration.k8s.io/v1beta1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>ValidatingWebhookConfiguration<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#00f;font-weight:bold">...</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">webhooks</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>my-webhook.example.com<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">rules</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- <span style="color:#008000;font-weight:bold">operations</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;CREATE&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">apiGroups</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;*&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">apiVersions</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;*&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">resources</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;*&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">scope</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;*&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span>...<span style="color:#bbb">
</span></code></pre></div></div></div>

<!--
Match update requests for all `status` subresources in all API groups and versions:
-->
<p>匹配所有 API 组和版本中所有 <code>status</code> 子资源的更新请求：</p>
<ul class="nav nav-tabs" id="validatingwebhookconfiguration-rules-2" role="tablist"><li class="nav-item"><a data-toggle="tab" class="nav-link active" href="#validatingwebhookconfiguration-rules-2-0" role="tab" aria-controls="validatingwebhookconfiguration-rules-2-0" aria-selected="true">admissionregistration.k8s.io/v1</a></li>
	  
		<li class="nav-item"><a data-toggle="tab" class="nav-link" href="#validatingwebhookconfiguration-rules-2-1" role="tab" aria-controls="validatingwebhookconfiguration-rules-2-1">admissionregistration.k8s.io/v1beta1</a></li></ul>
<div class="tab-content" id="validatingwebhookconfiguration-rules-2"><div id="validatingwebhookconfiguration-rules-2-0" class="tab-pane show active" role="tabpanel" aria-labelledby="validatingwebhookconfiguration-rules-2-0">

<p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>admissionregistration.k8s.io/v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>ValidatingWebhookConfiguration<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#00f;font-weight:bold">...</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">webhooks</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>my-webhook.example.com<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">rules</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- <span style="color:#008000;font-weight:bold">operations</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;CREATE&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">apiGroups</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;*&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">apiVersions</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;*&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">resources</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;*&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">scope</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;*&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span>...<span style="color:#bbb">
</span></code></pre></div></div>
  <div id="validatingwebhookconfiguration-rules-2-1" class="tab-pane" role="tabpanel" aria-labelledby="validatingwebhookconfiguration-rules-2-1">

<p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#080;font-style:italic"># v1.16 中被废弃，推荐使用 admissionregistration.k8s.io/v1</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>admissionregistration.k8s.io/v1beta1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>ValidatingWebhookConfiguration<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#00f;font-weight:bold">...</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">webhooks</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>my-webhook.example.com<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">rules</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- <span style="color:#008000;font-weight:bold">operations</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;CREATE&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">apiGroups</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;*&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">apiVersions</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;*&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">resources</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;*&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">scope</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;*&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span>...<span style="color:#bbb">
</span></code></pre></div></div></div>

<!--
### Matching requests: objectSelector
-->
<h3 id="matching-requests-objectselector">匹配请求：objectSelector</h3>
<!--
In v1.15+, webhooks may optionally limit which requests are intercepted based on the labels of the
objects they would be sent, by specifying an `objectSelector`. If specified, the objectSelector
is evaluated against both the object and oldObject that would be sent to the webhook,
and is considered to match if either object matches the selector.
-->
<p>在版本 v1.15+ 中, 通过指定 <code>objectSelector</code>，Webhook 能够根据
可能发送的对象的标签来限制哪些请求被拦截。
如果指定，则将对 <code>objectSelector</code> 和可能发送到 Webhook 的 object 和 oldObject
进行评估。如果两个对象之一与选择器匹配，则认为该请求已匹配。</p>
<!--
A null object (oldObject in the case of create, or newObject in the case of delete),
or an object that cannot have labels (like a `DeploymentRollback` or a `PodProxyOptions` object)
is not considered to match.
-->
<p>空对象（对于创建操作而言为 oldObject，对于删除操作而言为 newObject），
或不能带标签的对象（例如 <code>DeploymentRollback</code> 或 <code>PodProxyOptions</code> 对象）
被认为不匹配。</p>
<!--
Use the object selector only if the webhook is opt-in, because end users may skip the admission webhook by setting the labels.
-->
<p>仅当选择使用 webhook 时才使用对象选择器，因为最终用户可以通过设置标签来
跳过准入 Webhook。</p>
<!--
This example shows a mutating webhook that would match a `CREATE` of any resource with the label `foo: bar`:
-->
<p>这个例子展示了一个 mutating webhook，它将匹配带有标签 <code>foo:bar</code> 的任何资源的
<code>CREATE</code> 的操作：</p>
<ul class="nav nav-tabs" id="objectselector-example" role="tablist"><li class="nav-item"><a data-toggle="tab" class="nav-link active" href="#objectselector-example-0" role="tab" aria-controls="objectselector-example-0" aria-selected="true">admissionregistration.k8s.io/v1</a></li>
	  
		<li class="nav-item"><a data-toggle="tab" class="nav-link" href="#objectselector-example-1" role="tab" aria-controls="objectselector-example-1">admissionregistration.k8s.io/v1beta1</a></li></ul>
<div class="tab-content" id="objectselector-example"><div id="objectselector-example-0" class="tab-pane show active" role="tabpanel" aria-labelledby="objectselector-example-0">

<p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>admissionregistration.k8s.io/v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>MutatingWebhookConfiguration<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#00f;font-weight:bold">...</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">webhooks</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>my-webhook.example.com<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">objectSelector</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">matchLabels</span>:<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">foo</span>:<span style="color:#bbb"> </span>bar<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">rules</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- <span style="color:#008000;font-weight:bold">operations</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;CREATE&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">apiGroups</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;*&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">apiVersions</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;*&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">resources</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;*&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">scope</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;*&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span>...<span style="color:#bbb">
</span></code></pre></div></div>
  <div id="objectselector-example-1" class="tab-pane" role="tabpanel" aria-labelledby="objectselector-example-1">

<p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#080;font-style:italic"># v1.16 中被废弃，推荐使用 admissionregistration.k8s.io/v1</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>admissionregistration.k8s.io/v1beta1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>MutatingWebhookConfiguration<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#00f;font-weight:bold">...</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">webhooks</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>my-webhook.example.com<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">objectSelector</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">matchLabels</span>:<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">foo</span>:<span style="color:#bbb"> </span>bar<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">rules</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- <span style="color:#008000;font-weight:bold">operations</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;CREATE&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">apiGroups</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;*&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">apiVersions</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;*&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">resources</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;*&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">scope</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;*&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span>...<span style="color:#bbb">
</span></code></pre></div></div></div>

<!--
See https://kubernetes.io/docs/concepts/overview/working-with-objects/labels for more examples of label selectors.
-->
<p>有关标签选择器的更多示例，请参见<a href="/zh/docs/concepts/overview/working-with-objects/labels">标签</a>。</p>
<!--
### Matching requests: namespaceSelector
-->
<h3 id="matching-requests-namespaceselector">匹配请求：namespaceSelector</h3>
<!--
Webhooks may optionally limit which requests for namespaced resources are intercepted,
based on the labels of the containing namespace, by specifying a `namespaceSelector`.
-->
<p>通过指定 <code>namespaceSelector</code>，Webhook 可以根据具有名字空间的资源所处的
名字空间的标签来选择拦截哪些资源的操作。</p>
<!--
The `namespaceSelector` decides whether to run the webhook on a request for a namespaced resource
(or a Namespace object), based on whether the namespace's labels match the selector.
If the object itself is a namespace, the matching is performed on object.metadata.labels.
If the object is a cluster scoped resource other than a Namespace, `namespaceSelector` has no effect.
-->
<p><code>namespaceSelector</code> 根据名字空间的标签是否匹配选择器，决定是否针对具名字空间的资源
（或 Namespace 对象）的请求运行 webhook。
如果对象是除 Namespace 以外的集群范围的资源，则 <code>namespaceSelector</code> 标签无效。</p>
<!--
This example shows a mutating webhook that matches a `CREATE` of any namespaced resource inside a namespace
that does not have a "runlevel" label of "0" or "1":
-->
<p>本例给出的修改性质的 Webhook 将匹配到对名字空间中具名字空间的资源的 <code>CREATE</code> 请求，
前提是这些资源不含值为 &quot;0&quot; 或 &quot;1&quot; 的 &quot;runlevel&quot; 标签：</p>
<ul class="nav nav-tabs" id="mutatingwebhookconfiguration-namespaceselector-1" role="tablist"><li class="nav-item"><a data-toggle="tab" class="nav-link active" href="#mutatingwebhookconfiguration-namespaceselector-1-0" role="tab" aria-controls="mutatingwebhookconfiguration-namespaceselector-1-0" aria-selected="true">admissionregistration.k8s.io/v1</a></li>
	  
		<li class="nav-item"><a data-toggle="tab" class="nav-link" href="#mutatingwebhookconfiguration-namespaceselector-1-1" role="tab" aria-controls="mutatingwebhookconfiguration-namespaceselector-1-1">admissionregistration.k8s.io/v1beta1</a></li></ul>
<div class="tab-content" id="mutatingwebhookconfiguration-namespaceselector-1"><div id="mutatingwebhookconfiguration-namespaceselector-1-0" class="tab-pane show active" role="tabpanel" aria-labelledby="mutatingwebhookconfiguration-namespaceselector-1-0">

<p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>admissionregistration.k8s.io/v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>MutatingWebhookConfiguration<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#00f;font-weight:bold">...</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">webhooks</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>my-webhook.example.com<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">namespaceSelector</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">matchExpressions</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span>- <span style="color:#008000;font-weight:bold">key</span>:<span style="color:#bbb"> </span>runlevel<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">operator</span>:<span style="color:#bbb"> </span>NotIn<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">values</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;0&#34;</span>,<span style="color:#b44">&#34;1&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">rules</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- <span style="color:#008000;font-weight:bold">operations</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;CREATE&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">apiGroups</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;*&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">apiVersions</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;*&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">resources</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;*&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">scope</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;Namespaced&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span>...<span style="color:#bbb">
</span></code></pre></div></div>
  <div id="mutatingwebhookconfiguration-namespaceselector-1-1" class="tab-pane" role="tabpanel" aria-labelledby="mutatingwebhookconfiguration-namespaceselector-1-1">

<p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#080;font-style:italic"># v1.16 中被废弃，推荐使用 admissionregistration.k8s.io/v1</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>admissionregistration.k8s.io/v1beta1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>MutatingWebhookConfiguration<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#00f;font-weight:bold">...</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">webhooks</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>my-webhook.example.com<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">namespaceSelector</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">matchExpressions</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span>- <span style="color:#008000;font-weight:bold">key</span>:<span style="color:#bbb"> </span>runlevel<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">operator</span>:<span style="color:#bbb"> </span>NotIn<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">values</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;0&#34;</span>,<span style="color:#b44">&#34;1&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">rules</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- <span style="color:#008000;font-weight:bold">operations</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;CREATE&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">apiGroups</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;*&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">apiVersions</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;*&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">resources</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;*&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">scope</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;Namespaced&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span>...<span style="color:#bbb">
</span></code></pre></div></div></div>

<!--
This example shows a validating webhook that matches a `CREATE` of any namespaced resource inside a namespace
that is associated with the "environment" of "prod" or "staging":
-->
<p>此示例显示了一个验证性质的 Webhook，它将匹配到对某名字空间中的任何具名字空间的资源的
<code>CREATE</code> 请求，前提是该名字空间具有值为 &quot;prod&quot; 或 &quot;staging&quot; 的 &quot;environment&quot; 标签：</p>
<ul class="nav nav-tabs" id="validatingwebhookconfiguration-namespaceselector-2" role="tablist"><li class="nav-item"><a data-toggle="tab" class="nav-link active" href="#validatingwebhookconfiguration-namespaceselector-2-0" role="tab" aria-controls="validatingwebhookconfiguration-namespaceselector-2-0" aria-selected="true">admissionregistration.k8s.io/v1</a></li>
	  
		<li class="nav-item"><a data-toggle="tab" class="nav-link" href="#validatingwebhookconfiguration-namespaceselector-2-1" role="tab" aria-controls="validatingwebhookconfiguration-namespaceselector-2-1">admissionregistration.k8s.io/v1beta1</a></li></ul>
<div class="tab-content" id="validatingwebhookconfiguration-namespaceselector-2"><div id="validatingwebhookconfiguration-namespaceselector-2-0" class="tab-pane show active" role="tabpanel" aria-labelledby="validatingwebhookconfiguration-namespaceselector-2-0">

<p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>admissionregistration.k8s.io/v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>ValidatingWebhookConfiguration<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#00f;font-weight:bold">...</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">webhooks</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>my-webhook.example.com<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">namespaceSelector</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">matchExpressions</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span>- <span style="color:#008000;font-weight:bold">key</span>:<span style="color:#bbb"> </span>environment<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">operator</span>:<span style="color:#bbb"> </span>In<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">values</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;prod&#34;</span>,<span style="color:#b44">&#34;staging&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">rules</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- <span style="color:#008000;font-weight:bold">operations</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;CREATE&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">apiGroups</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;*&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">apiVersions</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;*&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">resources</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;*&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">scope</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;Namespaced&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span>...<span style="color:#bbb">
</span></code></pre></div></div>
  <div id="validatingwebhookconfiguration-namespaceselector-2-1" class="tab-pane" role="tabpanel" aria-labelledby="validatingwebhookconfiguration-namespaceselector-2-1">

<p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#080;font-style:italic"># v1.16 中被废弃，推荐使用 admissionregistration.k8s.io/v1</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>admissionregistration.k8s.io/v1beta1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>ValidatingWebhookConfiguration<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#00f;font-weight:bold">...</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">webhooks</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>my-webhook.example.com<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">namespaceSelector</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">matchExpressions</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span>- <span style="color:#008000;font-weight:bold">key</span>:<span style="color:#bbb"> </span>environment<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">operator</span>:<span style="color:#bbb"> </span>In<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">values</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;prod&#34;</span>,<span style="color:#b44">&#34;staging&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">rules</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- <span style="color:#008000;font-weight:bold">operations</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;CREATE&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">apiGroups</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;*&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">apiVersions</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;*&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">resources</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;*&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">scope</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;Namespaced&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span>...<span style="color:#bbb">
</span></code></pre></div></div></div>

<!--
See https://kubernetes.io/docs/concepts/overview/working-with-objects/labels for more examples of label selectors.
-->
<p>有关标签选择器的更多示例，请参见
<a href="/zh/docs/concepts/overview/working-with-objects/labels">标签</a>。</p>
<!--
### Matching requests: matchPolicy
-->
<h3 id="matching-requests-matchpolicy">匹配请求：matchPolicy</h3>
<!--
API servers can make objects available via multiple API groups or versions.
For example, the Kubernetes API server allows creating and modifying `Deployment` objects
via `extensions/v1beta1`, `apps/v1beta1`, `apps/v1beta2`, and `apps/v1` APIs.
-->
<p>API 服务器可以通过多个 API 组或版本来提供对象。
例如，Kubernetes API 服务器允许通过 <code>extensions/v1beta1</code>、<code>apps/v1beta1</code>、
<code>apps/v1beta2</code> 和 <code>apps/v1</code> API 创建和修改 <code>Deployment</code> 对象。</p>
<!--
For example, if a webhook only specified a rule for some API groups/versions (like `apiGroups:["apps"], apiVersions:["v1","v1beta1"]`),
and a request was made to modify the resource via another API group/version (like `extensions/v1beta1`),
the request would not be sent to the webhook.
-->
<p>例如，如果一个 webhook 仅为某些 API 组/版本指定了规则（例如
<code>apiGroups:[&quot;apps&quot;], apiVersions:[&quot;v1&quot;,&quot;v1beta1&quot;]</code>），而修改资源的请求
是通过另一个 API 组/版本（例如 <code>extensions/v1beta1</code>）发出的，
该请求将不会被发送到 Webhook。</p>
<!--
In v1.15+, `matchPolicy` lets a webhook define how its `rules` are used to match incoming requests.
Allowed values are `Exact` or `Equivalent`.
-->
<p>在 v1.15+ 中，<code>matchPolicy</code> 允许 webhook 定义如何使用其 <code>rules</code> 匹配传入的请求。
允许的值为 <code>Exact</code> 或 <code>Equivalent</code>。</p>
<!--
* `Exact` means a request should be intercepted only if it exactly matches a specified rule.
* `Equivalent` means a request should be intercepted if modifies a resource listed in `rules`, even via another API group or version.

In the example given above, the webhook that only registered for `apps/v1` could use `matchPolicy`:
* `matchPolicy: Exact` would mean the `extensions/v1beta1` request would not be sent to the webhook
* `matchPolicy: Equivalent` means the `extensions/v1beta1` request would be sent to the webhook (with the objects converted to a version the webhook had specified: `apps/v1`)
-->
<ul>
<li><code>Exact</code> 表示仅当请求与指定规则完全匹配时才应拦截该请求。</li>
<li><code>Equivalent</code> 表示如果某个请求意在修改 <code>rules</code> 中列出的资源，
即使该请求是通过其他 API 组或版本发起，也应拦截该请求。</li>
</ul>
<p>在上面给出的示例中，仅为 <code>apps/v1</code> 注册的 webhook 可以使用 <code>matchPolicy</code>：</p>
<ul>
<li><code>matchPolicy: Exact</code> 表示不会将 <code>extensions/v1beta1</code> 请求发送到 Webhook</li>
<li><code>matchPolicy:Equivalent</code> 表示将 <code>extensions/v1beta1</code> 请求发送到 webhook
（将对象转换为 webhook 指定的版本：<code>apps/v1</code>）</li>
</ul>
<!--
Specifying `Equivalent` is recommended, and ensures that webhooks continue to intercept the
resources they expect when upgrades enable new versions of the resource in the API server.
-->
<p>建议指定 <code>Equivalent</code>，确保升级后启用 API 服务器中资源的新版本时，
Webhook 继续拦截他们期望的资源。</p>
<!--
When a resource stops being served by the API server, it is no longer considered equivalent to other versions of that resource that are still served.
For example, deprecated `extensions/v1beta1` deployments are scheduled to stop being served by default in v1.16.
Once that occurs, a webhook with a `apiGroups:["extensions"], apiVersions:["v1beta1"], resources:["deployments"]` rule
would no longer intercept deployments created via `apps/v1` APIs. For that reason, webhooks should prefer registering
for stable versions of resources.
-->
<p>当 API 服务器停止提供某资源时，该资源不再被视为等同于该资源的其他仍在提供服务的版本。
例如，<code>extensions/v1beta1</code> 中的 Deployment 已被废弃，计划在 v1.16 中默认停止使用。
在这种情况下，带有 <code>apiGroups:[&quot;extensions&quot;], apiVersions:[&quot;v1beta1&quot;], resources: [&quot;deployments&quot;]</code>
规则的 Webhook 将不再拦截通过 <code>apps/v1</code> API 来创建 Deployment 的请求。
[&quot;deployments&quot;] 规则将不再拦截通过 <code>apps/v1</code> API 创建的部署。</p>
<!--
This example shows a validating webhook that intercepts modifications to deployments (no matter the API group or version),
and is always sent an `apps/v1` `Deployment` object:
-->
<p>此示例显示了一个验证性质的 Webhook，该 Webhook 拦截对 Deployment 的修改（无论 API 组或版本是什么），
始终会发送一个 <code>apps/v1</code> 版本的 Deployment 对象：</p>
<ul class="nav nav-tabs" id="validatingwebhookconfiguration-matchpolicy" role="tablist"><li class="nav-item"><a data-toggle="tab" class="nav-link active" href="#validatingwebhookconfiguration-matchpolicy-0" role="tab" aria-controls="validatingwebhookconfiguration-matchpolicy-0" aria-selected="true">admissionregistration.k8s.io/v1</a></li>
	  
		<li class="nav-item"><a data-toggle="tab" class="nav-link" href="#validatingwebhookconfiguration-matchpolicy-1" role="tab" aria-controls="validatingwebhookconfiguration-matchpolicy-1">admissionregistration.k8s.io/v1beta1</a></li></ul>
<div class="tab-content" id="validatingwebhookconfiguration-matchpolicy"><div id="validatingwebhookconfiguration-matchpolicy-0" class="tab-pane show active" role="tabpanel" aria-labelledby="validatingwebhookconfiguration-matchpolicy-0">

<p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>admissionregistration.k8s.io/v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>ValidatingWebhookConfiguration<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#00f;font-weight:bold">...</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">webhooks</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>my-webhook.example.com<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">matchPolicy</span>:<span style="color:#bbb"> </span>Equivalent<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">rules</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- <span style="color:#008000;font-weight:bold">operations</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;CREATE&#34;</span>,<span style="color:#b44">&#34;UPDATE&#34;</span>,<span style="color:#b44">&#34;DELETE&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">apiGroups</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;apps&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">apiVersions</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;v1&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">resources</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;deployments&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">scope</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;Namespaced&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span>...<span style="color:#bbb">
</span></code></pre></div><!--
Admission webhooks created using `admissionregistration.k8s.io/v1` default to `Equivalent`.
-->
<p>使用 <code>admissionregistration.k8s.io/v1</code> 创建的 admission webhhok 默认为 <code>Equivalent</code>。</p>
</div>
  <div id="validatingwebhookconfiguration-matchpolicy-1" class="tab-pane" role="tabpanel" aria-labelledby="validatingwebhookconfiguration-matchpolicy-1">

<p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#080;font-style:italic"># v1.16 中被废弃，推荐使用 admissionregistration.k8s.io/v1</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>admissionregistration.k8s.io/v1beta1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>ValidatingWebhookConfiguration<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#00f;font-weight:bold">...</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">webhooks</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>my-webhook.example.com<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">matchPolicy</span>:<span style="color:#bbb"> </span>Equivalent<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">rules</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- <span style="color:#008000;font-weight:bold">operations</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;CREATE&#34;</span>,<span style="color:#b44">&#34;UPDATE&#34;</span>,<span style="color:#b44">&#34;DELETE&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">apiGroups</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;apps&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">apiVersions</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;v1&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">resources</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;deployments&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">scope</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;Namespaced&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span>...<span style="color:#bbb">
</span></code></pre></div><!--
Admission webhooks created using `admissionregistration.k8s.io/v1beta1` default to `Exact`.
-->
<p>使用 <code>admissionregistration.k8s.io/v1beta1</code> 创建的准入 Webhook 默认为 <code>Exact</code>。</p>
</div></div>

<!--
### Contacting the webhook
-->
<h3 id="调用-webhook">调用 Webhook</h3>
<!--
Once the API server has determined a request should be sent to a webhook,
it needs to know how to contact the webhook. This is specified in the `clientConfig`
stanza of the webhook configuration.

Webhooks can either be called via a URL or a service reference,
and can optionally include a custom CA bundle to use to verify the TLS connection.
-->
<p>API 服务器确定请求应发送到 webhook 后，它需要知道如何调用 webhook。
此信息在 webhook 配置的 <code>clientConfig</code> 节中指定。</p>
<p>Webhook 可以通过 URL 或服务引用来调用，并且可以选择包含自定义 CA 包，以用于验证 TLS 连接。</p>
<!--
#### URL
-->
<h4 id="url">URL</h4>
<!--
`url` gives the location of the webhook, in standard URL form
(`scheme://host:port/path`).
-->
<p><code>url</code> 以标准 URL 形式给出 webhook 的位置（<code>scheme://host:port/path</code>）。</p>
<!--
The `host` should not refer to a service running in the cluster; use
a service reference by specifying the `service` field instead.
The host might be resolved via external DNS in some apiservers
(e.g., `kube-apiserver` cannot resolve in-cluster DNS as that would
be a layering violation). `host` may also be an IP address.
-->
<p><code>host</code> 不应引用集群中运行的服务；通过指定 <code>service</code> 字段来使用服务引用。
主机可以通过某些 apiserver 中的外部 DNS 进行解析。
（例如，<code>kube-apiserver</code> 无法解析集群内 DNS，因为这将违反分层规则）。<code>host</code> 也可以是 IP 地址。</p>
<!--
Please note that using `localhost` or `127.0.0.1` as a `host` is
risky unless you take great care to run this webhook on all hosts
which run an apiserver which might need to make calls to this
webhook. Such installs are likely to be non-portable, i.e., not easy
to turn up in a new cluster.
-->
<p>请注意，将 <code>localhost</code> 或 <code>127.0.0.1</code> 用作 <code>host</code> 是有风险的，
除非你非常小心地在所有运行 apiserver 的、可能需要对此 webhook
进行调用的主机上运行。这样的安装可能不具有可移植性，即很难在新集群中启用。</p>
<!--
The scheme must be "https"; the URL must begin with "https://".
-->
<p>scheme 必须为 &quot;https&quot;；URL 必须以 &quot;https://&quot; 开头。</p>
<!--
Attempting to use a user or basic auth e.g. "user:password@" is not allowed.
Fragments ("#...") and query parameters ("?...") are also not allowed.
-->
<p>使用用户或基本身份验证（例如：&quot;user:password@&quot;）是不允许的。
使用片段（&quot;#...&quot;）和查询参数（&quot;?...&quot;）也是不允许的。</p>
<!--
Here is an example of a mutating webhook configured to call a URL
(and expects the TLS certificate to be verified using system trust roots, so does not specify a caBundle):
-->
<p>这是配置为调用 URL 的修改性质的 Webhook 的示例
（并且期望使用系统信任根证书来验证 TLS 证书，因此不指定 caBundle）：</p>
<ul class="nav nav-tabs" id="mutatingwebhookconfiguration-url" role="tablist"><li class="nav-item"><a data-toggle="tab" class="nav-link active" href="#mutatingwebhookconfiguration-url-0" role="tab" aria-controls="mutatingwebhookconfiguration-url-0" aria-selected="true">admissionregistration.k8s.io/v1</a></li>
	  
		<li class="nav-item"><a data-toggle="tab" class="nav-link" href="#mutatingwebhookconfiguration-url-1" role="tab" aria-controls="mutatingwebhookconfiguration-url-1">admissionregistration.k8s.io/v1beta1</a></li></ul>
<div class="tab-content" id="mutatingwebhookconfiguration-url"><div id="mutatingwebhookconfiguration-url-0" class="tab-pane show active" role="tabpanel" aria-labelledby="mutatingwebhookconfiguration-url-0">

<p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>admissionregistration.k8s.io/v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>MutatingWebhookConfiguration<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#00f;font-weight:bold">...</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">webhooks</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>my-webhook.example.com<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">clientConfig</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">url</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;https://my-webhook.example.com:9443/my-webhook-path&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span>...<span style="color:#bbb">
</span></code></pre></div></div>
  <div id="mutatingwebhookconfiguration-url-1" class="tab-pane" role="tabpanel" aria-labelledby="mutatingwebhookconfiguration-url-1">

<p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#080;font-style:italic"># v1.16 中被废弃，推荐使用 admissionregistration.k8s.io/v1</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>admissionregistration.k8s.io/v1beta1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>MutatingWebhookConfiguration<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#00f;font-weight:bold">...</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">webhooks</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>my-webhook.example.com<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">clientConfig</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">url</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;https://my-webhook.example.com:9443/my-webhook-path&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span>...<span style="color:#bbb">
</span></code></pre></div></div></div>

<!--
#### Service reference
-->
<h4 id="service-reference">服务引用 </h4>
<!--
The `service` stanza inside `clientConfig` is a reference to the service for this webhook.
If the webhook is running within the cluster, then you should use `service` instead of `url`.
The service namespace and name are required. The port is optional and defaults to 443.
The path is optional and defaults to "/".
-->
<p><code>clientConfig</code> 内部的 Service 是对该 Webhook 服务的引用。
如果 Webhook 在集群中运行，则应使用 <code>service</code> 而不是 <code>url</code>。
服务的 <code>namespace</code> 和 <code>name</code> 是必需的。
<code>port</code> 是可选的，默认值为 443。<code>path</code> 是可选的，默认为 &quot;/&quot;。</p>
<!--
Here is an example of a mutating webhook configured to call a service on port "1234"
at the subpath "/my-path", and to verify the TLS connection against the ServerName
`my-service-name.my-service-namespace.svc` using a custom CA bundle:
-->
<p>这是一个 mutating Webhook 的示例，该 mutating Webhook 配置为在子路径 &quot;/my-path&quot; 端口
&quot;1234&quot; 上调用服务，并使用自定义 CA 包针对 ServerName
<code>my-service-name.my-service-namespace.svc</code> 验证 TLS 连接：</p>
<ul class="nav nav-tabs" id="mutatingwebhookconfiguration-service" role="tablist"><li class="nav-item"><a data-toggle="tab" class="nav-link active" href="#mutatingwebhookconfiguration-service-0" role="tab" aria-controls="mutatingwebhookconfiguration-service-0" aria-selected="true">admissionregistration.k8s.io/v1</a></li>
	  
		<li class="nav-item"><a data-toggle="tab" class="nav-link" href="#mutatingwebhookconfiguration-service-1" role="tab" aria-controls="mutatingwebhookconfiguration-service-1">admissionregistration.k8s.io/v1beta1</a></li></ul>
<div class="tab-content" id="mutatingwebhookconfiguration-service"><div id="mutatingwebhookconfiguration-service-0" class="tab-pane show active" role="tabpanel" aria-labelledby="mutatingwebhookconfiguration-service-0">

<p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>admissionregistration.k8s.io/v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>MutatingWebhookConfiguration<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#00f;font-weight:bold">...</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">webhooks</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>my-webhook.example.com<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">clientConfig</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">caBundle</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;Ci0tLS0tQk...&lt;base64-encoded PEM bundle containing the CA that signed the webhook&#39;s serving certificate&gt;...tLS0K&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">service</span>:<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">namespace</span>:<span style="color:#bbb"> </span>my-service-namespace<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>my-service-name<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">path</span>:<span style="color:#bbb"> </span>/my-path<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">port</span>:<span style="color:#bbb"> </span><span style="color:#666">1234</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span>...<span style="color:#bbb">
</span></code></pre></div></div>
  <div id="mutatingwebhookconfiguration-service-1" class="tab-pane" role="tabpanel" aria-labelledby="mutatingwebhookconfiguration-service-1">

<p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#080;font-style:italic"># v1.16 中被废弃，推荐使用 admissionregistration.k8s.io/v1</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>admissionregistration.k8s.io/v1beta1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>MutatingWebhookConfiguration<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#00f;font-weight:bold">...</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">webhooks</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>my-webhook.example.com<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">clientConfig</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">caBundle</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;Ci0tLS0tQk...&lt;base64-encoded PEM bundle containing the CA that signed the webhook&#39;s serving certificate&gt;...tLS0K&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">service</span>:<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">namespace</span>:<span style="color:#bbb"> </span>my-service-namespace<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>my-service-name<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">path</span>:<span style="color:#bbb"> </span>/my-path<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">port</span>:<span style="color:#bbb"> </span><span style="color:#666">1234</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span>...<span style="color:#bbb">
</span></code></pre></div></div></div>

<!--
### Side effects
-->
<h3 id="side-effects">副作用</h3>
<!--
Webhooks typically operate only on the content of the `AdmissionReview` sent to them.
Some webhooks, however, make out-of-band changes as part of processing admission requests.
-->
<p>Webhook 通常仅对发送给他们的 <code>AdmissionReview</code> 内容进行操作。
但是，某些 Webhook 在处理 admission 请求时会进行带外更改。</p>
<!--
Webhooks that make out-of-band changes ("side effects") must also have a reconcilation mechanism
(like a controller) that periodically determines the actual state of the world, and adjusts
the out-of-band data modified by the admission webhook to reflect reality.
This is because a call to an admission webhook does not guarantee the admitted object will be persisted as is, or at all.
Later webhooks can modify the content of the object, a conflict could be encountered while writing to storage,
or the server could power off before persisting the object.
-->
<p>进行带外更改的（产生“副作用”的） Webhook 必须具有协调机制（如控制器），
该机制定期确定事物的实际状态，并调整由准入 Webhook 修改的带外数据以反映现实情况。
这是因为对准入 Webhook 的调用不能保证所准入的对象将原样保留，或根本不保留。
以后，webhook 可以修改对象的内容，在写入存储时可能会发生冲突，或者
服务器可以在持久保存对象之前关闭电源。</p>
<!--
Additionally, webhooks with side effects must skip those side-effects when `dryRun: true` admission requests are handled.
A webhook must explicitly indicate that it will not have side-effects when run with `dryRun`,
or the dry-run request will not be sent to the webhook and the API request will fail instead.
-->
<p>此外，处理 <code>dryRun: true</code> admission 请求时，具有副作用的 Webhook 必须避免产生副作用。
一个 Webhook 必须明确指出在使用 <code>dryRun</code> 运行时不会有副作用，
否则 <code>dry-run</code> 请求将不会发送到该 Webhook，而 API 请求将会失败。</p>
<!--
Webhooks indicate whether they have side effects using the `sideEffects` field in the webhook configuration:
* `Unknown`: no information is known about the side effects of calling the webhook.
If a request with `dryRun: true` would trigger a call to this webhook, the request will instead fail, and the webhook will not be called.
* `None`: calling the webhook will have no side effects.
* `Some`: calling the webhook will possibly have side effects.
If a request with the dry-run attribute would trigger a call to this webhook, the request will instead fail, and the webhook will not be called.
* `NoneOnDryRun`: calling the webhook will possibly have side effects,
but if a request with `dryRun: true` is sent to the webhook, the webhook will suppress the side effects (the webhook is `dryRun`-aware).
-->
<p>Webhook 使用 webhook 配置中的 <code>sideEffects</code> 字段显示它们是否有副作用：</p>
<ul>
<li><code>Unknown</code>：有关调用 Webhook 的副作用的信息是不可知的。
如果带有 <code>dryRun：true</code> 的请求将触发对该 Webhook 的调用，则该请求将失败，并且不会调用该 Webhook。</li>
<li><code>None</code>：调用 webhook 没有副作用。</li>
<li><code>Some</code>：调用 webhook 可能会有副作用。
如果请求具有 <code>dry-run</code> 属性将触发对此 Webhook 的调用，
则该请求将会失败，并且不会调用该 Webhook。</li>
<li><code>NoneOnDryRun</code>：调用 webhook 可能会有副作用，但是如果将带有 <code>dryRun: true</code>
属性的请求发送到 webhook，则 webhook 将抑制副作用（该 webhook 可识别 <code>dryRun</code>）。</li>
</ul>
<!--
Allowed values:
* In `admissionregistration.k8s.io/v1beta1`, `sideEffects` may be set to `Unknown`, `None`, `Some`, or `NoneOnDryRun`, and defaults to `Unknown`.
* In `admissionregistration.k8s.io/v1`, `sideEffects` must be set to `None` or `NoneOnDryRun`.
-->
<p>允许值：</p>
<ul>
<li>在 <code>admissionregistration.k8s.io/v1beta1</code> 中，<code>sideEffects</code> 可以设置为
<code>Unknown</code>、<code>None</code>、<code>Some</code> 或者 <code>NoneOnDryRun</code>，并且默认值为 <code>Unknown</code>。</li>
<li>在 <code>admissionregistration.k8s.io/v1</code> 中, <code>sideEffects</code> 必须设置为
<code>None</code> 或者 <code>NoneOnDryRun</code>。</li>
</ul>
<!--
Here is an example of a validating webhook indicating it has no side effects on `dryRun: true` requests:
-->
<p>这是一个 validating webhook 的示例，表明它对 <code>dryRun: true</code> 请求没有副作用：</p>
<ul class="nav nav-tabs" id="validatingwebhookconfiguration-sideeffects" role="tablist"><li class="nav-item"><a data-toggle="tab" class="nav-link active" href="#validatingwebhookconfiguration-sideeffects-0" role="tab" aria-controls="validatingwebhookconfiguration-sideeffects-0" aria-selected="true">admissionregistration.k8s.io/v1</a></li>
	  
		<li class="nav-item"><a data-toggle="tab" class="nav-link" href="#validatingwebhookconfiguration-sideeffects-1" role="tab" aria-controls="validatingwebhookconfiguration-sideeffects-1">admissionregistration.k8s.io/v1beta1</a></li></ul>
<div class="tab-content" id="validatingwebhookconfiguration-sideeffects"><div id="validatingwebhookconfiguration-sideeffects-0" class="tab-pane show active" role="tabpanel" aria-labelledby="validatingwebhookconfiguration-sideeffects-0">

<p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>admissionregistration.k8s.io/v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>ValidatingWebhookConfiguration<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#00f;font-weight:bold">...</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">webhooks</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>my-webhook.example.com<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">sideEffects</span>:<span style="color:#bbb"> </span>NoneOnDryRun<span style="color:#bbb">
</span><span style="color:#bbb">  </span>...<span style="color:#bbb">
</span></code></pre></div></div>
  <div id="validatingwebhookconfiguration-sideeffects-1" class="tab-pane" role="tabpanel" aria-labelledby="validatingwebhookconfiguration-sideeffects-1">

<p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#080;font-style:italic"># v1.16 中被废弃，推荐使用 admissionregistration.k8s.io/v1</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>admissionregistration.k8s.io/v1beta1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>ValidatingWebhookConfiguration<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#00f;font-weight:bold">...</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">webhooks</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>my-webhook.example.com<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">sideEffects</span>:<span style="color:#bbb"> </span>NoneOnDryRun<span style="color:#bbb">
</span><span style="color:#bbb">  </span>...<span style="color:#bbb">
</span></code></pre></div></div></div>

<!--
### Timeouts
-->
<h3 id="timeouts">超时</h3>
<!--
Because webhooks add to API request latency, they should evaluate as quickly as possible.
`timeoutSeconds` allows configuring how long the API server should wait for a webhook to respond
before treating the call as a failure.
-->
<p>由于 Webhook 会增加 API 请求的延迟，因此应尽快完成自身的操作。
<code>timeoutSeconds</code> 用来配置在将调用视为失败之前，允许 API 服务器等待 Webhook 响应的时间长度。</p>
<!--
If the timeout expires before the webhook responds, the webhook call will be ignored or
the API call will be rejected based on the [failure policy](#failure-policy).

The timeout value must be between 1 and 30 seconds.

Here is an example of a validating webhook with a custom timeout of 2 seconds:
-->
<p>如果超时在 Webhook 响应之前被触发，则基于<a href="#failure-policy">失败策略</a>，将忽略
Webhook 调用或拒绝 API 调用。</p>
<p>超时值必须设置在 1 到 30 秒之间。</p>
<p>这是一个自定义超时设置为 2 秒的 validating Webhook 的示例：</p>
<ul class="nav nav-tabs" id="validatingwebhookconfiguration-timeoutseconds" role="tablist"><li class="nav-item"><a data-toggle="tab" class="nav-link active" href="#validatingwebhookconfiguration-timeoutseconds-0" role="tab" aria-controls="validatingwebhookconfiguration-timeoutseconds-0" aria-selected="true">admissionregistration.k8s.io/v1</a></li>
	  
		<li class="nav-item"><a data-toggle="tab" class="nav-link" href="#validatingwebhookconfiguration-timeoutseconds-1" role="tab" aria-controls="validatingwebhookconfiguration-timeoutseconds-1">admissionregistration.k8s.io/v1beta1</a></li></ul>
<div class="tab-content" id="validatingwebhookconfiguration-timeoutseconds"><div id="validatingwebhookconfiguration-timeoutseconds-0" class="tab-pane show active" role="tabpanel" aria-labelledby="validatingwebhookconfiguration-timeoutseconds-0">

<p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>admissionregistration.k8s.io/v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>ValidatingWebhookConfiguration<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#00f;font-weight:bold">...</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">webhooks</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>my-webhook.example.com<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">timeoutSeconds</span>:<span style="color:#bbb"> </span><span style="color:#666">2</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span>...<span style="color:#bbb">
</span></code></pre></div><!--
Admission webhooks created using `admissionregistration.k8s.io/v1` default timeouts to 10 seconds.
-->
<p>使用 <code>admissionregistration.k8s.io/v1</code> 创建的准入 Webhook 默认超时为 10 秒。</p>
</div>
  <div id="validatingwebhookconfiguration-timeoutseconds-1" class="tab-pane" role="tabpanel" aria-labelledby="validatingwebhookconfiguration-timeoutseconds-1">

<p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#080;font-style:italic"># v1.16 中被废弃，推荐使用 admissionregistration.k8s.io/v1</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>admissionregistration.k8s.io/v1beta1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>ValidatingWebhookConfiguration<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#00f;font-weight:bold">...</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">webhooks</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>my-webhook.example.com<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">timeoutSeconds</span>:<span style="color:#bbb"> </span><span style="color:#666">2</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span>...<span style="color:#bbb">
</span></code></pre></div><!--
Admission webhooks created using `admissionregistration.k8s.io/v1beta1` default timeouts to 30 seconds.
-->
<p>使用 <code>admissionregistration.k8s.io/v1beta1</code> 创建的准入 Webhook 默认超时为 30 秒。</p>
</div></div>

<!--
### Reinvocation policy
-->
<h3 id="reinvocation-policy">再调用策略 </h3>
<!--
A single ordering of mutating admissions plugins (including webhooks) does not work for all cases
(see https://issue.k8s.io/64333 as an example). A mutating webhook can add a new sub-structure
to the object (like adding a `container` to a `pod`), and other mutating plugins which have already
run may have opinions on those new structures (like setting an `imagePullPolicy` on all containers).
-->
<p>修改性质的准入插件（包括 Webhook）的任何一种排序方式都不会适用于所有情况。
(参见 <a href="https://issue.k8s.io/64333">https://issue.k8s.io/64333</a> 示例)。
修改性质的 Webhook 可以向对象中添加新的子结构（例如向 <code>pod</code> 中添加 <code>container</code>），
已经运行的其他修改插件可能会对这些新结构有影响
（就像在所有容器上设置 <code>imagePullPolicy</code> 一样）。</p>
<!--
In v1.15+, to allow mutating admission plugins to observe changes made by other plugins,
built-in mutating admission plugins are re-run if a mutating webhook modifies an object,
and mutating webhooks can specify a `reinvocationPolicy` to control whether they are reinvoked as well.
-->
<p>在 v1.15+ 中，允许修改性质的准入插件感应到其他插件所做的更改，
如果修改性质的 Webhook 修改了一个对象，则会重新运行内置的修改性质的准入插件，
并且修改性质的 Webhook 可以指定 <code>reinvocationPolicy</code> 来控制是否也重新调用它们。</p>
<!--
`reinvocationPolicy` may be set to `Never` or `IfNeeded`. It defaults to `Never`.
-->
<p>可以将 <code>reinvocationPolicy</code> 设置为 <code>Never</code> 或 <code>IfNeeded</code>。 默认为 <code>Never</code>。</p>
<!--
* `Never`: the webhook must not be called more than once in a single admission evaluation
* `IfNeeded`: the webhook may be called again as part of the admission evaluation if the object
being admitted is modified by other admission plugins after the initial webhook call.
-->
<ul>
<li><code>Never</code>: 在一次准入测试中，不得多次调用 Webhook。</li>
<li><code>IfNeeded</code>: 如果在最初的 Webhook 调用之后被其他对象的插件修改了被接纳的对象，
则可以作为准入测试的一部分再次调用该 webhook。</li>
</ul>
<!--
The important elements to note are:
-->
<p>要注意的重要因素有：</p>
<!--
* The number of additional invocations is not guaranteed to be exactly one.
* If additional invocations result in further modifications to the object, webhooks are not guaranteed to be invoked again.
* Webhooks that use this option may be reordered to minimize the number of additional invocations.
* To validate an object after all mutations are guaranteed complete, use a validating admission webhook instead (recommended for webhooks with side-effects).
-->
<ul>
<li>不能保证附加调用的次数恰好是一。</li>
<li>如果其他调用导致对该对象的进一步修改，则不能保证再次调用 Webhook。</li>
<li>使用此选项的 Webhook 可能会重新排序，以最大程度地减少额外调用的次数。</li>
<li>要在确保所有修改都完成后验证对象，请改用验证性质的 Webhook
（推荐用于有副作用的 Webhook）。</li>
</ul>
<!--
Here is an example of a mutating webhook opting into being re-invoked if later admission plugins modify the object:
-->
<p>这是一个修改性质的 Webhook 的示例，该 Webhook 在以后的准入插件修改对象时被重新调用：</p>
<ul class="nav nav-tabs" id="mutatingwebhookconfiguration-reinvocationpolicy" role="tablist"><li class="nav-item"><a data-toggle="tab" class="nav-link active" href="#mutatingwebhookconfiguration-reinvocationpolicy-0" role="tab" aria-controls="mutatingwebhookconfiguration-reinvocationpolicy-0" aria-selected="true">admissionregistration.k8s.io/v1</a></li>
	  
		<li class="nav-item"><a data-toggle="tab" class="nav-link" href="#mutatingwebhookconfiguration-reinvocationpolicy-1" role="tab" aria-controls="mutatingwebhookconfiguration-reinvocationpolicy-1">admissionregistration.k8s.io/v1beta1</a></li></ul>
<div class="tab-content" id="mutatingwebhookconfiguration-reinvocationpolicy"><div id="mutatingwebhookconfiguration-reinvocationpolicy-0" class="tab-pane show active" role="tabpanel" aria-labelledby="mutatingwebhookconfiguration-reinvocationpolicy-0">

<p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>admissionregistration.k8s.io/v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>MutatingWebhookConfiguration<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#00f;font-weight:bold">...</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">webhooks</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>my-webhook.example.com<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">reinvocationPolicy</span>:<span style="color:#bbb"> </span>IfNeeded<span style="color:#bbb">
</span><span style="color:#bbb">  </span>...<span style="color:#bbb">
</span></code></pre></div></div>
  <div id="mutatingwebhookconfiguration-reinvocationpolicy-1" class="tab-pane" role="tabpanel" aria-labelledby="mutatingwebhookconfiguration-reinvocationpolicy-1">

<p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#080;font-style:italic"># v1.16 中被废弃，推荐使用 admissionregistration.k8s.io/v1</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>admissionregistration.k8s.io/v1beta1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>MutatingWebhookConfiguration<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#00f;font-weight:bold">...</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">webhooks</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>my-webhook.example.com<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">reinvocationPolicy</span>:<span style="color:#bbb"> </span>IfNeeded<span style="color:#bbb">
</span><span style="color:#bbb">  </span>...<span style="color:#bbb">
</span></code></pre></div></div></div>

<!--
Mutating webhooks must be [idempotent](#idempotence), able to successfully process an object they have already admitted
and potentially modified. This is true for all mutating admission webhooks, since any change they can make
in an object could already exist in the user-provided object, but it is essential for webhooks that opt into reinvocation.
-->
<p>修改性质的 Webhook 必须具有<a href="#idempotence">幂等</a>性，并且能够成功处理
已被接纳并可能被修改的对象的修改性质的 Webhook。
对于所有修改性质的准入 Webhook 都是如此，因为它们可以在对象中进行的
任何更改可能已经存在于用户提供的对象中，但是对于选择重新调用的 webhook
来说是必不可少的。</p>
<!--
### Failure policy
-->
<h3 id="failure-policy">失败策略</h3>
<!--
`failurePolicy` defines how unrecognized errors and timeout errors from the admission webhook
are handled. Allowed values are `Ignore` or `Fail`.

* `Ignore` means that an error calling the webhook is ignored and the API request is allowed to continue.
* `Fail` means that an error calling the webhook causes the admission to fail and the API request to be rejected.

Here is a mutating webhook configured to reject an API request if errors are encountered calling the admission webhook:
-->
<p><code>failurePolicy</code> 定义了如何处理准入 webhook 中无法识别的错误和超时错误。允许的值为 <code>Ignore</code> 或 <code>Fail</code>。</p>
<ul>
<li><code>Ignore</code> 表示调用 webhook 的错误将被忽略并且允许 API 请求继续。</li>
<li><code>Fail</code> 表示调用 webhook 的错误导致准入失败并且 API 请求被拒绝。</li>
</ul>
<p>这是一个修改性质的 webhook，配置为在调用准入 Webhook 遇到错误时拒绝 API 请求：</p>
<ul class="nav nav-tabs" id="mutatingwebhookconfiguration-failurepolicy" role="tablist"><li class="nav-item"><a data-toggle="tab" class="nav-link active" href="#mutatingwebhookconfiguration-failurepolicy-0" role="tab" aria-controls="mutatingwebhookconfiguration-failurepolicy-0" aria-selected="true">admissionregistration.k8s.io/v1</a></li>
	  
		<li class="nav-item"><a data-toggle="tab" class="nav-link" href="#mutatingwebhookconfiguration-failurepolicy-1" role="tab" aria-controls="mutatingwebhookconfiguration-failurepolicy-1">admissionregistration.k8s.io/v1beta1</a></li></ul>
<div class="tab-content" id="mutatingwebhookconfiguration-failurepolicy"><div id="mutatingwebhookconfiguration-failurepolicy-0" class="tab-pane show active" role="tabpanel" aria-labelledby="mutatingwebhookconfiguration-failurepolicy-0">

<p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>admissionregistration.k8s.io/v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>MutatingWebhookConfiguration<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#00f;font-weight:bold">...</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">webhooks</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>my-webhook.example.com<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">failurePolicy</span>:<span style="color:#bbb"> </span>Fail<span style="color:#bbb">
</span><span style="color:#bbb">  </span>...<span style="color:#bbb">
</span></code></pre></div><!--
Admission webhooks created using `admissionregistration.k8s.io/v1` default `failurePolicy` to `Fail`.
-->
<p>使用 <code>admissionregistration.k8s.io/v1beta1</code> 创建的准入 Webhook 将
<code>failurePolicy</code> 默认设置为 <code>Ignore</code>。</p>
</div>
  <div id="mutatingwebhookconfiguration-failurepolicy-1" class="tab-pane" role="tabpanel" aria-labelledby="mutatingwebhookconfiguration-failurepolicy-1">

<p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#080;font-style:italic"># v1.16 中被废弃，推荐使用 admissionregistration.k8s.io/v1</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>admissionregistration.k8s.io/v1beta1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>MutatingWebhookConfiguration<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#00f;font-weight:bold">...</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">webhooks</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>my-webhook.example.com<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">failurePolicy</span>:<span style="color:#bbb"> </span>Fail<span style="color:#bbb">
</span><span style="color:#bbb">  </span>...<span style="color:#bbb">
</span></code></pre></div><!--
Admission webhooks created using `admissionregistration.k8s.io/v1beta1` default `failurePolicy` to `Ignore`.
-->
<p>使用 <code>admissionregistration.k8s.io/v1beta1</code> 创建的准入 Webhook 将
<code>failurePolicy</code> 默认设置为 <code>Ignore</code>。</p>
</div></div>

<!--
## Monitoring admission webhooks
-->
<h2 id="monitoring-admission-webhooks">监控 Admission Webhook   </h2>
<!--
The API server provides ways to monitor admission webhook behaviors. These
monitoring mechanisms help cluster admins to answer questions like:

1. Which mutating webhook mutated the object in a API request?

2. What change did the mutating webhook applied to the object?

3. Which webhooks are frequently rejecting API requests? What's the reason for a
   rejection?
-->
<p>API 服务器提供了监视准入 Webhook 行为的方法。这些监视机制可帮助集群管理员
回答以下问题：</p>
<ol>
<li>哪个修改性质的 webhook 改变了 API 请求中的对象？</li>
<li>修改性质的 Webhook 对对象做了哪些更改？</li>
<li>哪些 webhook 经常拒绝 API 请求？是什么原因拒绝？</li>
</ol>
<!--
### Mutating webhook auditing annotations
-->
<h3 id="mutating-webhook-审计注解">Mutating Webhook 审计注解</h3>
<!--
Sometimes it's useful to know which mutating webhook mutated the object in a API request, and what change did the
webhook apply.
-->
<p>有时，了解 API 请求中的哪个修改性质的 Webhook 使对象改变以及该
Webhook 应用了哪些更改很有用。</p>
<!--
In v1.16+, kube-apiserver performs [auditing](/docs/tasks/debug-application-cluster/audit/) on each mutating webhook
invocation. Each invocation generates an auditing annotation
capturing if a request object is mutated by the invocation, and optionally generates an annotation capturing the applied
patch from the webhook admission response. The annotations are set in the audit event for given request on given stage of
its execution, which is then pre-processed according to a certain policy and written to a backend.
-->
<p>在 v1.16+ 中，kube-apiserver 针对每个修改性质的 Webhook 调用执行
<a href="/zh/docs/tasks/debug-application-cluster/audit/">审计</a>操作。
每个调用都会生成一个审计注解，记述请求对象是否发生改变，
可选地还可以根据 webhook 的准入响应生成一个注解，记述所应用的修补。
针对给定请求的给定执行阶段，注解被添加到审计事件中，
然后根据特定策略进行预处理并写入后端。</p>
<!--
The audit level of a event determines which annotations get recorded:
-->
<p>事件的审计级别决定了要记录哪些注解：</p>
<!--
- At `Metadata` audit level or higher, an annotation with key
`mutation.webhook.admission.k8s.io/round_{round idx}_index_{order idx}` gets logged with JSON payload indicating
a webhook gets invoked for given request and whether it mutated the object or not.
-->
<p>在 <code>Metadata</code> 或更高审计级别上，将使用 JSON 负载记录带有键名
<code>mutation.webhook.admission.k8s.io/round_{round idx}_index_{order idx}</code> 的注解，
该注解表示针对给定请求调用了 Webhook，以及该 Webhook 是否更改了对象。</p>
<!--
For example, the following annotation gets recorded for a webhook being reinvoked. The webhook is ordered the third in the
mutating webhook chain, and didn't mutated the request object during the invocation.
-->
<p>例如，对于正在被重新调用的某 Webhook，所记录的注解如下。
Webhook 在 mutating Webhook 链中排在第三个位置，并且在调用期间未改变请求对象。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#080;font-style:italic"># 审计事件相关记录</span><span style="color:#bbb">
</span><span style="color:#bbb"></span>{<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">&#34;kind&#34;: </span><span style="color:#b44">&#34;Event&#34;</span>,<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">&#34;apiVersion&#34;: </span><span style="color:#b44">&#34;audit.k8s.io/v1&#34;</span>,<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">&#34;annotations&#34;: </span>{<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#008000;font-weight:bold">&#34;mutation.webhook.admission.k8s.io/round_1_index_2&#34;: &#34;{\&#34;configuration\&#34;:\&#34;my-mutating-webhook-configuration.example.com\&#34;,\&#34;webhook\&#34;:\&#34;my-webhook.example.com\&#34;,\&#34;mutated\&#34;: </span><span style="color:#a2f;font-weight:bold">false</span>}&#34;<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#080;font-style:italic"># 其他注解</span><span style="color:#bbb">
</span><span style="color:#bbb">        </span>...<span style="color:#bbb">
</span><span style="color:#bbb">    </span>}<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#080;font-style:italic"># 其他字段</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span>...<span style="color:#bbb">
</span><span style="color:#bbb"></span>}<span style="color:#bbb">
</span></code></pre></div><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#080;font-style:italic"># 反序列化的注解值</span><span style="color:#bbb">
</span><span style="color:#bbb"></span>{<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">&#34;configuration&#34;: </span><span style="color:#b44">&#34;my-mutating-webhook-configuration.example.com&#34;</span>,<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">&#34;webhook&#34;: </span><span style="color:#b44">&#34;my-webhook.example.com&#34;</span>,<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">&#34;mutated&#34;: </span><span style="color:#a2f;font-weight:bold">false</span><span style="color:#bbb">
</span><span style="color:#bbb"></span>}<span style="color:#bbb">
</span></code></pre></div><!--
The following annotation gets recorded for a webhook being invoked in the first round. The webhook is ordered the first in\
the mutating webhook chain, and mutated the request object during the invocation.
-->
<p>对于在第一轮中调用的 Webhook，所记录的注解如下。
Webhook 在 mutating Webhook 链中排在第一位，并在调用期间改变了请求对象。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#080;font-style:italic"># 审计事件相关记录</span><span style="color:#bbb">
</span><span style="color:#bbb"></span>{<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">&#34;kind&#34;: </span><span style="color:#b44">&#34;Event&#34;</span>,<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">&#34;apiVersion&#34;: </span><span style="color:#b44">&#34;audit.k8s.io/v1&#34;</span>,<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">&#34;annotations&#34;: </span>{<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#008000;font-weight:bold">&#34;mutation.webhook.admission.k8s.io/round_0_index_0&#34;: &#34;{\&#34;configuration\&#34;:\&#34;my-mutating-webhook-configuration.example.com\&#34;,\&#34;webhook\&#34;:\&#34;my-webhook-always-mutate.example.com\&#34;,\&#34;mutated\&#34;: </span><span style="color:#a2f;font-weight:bold">true</span>}&#34;<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#080;font-style:italic"># 其他注解</span><span style="color:#bbb">
</span><span style="color:#bbb">        </span>...<span style="color:#bbb">
</span><span style="color:#bbb">    </span>}<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#080;font-style:italic"># 其他字段</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span>...<span style="color:#bbb">
</span><span style="color:#bbb"></span>}<span style="color:#bbb">
</span></code></pre></div><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#080;font-style:italic"># 反序列化的注解值</span><span style="color:#bbb">
</span><span style="color:#bbb"></span>{<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">&#34;configuration&#34;: </span><span style="color:#b44">&#34;my-mutating-webhook-configuration.example.com&#34;</span>,<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">&#34;webhook&#34;: </span><span style="color:#b44">&#34;my-webhook-always-mutate.example.com&#34;</span>,<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">&#34;mutated&#34;: </span><span style="color:#a2f;font-weight:bold">true</span><span style="color:#bbb">
</span><span style="color:#bbb"></span>}<span style="color:#bbb">
</span></code></pre></div><!--
- At `Request` audit level or higher, an annotation with key
`patch.webhook.admission.k8s.io/round_{round idx}_index_{order idx}` gets logged with JSON payload indicating
a webhook gets invoked for given request and what patch gets applied to the request object.
-->
<p>在 <code>Request</code> 或更高审计级别上，将使用 JSON 负载记录带有键名为
<code>patch.webhook.admission.k8s.io/round_{round idx}_index_{order idx}</code> 的注解，
该注解表明针对给定请求调用了 Webhook 以及应用于请求对象之上的修改。</p>
<!--
For example, the following annotation gets recorded for a webhook being reinvoked. The webhook is ordered the fourth in the
mutating webhook chain, and responded with a JSON patch which got applied to the request object.
-->
<p>例如，以下是针对正在被重新调用的某 Webhook 所记录的注解。
Webhook 在修改性质的 Webhook 链中排在第四，并在其响应中包含一个 JSON 补丁，
该补丁已被应用于请求对象。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#080;font-style:italic"># 审计事件相关记录</span><span style="color:#bbb">
</span><span style="color:#bbb"></span>{<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">&#34;kind&#34;: </span><span style="color:#b44">&#34;Event&#34;</span>,<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">&#34;apiVersion&#34;: </span><span style="color:#b44">&#34;audit.k8s.io/v1&#34;</span>,<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">&#34;annotations&#34;: </span>{<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#008000;font-weight:bold">&#34;patch.webhook.admission.k8s.io/round_1_index_3&#34;: </span><span style="color:#b44">&#34;{\&#34;configuration\&#34;:\&#34;my-other-mutating-webhook-configuration.example.com\&#34;,\&#34;webhook\&#34;:\&#34;my-webhook-always-mutate.example.com\&#34;,\&#34;patch\&#34;:[{\&#34;op\&#34;:\&#34;add\&#34;,\&#34;path\&#34;:\&#34;/data/mutation-stage\&#34;,\&#34;value\&#34;:\&#34;yes\&#34;}],\&#34;patchType\&#34;:\&#34;JSONPatch\&#34;}&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#080;font-style:italic"># 其他注解</span><span style="color:#bbb">
</span><span style="color:#bbb">        </span>...<span style="color:#bbb">
</span><span style="color:#bbb">    </span>}<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#080;font-style:italic"># 其他字段</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span>...<span style="color:#bbb">
</span><span style="color:#bbb"></span>}<span style="color:#bbb">
</span></code></pre></div><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#080;font-style:italic"># 反序列化的注解值</span><span style="color:#bbb">
</span><span style="color:#bbb"></span>{<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">&#34;configuration&#34;: </span><span style="color:#b44">&#34;my-other-mutating-webhook-configuration.example.com&#34;</span>,<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">&#34;webhook&#34;: </span><span style="color:#b44">&#34;my-webhook-always-mutate.example.com&#34;</span>,<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">&#34;patchType&#34;: </span><span style="color:#b44">&#34;JSONPatch&#34;</span>,<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">&#34;patch&#34;: </span>[<span style="color:#bbb">
</span><span style="color:#bbb">        </span>{<span style="color:#bbb">
</span><span style="color:#bbb">            </span><span style="color:#008000;font-weight:bold">&#34;op&#34;: </span><span style="color:#b44">&#34;add&#34;</span>,<span style="color:#bbb">
</span><span style="color:#bbb">            </span><span style="color:#008000;font-weight:bold">&#34;path&#34;: </span><span style="color:#b44">&#34;/data/mutation-stage&#34;</span>,<span style="color:#bbb">
</span><span style="color:#bbb">            </span><span style="color:#008000;font-weight:bold">&#34;value&#34;: </span><span style="color:#b44">&#34;yes&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">        </span>}<span style="color:#bbb">
</span><span style="color:#bbb">    </span>]<span style="color:#bbb">
</span><span style="color:#bbb"></span>}<span style="color:#bbb">
</span></code></pre></div><!--
### Admission webhook metrics
-->
<h3 id="准入-webhook-度量值">准入 Webhook 度量值</h3>
<!--
Kube-apiserver exposes Prometheus metrics from the `/metrics` endpoint, which can be used for monitoring and
diagnosing API server status. The following metrics record status related to admission webhooks.
-->
<p>Kube-apiserver 从 <code>/metrics</code> 端点公开 Prometheus 指标，这些指标可用于监控和诊断
apiserver 状态。以下指标记录了与准入 Webhook 相关的状态。</p>
<!--
#### API server admission webhook rejection count
-->
<h4 id="apiserver-准入-webhook-拒绝次数">apiserver 准入 Webhook 拒绝次数</h4>
<!--
Sometimes it's useful to know which admission webhooks are frequently rejecting API requests, and the
reason for a rejection.

In v1.16+, kube-apiserver exposes a Prometheus counter metric recording admission webhook rejections. The
metrics are labelled to identify the causes of webhook rejection(s):
-->
<p>有时，了解哪些准入 Webhook 经常拒绝 API 请求以及拒绝的原因是很有用的。</p>
<p>在 v1.16+ 中，kube-apiserver 提供了 Prometheus 计数器度量值，记录
准入 Webhook 的拒绝次数。
度量值的标签给出了 Webhook 拒绝该请求的原因：</p>
<!--
- `name`: the name of the webhook that rejected a request.
- `operation`: the operation type of the request, can be one of `CREATE`,
  `UPDATE`, `DELETE` and `CONNECT`.
- `type`: the admission webhook type, can be one of `admit` and `validating`.
- `error_type`: identifies if an error occurred during the webhook invocation
  that caused the rejection. Its value can be one of:
   - `calling_webhook_error`: unrecognized errors or timeout errors from the admission webhook happened and the
   webhook's [Failure policy](#failure-policy) is set to `Fail`.
   - `no_error`: no error occurred. The webhook rejected the request with `allowed: false` in the admission
   response. The metrics label `rejection_code` records the `.status.code` set in the admission response.
   - `apiserver_internal_error`: an API server internal error happened.
- `rejection_code`: the HTTP status code set in the admission response when a
  webhook rejected a request.
-->
<ul>
<li><code>name</code>：拒绝请求 Webhook 的名称。</li>
<li><code>operation</code>：请求的操作类型可以是 <code>CREATE</code>、<code>UPDATE</code>、<code>DELETE</code> 和 <code>CONNECT</code> 其中之一。</li>
<li><code>type</code>：Admission webhook 类型，可以是 <code>admit</code> 和 <code>validating</code> 其中之一。</li>
<li><code>error_type</code>：标识在 webhook 调用期间是否发生了错误并且导致了拒绝。其值可以是以下之一：
<ul>
<li><code>calling_webhook_error</code>：发生了来自准入 Webhook 的无法识别的错误或超时错误，
并且 webhook 的 <a href="#failure-policy">失败策略</a> 设置为 <code>Fail</code>。</li>
<li><code>no_error</code>：未发生错误。Webhook 在准入响应中以 <code>allowed: false</code> 值拒绝了请求。
度量标签 <code>rejection_code</code> 记录了在准入响应中设置的 <code>.status.code</code>。</li>
<li><code>apiserver_internal_error</code>：apiserver 发生内部错误。</li>
</ul>
</li>
<li><code>rejection_code</code>：当 Webhook 拒绝请求时，在准入响应中设置的 HTTP 状态码。</li>
</ul>
<!--
Example of the rejection count metrics:
-->
<p>拒绝计数指标示例：</p>
<pre tabindex="0"><code># HELP apiserver_admission_webhook_rejection_count [ALPHA] Admission webhook rejection count, identified by name and broken out for each admission type (validating or admit) and operation. Additional labels specify an error type (calling_webhook_error or apiserver_internal_error if an error occurred; no_error otherwise) and optionally a non-zero rejection code if the webhook rejects the request with an HTTP status code (honored by the apiserver when the code is greater or equal to 400). Codes greater than 600 are truncated to 600, to keep the metrics cardinality bounded.
# TYPE apiserver_admission_webhook_rejection_count counter
apiserver_admission_webhook_rejection_count{error_type=&quot;calling_webhook_error&quot;,name=&quot;always-timeout-webhook.example.com&quot;,operation=&quot;CREATE&quot;,rejection_code=&quot;0&quot;,type=&quot;validating&quot;} 1
apiserver_admission_webhook_rejection_count{error_type=&quot;calling_webhook_error&quot;,name=&quot;invalid-admission-response-webhook.example.com&quot;,operation=&quot;CREATE&quot;,rejection_code=&quot;0&quot;,type=&quot;validating&quot;} 1
apiserver_admission_webhook_rejection_count{error_type=&quot;no_error&quot;,name=&quot;deny-unwanted-configmap-data.example.com&quot;,operation=&quot;CREATE&quot;,rejection_code=&quot;400&quot;,type=&quot;validating&quot;} 13
</code></pre><!--
## Best practices and warnings

### Idempotence
-->
<h2 id="最佳实践和警告">最佳实践和警告</h2>
<h3 id="idempotence">幂等性 </h3>
<!--
An idempotent mutating admission webhook is able to successfully process an object it has already admitted
and potentially modified. The admission can be applied multiple times without changing the result beyond
the initial application.
-->
<p>幂等的修改性质的准入 Webhook 能够成功处理已经被它接纳甚或修改的对象。
即使多次执行该准入测试，也不会产生与初次执行结果相异的结果。</p>
<!--
#### Example of idempotent mutating admission webhooks:

1. For a `CREATE` pod request, set the field `.spec.securityContext.runAsNonRoot` of the
   pod to true, to enforce security best practices.

2. For a `CREATE` pod request, if the field `.spec.containers[].resources.limits`
   of a container is not set, set default resource limits.

3. For a `CREATE` pod request, inject a sidecar container with name `foo-sidecar` if no container with the name `foo-sidecar` already exists.

In the cases above, the webhook can be safely reinvoked, or admit an object that already has the fields set.
-->
<h4 id="幂等-mutating-admission-webhook-的示例">幂等 mutating admission Webhook 的示例：</h4>
<ol>
<li>对于 <code>CREATE</code> Pod 请求，将 Pod 的字段 <code>.spec.securityContext.runAsNonRoot</code>
设置为 true，以实施安全最佳实践。</li>
<li>对于 <code>CREATE</code> Pod 请求，如果未设置容器的字段
<code>.spec.containers[].resources.limits</code>，设置默认资源限制值。</li>
<li>对于 <code>CREATE</code> pod 请求，如果 Pod 中不存在名为 <code>foo-sidecar</code> 的边车容器，
向 Pod 注入一个 <code>foo-sidecar</code> 容器。</li>
</ol>
<p>在上述情况下，可以安全地重新调用 Webhook，或接受已经设置了字段的对象。</p>
<!--
#### Example of non-idempotent mutating admission webhooks:
-->
<h4 id="非幂等-mutating-admission-webhook-的示例">非幂等 mutating admission Webhook 的示例：</h4>
<!--
1. For a `CREATE` pod request, inject a sidecar container with name `foo-sidecar`
   suffixed with the current timestamp (e.g. `foo-sidecar-19700101-000000`).

2. For a `CREATE`/`UPDATE` pod request, reject if the pod has label `"env"` set,
   otherwise add an `"env": "prod"` label to the pod.

3. For a `CREATE` pod request, blindly append a sidecar container named
   `foo-sidecar` without looking to see if there is already a `foo-sidecar`
   container in the pod.
-->
<ol>
<li>对于 <code>CREATE</code> pod 请求，注入名称为 <code>foo-sidecar</code> 并带有当前时间戳的
边车容器（例如 <code>foo-sidecar-19700101-000000</code>）。</li>
<li>对于 <code>CREATE/UPDATE</code> pod 请求，如果容器已设置标签 <code>&quot;env&quot;</code> 则拒绝，
否则将 <code>&quot;env&quot;: &quot;prod&quot;</code> 标签添加到容器。</li>
<li>对于 <code>CREATE</code> pod 请求，盲目地添加一个名为 <code>foo-sidecar</code> 的边车容器，
而未查看 Pod 中是否已经有 <code>foo-sidecar</code> 容器。</li>
</ol>
<!--
In the first case above, reinvoking the webhook can result in the same sidecar being injected multiple times to a pod, each time
with a different container name. Similarly the webhook can inject duplicated containers if the sidecar already exists in
a user-provided pod.

In the second case above, reinvoking the webhook will result in the webhook failing on its own output.

In the third case above, reinvoking the webhook will result in duplicated containers in the pod spec, which makes
the request invalid and rejected by the API server.
-->
<p>在上述第一种情况下，重新调用该 Webhook 可能导致同一个 Sidecar 容器
多次注入到 Pod 中，而且每次使用不同的容器名称。
类似地，如果 Sidecar 已存在于用户提供的 Pod 中，则 Webhook 可能注入重复的容器。</p>
<p>在上述第二种情况下，重新调用 Webhook 将导致 Webhook 自身输出失败。</p>
<p>在上述第三种情况下，重新调用 Webhook 将导致 Pod 规范中的容器重复，
从而使请求无效并被 API 服务器拒绝。</p>
<!--
### Intercepting all versions of an object

It is recommended that admission webhooks should always intercept all versions of an object by setting `.webhooks[].matchPolicy`
to `Equivalent`. It is also recommended that admission webhooks should prefer registering for stable versions of resources.
Failure to intercept all versions of an object can result in admission policies not being enforced for requests in certain
versions. See [Matching requests: matchPolicy](#matching-requests-matchpolicy) for examples.
-->
<h3 id="拦截对象的所有版本">拦截对象的所有版本</h3>
<p>建议通过将 <code>.webhooks[].matchPolicy</code> 设置为 <code>Equivalent</code>，
以确保准入 Webhooks 始终拦截对象的所有版本。
建议准入 Webhooks 应该更偏向注册资源的稳定版本。
如果无法拦截对象的所有版本，可能会导致准入策略未再某些版本的请求上执行。
有关示例，请参见<a href="#matching-requests-matchpolicy">匹配请求：matchPolicy</a>。</p>
<!--
### Availability

It is recommended that admission Webhooks should evaluate as quickly as possible (typically in milliseconds), since they add to API request latency.
It is encouraged to use a small timeout for webhooks. See [Timeouts](#timeouts) for more detail.

It is recommended that admission webhooks should leverage some format of load-balancing, to provide high availability and
performance benefits. If a webhook is running within the cluster, you can run multiple webhook backends behind a service
to leverage the load-balancing that service supports.
-->
<h3 id="availability">可用性  </h3>
<p>建议准入 webhook 尽快完成执行（时长通常是毫秒级），因为它们会增加 API 请求的延迟。
建议对 Webhook 使用较小的超时值。有关更多详细信息，请参见<a href="#timeouts">超时</a>。</p>
<p>建议 Admission Webhook 应该采用某种形式的负载均衡机制，以提供高可用性和高性能。
如果集群中正在运行 Webhook，则可以在服务后面运行多个 Webhook 后端，以利用该服务支持的负载均衡。</p>
<!--
### Guaranteeing the final state of the object is seen

Admission webhooks that need to guarantee they see the final state of the object in order to enforce policy
should use a validating admission webhook, since objects can be modified after being seen by mutating webhooks.

For example, a mutating admission webhook is configured to inject a sidecar container with name "foo-sidecar" on every
`CREATE` pod request. If the sidecar *must* be present, a validating admisson webhook should also be configured to intercept `CREATE` pod requests, and validate
that a container with name "foo-sidecar" with the expected configuration exists in the to-be-created object.
-->
<h3 id="确保看到对象的最终状态">确保看到对象的最终状态</h3>
<p>如果某准入 Webhook 需要保证自己能够看到对象的最终状态以实施策略，
则应该使用一个验证性质的 webhook，
因为可以通过 mutating Webhook 看到对象后对其进行修改。</p>
<p>例如，一个修改性质的准入Webhook 被配置为在每个 <code>CREATE</code> Pod 请求中
注入一个名称为 &quot;foo-sidecar&quot; 的 sidecar 容器。</p>
<p>如果<em>必须</em>存在边车容器，则还应配置一个验证性质的准入 Webhook 以拦截
<code>CREATE</code> Pod 请求，并验证要创建的对象中是否存在具有预期配置的名称为
&quot;foo-sidecar&quot; 的容器。</p>
<!--
### Avoiding deadlocks in self-hosted webhooks

A webhook running inside the cluster might cause deadlocks for its own deployment if it is configured
to intercept resources required to start its own pods.

For example, a mutating admission webhook is configured to admit `CREATE` pod requests only if a certain label is set in the
pod (e.g. `"env": "prod"`). The webhook server runs in a deployment which doesn't set the `"env"` label.
When a node that runs the webhook server pods
becomes unhealthy, the webhook deployment will try to reschedule the pods to another node. However the requests will
get rejected by the existing webhook server since the `"env"` label is unset, and the migration cannot happen.

It is recommended to exclude the namespace where your webhook is running with a [namespaceSelector](#matching-requests-namespaceselector).
-->
<h3 id="避免自托管的-webhooks-中出现死锁">避免自托管的 Webhooks 中出现死锁</h3>
<p>如果集群内的 Webhook 配置能够拦截启动其自己的 Pod 所需的资源，
则该 Webhook 可能导致其自身部署时发生死锁。</p>
<p>例如，某修改性质的准入 Webhook 配置为仅当 Pod 中设置了某个标签
（例如 <code>&quot;env&quot;: &quot;prod&quot;</code>）时，才接受 <code>CREATE</code> Pod 请求。
Webhook 服务器在未设置 <code>&quot;env&quot;</code> 标签的 Deployment 中运行。当运行 Webhook 服务器的
容器的节点运行不正常时，Webhook 部署尝试将容器重新调度到另一个节点。
但是，由于未设置 <code>&quot;env&quot;</code> 标签，因此请求将被现有的 Webhook 服务器拒绝，并且调度迁移不会发生。</p>
<p>建议使用 <a href="#matching-requests-namespaceselector">namespaceSelector</a> 排除
Webhook 所在的名字空间。</p>
<!--
### Side effects

It is recommended that admission webhooks should avoid side effects if possible, which means the webhooks operate only on the
content of the `AdmissionReview` sent to them, and do not make out-of-band changes. The `.webhooks[].sideEffects` field should
be set to `None` if a webhook doesn't have any side effect.

If side effects are required during the admission evaluation, they must be suppressed when processing an
`AdmissionReview` object with `dryRun` set to `true`, and the `.webhooks[].sideEffects` field should be
set to `NoneOnDryRun`. See [Side effects](#side-effects) for more detail.
-->
<h3 id="side-effects">副作用 </h3>
<p>建议准入 Webhook 应尽可能避免副作用，这意味着该准入 webhook 仅对发送给他们的
<code>AdmissionReview</code> 的内容起作用，并且不要进行额外更改。
如果 Webhook 没有任何副作用，则 <code>.webhooks[].sideEffects</code> 字段应设置为
<code>None</code>。</p>
<p>如果在准入执行期间存在副作用，则应在处理 <code>dryRun</code> 为 <code>true</code> 的 <code>AdmissionReview</code>
对象时避免产生副作用，并且其 <code>.webhooks[].sideEffects</code> 字段应设置为
<code>NoneOnDryRun</code>。更多详细信息，请参见<a href="#side-effects">副作用</a>。</p>
<!--
### Avoiding operating on the kube-system namespace
-->
<h3 id="避免对-kube-system-名字空间进行操作">避免对 kube-system 名字空间进行操作</h3>
<!--
The `kube-system` namespace contains objects created by the Kubernetes system,
e.g. service accounts for the control plane components, pods like `kube-dns`.
Accidentally mutating or rejecting requests in the `kube-system` namespace may
cause the control plane components to stop functioning or introduce unknown behavior.
If your admission webhooks don't intend to modify the behavior of the Kubernetes control
plane, exclude the `kube-system` namespace from being intercepted using a
[`namespaceSelector`](#matching-requests-namespaceselector).
-->
<p><code>kube-system</code> 名字空间包含由 Kubernetes 系统创建的对象，
例如用于控制平面组件的服务账号，诸如 <code>kube-dns</code> 之类的 Pod 等。
意外更改或拒绝 <code>kube-system</code> 名字空间中的请求可能会导致控制平面组件
停止运行或者导致未知行为发生。
如果你的准入 Webhook 不想修改 Kubernetes 控制平面的行为，请使用
<a href="#matching-requests-namespaceselector"><code>namespaceSelector</code></a> 避免
拦截 <code>kube-system</code> 名字空间。</p>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-bea207258f3576b8ec7444a20d498e1d">4.6 - 管理服务账号</h1>
    
	<!--
reviewers:
- bprashanth
- davidopp
- lavalamp
- liggitt
title: Managing Service Accounts
content_type: concept
weight: 50
-->
<!-- overview -->
<!--
This is a Cluster Administrator guide to service accounts. You should be familiar with 
[configuring Kubernetes service accounts](/docs/tasks/configure-pod-container/configure-service-account/).

Support for authorization and user accounts is planned but incomplete. Sometimes
incomplete features are referred to in order to better describe service accounts.
-->
<p>这是一篇针对服务账号的集群管理员指南。你应该熟悉
<a href="/zh/docs/tasks/configure-pod-container/configure-service-account/">配置 Kubernetes 服务账号</a>。</p>
<p>对鉴权和用户账号的支持已在规划中，当前并不完备。
为了更好地描述服务账号，有时这些不完善的特性也会被提及。</p>
<!-- body -->
<!--
## User accounts versus service accounts

Kubernetes distinguishes between the concept of a user account and a service account
for a number of reasons:
-->
<h2 id="user-accounts-versus-service-accounts">用户账号与服务账号 </h2>
<p>Kubernetes 区分用户账号和服务账号的概念，主要基于以下原因：</p>
<!--
- User accounts are for humans. Service accounts are for processes, which run
  in pods.
- User accounts are intended to be global. Names must be unique across all
  namespaces of a cluster. Service accounts are namespaced.
- Typically, a cluster's user accounts might be synced from a corporate
  database, where new user account creation requires special privileges and is
  tied to complex business processes. Service account creation is intended to be
  more lightweight, allowing cluster users to create service accounts for
  specific tasks by following the principle of least privilege.
- Auditing considerations for humans and service accounts may differ.
- A config bundle for a complex system may include definition of various service
  accounts for components of that system. Because service accounts can be created
  without many constraints and have namespaced names, such config is portable.
-->
<ul>
<li>用户账号是针对人而言的。 服务账号是针对运行在 Pod 中的进程而言的。</li>
<li>用户账号是全局性的。其名称跨集群中名字空间唯一的。服务账号是名字空间作用域的。</li>
<li>通常情况下，集群的用户账号可能会从企业数据库进行同步，其创建需要特殊权限，
并且涉及到复杂的业务流程。
服务账号创建有意做得更轻量，允许集群用户为了具体的任务创建服务账号
以遵从权限最小化原则。</li>
<li>对人员和服务账号审计所考虑的因素可能不同。</li>
<li>针对复杂系统的配置包可能包含系统组件相关的各种服务账号的定义。因为服务账号
的创建约束不多并且有名字空间域的名称，这种配置是很轻量的。</li>
</ul>
<!--
## Service account automation

Three separate components cooperate to implement the automation around service accounts:

- A `ServiceAccount` admission controller
- A Token controller
- A `ServiceAccount` controller
-->
<h2 id="service-account-automation">服务账号的自动化  </h2>
<p>三个独立组件协作完成服务账号相关的自动化：</p>
<ul>
<li><code>ServiceAccount</code> 准入控制器</li>
<li>Token 控制器</li>
<li><code>ServiceAccount</code> 控制器</li>
</ul>
<!--
### ServiceAccount Admission Controller

The modification of pods is implemented via a plugin
called an [Admission Controller](/docs/reference/access-authn-authz/admission-controllers/).
It is part of the API server.
It acts synchronously to modify pods as they are created or updated. When this plugin is active
(and it is by default on most distributions), then it does the following when a pod is created or modified:
-->
<h3 id="serviceaccount-admission-controller">ServiceAccount 准入控制器  </h3>
<p>对 Pod 的改动通过一个被称为
<a href="/zh/docs/reference/access-authn-authz/admission-controllers/">准入控制器</a>
的插件来实现。它是 API 服务器的一部分。
当 Pod 被创建或更新时，它会同步地修改 Pod。
如果该插件处于激活状态（在大多数发行版中都是默认激活的），当 Pod 被创建
或更新时它会进行以下操作：</p>
<!--
1. If the pod does not have a `ServiceAccount` set, it sets the `ServiceAccount` to `default`.
1. It ensures that the `ServiceAccount` referenced by the pod exists, and otherwise rejects it.
1. It adds a `volume` to the pod which contains a token for API access
   if neither the ServiceAccount `automountServiceAccountToken` nor the Pod's
   `automountServiceAccountToken` is set to `false`.
1. It adds a `volumeSource` to each container of the pod mounted at
   `/var/run/secrets/kubernetes.io/serviceaccount`, if the previous step has
   created a volume for ServiceAccount token.
1. If the pod does not contain any `ImagePullSecrets`, then `ImagePullSecrets` of the `ServiceAccount` are added to the pod.
-->
<ol>
<li>如果该 Pod 没有设置 <code>ServiceAccount</code>，将其 <code>ServiceAccount</code> 设为 <code>default</code>。</li>
<li>保证 Pod 所引用的 <code>ServiceAccount</code> 确实存在，否则拒绝该 Pod。</li>
<li>如果服务账号的 <code>automountServiceAccountToken</code> 或 Pod 的
<code>automountServiceAccountToken</code> 都未显式设置为 <code>false</code>，则为 Pod 创建一个
<code>volume</code>，在其中包含用来访问 API 的令牌。</li>
<li>如果前一步中为服务账号令牌创建了卷，则为 Pod 中的每个容器添加一个
<code>volumeSource</code>，挂载在其 <code>/var/run/secrets/kubernetes.io/serviceaccount</code>
目录下。</li>
<li>如果 Pod 不包含 <code>imagePullSecrets</code> 设置，将 <code>ServiceAccount</code> 所引用
的服务账号中的 <code>imagePullSecrets</code> 信息添加到 Pod 中。</li>
</ol>
<!--
#### Bound Service Account Token Volume
-->
<h4 id="bound-service-account-token-volume">绑定的服务账号令牌卷 </h4>





<div style="margin-top: 10px; margin-bottom: 10px;">
<b>FEATURE STATE:</b> <code>Kubernetes v1.22 [stable]</code>
</div>

<!--
The ServiceAccount admission controller will add the following projected volume instead of a Secret-based volume for the non-expiring service account token created by Token Controller.
-->
<p>当 <code>BoundServiceAccountTokenVolume</code>
ServiceAccount 准入控制器将添加如下投射卷，而不是为令牌控制器
所生成的不过期的服务账号令牌而创建的基于 Secret 的卷。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml">- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>kube-api-access-&lt;随机后缀&gt;<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">projected</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">defaultMode</span>:<span style="color:#bbb"> </span><span style="color:#666">420</span><span style="color:#bbb"> </span><span style="color:#080;font-style:italic"># 0644</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">sources</span>:<span style="color:#bbb">
</span><span style="color:#bbb">      </span>- <span style="color:#008000;font-weight:bold">serviceAccountToken</span>:<span style="color:#bbb">
</span><span style="color:#bbb">          </span><span style="color:#008000;font-weight:bold">expirationSeconds</span>:<span style="color:#bbb"> </span><span style="color:#666">3600</span><span style="color:#bbb">
</span><span style="color:#bbb">          </span><span style="color:#008000;font-weight:bold">path</span>:<span style="color:#bbb"> </span>token<span style="color:#bbb">
</span><span style="color:#bbb">      </span>- <span style="color:#008000;font-weight:bold">configMap</span>:<span style="color:#bbb">
</span><span style="color:#bbb">          </span><span style="color:#008000;font-weight:bold">items</span>:<span style="color:#bbb">
</span><span style="color:#bbb">            </span>- <span style="color:#008000;font-weight:bold">key</span>:<span style="color:#bbb"> </span>ca.crt<span style="color:#bbb">
</span><span style="color:#bbb">              </span><span style="color:#008000;font-weight:bold">path</span>:<span style="color:#bbb"> </span>ca.crt<span style="color:#bbb">
</span><span style="color:#bbb">          </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>kube-root-ca.crt<span style="color:#bbb">
</span><span style="color:#bbb">      </span>- <span style="color:#008000;font-weight:bold">downwardAPI</span>:<span style="color:#bbb">
</span><span style="color:#bbb">          </span><span style="color:#008000;font-weight:bold">items</span>:<span style="color:#bbb">
</span><span style="color:#bbb">            </span>- <span style="color:#008000;font-weight:bold">fieldRef</span>:<span style="color:#bbb">
</span><span style="color:#bbb">                </span><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>v1<span style="color:#bbb">
</span><span style="color:#bbb">                </span><span style="color:#008000;font-weight:bold">fieldPath</span>:<span style="color:#bbb"> </span>metadata.namespace<span style="color:#bbb">
</span><span style="color:#bbb">              </span><span style="color:#008000;font-weight:bold">path</span>:<span style="color:#bbb"> </span>namespace<span style="color:#bbb">
</span></code></pre></div><!--
This projected volume consists of three sources:

1. A ServiceAccountToken acquired from kube-apiserver via TokenRequest API. It will expire after 1 hour by default or when the pod is deleted. It is bound to the pod and has kube-apiserver as the audience.
1. A ConfigMap containing a CA bundle used for verifying connections to the kube-apiserver. This feature depends on the `RootCAConfigMap` feature gate, which publishes a "kube-root-ca.crt" ConfigMap to every namespace. `RootCAConfigMap` feature gate is graduated to GA in 1.21 and default to true. (This feature will be removed from --feature-gate arg in 1.22).
1. A DownwardAPI that references the namespace of the pod.
-->
<p>此投射卷有三个数据源：</p>
<ol>
<li>通过 TokenRequest API 从 kube-apiserver 处获得的 ServiceAccountToken。
这一令牌默认会在一个小时之后或者 Pod 被删除时过期。
该令牌绑定到 Pod 实例上，并将 kube-apiserver 作为其受众（audience）。</li>
<li>包含用来验证与 kube-apiserver 连接的 CA 证书包的 ConfigMap 对象。
这一特性依赖于 <code>RootCAConfigMap</code> 特性门控。该特性被启用时，
控制面会公开一个名为 <code>kube-root-ca.crt</code> 的 ConfigMap 给所有名字空间。
<code>RootCAConfigMap</code> 在 1.21 版本中进入 GA 状态，默认被启用，
该特性门控会在 1.22 版本中从 <code>--feature-gate</code> 参数中删除。</li>
<li>引用 Pod 名字空间的一个 DownwardAPI。</li>
</ol>
<!--
See more details about [projected volumes](/docs/tasks/configure-pod-container/configure-projected-volume-storage/).
-->
<p>参阅<a href="/zh/docs/tasks/configure-pod-container/configure-projected-volume-storage/">投射卷</a>
了解进一步的细节。</p>
<!--
### Token Controller

TokenController runs as part of `kube-controller-manager`. It acts asynchronously. It:

- watches ServiceAccount creation and creates a corresponding
  ServiceAccount token Secret to allow API access.
- watches ServiceAccount deletion and deletes all corresponding ServiceAccount
  token Secrets.
- watches ServiceAccount token Secret addition, and ensures the referenced
  ServiceAccount exists, and adds a token to the Secret if needed.
- watches Secret deletion and removes a reference from the corresponding
  ServiceAccount if needed.
-->
<h3 id="token-controller">Token 控制器   </h3>
<p>TokenController 作为 <code>kube-controller-manager</code> 的一部分运行，以异步的形式工作。
其职责包括：</p>
<ul>
<li>监测 ServiceAccount 的创建并创建相应的服务账号令牌 Secret 以允许访问 API。</li>
<li>监测 ServiceAccount 的删除并删除所有相应的服务账号令牌 Secret。</li>
<li>监测服务账号令牌 Secret 的添加，保证相应的 ServiceAccount 存在，如有需要，
向 Secret 中添加令牌。</li>
<li>监测服务账号令牌 Secret 的删除，如有需要，从相应的 ServiceAccount 中移除引用。</li>
</ul>
<!--
You must pass a service account private key file to the token controller in
the `kube-controller-manager` using the `--service-account-private-key-file`
flag. The private key is used to sign generated service account tokens.
Similarly, you must pass the corresponding public key to the `kube-apiserver`
using the `--service-account-key-file` flag. The public key will be used to
verify the tokens during authentication.
-->
<p>你必须通过 <code>--service-account-private-key-file</code> 标志为 <code>kube-controller-manager</code>
的令牌控制器传入一个服务账号私钥文件。该私钥用于为所生成的服务账号令牌签名。
同样地，你需要通过 <code>--service-account-key-file</code> 标志将对应的公钥通知给
kube-apiserver。公钥用于在身份认证过程中校验令牌。</p>
<!--
#### To create additional API tokens

A controller loop ensures a Secret with an API token exists for each
ServiceAccount. To create additional API tokens for a ServiceAccount, create a
Secret of type `kubernetes.io/service-account-token` with an annotation
referencing the ServiceAccount, and the controller will update it with a
generated token:

Below is a sample configuration for such a Secret:
-->
<h4 id="to-create-additional-api-tokens">创建额外的 API 令牌  </h4>
<p>控制器中有专门的循环来保证每个 ServiceAccount 都存在对应的包含 API 令牌的 Secret。
当需要为 ServiceAccount 创建额外的 API 令牌时，可以创建一个类型为
<code>kubernetes.io/service-account-token</code> 的 Secret，并在其注解中引用对应的
ServiceAccount。控制器会生成令牌并更新该 Secret：</p>
<p>下面是这种 Secret 的一个示例配置：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>Secret<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>mysecretname<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">annotations</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">kubernetes.io/service-account.name</span>:<span style="color:#bbb"> </span>myserviceaccount<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">type</span>:<span style="color:#bbb"> </span>kubernetes.io/service-account-token<span style="color:#bbb">
</span></code></pre></div><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl create -f ./secret.json
kubectl describe secret mysecretname
</code></pre></div><!--
#### To delete/invalidate a ServiceAccount token Secret
-->
<h4 id="删除-废止服务账号令牌-secret">删除/废止服务账号令牌 Secret</h4>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl delete secret mysecretname
</code></pre></div><!--
### ServiceAccount controller

A ServiceAccount controller manages the ServiceAccounts inside namespaces, and
ensures a ServiceAccount named "default" exists in every active namespace.
-->
<h3 id="serviceaccount-controller">服务账号控制器  </h3>
<p>服务账号控制器管理各名字空间下的 ServiceAccount 对象，并且保证每个活跃的
名字空间下存在一个名为 &quot;default&quot; 的 ServiceAccount。</p>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-342be69d36f174f762c36f4fe11fcb20">4.7 - 鉴权概述</h1>
    
	<!--
reviewers:
- erictune
- lavalamp
- deads2k
- liggitt
title: Authorization Overview
content_type: concept
weight: 60
-->
<!-- overview -->
<!--
Learn more about Kubernetes authorization, including details about creating
policies using the supported authorization modules.
-->
<p>了解有关 Kubernetes 鉴权的更多信息，包括使用支持的鉴权模块创建策略的详细信息。</p>
<!-- body -->
<!--
In Kubernetes, you must be authenticated (logged in) before your request can be
authorized (granted permission to access). For information about authentication,
see [Accessing Control Overview](/docs/concepts/security/controlling-access/).

Kubernetes expects attributes that are common to REST API requests. This means
that Kubernetes authorization works with existing organization-wide or
cloud-provider-wide access control systems which may handle other APIs besides
the Kubernetes API.
-->
<p>在 Kubernetes 中，你必须在鉴权（授予访问权限）之前进行身份验证（登录），有关身份验证的信息，
请参阅<a href="/zh/docs/concepts/security/controlling-access/">访问控制概述</a>.</p>
<p>Kubernetes 期望请求中存在 REST API 常见的属性。
这意味着 Kubernetes 鉴权适用于现有的组织范围或云提供商范围的访问控制系统，
除了 Kubernetes API 之外，它还可以处理其他 API。</p>
<!--
## Determine Whether a Request is Allowed or Denied

Kubernetes authorizes API requests using the API server. It evaluates all of the
request attributes against all policies and allows or denies the request. All
parts of an API request must be allowed by some policy in order to proceed. This
means that permissions are denied by default.

(Although Kubernetes uses the API server, access controls and policies that
depend on specific fields of specific kinds of objects are handled by Admission
Controllers.)

When multiple authorization modules are configured, each is checked in sequence.
If any authorizer approves or denies a request, that decision is immediately
returned and no other authorizer is consulted. If all modules have no opinion on
the request, then the request is denied. A deny returns an HTTP status code 403.
-->
<h2 id="确定是允许还是拒绝请求">确定是允许还是拒绝请求</h2>
<p>Kubernetes 使用 API 服务器对 API 请求进行鉴权。
它根据所有策略评估所有请求属性来决定允许或拒绝请求。
一个 API 请求的所有部分都必须被某些策略允许才能继续。
这意味着默认情况下拒绝权限。</p>
<p>（尽管 Kubernetes 使用 API 服务器，但是依赖于特定对象种类的特定字段的访问控制
和策略由准入控制器处理。）</p>
<p>当系统配置了多个鉴权模块时，Kubernetes 将按顺序使用每个模块。
如果任何鉴权模块批准或拒绝请求，则立即返回该决定，并且不会与其他鉴权模块协商。
如果所有模块对请求没有意见，则拒绝该请求。
被拒绝响应返回 HTTP 状态代码 403。</p>
<!--
## Review Your Request Attributes

Kubernetes reviews only the following API request attributes:

 * **user** - The `user` string provided during authentication.
 * **group** - The list of group names to which the authenticated user belongs.
 * **extra** - A map of arbitrary string keys to string values, provided by the authentication layer.
 * **API** - Indicates whether the request is for an API resource.
 * **Request path** - Path to miscellaneous non-resource endpoints like `/api` or `/healthz`.
 * **API request verb** - API verbs `get`, `list`, `create`, `update`, `patch`, `watch`, `proxy`, `redirect`, `delete`, and `deletecollection` are used for resource requests. To determine the request verb for a resource API endpoint, see [Determine the request verb](/docs/reference/access-authn-authz/authorization/#determine-whether-a-request-is-allowed-or-denied) below.
 * **HTTP request verb** - HTTP verbs `get`, `post`, `put`, and `delete` are used for non-resource requests.
 * **Resource** - The ID or name of the resource that is being accessed (for resource requests only) -- For resource requests using `get`, `update`, `patch`, and `delete` verbs, you must provide the resource name.
 * **Subresource** - The subresource that is being accessed (for resource requests only).
 * **Namespace** - The namespace of the object that is being accessed (for namespaced resource requests only).
 * **API group** - The <a class='glossary-tooltip' title='Kubernetes API 中的一组相关路径' data-toggle='tooltip' data-placement='top' href='/zh/docs/concepts/overview/kubernetes-api/#api-groups-and-versioning' target='_blank' aria-label='API Group'>API Group</a> being accessed (for resource requests only). An empty string designates the _core_ [API group](/docs/reference/using-api/#api-groups).
-->
<h2 id="审查你的请求属性">审查你的请求属性</h2>
<p>Kubernetes 仅审查以下 API 请求属性：</p>
<ul>
<li><strong>用户</strong> - 身份验证期间提供的 <code>user</code> 字符串。</li>
<li><strong>组</strong> - 经过身份验证的用户所属的组名列表。</li>
<li><strong>额外信息</strong> - 由身份验证层提供的任意字符串键到字符串值的映射。</li>
<li><strong>API</strong> - 指示请求是否针对 API 资源。</li>
<li><strong>请求路径</strong> - 各种非资源端点的路径，如 <code>/api</code> 或 <code>/healthz</code>。</li>
<li><strong>API 请求动词</strong> - API 动词 <code>get</code>、<code>list</code>、<code>create</code>、<code>update</code>、<code>patch</code>、<code>watch</code>、
<code>proxy</code>、<code>redirect</code>、<code>delete</code> 和 <code>deletecollection</code> 用于资源请求。
要确定资源 API 端点的请求动词，请参阅
<a href="#determine-the-request-verb">确定请求动词</a>。</li>
<li><strong>HTTP 请求动词</strong> - HTTP 动词 <code>get</code>、<code>post</code>、<code>put</code> 和 <code>delete</code> 用于非资源请求。</li>
<li><strong>Resource</strong> - 正在访问的资源的 ID 或名称（仅限资源请求）-
对于使用 <code>get</code>、<code>update</code>、<code>patch</code> 和 <code>delete</code> 动词的资源请求，你必须提供资源名称。</li>
<li><strong>子资源</strong> - 正在访问的子资源（仅限资源请求）。</li>
<li><strong>名字空间</strong> - 正在访问的对象的名称空间（仅适用于名字空间资源请求）。</li>
<li><strong>API 组</strong> - 正在访问的 <a class='glossary-tooltip' title='Kubernetes API 中的一组相关路径' data-toggle='tooltip' data-placement='top' href='/zh/docs/concepts/overview/kubernetes-api/#api-groups-and-versioning' target='_blank' aria-label='API 组'>API 组</a>
（仅限资源请求）。空字符串表示<a href="/zh/docs/reference/using-api/#api-groups">核心 API 组</a>。</li>
</ul>
<!--
## Determine the Request Verb

**Non-resource requests**
Requests to endpoints other than `/api/v1/...` or `/apis/<group>/<version>/...`
are considered "non-resource requests", and use the lower-cased HTTP method of the request as the verb.
For example, a `GET` request to endpoints like `/api` or `/healthz` would use `get` as the verb.
-->
<h2 id="determine-the-request-verb">确定请求动词 </h2>
<p><strong>非资源请求</strong></p>
<p>对于 <code>/api/v1/...</code> 或 <code>/apis/&lt;group&gt;/&lt;version&gt;/...</code> 之外的端点的请求被
视为“非资源请求（Non-Resource Requests）”，并使用该请求的 HTTP 方法的
小写形式作为其请求动词。
例如，对 <code>/api</code> 或 <code>/healthz</code> 这类端点的 <code>GET</code> 请求将使用 <code>get</code> 作为其动词。</p>
<!--
**Resource requests**

To determine the request verb for a resource API endpoint, review the HTTP verb
used and whether or not the request acts on an individual resource or a
collection of resources:
-->
<p><strong>资源请求</strong></p>
<p>要确定对资源 API 端点的请求动词，需要查看所使用的 HTTP 动词以及该请求是针对
单个资源还是一组资源：</p>
<!--
HTTP verb | request verb
----------|---------------
POST      | create
GET, HEAD | get (for individual resources), list (for collections)
PUT       | update
PATCH     | patch
DELETE    | delete (for individual resources), deletecollection (for collections)
-->
<table>
<thead>
<tr>
<th>HTTP 动词</th>
<th>请求动词</th>
</tr>
</thead>
<tbody>
<tr>
<td>POST</td>
<td>create</td>
</tr>
<tr>
<td>GET, HEAD</td>
<td>get （针对单个资源）、list（针对集合）</td>
</tr>
<tr>
<td>PUT</td>
<td>update</td>
</tr>
<tr>
<td>PATCH</td>
<td>patch</td>
</tr>
<tr>
<td>DELETE</td>
<td>delete（针对单个资源）、deletecollection（针对集合）</td>
</tr>
</tbody>
</table>
<!--
Kubernetes sometimes checks authorization for additional permissions using specialized verbs. For example:

* [PodSecurityPolicy](/docs/concepts/policy/pod-security-policy/)
  * `use` verb on `podsecuritypolicies` resources in the `policy` API group.
* [RBAC](/docs/reference/access-authn-authz/rbac/#privilege-escalation-prevention-and-bootstrapping)
  * `bind` and `escalate` verbs on `roles` and `clusterroles` resources in the `rbac.authorization.k8s.io` API group.
* [Authentication](/docs/reference/access-authn-authz/authentication/)
  * `impersonate` verb on `users`, `groups`, and `serviceaccounts` in the core API group, and the `userextras` in the `authentication.k8s.io` API group.
-->
<p>Kubernetes 有时使用专门的动词以对额外的权限进行鉴权。例如：</p>
<ul>
<li><a href="/zh/docs/concepts/policy/pod-security-policy/">PodSecurityPolicy</a>
<ul>
<li><code>policy</code> API 组中 <code>podsecuritypolicies</code> 资源使用 <code>use</code> 动词</li>
</ul>
</li>
<li><a href="/zh/docs/reference/access-authn-authz/rbac/#privilege-escalation-prevention-and-bootstrapping">RBAC</a>
<ul>
<li>对 <code>rbac.authorization.k8s.io</code> API 组中 <code>roles</code> 和 <code>clusterroles</code> 资源的 <code>bind</code>
和 <code>escalate</code> 动词</li>
</ul>
</li>
<li><a href="/zh/docs/reference/access-authn-authz/authentication/">身份认证</a>
<ul>
<li>对核心 API 组中 <code>users</code>、<code>groups</code> 和 <code>serviceaccounts</code> 以及 <code>authentication.k8s.io</code>
API 组中的 <code>userextras</code> 所使用的 <code>impersonate</code> 动词。</li>
</ul>
</li>
</ul>
<!--
## Authorization Modules  {#authorization-modules}

 * **Node** - A special-purpose authorizer that grants permissions to kubelets based on the pods they are scheduled to run. To learn more about using the Node authorization mode, see [Node Authorization](/docs/reference/access-authn-authz/node/).
 * **ABAC** - Attribute-based access control (ABAC) defines an access control paradigm whereby access rights are granted to users through the use of policies which combine attributes together. The policies can use any type of attributes (user attributes, resource attributes, object, environment attributes, etc). To learn more about using the ABAC mode, see [ABAC Mode](/docs/reference/access-authn-authz/abac/).
 * **RBAC** - Role-based access control (RBAC) is a method of regulating access to computer or network resources based on the roles of individual users within an enterprise. In this context, access is the ability of an individual user to perform a specific task, such as view, create, or modify a file. To learn more about using the RBAC mode, see [RBAC Mode](/docs/reference/access-authn-authz/rbac/)
   * When specified RBAC (Role-Based Access Control) uses the `rbac.authorization.k8s.io` API group to drive authorization decisions, allowing admins to dynamically configure permission policies through the Kubernetes API.
   * To enable RBAC, start the apiserver with `--authorization-mode=RBAC`.
 * **Webhook** - A WebHook is an HTTP callback: an HTTP POST that occurs when something happens; a simple event-notification via HTTP POST. A web application implementing WebHooks will POST a message to a URL when certain things happen. To learn more about using the Webhook mode, see [Webhook Mode](/docs/reference/access-authn-authz/webhook/).
-->
<h2 id="authorization-modules">鉴权模块 </h2>
<ul>
<li><strong>Node</strong> - 一个专用鉴权组件，根据调度到 kubelet 上运行的 Pod 为 kubelet 授予权限。
了解有关使用节点鉴权模式的更多信息，请参阅<a href="/zh/docs/reference/access-authn-authz/node/">节点鉴权</a>。</li>
<li><strong>ABAC</strong> - 基于属性的访问控制（ABAC）定义了一种访问控制范型，通过使用将属性组合
在一起的策略，将访问权限授予用户。策略可以使用任何类型的属性（用户属性、资源属性、
对象，环境属性等）。要了解有关使用 ABAC 模式的更多信息，请参阅
<a href="/zh/docs/reference/access-authn-authz/abac/">ABAC 模式</a>。</li>
<li><strong>RBAC</strong> - 基于角色的访问控制（RBAC）是一种基于企业内个人用户的角色来管理对
计算机或网络资源的访问的方法。在此上下文中，权限是单个用户执行特定任务的能力，
例如查看、创建或修改文件。要了解有关使用 RBAC 模式的更多信息，请参阅
<a href="/zh/docs/reference/access-authn-authz/rbac/">RBAC 模式</a>。
<ul>
<li>被启用之后，RBAC（基于角色的访问控制）使用 <code>rbac.authorization.k8s.io</code> API 组来
驱动鉴权决策，从而允许管理员通过 Kubernetes API 动态配置权限策略。</li>
<li>要启用 RBAC，请使用 <code>--authorization-mode = RBAC</code> 启动 API 服务器。</li>
</ul>
</li>
<li><strong>Webhook</strong> - WebHook 是一个 HTTP 回调：发生某些事情时调用的 HTTP POST；
通过 HTTP POST 进行简单的事件通知。实现 WebHook 的 Web 应用程序会在发生某些事情时
将消息发布到 URL。要了解有关使用 Webhook 模式的更多信息，请参阅
<a href="/zh/docs/reference/access-authn-authz/webhook/">Webhook 模式</a>。</li>
</ul>
<!--
#### Checking API Access

`kubectl` provides the `auth can-i` subcommand for quickly querying the API authorization layer.
The command uses the `SelfSubjectAccessReview` API to determine if the current user can perform
a given action, and works regardless of the authorization mode used.
-->
<h4 id="checking-api-access">检查 API 访问  </h4>
<p><code>kubectl</code> 提供 <code>auth can-i</code> 子命令，用于快速查询 API 鉴权。
该命令使用 <code>SelfSubjectAccessReview</code> API 来确定当前用户是否可以执行给定操作，
无论使用何种鉴权模式该命令都可以工作。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl auth can-i create deployments --namespace dev
</code></pre></div><pre tabindex="0"><code>yes
</code></pre><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl auth can-i create deployments --namespace prod
</code></pre></div><pre tabindex="0"><code>no
</code></pre><!--
Administrators can combine this with [user impersonation](/docs/reference/access-authn-authz/authentication/#user-impersonation)
to determine what action other users can perform.
-->
<p>管理员可以将此与
<a href="/zh/docs/reference/access-authn-authz/authentication/#user-impersonation">用户扮演</a>
结合使用，以确定其他用户可以执行的操作。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">kubectl auth can-i list secrets --namespace dev --as dave
</code></pre></div><pre tabindex="0"><code>no
</code></pre><!--
`SelfSubjectAccessReview` is part of the `authorization.k8s.io` API group, which
exposes the API server authorization to external services. Other resources in
this group include:

* `SubjectAccessReview` - Access review for any user, not just the current one. Useful for delegating authorization decisions to the API server. For example, the kubelet and extension API servers use this to determine user access to their own APIs.
* `LocalSubjectAccessReview` - Like `SubjectAccessReview` but restricted to a specific namespace.
* `SelfSubjectRulesReview` - A review which returns the set of actions a user can perform within a namespace. Useful for users to quickly summarize their own access, or for UIs to hide/show actions.

These APIs can be queried by creating normal Kubernetes resources, where the response "status"
field of the returned object is the result of the query.
-->
<p><code>SelfSubjectAccessReview</code> 是 <code>authorization.k8s.io</code> API 组的一部分，它将 API
服务器鉴权公开给外部服务。该组中的其他资源包括：</p>
<ul>
<li><code>SubjectAccessReview</code> - 对任意用户的访问进行评估，而不仅仅是当前用户。
当鉴权决策被委派给 API 服务器时很有用。例如，kubelet 和扩展 API 服务器使用
它来确定用户对自己的 API 的访问权限。</li>
<li><code>LocalSubjectAccessReview</code> - 与 <code>SubjectAccessReview</code> 类似，但仅限于特定的
名字空间。</li>
<li><code>SelfSubjectRulesReview</code> - 返回用户可在名字空间内执行的操作集的审阅。
用户可以快速汇总自己的访问权限，或者用于 UI 中的隐藏/显示动作。</li>
</ul>
<p>可以通过创建普通的 Kubernetes 资源来查询这些 API，其中返回对象的响应 &quot;status&quot;
字段是查询的结果。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">kubectl create -f - -o yaml <span style="color:#b44">&lt;&lt; EOF
</span><span style="color:#b44">apiVersion: authorization.k8s.io/v1
</span><span style="color:#b44">kind: SelfSubjectAccessReview
</span><span style="color:#b44">spec:
</span><span style="color:#b44">  resourceAttributes:
</span><span style="color:#b44">    group: apps
</span><span style="color:#b44">    name: deployments
</span><span style="color:#b44">    verb: create
</span><span style="color:#b44">    namespace: dev
</span><span style="color:#b44">EOF</span>
</code></pre></div><!--
The generated `SelfSubjectAccessReview` is:
-->
<p>生成的 <code>SelfSubjectAccessReview</code> 为：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>authorization.k8s.io/v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>SelfSubjectAccessReview<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">creationTimestamp</span>:<span style="color:#bbb"> </span><span style="color:#a2f;font-weight:bold">null</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">spec</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">resourceAttributes</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">group</span>:<span style="color:#bbb"> </span>apps<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>deployments<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">namespace</span>:<span style="color:#bbb"> </span>dev<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">verb</span>:<span style="color:#bbb"> </span>create<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">status</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">allowed</span>:<span style="color:#bbb"> </span><span style="color:#a2f;font-weight:bold">true</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">denied</span>:<span style="color:#bbb"> </span><span style="color:#a2f;font-weight:bold">false</span><span style="color:#bbb">
</span></code></pre></div><!--
## Using Flags for Your Authorization Module

You must include a flag in your policy to indicate which authorization module
your policies include:

The following flags can be used:
-->
<h2 id="为你的鉴权模块设置参数">为你的鉴权模块设置参数</h2>
<p>你必须在策略中包含一个参数标志，以指明你的策略包含哪个鉴权模块：</p>
<p>可以使用的参数有：</p>
<!--
  * `--authorization-mode=ABAC` Attribute-Based Access Control (ABAC) mode allows you to configure policies using local files.
  * `--authorization-mode=RBAC` Role-based access control (RBAC) mode allows you to create and store policies using the Kubernetes API.
  * `--authorization-mode=Webhook` WebHook is an HTTP callback mode that allows you to manage authorization using a remote REST endpoint.
  * `--authorization-mode=Node` Node authorization is a special-purpose authorization mode that specifically authorizes API requests made by kubelets.
  * `--authorization-mode=AlwaysDeny` This flag blocks all requests. Use this flag only for testing.
  * `--authorization-mode=AlwaysAllow` This flag allows all requests. Use this flag only if you do not require authorization for your API requests.
-->
<ul>
<li><code>--authorization-mode=ABAC</code> 基于属性的访问控制（ABAC）模式允许你
使用本地文件配置策略。</li>
<li><code>--authorization-mode=RBAC</code> 基于角色的访问控制（RBAC）模式允许你使用
Kubernetes API 创建和存储策略。</li>
<li><code>--authorization-mode=Webhook</code> WebHook 是一种 HTTP 回调模式，允许你使用远程
REST 端点管理鉴权。</li>
<li><code>--authorization-mode=Node</code> 节点鉴权是一种特殊用途的鉴权模式，专门对
kubelet 发出的 API 请求执行鉴权。</li>
<li><code>--authorization-mode=AlwaysDeny</code> 该标志阻止所有请求。仅将此标志用于测试。</li>
<li><code>--authorization-mode=AlwaysAllow</code> 此标志允许所有请求。仅在你不需要 API 请求
的鉴权时才使用此标志。</li>
</ul>
<!--
You can choose more than one authorization module. Modules are checked in order
so an earlier module has higher priority to allow or deny a request.
-->
<p>你可以选择多个鉴权模块。模块按顺序检查，以便较靠前的模块具有更高的优先级来允许
或拒绝请求。</p>
<!--
## Privilege escalation via pod creation

Users who have the ability to create pods in a namespace can potentially
escalate their privileges within that namespace.  They can create pods that
access their privileges within that namespace. They can create pods that access
secrets the user cannot themselves read, or that run under a service account
with different/greater permissions.
-->
<h2 id="通过创建-pod-提升权限">通过创建 Pod 提升权限</h2>
<p>能够在名字空间中创建 Pod 的用户可能会提升其在该名字空间内的权限。
他们可以创建在该名字空间内访问其权限的 Pod。
他们可以创建 Pod 访问用户自己无法读取的 Secret，或者在具有不同/更高权限的
服务帐户下运行的 Pod 。</p>
<blockquote class="caution callout">
  <div><strong>注意：</strong> <!--
System administrators, use care when granting access to pod creation.  A user
granted permission to create pods (or controllers that create pods) in the
namespace can: read all secrets in the namespace; read all config maps in the
namespace; and impersonate any service account in the namespace and take any
action the account could take. This applies regardless of authorization mode.
-->
<p>系统管理员在授予对 Pod 创建的访问权限时要小心。
被授予在名字空间中创建 Pod（或创建 Pod 的控制器）的权限的用户可以：
读取名字空间中的所有 Secret；读取名字空间中的所有 ConfigMap；
并模拟名字空间中的任意服务账号并执行账号可以执行的任何操作。
无论采用何种鉴权方式，这都适用。</div>
</blockquote>

<h2 id="接下来">接下来</h2>
<!--
* To learn more about Authentication, see **Authentication** in [Controlling Access to the Kubernetes API](/docs/concepts/security/controlling-access/).
* To learn more about Admission Control, see [Using Admission Controllers](/docs/reference/access-authn-authz/admission-controllers/).
-->
<ul>
<li>要了解有关身份验证的更多信息，请参阅
<a href="/zh/docs/concepts/security/controlling-access/">控制对 Kubernetes API 的访问</a>
中的 <strong>身份验证</strong>  部分。</li>
<li>要了解有关准入控制的更多信息，请参阅
<a href="/zh/docs/reference/access-authn-authz/admission-controllers/">使用准入控制器</a>。</li>
</ul>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-954776b47f2d90515f375623a0ce98e1">4.8 - 使用 RBAC 鉴权</h1>
    
	<!--
reviewers:
- erictune
- deads2k
- liggitt
title: Using RBAC Authorization
content_type: concept
weight: 70
-->
<!-- overview -->
<!--
Role-based access control (RBAC) is a method of regulating access to computer or
network resources based on the roles of individual users within your organization.
-->
<p>基于角色（Role）的访问控制（RBAC）是一种基于组织中用户的角色来调节控制对
计算机或网络资源的访问的方法。</p>
<!-- body -->
<!--
RBAC authorization uses the `rbac.authorization.k8s.io`
<a class='glossary-tooltip' title='Kubernetes API 中的一组相关路径' data-toggle='tooltip' data-placement='top' href='/zh/docs/concepts/overview/kubernetes-api/#api-groups-and-versioning' target='_blank' aria-label='API Group'>API Group</a> to drive authorization
decisions, allowing you to dynamically configure policies through the Kubernetes API.
-->
<p>RBAC 鉴权机制使用 <code>rbac.authorization.k8s.io</code>
<a class='glossary-tooltip' title='Kubernetes API 中的一组相关路径' data-toggle='tooltip' data-placement='top' href='/zh/docs/concepts/overview/kubernetes-api/#api-groups-and-versioning' target='_blank' aria-label='API 组'>API 组</a>
来驱动鉴权决定，允许你通过 Kubernetes API 动态配置策略。</p>
<!--
To enable RBAC, start the <a class='glossary-tooltip' title='提供 Kubernetes API 服务的控制面组件。' data-toggle='tooltip' data-placement='top' href='/zh/docs/reference/command-line-tools-reference/kube-apiserver/' target='_blank' aria-label='API server'>API server</a>
with the `-authorization-mode` flag set to a comma-separated list that includes `RBAC`;
for example:
-->
<p>要启用 RBAC，在启动 <a class='glossary-tooltip' title='提供 Kubernetes API 服务的控制面组件。' data-toggle='tooltip' data-placement='top' href='/zh/docs/reference/command-line-tools-reference/kube-apiserver/' target='_blank' aria-label='API 服务器'>API 服务器</a>
时将 <code>--authorization-mode</code> 参数设置为一个逗号分隔的列表并确保其中包含 <code>RBAC</code>。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kube-apiserver --authorization-mode<span style="color:#666">=</span>Example,RBAC --&lt;其他选项&gt; --&lt;其他选项&gt;
</code></pre></div><!--
## API objects {#api-overview}

The RBAC API declares four kinds of Kubernetes object: _Role_, _ClusterRole_,
_RoleBinding_ and _ClusterRoleBinding_. You can
[describe objects](/docs/concepts/overview/working-with-objects/kubernetes-objects/#understanding-kubernetes-objects),
or amend them, using tools such as `kubectl,` just like any other Kubernetes object.

-->
<h2 id="api-overview">API 对象 </h2>
<p>RBAC API 声明了四种 Kubernetes 对象：<em>Role</em>、<em>ClusterRole</em>、<em>RoleBinding</em> 和
<em>ClusterRoleBinding</em>。你可以像使用其他 Kubernetes 对象一样，
通过类似 <code>kubectl</code> 这类工具
<a href="/zh/docs/concepts/overview/working-with-objects/kubernetes-objects/#understanding-kubernetes-objects">描述对象</a>,
或修补对象。</p>
<blockquote class="caution callout">
  <div><strong>注意：</strong> <!--
These objects, by design, impose access restrictions. If you are making changes
to a cluster as you learn, see
[privilege escalation prevention and bootstrapping](#privilege-escalation-prevention-and-bootstrapping)
to understand how those restrictions can prevent you making some changes.
-->
<p>这些对象在设计时即实施了一些访问限制。如果你在学习过程中对集群做了更改，请参考
<a href="#privilege-escalation-prevention-and-bootstrapping">避免特权提升和引导</a>
一节，以了解这些限制会以怎样的方式阻止你做出修改。</div>
</blockquote>

<!--
### Role and ClusterRole

An RBAC _Role_ or _ClusterRole_ contains rules that represent a set of permissions.
Permissions are purely additive (there are no "deny" rules).

A Role always sets permissions within a particular <a class='glossary-tooltip' title='名字空间是 Kubernetes 为了在同一物理集群上支持多个虚拟集群而使用的一种抽象。' data-toggle='tooltip' data-placement='top' href='/zh/docs/concepts/overview/working-with-objects/namespaces/' target='_blank' aria-label='namespace'>namespace</a>;
when you create a Role, you have to specify the namespace it belongs in.

ClusterRole, by contrast, is a non-namespaced resource. The resources have different names (Role
and ClusterRole) because a Kubernetes object always has to be either namespaced or not namespaced;
it can't be both.
-->
<h3 id="role-and-clusterole">Role 和 ClusterRole  </h3>
<p>RBAC 的 <em>Role</em> 或 <em>ClusterRole</em> 中包含一组代表相关权限的规则。
这些权限是纯粹累加的（不存在拒绝某操作的规则）。</p>
<p>Role 总是用来在某个<a class='glossary-tooltip' title='名字空间是 Kubernetes 为了在同一物理集群上支持多个虚拟集群而使用的一种抽象。' data-toggle='tooltip' data-placement='top' href='/zh/docs/concepts/overview/working-with-objects/namespaces/' target='_blank' aria-label='名字空间'>名字空间</a>
内设置访问权限；在你创建 Role 时，你必须指定该 Role 所属的名字空间。</p>
<p>与之相对，ClusterRole 则是一个集群作用域的资源。这两种资源的名字不同（Role 和
ClusterRole）是因为 Kubernetes 对象要么是名字空间作用域的，要么是集群作用域的，
不可两者兼具。</p>
<!--
ClusterRoles have several uses. You can use a ClusterRole to:

1. define permissions on namespaced resources and be granted within individual namespace(s)
1. define permissions on namespaced resources and be granted across all namespaces
1. define permissions on cluster-scoped resources

If you want to define a role within a namespace, use a Role; if you want to define
a role cluster-wide, use a ClusterRole.
-->
<p>ClusterRole 有若干用法。你可以用它来：</p>
<ol>
<li>定义对某名字空间域对象的访问权限，并将在各个名字空间内完成授权；</li>
<li>为名字空间作用域的对象设置访问权限，并跨所有名字空间执行授权；</li>
<li>为集群作用域的资源定义访问权限。</li>
</ol>
<p>如果你希望在名字空间内定义角色，应该使用 Role；
如果你希望定义集群范围的角色，应该使用 ClusterRole。</p>
<!--
#### Role example

Here's an example Role in the "default" namespace that can be used to grant read access to
<a class='glossary-tooltip' title='Pod 表示您的集群上一组正在运行的容器。' data-toggle='tooltip' data-placement='top' href='/docs/concepts/workloads/pods/pod-overview/' target='_blank' aria-label='pods'>pods</a>:
-->
<h4 id="role-示例">Role 示例</h4>
<p>下面是一个位于 &quot;default&quot; 名字空间的 Role 的示例，可用来授予对
<a class='glossary-tooltip' title='Pod 表示您的集群上一组正在运行的容器。' data-toggle='tooltip' data-placement='top' href='/docs/concepts/workloads/pods/pod-overview/' target='_blank' aria-label='pods'>pods</a> 的读访问权限：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>rbac.authorization.k8s.io/v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>Role<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">namespace</span>:<span style="color:#bbb"> </span>default<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>pod-reader<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">rules</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">apiGroups</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;&#34;</span>]<span style="color:#bbb"> </span><span style="color:#080;font-style:italic"># &#34;&#34; 标明 core API 组</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">resources</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;pods&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">verbs</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;get&#34;</span>,<span style="color:#bbb"> </span><span style="color:#b44">&#34;watch&#34;</span>,<span style="color:#bbb"> </span><span style="color:#b44">&#34;list&#34;</span>]<span style="color:#bbb">
</span></code></pre></div><!--
#### ClusterRole example

A ClusterRole can be used to grant the same permissions as a Role.
Because they are cluster-scoped, you can also use them to grant access to:

* cluster-scoped resources (like <a class='glossary-tooltip' title='Kubernetes 中的工作机器称作节点。' data-toggle='tooltip' data-placement='top' href='/zh/docs/concepts/architecture/nodes/' target='_blank' aria-label='nodes'>nodes</a>)
* non-resource endpoints (like `/healthz`)
* namespaced resources (like Pods), across all namespaces
  For example: you can use a ClusterRole to allow a particular user to run
  `kubectl get pods -all-namespaces`
-->
<h3 id="clusterrole-示例">ClusterRole 示例</h3>
<p>ClusterRole 可以和 Role 相同完成授权。
因为 ClusterRole 属于集群范围，所以它也可以为以下资源授予访问权限：</p>
<ul>
<li>集群范围资源（比如 <a class='glossary-tooltip' title='Kubernetes 中的工作机器称作节点。' data-toggle='tooltip' data-placement='top' href='/zh/docs/concepts/architecture/nodes/' target='_blank' aria-label='节点（Node）'>节点（Node）</a>）</li>
<li>非资源端点（比如 <code>/healthz</code>）</li>
<li>跨名字空间访问的名字空间作用域的资源（如 Pods），比如，你可以使用
ClusterRole 来允许某特定用户执行 <code>kubectl get pods --all-namespaces</code></li>
</ul>
<!--
Here is an example of a ClusterRole that can be used to grant read access to
<a class='glossary-tooltip' title='Secret 用于存储敏感信息，如密码、 OAuth 令牌和 SSH 密钥。' data-toggle='tooltip' data-placement='top' href='/zh/docs/concepts/configuration/secret/' target='_blank' aria-label='secrets'>secrets</a> in any particular namespace,
or across all namespaces (depending on how it is [bound](#rolebinding-and-clusterrolebinding)):
-->
<p>下面是一个 ClusterRole 的示例，可用来为任一特定名字空间中的
<a class='glossary-tooltip' title='Secret 用于存储敏感信息，如密码、 OAuth 令牌和 SSH 密钥。' data-toggle='tooltip' data-placement='top' href='/zh/docs/concepts/configuration/secret/' target='_blank' aria-label='Secret'>Secret</a> 授予读访问权限，
或者跨名字空间的访问权限（取决于该角色是如何<a href="#rolebinding-and-clusterrolebinding">绑定</a>的）：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>rbac.authorization.k8s.io/v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>ClusterRole<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#080;font-style:italic"># &#34;namespace&#34; 被忽略，因为 ClusterRoles 不受名字空间限制</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>secret-reader<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">rules</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">apiGroups</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#080;font-style:italic"># 在 HTTP 层面，用来访问 Secret 对象的资源的名称为 &#34;secrets&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">resources</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;secrets&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">verbs</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;get&#34;</span>,<span style="color:#bbb"> </span><span style="color:#b44">&#34;watch&#34;</span>,<span style="color:#bbb"> </span><span style="color:#b44">&#34;list&#34;</span>]<span style="color:#bbb">
</span></code></pre></div><!--
The name of a Role or a ClusterRole object must be a valid
[path segment name](/docs/concepts/overview/working-with-objects/names#path-segment-names).
-->
<p>Role 或 ClusterRole 对象的名称必须是合法的
<a href="/zh/docs/concepts/overview/working-with-objects/names#path-segment-names">路径区段名称</a>。</p>
<!--
### RoleBinding and ClusterRoleBinding

A role binding grants the permissions defined in a role to a user or set of users.
It holds a list of *subjects* (users, groups, or service accounts), and a reference to the
role being granted.
A RoleBinding grants permissions within a specific namespace whereas a ClusterRoleBinding
grants that access cluster-wide.

A RoleBinding may reference any Role in the same namespace. Alternatively, a RoleBinding
can reference a ClusterRole and bind that ClusterRole to the namespace of the RoleBinding.
If you want to bind a ClusterRole to all the namespaces in your cluster, you use a
ClusterRoleBinding.

The name of a RoleBinding or ClusterRoleBinding object must be a valid
[path segment name](/docs/concepts/overview/working-with-objects/names#path-segment-names).
-->
<h3 id="rolebinding-and-clusterrolebinding">RoleBinding 和 ClusterRoleBinding  </h3>
<p>角色绑定（Role Binding）是将角色中定义的权限赋予一个或者一组用户。
它包含若干 <strong>主体</strong>（用户、组或服务账户）的列表和对这些主体所获得的角色的引用。
RoleBinding 在指定的名字空间中执行授权，而 ClusterRoleBinding 在集群范围执行授权。</p>
<p>一个 RoleBinding 可以引用同一的名字空间中的任何 Role。
或者，一个 RoleBinding 可以引用某 ClusterRole 并将该 ClusterRole 绑定到
RoleBinding 所在的名字空间。
如果你希望将某  ClusterRole 绑定到集群中所有名字空间，你要使用 ClusterRoleBinding。</p>
<p>RoleBinding 或 ClusterRoleBinding 对象的名称必须是合法的
<a href="/zh/docs/concepts/overview/working-with-objects/names#path-segment-names">路径区段名称</a>。</p>
<!--
#### RoleBinding examples {#rolebinding-example}

Here is an example of a RoleBinding that grants the "pod-reader" Role to the user "jane"
within the "default" namespace.
This allows "jane" to read pods in the "default" namespace.
-->
<h4 id="rolebinding-example">RoleBinding 示例  </h4>
<p>下面的例子中的 RoleBinding 将 &quot;pod-reader&quot; Role 授予在 &quot;default&quot; 名字空间中的用户 &quot;jane&quot;。
这样，用户 &quot;jane&quot; 就具有了读取 &quot;default&quot; 名字空间中 pods 的权限。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>rbac.authorization.k8s.io/v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#080;font-style:italic"># 此角色绑定允许 &#34;jane&#34; 读取 &#34;default&#34; 名字空间中的 Pods</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>RoleBinding<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>read-pods<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">namespace</span>:<span style="color:#bbb"> </span>default<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">subjects</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#080;font-style:italic"># 你可以指定不止一个“subject（主体）”</span><span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>User<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>jane<span style="color:#bbb"> </span><span style="color:#080;font-style:italic"># &#34;name&#34; 是区分大小写的</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">apiGroup</span>:<span style="color:#bbb"> </span>rbac.authorization.k8s.io<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">roleRef</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#080;font-style:italic"># &#34;roleRef&#34; 指定与某 Role 或 ClusterRole 的绑定关系</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>Role<span style="color:#bbb"> </span><span style="color:#080;font-style:italic"># 此字段必须是 Role 或 ClusterRole</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>pod-reader    <span style="color:#bbb"> </span><span style="color:#080;font-style:italic"># 此字段必须与你要绑定的 Role 或 ClusterRole 的名称匹配</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">apiGroup</span>:<span style="color:#bbb"> </span>rbac.authorization.k8s.io<span style="color:#bbb">
</span></code></pre></div><!--
A RoleBinding can also reference a ClusterRole to grant the permissions defined in that
ClusterRole to resources inside the RoleBinding's namespace. This kind of reference
lets you define a set of common roles across your cluster, then reuse them within
multiple namespaces.

For instance, even though the following RoleBinding refers to a ClusterRole,
"dave" (the subject, case sensitive) will only be able to read Secrets in the "development"
namespace, because the RoleBinding's namespace (in its metadata) is "development".
-->
<p>RoleBinding 也可以引用 ClusterRole，以将对应 ClusterRole 中定义的访问权限授予
RoleBinding 所在名字空间的资源。这种引用使得你可以跨整个集群定义一组通用的角色，
之后在多个名字空间中复用。</p>
<p>例如，尽管下面的 RoleBinding 引用的是一个 ClusterRole，&quot;dave&quot;（这里的主体，
区分大小写）只能访问 &quot;development&quot; 名字空间中的 Secrets 对象，因为 RoleBinding
所在的名字空间（由其 metadata 决定）是 &quot;development&quot;。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>rbac.authorization.k8s.io/v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#080;font-style:italic"># 此角色绑定使得用户 &#34;dave&#34; 能够读取 &#34;development&#34; 名字空间中的 Secrets</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#080;font-style:italic"># 你需要一个名为 &#34;secret-reader&#34; 的 ClusterRole</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>RoleBinding<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>read-secrets<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#080;font-style:italic"># RoleBinding 的名字空间决定了访问权限的授予范围。</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#080;font-style:italic"># 这里隐含授权仅在 &#34;development&#34; 名字空间内的访问权限。</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">namespace</span>:<span style="color:#bbb"> </span>development<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">subjects</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>User<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>dave<span style="color:#bbb"> </span><span style="color:#080;font-style:italic"># &#39;name&#39; 是区分大小写的</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">apiGroup</span>:<span style="color:#bbb"> </span>rbac.authorization.k8s.io<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">roleRef</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>ClusterRole<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>secret-reader<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">apiGroup</span>:<span style="color:#bbb"> </span>rbac.authorization.k8s.io<span style="color:#bbb">
</span></code></pre></div><!--
#### ClusterRoleBinding example

To grant permissions across a whole cluster, you can use a ClusterRoleBinding.
The following ClusterRoleBinding allows any user in the group "manager" to read
secrets in any namespace.
-->
<h4 id="clusterrolebinding-example">ClusterRoleBinding 示例  </h4>
<p>要跨整个集群完成访问权限的授予，你可以使用一个 ClusterRoleBinding。
下面的 ClusterRoleBinding 允许 &quot;manager&quot; 组内的所有用户访问任何名字空间中的
Secrets。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>rbac.authorization.k8s.io/v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#080;font-style:italic"># 此集群角色绑定允许 “manager” 组中的任何人访问任何名字空间中的 secrets</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>ClusterRoleBinding<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>read-secrets-global<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">subjects</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>Group<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>manager<span style="color:#bbb"> </span><span style="color:#080;font-style:italic"># &#39;name&#39; 是区分大小写的</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">apiGroup</span>:<span style="color:#bbb"> </span>rbac.authorization.k8s.io<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">roleRef</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>ClusterRole<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>secret-reader<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">apiGroup</span>:<span style="color:#bbb"> </span>rbac.authorization.k8s.io<span style="color:#bbb">
</span></code></pre></div><!--
After you create a binding, you cannot change the Role or ClusterRole that it refers to.
If you try to change a binding's `roleRef`, you get a validation error. If you do want
to change the `roleRef` for a binding, you need to remove the binding object and create
a replacement.

There are two reasons for this restriction:
-->
<p>创建了绑定之后，你不能再修改绑定对象所引用的 Role 或 ClusterRole。
试图改变绑定对象的 <code>roleRef</code> 将导致合法性检查错误。
如果你想要改变现有绑定对象中 <code>roleRef</code> 字段的内容，必须删除重新创建绑定对象。</p>
<p>这种限制有两个主要原因：</p>
<!--
1. A binding to a different role is a fundamentally different binding.
Requiring a binding to be deleted/recreated in order to change the `roleRef`
ensures the full list of subjects in the binding is intended to be granted
the new role (as opposed to enabling or accidentally modifying only the roleRef
without verifying all of the existing subjects should be given the new role's permissions).
2. Making `roleRef` immutable allows giving `update` permission on an existing binding object
to a user, which lets them manage the list of subjects, without being able to change the
role that is granted to those subjects.
-->
<ol>
<li>针对不同角色的绑定是完全不一样的绑定。要求通过删除/重建绑定来更改 <code>roleRef</code>,
这样可以确保要赋予绑定的所有主体会被授予新的角色（而不是在允许或者不小心修改
了 <code>roleRef</code> 的情况下导致所有现有主体未经验证即被授予新角色对应的权限）。</li>
<li>将 <code>roleRef</code> 设置为不可以改变，这使得可以为用户授予对现有绑定对象的 <code>update</code> 权限，
这样可以让他们管理主体列表，同时不能更改被授予这些主体的角色。</li>
</ol>
<!--
The `kubectl auth reconcile` command-line utility creates or updates a manifest file containing RBAC objects,
and handles deleting and recreating binding objects if required to change the role they refer to.
See [command usage and examples](#kubectl-auth-reconcile) for more information.
-->
<p>命令 <code>kubectl auth reconcile</code> 可以创建或者更新包含 RBAC 对象的清单文件，
并且在必要的情况下删除和重新创建绑定对象，以改变所引用的角色。
更多相关信息请参照<a href="#kubectl-auth-reconcile">命令用法和示例</a></p>
<!--
### Referring to Resources

In the Kubernetes API, most resources are represented and accessed using a string representation of
their object name, such as `pods` for a Pod. RBAC refers to resources using exactly the same
name that appears in the URL for the relevant API endpoint.
Some Kubernetes APIs involve a
_subresource_, such as the logs for a Pod. A request for a Pod's logs looks like:
-->
<h3 id="referring-to-resources">对资源的引用   </h3>
<p>在 Kubernetes API 中，大多数资源都是使用对象名称的字符串表示来呈现与访问的。
例如，对于 Pod 应使用 &quot;pods&quot;。
RBAC 使用对应 API 端点的 URL 中呈现的名字来引用资源。
有一些 Kubernetes API 涉及 <strong>子资源（subresource）</strong>，例如 Pod 的日志。
对 Pod 日志的请求看起来像这样：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-http" data-lang="http"><span style="">GET /api/v1/namespaces/{namespace}/pods/{name}/log
</span></code></pre></div><!--
In this case, `pods` is the namespaced resource for Pod resources, and `log` is a
subresource of `pods`. To represent this in an RBAC role, use a slash (`/`) to
delimit the resource and subresource. To allow a subject to read `pods` and
also access the `log` subresource for each of those Pods, you write:
-->
<p>在这里，<code>pods</code> 对应名字空间作用域的 Pod 资源，而 <code>log</code> 是 <code>pods</code> 的子资源。
在 RBAC 角色表达子资源时，使用斜线（<code>/</code>）来分隔资源和子资源。
要允许某主体读取 <code>pods</code> 同时访问这些 Pod 的 <code>log</code> 子资源，你可以这么写：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>rbac.authorization.k8s.io/v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>Role<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">namespace</span>:<span style="color:#bbb"> </span>default<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>pod-and-pod-logs-reader<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">rules</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">apiGroups</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">resources</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;pods&#34;</span>,<span style="color:#bbb"> </span><span style="color:#b44">&#34;pods/log&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">verbs</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;get&#34;</span>,<span style="color:#bbb"> </span><span style="color:#b44">&#34;list&#34;</span>]<span style="color:#bbb">
</span></code></pre></div><!--
You can also refer to resources by name for certain requests through the `resourceNames` list.
When specified, requests can be restricted to individual instances of a resource.
Here is an example that restricts its subject to only `get` or `update` a
<a class='glossary-tooltip' title='ConfigMap 是一种 API 对象，用来将非机密性的数据保存到键值对中。使用时可以用作环境变量、命令行参数或者存储卷中的配置文件。' data-toggle='tooltip' data-placement='top' href='/zh/docs/tasks/configure-pod-container/configure-pod-configmap/' target='_blank' aria-label='ConfigMap'>ConfigMap</a> named `my-configmap`:
-->
<p>对于某些请求，也可以通过 <code>resourceNames</code> 列表按名称引用资源。
在指定时，可以将请求限定为资源的单个实例。
下面的例子中限制可以 &quot;get&quot; 和 &quot;update&quot; 一个名为 <code>my-configmap</code> 的
<a class='glossary-tooltip' title='ConfigMap 是一种 API 对象，用来将非机密性的数据保存到键值对中。使用时可以用作环境变量、命令行参数或者存储卷中的配置文件。' data-toggle='tooltip' data-placement='top' href='/zh/docs/tasks/configure-pod-container/configure-pod-configmap/' target='_blank' aria-label='ConfigMap'>ConfigMap</a>：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>rbac.authorization.k8s.io/v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>Role<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">namespace</span>:<span style="color:#bbb"> </span>default<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>configmap-updater<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">rules</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">apiGroups</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#080;font-style:italic"># 在 HTTP 层面，用来访问 ConfigMap 的资源的名称为 &#34;configmaps&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">resources</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;configmaps&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">resourceNames</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;my-configmap&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">verbs</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;update&#34;</span>,<span style="color:#bbb"> </span><span style="color:#b44">&#34;get&#34;</span>]<span style="color:#bbb">
</span></code></pre></div><blockquote class="note callout">
  <div><strong>说明：</strong> <!--
You cannot restrict `create` or `deletecollection` requests by resourceName. For `create`, this
limitation is because the object name is not known at authorization time.
-->
<p>你不能针对 <code>create</code> 或者 <code>deletecollection</code> 请求来实施 resourceName 限制。
对于 <code>create</code> 操作而言，这是因为在鉴权时还不知道对象名称。</div>
</blockquote>
<!--
### Aggregated ClusterRoles

You can _aggregate_ several ClusterRoles into one combined ClusterRole.
A controller, running as part of the cluster control plane, watches for ClusterRole
objects with an `aggregationRule` set. The `aggregationRule` defines a label
<a class='glossary-tooltip' title='选择算符允许用户通过标签对一组资源对象进行筛选过滤。' data-toggle='tooltip' data-placement='top' href='/zh/docs/concepts/overview/working-with-objects/labels/' target='_blank' aria-label='selector'>selector</a> that the controller
uses to match other ClusterRole objects that should be combined into the `rules`
field of this one.

Here is an example aggregated ClusterRole:
-->
<h3 id="aggregated-clusterroles">聚合的 ClusterRole   </h3>
<p>你可以将若干 ClusterRole <strong>聚合（Aggregate）</strong> 起来，形成一个复合的 ClusterRole。
某个控制器作为集群控制面的一部分会监视带有 <code>aggregationRule</code> 的 ClusterRole
对象集合。<code>aggregationRule</code> 为控制器定义一个标签
<a class='glossary-tooltip' title='选择算符允许用户通过标签对一组资源对象进行筛选过滤。' data-toggle='tooltip' data-placement='top' href='/zh/docs/concepts/overview/working-with-objects/labels/' target='_blank' aria-label='选择算符'>选择算符</a>供后者匹配
应该组合到当前 ClusterRole 的 <code>roles</code> 字段中的 ClusterRole 对象。</p>
<p>下面是一个聚合 ClusterRole 的示例：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>rbac.authorization.k8s.io/v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>ClusterRole<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>monitoring<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">aggregationRule</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">clusterRoleSelectors</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- <span style="color:#008000;font-weight:bold">matchLabels</span>:<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">rbac.example.com/aggregate-to-monitoring</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;true&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">rules</span>:<span style="color:#bbb"> </span>[]<span style="color:#bbb"> </span><span style="color:#080;font-style:italic"># 控制面自动填充这里的规则</span><span style="color:#bbb">
</span></code></pre></div><!--
If you create a new ClusterRole that matches the label selector of an existing aggregated ClusterRole,
that change triggers adding the new rules into the aggregated ClusterRole.
Here is an example that adds rules to the "monitoring" ClusterRole, by creating another
ClusterRole labeled `rbac.example.com/aggregate-to-monitoring: true`.
-->
<p>如果你创建一个与某现有聚合 ClusterRole 的标签选择算符匹配的 ClusterRole，
这一变化会触发新的规则被添加到聚合 ClusterRole 的操作。
下面的例子中，通过创建一个标签同样为 <code>rbac.example.com/aggregate-to-monitoring: true</code>
的 ClusterRole，新的规则可被添加到 &quot;monitoring&quot; ClusterRole 中。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>rbac.authorization.k8s.io/v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>ClusterRole<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>monitoring-endpoints<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">labels</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">rbac.example.com/aggregate-to-monitoring</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;true&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#080;font-style:italic"># 当你创建 &#34;monitoring-endpoints&#34; ClusterRole 时，</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#080;font-style:italic"># 下面的规则会被添加到 &#34;monitoring&#34; ClusterRole 中</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">rules</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">apiGroups</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">resources</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;services&#34;</span>,<span style="color:#bbb"> </span><span style="color:#b44">&#34;endpoints&#34;</span>,<span style="color:#bbb"> </span><span style="color:#b44">&#34;pods&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">verbs</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;get&#34;</span>,<span style="color:#bbb"> </span><span style="color:#b44">&#34;list&#34;</span>,<span style="color:#bbb"> </span><span style="color:#b44">&#34;watch&#34;</span>]<span style="color:#bbb">
</span></code></pre></div><!--
The [default user-facing roles](#default-roles-and-role-bindings) use ClusterRole aggregation. This lets you,
as a cluster administrator, include rules for custom resources, such as those served by
<a class='glossary-tooltip' title='通过定制化的代码给您的 Kubernetes API 服务器增加资源对象，而无需编译完整的定制 API 服务器。' data-toggle='tooltip' data-placement='top' href='/zh/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/' target='_blank' aria-label='CustomResourceDefinitions'>CustomResourceDefinitions</a>
or aggregated API servers, to extend the default roles.

For example: the following ClusterRoles let the "admin" and "edit" default roles manage the custom resource
named CronTab, whereas the "view" role can perform only read actions on CronTab resources.
You can assume that CronTab objects are named `"crontabs"` in URLs as seen by the API server.
-->
<p>默认的<a href="#default-roles-and-role-bindings">面向用户的角色</a> 使用 ClusterRole 聚合。
这使得作为集群管理员的你可以为扩展默认规则，包括为定制资源设置规则，
比如通过 CustomResourceDefinitions 或聚合 API 服务器提供的定制资源。</p>
<p>例如，下面的 ClusterRoles 让默认角色 &quot;admin&quot; 和 &quot;edit&quot; 拥有管理自定义资源 &quot;CronTabs&quot; 的权限，
&quot;view&quot; 角色对 CronTab 资源拥有读操作权限。
你可以假定 CronTab 对象在 API 服务器所看到的 URL 中被命名为 <code>&quot;crontabs&quot;</code>。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>rbac.authorization.k8s.io/v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>ClusterRole<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>aggregate-cron-tabs-edit<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">labels</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#080;font-style:italic"># 添加以下权限到默认角色 &#34;admin&#34; 和 &#34;edit&#34; 中</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">rbac.authorization.k8s.io/aggregate-to-admin</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;true&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">rbac.authorization.k8s.io/aggregate-to-edit</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;true&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">rules</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">apiGroups</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;stable.example.com&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">resources</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;crontabs&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">verbs</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;get&#34;</span>,<span style="color:#bbb"> </span><span style="color:#b44">&#34;list&#34;</span>,<span style="color:#bbb"> </span><span style="color:#b44">&#34;watch&#34;</span>,<span style="color:#bbb"> </span><span style="color:#b44">&#34;create&#34;</span>,<span style="color:#bbb"> </span><span style="color:#b44">&#34;update&#34;</span>,<span style="color:#bbb"> </span><span style="color:#b44">&#34;patch&#34;</span>,<span style="color:#bbb"> </span><span style="color:#b44">&#34;delete&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#00f;font-weight:bold">---</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>ClusterRole<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>rbac.authorization.k8s.io/v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>aggregate-cron-tabs-view<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">labels</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#080;font-style:italic"># 添加以下权限到 &#34;view&#34; 默认角色中</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">rbac.authorization.k8s.io/aggregate-to-view</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;true&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">rules</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">apiGroups</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;stable.example.com&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">resources</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;crontabs&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">verbs</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;get&#34;</span>,<span style="color:#bbb"> </span><span style="color:#b44">&#34;list&#34;</span>,<span style="color:#bbb"> </span><span style="color:#b44">&#34;watch&#34;</span>]<span style="color:#bbb">
</span></code></pre></div><!--
#### Role Examples

The following examples are excerpts from Role or ClusterRole objects, showing only
the `rules` section.

Allow reading `"pods"` resources in the core
<a class='glossary-tooltip' title='Kubernetes API 中的一组相关路径' data-toggle='tooltip' data-placement='top' href='/zh/docs/concepts/overview/kubernetes-api/#api-groups-and-versioning' target='_blank' aria-label='API Group'>API Group</a>:
-->
<h4 id="role-examples">Role 示例  </h4>
<p>以下示例均为从 Role 或 CLusterRole 对象中截取出来，我们仅展示其 <code>rules</code> 部分。</p>
<p>允许读取在核心 <a class='glossary-tooltip' title='Kubernetes API 中的一组相关路径' data-toggle='tooltip' data-placement='top' href='/zh/docs/concepts/overview/kubernetes-api/#api-groups-and-versioning' target='_blank' aria-label='API 组'>API 组</a>下的
<code>&quot;Pods&quot;</code>：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">rules</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">apiGroups</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#080;font-style:italic"># 在 HTTP 层面，用来访问 Pod 的资源的名称为 &#34;pods&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">resources</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;pods&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">verbs</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;get&#34;</span>,<span style="color:#bbb"> </span><span style="color:#b44">&#34;list&#34;</span>,<span style="color:#bbb"> </span><span style="color:#b44">&#34;watch&#34;</span>]<span style="color:#bbb">
</span></code></pre></div><!--
Allow reading/writing Deployments (at the HTTP level: objects with `"deployments"`
in the resource part of their URL) in both the `"extensions"` and `"apps"` API groups:
-->
<p>允许读/写在 &quot;extensions&quot; 和 &quot;apps&quot; API 组中的 Deployment（在 HTTP 层面，对应
URL 中资源部分为 &quot;deployments&quot;）：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">rules</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">apiGroups</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;extensions&#34;</span>,<span style="color:#bbb"> </span><span style="color:#b44">&#34;apps&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">resources</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;deployments&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">verbs</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;get&#34;</span>,<span style="color:#bbb"> </span><span style="color:#b44">&#34;list&#34;</span>,<span style="color:#bbb"> </span><span style="color:#b44">&#34;watch&#34;</span>,<span style="color:#bbb"> </span><span style="color:#b44">&#34;create&#34;</span>,<span style="color:#bbb"> </span><span style="color:#b44">&#34;update&#34;</span>,<span style="color:#bbb"> </span><span style="color:#b44">&#34;patch&#34;</span>,<span style="color:#bbb"> </span><span style="color:#b44">&#34;delete&#34;</span>]<span style="color:#bbb">
</span></code></pre></div><!--
Allow reading Pods in the core API group, as well as reading or writing Job
resources in the `"batch"` or `"extensions"` API groups:
-->
<p>允许读取核心 API 组中的 &quot;pods&quot; 和读/写 <code>&quot;batch&quot;</code> 或 <code>&quot;extensions&quot;</code> API 组中的
&quot;jobs&quot;：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">rules</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">apiGroups</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">resources</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;pods&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">verbs</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;get&#34;</span>,<span style="color:#bbb"> </span><span style="color:#b44">&#34;list&#34;</span>,<span style="color:#bbb"> </span><span style="color:#b44">&#34;watch&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">apiGroups</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;batch&#34;</span>,<span style="color:#bbb"> </span><span style="color:#b44">&#34;extensions&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">resources</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;jobs&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">verbs</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;get&#34;</span>,<span style="color:#bbb"> </span><span style="color:#b44">&#34;list&#34;</span>,<span style="color:#bbb"> </span><span style="color:#b44">&#34;watch&#34;</span>,<span style="color:#bbb"> </span><span style="color:#b44">&#34;create&#34;</span>,<span style="color:#bbb"> </span><span style="color:#b44">&#34;update&#34;</span>,<span style="color:#bbb"> </span><span style="color:#b44">&#34;patch&#34;</span>,<span style="color:#bbb"> </span><span style="color:#b44">&#34;delete&#34;</span>]<span style="color:#bbb">
</span></code></pre></div><!--
Allow reading a ConfigMap named "my-config" (must be bound with a
RoleBinding to limit to a single ConfigMap in a single namespace):
-->
<p>允许读取名称为 &quot;my-config&quot; 的 ConfigMap（需要通过 RoleBinding 绑定以
限制为某名字空间中特定的 ConfigMap）：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">rules</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">apiGroups</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">resources</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;configmaps&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">resourceNames</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;my-config&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">verbs</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;get&#34;</span>]<span style="color:#bbb">
</span></code></pre></div><!--
Allow reading the resource `"nodes"` in the core group (because a
Node is cluster-scoped, this must be in a ClusterRole bound with a
ClusterRoleBinding to be effective):
-->
<p>允许读取在核心组中的 &quot;nodes&quot; 资源（因为 <code>Node</code> 是集群作用域的，所以需要
ClusterRole 绑定到 ClusterRoleBinding 才生效）：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">rules</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">apiGroups</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">resources</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;nodes&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">verbs</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;get&#34;</span>,<span style="color:#bbb"> </span><span style="color:#b44">&#34;list&#34;</span>,<span style="color:#bbb"> </span><span style="color:#b44">&#34;watch&#34;</span>]<span style="color:#bbb">
</span></code></pre></div><!--
Allow GET and POST requests to the non-resource endpoint `/healthz` and
all subpaths (must be in a ClusterRole bound with a ClusterRoleBinding
to be effective):
-->
<p>允许针对非资源端点 <code>/healthz</code> 和其子路径上发起 GET 和 POST 请求
（必须在 ClusterRole 绑定 ClusterRoleBinding 才生效）：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">rules</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- <span style="color:#008000;font-weight:bold">nonResourceURLs</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;/healthz&#34;</span>,<span style="color:#bbb"> </span><span style="color:#b44">&#34;/healthz/*&#34;</span>]<span style="color:#bbb"> </span><span style="color:#080;font-style:italic"># nonResourceURL 中的 &#39;*&#39; 是一个全局通配符</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">verbs</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;get&#34;</span>,<span style="color:#bbb"> </span><span style="color:#b44">&#34;post&#34;</span>]<span style="color:#bbb">
</span></code></pre></div><!--
### Referring to Subjects

A RoleBinding or ClusterRoleBinding binds a role to subjects.
Subjects can be groups, users or
<a class='glossary-tooltip' title='为在 Pod 中运行的进程提供标识。' data-toggle='tooltip' data-placement='top' href='/zh/docs/tasks/configure-pod-container/configure-service-account/' target='_blank' aria-label='ServiceAccounts'>ServiceAccounts</a>.

Kubernetes represents usernames as strings.
These can be: plain names, such as "alice"; email-style names, like "bob@example.com";
or numeric user IDs represented as a string.  It is up to you as a cluster administrator
to configure the [authentication modules](/docs/reference/access-authn-authz/authentication/)
so that authentication produces usernames in the format you want.
-->
<h3 id="referring-to-subjects">对主体的引用  </h3>
<p>RoleBinding 或者 ClusterRoleBinding 可绑定角色到某 *主体（Subject）*上。
主体可以是组，用户或者
<a class='glossary-tooltip' title='为在 Pod 中运行的进程提供标识。' data-toggle='tooltip' data-placement='top' href='/zh/docs/tasks/configure-pod-container/configure-service-account/' target='_blank' aria-label='服务账户'>服务账户</a>。</p>
<p>Kubernetes 用字符串来表示用户名。
用户名可以是普通的用户名，像 &quot;alice&quot;；或者是邮件风格的名称，如 &quot;bob@example.com&quot;，
或者是以字符串形式表达的数字 ID。
你作为 Kubernetes 管理员负责配置
<a href="/zh/docs/reference/access-authn-authz/authentication/">身份认证模块</a>
以便后者能够生成你所期望的格式的用户名。</p>
<blockquote class="caution callout">
  <div><strong>注意：</strong> <!--
The prefix `system:` is reserved for Kubernetes system use, so you should ensure
that you don't have users or groups with names that start with `system:` by
accident.
Other than this special prefix, the RBAC authorization system does not require any format
for usernames.
-->
<p>前缀 <code>system:</code> 是 Kubernetes 系统保留的，所以你要确保
所配置的用户名或者组名不能出现上述 <code>system:</code> 前缀。
除了对前缀的限制之外，RBAC 鉴权系统不对用户名格式作任何要求。</div>
</blockquote>

<!--
In Kubernetes, Authenticator modules provide group information.
Groups, like users, are represented as strings, and that string has no format requirements,
other than that the prefix `system:` is reserved.

[Service Accounts](/docs/tasks/configure-pod-container/configure-service-account/) have usernames with the `system:serviceaccount:` prefix and belong
to groups with the `system:serviceaccounts:` prefix.
-->
<p>在 Kubernetes 中，鉴权模块提供用户组信息。
与用户名一样，用户组名也用字符串来表示，而且对该字符串没有格式要求，
只是不能使用保留的前缀 <code>system:</code>。</p>
<p><a href="/zh/docs/tasks/configure-pod-container/configure-service-account/">服务账户</a>
的用户名前缀为 <code>system:serviceaccount:</code>，属于前缀为 <code>system:serviceaccounts:</code>
的用户组。</p>
<blockquote class="note callout">
  <div><strong>说明：</strong> <!--
- `system:serviceaccount:` (singular) is the prefix for service account usernames.
- `system:serviceaccounts:` (plural) is the prefix for service account groups.
-->
<ul>
<li><code>system:serviceaccount:</code> （单数）是用于服务账户用户名的前缀；</li>
<li><code>system:serviceaccounts:</code> （复数）是用于服务账户组名的前缀。</li>
</ul>
</div>
</blockquote>
<!--
#### Role Binding Examples

The following examples are `RoleBinding` excerpts that only
show the `subjects` section.

For a user named `alice@example.com`:
-->
<h4 id="role-binding-examples">RoleBinding 示例  </h4>
<p>下面示例是 <code>RoleBinding</code> 中的片段，仅展示其 <code>subjects</code> 的部分。</p>
<p>对于名称为 <code>alice@example.com</code> 的用户：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">subjects</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>User<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;alice@example.com&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">apiGroup</span>:<span style="color:#bbb"> </span>rbac.authorization.k8s.io<span style="color:#bbb">
</span></code></pre></div><!--
For a group named `frontend-admins`:
-->
<p>对于名称为 <code>frontend-admins</code> 的用户组：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">subjects</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>Group<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;frontend-admins&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">apiGroup</span>:<span style="color:#bbb"> </span>rbac.authorization.k8s.io<span style="color:#bbb">
</span></code></pre></div><!--
For the default service account in the "kube-system" namespace:
-->
<p>对于 <code>kube-system</code> 名字空间中的默认服务账户：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">subjects</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>ServiceAccount<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>default<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">namespace</span>:<span style="color:#bbb"> </span>kube-system<span style="color:#bbb">
</span></code></pre></div><!--
For all service accounts in the "qa" group in any namespace:
-->
<p>对于任何名称空间中的 &quot;qa&quot; 组中所有的服务账户：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">subjects</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>Group<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>system:serviceaccounts:qa<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">apiGroup</span>:<span style="color:#bbb"> </span>rbac.authorization.k8s.io<span style="color:#bbb">
</span></code></pre></div><!-- 
For all service accounts in the "dev" group in the "development" namespace:
-->
<p>对于 &quot;development&quot; 名称空间中 &quot;dev&quot; 组中的所有服务帐户：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">subjects</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>Group<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>system:serviceaccounts:dev<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">apiGroup</span>:<span style="color:#bbb"> </span>rbac.authorization.k8s.io<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">namespace</span>:<span style="color:#bbb"> </span>development<span style="color:#bbb">
</span></code></pre></div><!--
For all service accounts in any namespace:
-->
<p>对于在任何名字空间中的服务账户：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">subjects</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>Group<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>system:serviceaccounts<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">apiGroup</span>:<span style="color:#bbb"> </span>rbac.authorization.k8s.io<span style="color:#bbb">
</span></code></pre></div><!--
For all authenticated users:
-->
<p>对于所有已经过认证的用户：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">subjects</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>Group<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>system:authenticated<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">apiGroup</span>:<span style="color:#bbb"> </span>rbac.authorization.k8s.io<span style="color:#bbb">
</span></code></pre></div><!--
For all unauthenticated users:
-->
<p>对于所有未通过认证的用户：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">subjects</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>Group<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>system:unauthenticated<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">apiGroup</span>:<span style="color:#bbb"> </span>rbac.authorization.k8s.io<span style="color:#bbb">
</span></code></pre></div><!--
For all users:
-->
<p>对于所有用户：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">subjects</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>Group<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>system:authenticated<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">apiGroup</span>:<span style="color:#bbb"> </span>rbac.authorization.k8s.io<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>Group<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>system:unauthenticated<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">apiGroup</span>:<span style="color:#bbb"> </span>rbac.authorization.k8s.io<span style="color:#bbb">
</span></code></pre></div><!--
## Default roles and role bindings

API servers create a set of default ClusterRole and ClusterRoleBinding objects.
Many of these are `system:` prefixed, which indicates that the resource is directly
managed by the cluster control plane.
All of the default ClusterRoles and ClusterRoleBindings are labeled with `kubernetes.io/bootstrapping=rbac-defaults`.
-->
<h2 id="默认-roles-和-role-bindings">默认 Roles 和 Role Bindings</h2>
<p>API 服务器创建一组默认的 ClusterRole 和 ClusterRoleBinding 对象。
这其中许多是以 <code>system:</code> 为前缀的，用以标识对应资源是直接由集群控制面管理的。
所有的默认 ClusterRole 和 ClusterRoleBinding 都有
<code>kubernetes.io/bootstrapping=rbac-defaults</code>
标签。</p>
<blockquote class="caution callout">
  <div><strong>注意：</strong> <!--
Take care when modifying ClusterRoles and ClusterRoleBindings with names
that have a `system:` prefix.
Modifications to these resources can result in non-functional clusters.
-->
<p>在修改名称包含 <code>system:</code> 前缀的 ClusterRole 和 ClusterRoleBinding
时要格外小心。
对这些资源的更改可能导致集群无法继续工作。</div>
</blockquote>

<!--
### Auto-reconciliation

At each start-up, the API server updates default cluster roles with any missing permissions,
and updates default cluster role bindings with any missing subjects.
This allows the cluster to repair accidental modifications, and helps to keep roles and role bindings
up-to-date as permissions and subjects change in new releases.

To opt out of this reconciliation, set the `rbac.authorization.kubernetes.io/autoupdate`
annotation on a default cluster role or rolebinding to `false`.
Be aware that missing default permissions and subjects can result in non-functional clusters.

Auto-reconciliation is enabled by default if the RBAC authorizer is active.
-->
<h3 id="auto-reconciliation">自动协商  </h3>
<p>在每次启动时，API 服务器都会更新默认 ClusterRole 以添加缺失的各种权限，并更新
默认的 ClusterRoleBinding 以增加缺失的各类主体。
这种自动协商机制允许集群去修复一些不小心发生的修改，并且有助于保证角色和角色绑定
在新的发行版本中有权限或主体变更时仍然保持最新。</p>
<p>如果要禁止此功能，请将默认 ClusterRole 以及 ClusterRoleBinding 的
<code>rbac.authorization.kubernetes.io/autoupdate</code> 注解设置成 <code>false</code>。
注意，缺少默认权限和角色绑定主体可能会导致集群无法正常工作。</p>
<p>如果基于 RBAC 的鉴权机制被启用，则自动协商功能默认是被启用的。</p>
<!--
### API discovery roles {#discovery-roles}

Default role bindings authorize unauthenticated and authenticated users to read API information that is deemed safe to be publicly accessible (including CustomResourceDefinitions). To disable anonymous unauthenticated access add `--anonymous-auth=false` to the API server configuration.

To view the configuration of these roles via `kubectl` run:
-->
<h3 id="discovery-roles">API 发现角色 </h3>
<p>无论是经过身份验证的还是未经过身份验证的用户，默认的角色绑定都授权他们读取被认为
是可安全地公开访问的 API（ 包括 CustomResourceDefinitions）。
如果要禁用匿名的未经过身份验证的用户访问，请在 API 服务器配置中中添加
<code>--anonymous-auth=false</code> 的配置选项。</p>
<p>通过运行命令 <code>kubectl</code> 可以查看这些角色的配置信息:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl get clusterroles system:discovery -o yaml
</code></pre></div><blockquote class="note callout">
  <div><strong>说明：</strong> <!--
If you edit that ClusterRole, your changes will be overwritten on API server restart
via [auto-reconciliation](#auto-reconciliation). To avoid that overwriting,
either do not manually edit the role, or disable auto-reconciliation.
-->
<p>如果你编辑该 ClusterRole，你所作的变更会被 API 服务器在重启时自动覆盖，这是通过
<a href="#auto-reconciliation">自动协商</a>机制完成的。要避免这类覆盖操作，
要么不要手动编辑这些角色，要么禁止自动协商机制。</div>
</blockquote>
<table>
<caption>
<!--
Kubernetes RBAC API discovery roles
-->
Kubernetes RBAC API 发现角色
</caption>
<colgroup><col width="25%"><col width="25%"><col></colgroup>
<thead>
<tr>
<!--
<th>Default ClusterRole</th>
<th>Default ClusterRoleBinding</th>
<th>Description</th>
-->
<th>默认 ClusterRole</th>
<th>默认 ClusterRoleBinding</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><b>system:basic-user</b></td>
<!-- 
<td><b>system:authenticated</b> group</td>
-->
<td><b>system:authenticated</b> 组</td>
<td>
<!-- 
Allows a user read-only access to basic information about themselves. 
Prior to 1.14, this role was also bound to <tt>system:unauthenticated</tt> by default.
-->
允许用户以只读的方式去访问他们自己的基本信息。在 1.14 版本之前，这个角色在默认情况下也绑定在 <tt>system:unauthenticated</tt> 上。
</td>
</tr>
<tr>
<td><b>system:discovery</b></td>
<!-- 
<td><b>system:authenticated</b> group</td>
-->
<td><b>system:authenticated</b> 组</td>
<td>
<!-- 
Allows read-only access to API discovery endpoints needed to discover and negotiate an API level. 
Prior to 1.14, this role was also bound to <tt>system:unauthenticated</tt> by default.
-->
允许以只读方式访问 API 发现端点，这些端点用来发现和协商 API 级别。
在 1.14 版本之前，这个角色在默认情况下绑定在 <tt>system:unauthenticated</tt> 上。
</td>
</tr>
<tr>
<td><b>system:public-info-viewer</b></td>
<!-- 
<td><b>system:authenticated</b> and <b>system:unauthenticated</b> groups</td>
-->
<td><b>system:authenticated</b> 和 <b>system:unauthenticated</b> 组</td>
<td>
<!-- 
Allows read-only access to non-sensitive information about the cluster. Introduced in Kubernetes v1.14.
-->
允许对集群的非敏感信息进行只读访问，它是在 1.14 版本中引入的。
</td>
</tr>
</tbody>
</table>
<!--
### User-facing roles

Some of the default ClusterRoles are not `system:` prefixed. These are intended to be user-facing roles.
They include super-user roles (`cluster-admin`), roles intended to be granted cluster-wide
using ClusterRoleBindings, and roles intended to be granted within particular
namespaces using RoleBindings (`admin`, `edit`, `view`).

User-facing ClusterRoles use [ClusterRole aggregation](#aggregated-clusterroles) to allow admins to include
rules for custom resources on these ClusterRoles. To add rules to the `admin`, `edit`, or `view` roles, create
a ClusterRole with one or more of the following labels:
-->
<h3 id="user-facing-roles">面向用户的角色  </h3>
<p>一些默认的 ClusterRole 不是以前缀 <code>system:</code> 开头的。这些是面向用户的角色。
它们包括超级用户（Super-User）角色（<code>cluster-admin</code>）、
使用 ClusterRoleBinding 在集群范围内完成授权的角色（<code>cluster-status</code>）、
以及使用 RoleBinding 在特定名字空间中授予的角色（<code>admin</code>、<code>edit</code>、<code>view</code>）。</p>
<p>面向用户的 ClusterRole 使用 <a href="#aggregated-clusterroles">ClusterRole 聚合</a>以允许管理员在
这些 ClusterRole 上添加用于定制资源的规则。如果想要添加规则到 <code>admin</code>、<code>edit</code> 或者 <code>view</code>，
可以创建带有以下一个或多个标签的 ClusterRole：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">labels</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">rbac.authorization.k8s.io/aggregate-to-admin</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;true&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">rbac.authorization.k8s.io/aggregate-to-edit</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;true&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">rbac.authorization.k8s.io/aggregate-to-view</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;true&#34;</span><span style="color:#bbb">
</span></code></pre></div><table>
<colgroup><col width="25%"><col width="25%"><col></colgroup>
<thead>
<tr>
<!--
<th>Default ClusterRole</th>
<th>Default ClusterRoleBinding</th>
<th>Description</th>
-->
<th>默认 ClusterRole</th>
<th>默认 ClusterRoleBinding</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><b>cluster-admin</b></td>
<!--
<td><b>system:masters</b> group</td>
-->
<td><b>system:masters</b> 组</td>
<td>
<!-- 
Allows super-user access to perform any action on any resource.
When used in a <b>ClusterRoleBinding</b>, it gives full control over every resource in the cluster and in all namespaces.
When used in a <b>RoleBinding</b>, it gives full control over every resource in the rolebinding's namespace, including the namespace itself.
-->
允许超级用户在平台上的任何资源上执行所有操作。
当在 <b>ClusterRoleBinding</b> 中使用时，可以授权对集群中以及所有名字空间中的全部资源进行完全控制。
当在 <b>RoleBinding</b> 中使用时，可以授权控制 RoleBinding 所在名字空间中的所有资源，包括名字空间本身。
</td>
</tr>
<tr>
<td><b>admin</b></td>
<!-- 
<td>None</td>
--->
<td>无</td>
<td>
<!-- 
Allows admin access, intended to be granted within a namespace using a <b>RoleBinding</b>.
If used in a <b>RoleBinding</b>, allows read/write access to most resources in a namespace,
including the ability to create roles and rolebindings within the namespace.
It does not allow write access to resource quota or to the namespace itself.
-->
允许管理员访问权限，旨在使用 <b>RoleBinding</b> 在名字空间内执行授权。
如果在 <b>RoleBinding</b> 中使用，则可授予对名字空间中的大多数资源的读/写权限，
包括创建角色和角色绑定的能力。
但是它不允许对资源配额或者名字空间本身进行写操作。
</td>
</tr>
<tr>
<td><b>edit</b></td>
<!-- 
<td>None</td>
-->
<td>无</td>
<td>
<!-- 
Allows read/write access to most objects in a namespace.
This role does not allow viewing or modifying roles or role bindings.
However, this role allows accessing Secrets and running Pods as any ServiceAccount in
the namespace, so it can be used to gain the API access levels of any ServiceAccount in
the namespace.
-->
允许对名字空间的大多数对象进行读/写操作。
它不允许查看或者修改角色或者角色绑定。
不过，此角色可以访问 Secret，以名字空间中任何 ServiceAccount 的身份运行 Pods，
所以可以用来了解名字空间内所有服务账户的 API 访问级别。
</td>
</tr>
<tr>
<td><b>view</b></td>
<!-- 
<td>None</td>
-->
<td>无</td>
<td>
<!-- 
Allows read-only access to see most objects in a namespace.
It does not allow viewing roles or rolebindings.
-->
允许对名字空间的大多数对象有只读权限。
它不允许查看角色或角色绑定。
<!--
This role does not allow viewing Secrets, since reading
the contents of Secrets enables access to ServiceAccount credentials
in the namespace, which would allow API access as any ServiceAccount
in the namespace (a form of privilege escalation). 
-->
<p>此角色不允许查看 Secrets，因为读取 Secret 的内容意味着可以访问名字空间中
ServiceAccount 的凭据信息，进而允许利用名字空间中任何 ServiceAccount 的
身份访问 API（这是一种特权提升）。</p>
</td>
</tr>
</tbody>
</table>
<!--
### Core component roles
-->
<h3 id="core-component-roles">核心组件角色  </h3>
<table>
<colgroup><col width="25%"><col width="25%"><col></colgroup>
<thead>
<tr>
<!--
<th>Default ClusterRole</th>
<th>Default ClusterRoleBinding</th>
<th>Description</th>
-->
<th>默认 ClusterRole</th>
<th>默认 ClusterRoleBinding</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><b>system:kube-scheduler</b></td>
<!-- 
<td><b>system:kube-scheduler</b> user</td> 
-->
<td><b>system:kube-scheduler</b> 用户</td>
<td>
<!-- 
Allows access to the resources required by the <a class='glossary-tooltip' title='控制平面组件，负责监视新创建的、未指定运行节点的 Pod，选择节点让 Pod 在上面运行。' data-toggle='tooltip' data-placement='top' href='/docs/reference/generated/kube-scheduler/' target='_blank' aria-label='scheduler'>scheduler</a> component.
-->
允许访问 <a class='glossary-tooltip' title='控制平面组件，负责监视新创建的、未指定运行节点的 Pod，选择节点让 Pod 在上面运行。' data-toggle='tooltip' data-placement='top' href='/docs/reference/generated/kube-scheduler/' target='_blank' aria-label='scheduler'>scheduler</a>
组件所需要的资源。
</td>
</tr>
<tr>
<td><b>system:volume-scheduler</b></td>
<!-- 
<td><b>system:kube-scheduler</b> user</td> 
-->
<td><b>system:kube-scheduler</b> 用户</td>
<td>
<!--
Allows access to the volume resources required by the kube-scheduler component.
-->
允许访问 kube-scheduler 组件所需要的卷资源。
</td>
</tr>
<tr>
<td><b>system:kube-controller-manager</b></td>
<!-- 
<td><b>system:kube-controller-manager</b> user</td> 
-->
<td><b>system:kube-controller-manager</b> 用户</td>
<td>
<!-- 
Allows access to the resources required by the <a class='glossary-tooltip' title='主节点上运行控制器的组件。' data-toggle='tooltip' data-placement='top' href='/docs/reference/generated/kube-controller-manager/' target='_blank' aria-label='controller manager'>controller manager</a> component.
The permissions required by individual controllers are detailed in the <a href="#controller-roles">controller roles</a>.
-->
允许访问<a class='glossary-tooltip' title='主节点上运行控制器的组件。' data-toggle='tooltip' data-placement='top' href='/docs/reference/generated/kube-controller-manager/' target='_blank' aria-label='控制器管理器'>控制器管理器</a>
组件所需要的资源。
各个控制回路所需要的权限在<a href="#controller-roles">控制器角色</a> 详述。
</td>
</tr>
<tr>
<td><b>system:node</b></td>
<!-- 
<td>None</td>
-->
<td>无</td>
<td>
<!--
Allows access to resources required by the kubelet, <b>including read access to all secrets, and write access to all pod status objects</b>.
-->
允许访问 kubelet 所需要的资源，<b>包括对所有 Secret 的读操作和对所有 Pod 状态对象的写操作。</b>
<!--  
You should use the <a href="/docs/reference/access-authn-authz/node/">Node authorizer</a> and 
<a href="/docs/reference/access-authn-authz/admission-controllers/#noderestriction">NodeRestriction admission plugin</a> 
instead of the <tt>system:node</tt> role, and allow granting API access to kubelets based on the Pods scheduled to run on them.
-->
<p>你应该使用 <a href="/zh/docs/reference/access-authn-authz/node/">Node 鉴权组件</a> 和
<a href="/zh/docs/reference/access-authn-authz/admission-controllers/#noderestriction">NodeRestriction 准入插件</a>
而不是 <tt>system:node</tt> 角色。同时基于 kubelet 上调度执行的 Pod 来授权
kubelet 对 API 的访问。</p>
<!--  
The <tt>system:node</tt> role only exists for compatibility with Kubernetes clusters upgraded from versions prior to v1.8.
-->
<p><tt>system:node</tt> 角色的意义仅是为了与从 v1.8 之前版本升级而来的集群兼容。</p>
</td>
</tr>
<tr>
<td><b>system:node-proxier</b></td>
<!-- <td><b>system:kube-proxy</b> user</td> -->
<td><b>system:kube-proxy</b> 用户</td>
<!-- td>Allows access to the resources required by the <a class='glossary-tooltip' title='kube-proxy 是集群中每个节点上运行的网络代理。' data-toggle='tooltip' data-placement='top' href='/zh/docs/reference/command-line-tools-reference/kube-proxy/' target='_blank' aria-label='kube-proxy'>kube-proxy</a> component.</td-->
<td>允许访问 <a class='glossary-tooltip' title='kube-proxy 是集群中每个节点上运行的网络代理。' data-toggle='tooltip' data-placement='top' href='/zh/docs/reference/command-line-tools-reference/kube-proxy/' target='_blank' aria-label='kube-proxy'>kube-proxy</a>
组件所需要的资源。</td>
</tr>
</tbody>
</table>
<!--
### Other component roles
-->
<h3 id="other-component-roles">其他组件角色   </h3>
<table>
<colgroup><col width="25%"><col width="25%"><col></colgroup>
<thead>
<tr>
<!-- 
<th>Default ClusterRole</th>
<th>Default ClusterRoleBinding</th>
<th>Description</th> 
-->
<th>默认 ClusterRole</th>
<th>默认 ClusterRoleBinding</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><b>system:auth-delegator</b></td>
<!-- 
<td>None</td> 
-->
<td>无</td>
<td>
<!-- 
Allows delegated authentication and authorization checks.
This is commonly used by add-on API servers for unified authentication and authorization.
-->
允许将身份认证和鉴权检查操作外包出去。
这种角色通常用在插件式 API 服务器上，以实现统一的身份认证和鉴权。
</td>
</tr>
<tr>
<td><b>system:heapster</b></td>
<!-- 
<td>None</td> 
-->
<td>无</td>
<td>
<!--
Role for the <a href="https://github.com/kubernetes/heapster">Heapster</a> component (deprecated).
-->
为 <a href="https://github.com/kubernetes/heapster">Heapster</a> 组件（已弃用）定义的角色。
</td>
</tr>
<tr>
<td><b>system:kube-aggregator</b></td>
<!-- 
<td>None</td> 
-->
<td>无</td>
<!-- td>Role for the <a href="https://github.com/kubernetes/kube-aggregator">kube-aggregator</a> component.</td -->
<td>为 <a href="https://github.com/kubernetes/kube-aggregator">kube-aggregator</a> 组件定义的角色。</td>
</tr>
<tr>
<td><b>system:kube-dns</b></td>
<td>
<!--
<b>kube-dns</b> service account in the <b>kube-system</b> namespace</td 
-->
在 <b>kube-system</b> 名字空间中的 <b>kube-dns</b> 服务账户</td>
<!-- td>Role for the <a href="/docs/concepts/services-networking/dns-pod-service/">kube-dns</a> component.</td -->
<td>为 <a href="/docs/concepts/services-networking/dns-pod-service/">kube-dns</a> 组件定义的角色。
</td>
</tr>
<tr>
<td><b>system:kubelet-api-admin</b></td>
<!-- 
<td>None</td> 
-->
<td>无</td>
<td>
<!-- 
Allows full access to the kubelet API.
-->
允许 kubelet API 的完全访问权限。
</td>
</tr>  
<tr>
<td><b>system:node-bootstrapper</b></td>
<!-- 
<td>None</td> 
-->
<td>无</td>
<td>
<!-- 
Allows access to the resources required to perform
<a href="/docs/reference/command-line-tools-reference/kubelet-tls-bootstrapping/">Kubelet TLS bootstrapping</a>.
-->
允许访问执行
<a href="/docs/reference/command-line-tools-reference/kubelet-tls-bootstrapping/">kubelet TLS 启动引导</a>
所需要的资源。
</td>
</tr>
<tr>
<td><b>system:node-problem-detector</b></td>
<!-- 
<td>None</td> 
-->
<td>无</td>
<td>
<!-- 
Role for the <a href="https://github.com/kubernetes/node-problem-detector">node-problem-detector</a> component.
-->
为 <a href="https://github.com/kubernetes/node-problem-detector">node-problem-detector</a> 组件定义的角色。
</td>
</tr>
<tr>
<td><b>system:persistent-volume-provisioner</b></td>
<!-- 
<td>None</td> 
-->
<td>无</td>
<td>
<!-- 
Allows access to the resources required by most <a href="/docs/concepts/storage/persistent-volumes/#provisioner">dynamic volume provisioners</a>.
-->
允许访问大部分
<a href="/docs/concepts/storage/persistent-volumes/#provisioner">动态卷驱动
</a>
所需要的资源。</td>
</tr>
<tr>
<td><b>system:monitoring</b></td>
<!-- 
<td><b>system:monitoring</b> group</td>
-->
<td><b>system:monitoring</b> 组</td>
<td>
<!--
Allows read access to control-plane monitoring endpoints 
(i.e. <a class='glossary-tooltip' title='提供 Kubernetes API 服务的控制面组件。' data-toggle='tooltip' data-placement='top' href='/zh/docs/reference/command-line-tools-reference/kube-apiserver/' target='_blank' aria-label='kube-apiserver'>kube-apiserver</a> liveness and readiness endpoints 
(<tt>/healthz</tt>, <tt>/livez</tt>, <tt>/readyz</tt>), the individual health-check endpoints 
(<tt>/healthz/*</tt>, <tt>/livez/*</tt>, <tt>/readyz/*</tt>),  and <tt>/metrics</tt>).
 Note that individual health check endpoints and the metric endpoint may expose sensitive information.
-->
允许对控制平面监控端点的读取访问（例如：<a class='glossary-tooltip' title='提供 Kubernetes API 服务的控制面组件。' data-toggle='tooltip' data-placement='top' href='/zh/docs/reference/command-line-tools-reference/kube-apiserver/' target='_blank' aria-label='kube-apiserver'>kube-apiserver</a>
存活和就绪端点（<tt>/healthz</tt>、<tt>/livez</tt>、<tt>/readyz</tt>），
各个健康检查端点（<tt>/healthz/*</tt>、<tt>/livez/*</tt>、<tt>/readyz/*</tt>）和 <tt>/metrics</tt>）。
请注意，各个运行状况检查端点和度量标准端点可能会公开敏感信息。
</td>
</tr>
</tbody>
</table>
<!--
### Roles for built-in controllers {#controller-roles}

The Kubernetes <a class='glossary-tooltip' title='主节点上运行控制器的组件。' data-toggle='tooltip' data-placement='top' href='/docs/reference/generated/kube-controller-manager/' target='_blank' aria-label='controller manager'>controller manager</a> runs
<a class='glossary-tooltip' title='控制器通过 apiserver 监控集群的公共状态，并致力于将当前状态转变为期望的状态。' data-toggle='tooltip' data-placement='top' href='/zh/docs/concepts/architecture/controller/' target='_blank' aria-label='controllers'>controllers</a> that are built in to the Kubernetes
control plane.
When invoked with `-use-service-account-credentials`, kube-controller-manager starts each controller
using a separate service account.
Corresponding roles exist for each built-in controller, prefixed with `system:controller:`.
If the controller manager is not started with `-use-service-account-credentials`, it runs all control loops
using its own credential, which must be granted all the relevant roles.
These roles include:
-->
<h3 id="controller-roles">内置控制器的角色  </h3>
<p>Kubernetes <a class='glossary-tooltip' title='主节点上运行控制器的组件。' data-toggle='tooltip' data-placement='top' href='/docs/reference/generated/kube-controller-manager/' target='_blank' aria-label='控制器管理器'>控制器管理器</a>
运行内建于 Kubernetes 控制面的<a class='glossary-tooltip' title='控制器通过 apiserver 监控集群的公共状态，并致力于将当前状态转变为期望的状态。' data-toggle='tooltip' data-placement='top' href='/zh/docs/concepts/architecture/controller/' target='_blank' aria-label='控制器'>控制器</a>。
当使用 <code>--use-service-account-credentials</code> 参数启动时, kube-controller-manager
使用单独的服务账户来启动每个控制器。
每个内置控制器都有相应的、前缀为 <code>system:controller:</code> 的角色。
如果控制管理器启动时未设置 <code>--use-service-account-credentials</code>，
它使用自己的身份凭据来运行所有的控制器，该身份必须被授予所有相关的角色。
这些角色包括:</p>
<ul>
<li><code>system:controller:attachdetach-controller</code></li>
<li><code>system:controller:certificate-controller</code></li>
<li><code>system:controller:clusterrole-aggregation-controller</code></li>
<li><code>system:controller:cronjob-controller</code></li>
<li><code>system:controller:daemon-set-controller</code></li>
<li><code>system:controller:deployment-controller</code></li>
<li><code>system:controller:disruption-controller</code></li>
<li><code>system:controller:endpoint-controller</code></li>
<li><code>system:controller:expand-controller</code></li>
<li><code>system:controller:generic-garbage-collector</code></li>
<li><code>system:controller:horizontal-pod-autoscaler</code></li>
<li><code>system:controller:job-controller</code></li>
<li><code>system:controller:namespace-controller</code></li>
<li><code>system:controller:node-controller</code></li>
<li><code>system:controller:persistent-volume-binder</code></li>
<li><code>system:controller:pod-garbage-collector</code></li>
<li><code>system:controller:pv-protection-controller</code></li>
<li><code>system:controller:pvc-protection-controller</code></li>
<li><code>system:controller:replicaset-controller</code></li>
<li><code>system:controller:replication-controller</code></li>
<li><code>system:controller:resourcequota-controller</code></li>
<li><code>system:controller:root-ca-cert-publisher</code></li>
<li><code>system:controller:route-controller</code></li>
<li><code>system:controller:service-account-controller</code></li>
<li><code>system:controller:service-controller</code></li>
<li><code>system:controller:statefulset-controller</code></li>
<li><code>system:controller:ttl-controller</code></li>
</ul>
<!--
## Privilege Escalation Prevention and Bootstrapping

The RBAC API prevents users from escalating privileges by editing roles or role bindings.
Because this is enforced at the API level, it applies even when the RBAC authorizer is not in use.
-->
<h2 id="初始化与预防权限提升">初始化与预防权限提升</h2>
<p>RBAC API 会阻止用户通过编辑角色或者角色绑定来提升权限。
由于这一点是在 API 级别实现的，所以在 RBAC 鉴权组件未启用的状态下依然可以正常工作。</p>
<!--
### Restrictions on role creation or update

You can only create/update a role if at least one of the following things is true:

1. You already have all the permissions contained in the role, at the same scope as the object being modified
(cluster-wide for a ClusterRole, within the same namespace or cluster-wide for a Role).
2. You are granted explicit permission to perform the `escalate` verb on the `roles` or `clusterroles` resource in the `rbac.authorization.k8s.io` API group.
-->
<h3 id="对角色创建或更新的限制">对角色创建或更新的限制</h3>
<p>只有在符合下列条件之一的情况下，你才能创建/更新角色:</p>
<ol>
<li>你已经拥有角色中包含的所有权限，且其作用域与正被修改的对象作用域相同。
（对 ClusterRole 而言意味着集群范围，对 Role 而言意味着相同名字空间或者集群范围）。</li>
<li>你被显式授权在 <code>rbac.authorization.k8s.io</code> API 组中的 <code>roles</code> 或 <code>clusterroles</code> 资源
使用 <code>escalate</code> 动词。</li>
</ol>
<!--
For example, if `user-1` does not have the ability to list Secrets cluster-wide, they cannot create a ClusterRole
containing that permission. To allow a user to create/update roles:

1. Grant them a role that allows them to create/update Role or ClusterRole objects, as desired.
2. Grant them permission to include specific permissions in the roles they create/update:
    * implicitly, by giving them those permissions (if they attempt to create or modify a Role or ClusterRole with permissions they themselves have not been granted, the API request will be forbidden)
    * or explicitly allow specifying any permission in a `Role` or `ClusterRole` by giving them permission to perform the `escalate` verb on `roles` or `clusterroles` resources in the `rbac.authorization.k8s.io` API group
-->
<p>例如，如果 <code>user-1</code> 没有列举集群范围所有 Secret 的权限，他将不能创建包含该权限的 ClusterRole。
若要允许用户创建/更新角色：</p>
<ol>
<li>根据需要赋予他们一个角色，允许他们根据需要创建/更新 Role 或者 ClusterRole 对象。</li>
<li>授予他们在所创建/更新角色中包含特殊权限的权限:
<ul>
<li>隐式地为他们授权（如果它们试图创建或者更改 Role 或 ClusterRole 的权限，
但自身没有被授予相应权限，API 请求将被禁止）。</li>
<li>通过允许他们在 Role 或 ClusterRole 资源上执行 <code>escalate</code> 动作显式完成授权。
这里的 <code>roles</code> 和 <code>clusterroles</code> 资源包含在 <code>rbac.authorization.k8s.io</code> API 组中。</li>
</ul>
</li>
</ol>
<!--
### Restrictions on role binding creation or update

You can only create/update a role binding if you already have all the permissions contained in the referenced role
(at the same scope as the role binding) *or* if you have been authorized to perform the `bind` verb on the referenced role.
For example, if `user-1` does not have the ability to list Secrets cluster-wide, they cannot create a ClusterRoleBinding
to a role that grants that permission. To allow a user to create/update role bindings:
-->
<h3 id="对角色绑定创建或更新的限制">对角色绑定创建或更新的限制</h3>
<p>只有你已经具有了所引用的角色中包含的全部权限时，或者你被授权在所引用的角色上执行 <code>bind</code>
动词时，你才可以创建或更新角色绑定。这里的权限与角色绑定的作用域相同。
例如，如果用户 <code>user-1</code> 没有列举集群范围所有 Secret 的能力，则他不可以创建
ClusterRoleBinding 引用授予该许可权限的角色。
如要允许用户创建或更新角色绑定：</p>
<!--
1. Grant them a role that allows them to create/update RoleBinding or ClusterRoleBinding objects, as desired.
2. Grant them permissions needed to bind a particular role:
    * implicitly, by giving them the permissions contained in the role.
    * explicitly, by giving them permission to perform the `bind` verb on the particular Role (or ClusterRole).

For example, this ClusterRole and RoleBinding would allow `user-1` to grant other users the `admin`, `edit`, and `view` roles in the namespace `user-1-namespace`:
-->
<ol>
<li>赋予他们一个角色，使得他们能够根据需要创建或更新 RoleBinding 或 ClusterRoleBinding
对象。</li>
<li>授予他们绑定某特定角色所需要的许可权限：
<ul>
<li>隐式授权下，可以将角色中包含的许可权限授予他们；</li>
<li>显式授权下，可以授权他们在特定 Role （或 ClusterRole）上执行 <code>bind</code> 动词的权限。</li>
</ul>
</li>
</ol>
<p>例如，下面的 ClusterRole 和 RoleBinding 将允许用户 <code>user-1</code> 把名字空间 <code>user-1-namespace</code>
中的 <code>admin</code>、<code>edit</code> 和 <code>view</code> 角色赋予其他用户：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>rbac.authorization.k8s.io/v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>ClusterRole<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>role-grantor<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">rules</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">apiGroups</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;rbac.authorization.k8s.io&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">resources</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;rolebindings&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">verbs</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;create&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">apiGroups</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;rbac.authorization.k8s.io&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">resources</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;clusterroles&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">verbs</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;bind&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#080;font-style:italic"># 忽略 resourceNames 意味着允许绑定任何 ClusterRole</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">resourceNames</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;admin&#34;</span>,<span style="color:#b44">&#34;edit&#34;</span>,<span style="color:#b44">&#34;view&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#00f;font-weight:bold">---</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>rbac.authorization.k8s.io/v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>RoleBinding<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>role-grantor-binding<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">namespace</span>:<span style="color:#bbb"> </span>user-1-namespace<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">roleRef</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">apiGroup</span>:<span style="color:#bbb"> </span>rbac.authorization.k8s.io<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>ClusterRole<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>role-grantor<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">subjects</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">apiGroup</span>:<span style="color:#bbb"> </span>rbac.authorization.k8s.io<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>User<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>user-1<span style="color:#bbb">
</span></code></pre></div><!--
When bootstrapping the first roles and role bindings, it is necessary for the initial user to grant permissions they do not yet have.
To bootstrap initial roles and role bindings:

* Use a credential with the `system:masters` group, which is bound to the `cluster-admin` super-user role by the default bindings.
* If your API server runs with the insecure port enabled (`-insecure-port`), you can also make API calls via that port, which does not enforce authentication or authorization.
-->
<p>当启动引导第一个角色和角色绑定时，需要为初始用户授予他们尚未拥有的权限。
对初始角色和角色绑定进行初始化时需要：</p>
<ul>
<li>使用用户组为 <code>system:masters</code> 的凭据，该用户组由默认绑定关联到 <code>cluster-admin</code>
这个超级用户角色。</li>
<li>如果你的 API 服务器启动时启用了不安全端口（使用 <code>--insecure-port</code>）, 你也可以通过
该端口调用 API ，这样的操作会绕过身份验证或鉴权。</li>
</ul>
<!--
## Command-line Utilities

### `kubectl create role`

Creates a `Role` object defining permissions within a single namespace. Examples:

* Create a Role named "pod-reader" that allows users to perform `get`, `watch` and `list` on pods:
-->
<h2 id="一些命令行工具">一些命令行工具</h2>
<h3 id="kubectl-create-role"><code>kubectl create role</code></h3>
<p>创建 Role 对象，定义在某一名字空间中的权限。例如:</p>
<ul>
<li>
<p>创建名称为 &quot;pod-reader&quot; 的 Role 对象，允许用户对 Pods 执行 <code>get</code>、<code>watch</code> 和 <code>list</code> 操作：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl create role pod-reader --verb<span style="color:#666">=</span>get --verb<span style="color:#666">=</span>list --verb<span style="color:#666">=</span>watch --resource<span style="color:#666">=</span>pods
</code></pre></div></li>
</ul>
<!--
* Create a Role named "pod-reader" with resourceNames specified:
-->
<ul>
<li>
<p>创建名称为 &quot;pod-reader&quot; 的 Role 对象并指定 <code>resourceNames</code>：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl create role pod-reader --verb<span style="color:#666">=</span>get --resource<span style="color:#666">=</span>pods --resource-name<span style="color:#666">=</span>readablepod --resource-name<span style="color:#666">=</span>anotherpod
</code></pre></div></li>
</ul>
<!--
* Create a `Role` named "foo" with apiGroups specified:
-->
<ul>
<li>
<p>创建名为 &quot;foo&quot; 的 Role 对象并指定 <code>apiGroups</code>：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl create role foo --verb<span style="color:#666">=</span>get,list,watch --resource<span style="color:#666">=</span>replicasets.apps
</code></pre></div></li>
</ul>
<!--
* Create a Role named "foo" with subresource permissions:
-->
<ul>
<li>
<p>创建名为 &quot;foo&quot; 的 Role 对象并指定子资源权限:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl create role foo --verb<span style="color:#666">=</span>get,list,watch --resource<span style="color:#666">=</span>pods,pods/status
</code></pre></div></li>
</ul>
<!--
* Create a Role named "my-component-lease-holder" with permissions to get/update a resource with a specific name:
-->
<ul>
<li>
<p>创建名为 &quot;my-component-lease-holder&quot; 的 Role 对象，使其具有对特定名称的
资源执行 get/update 的权限：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl create role my-component-lease-holder --verb<span style="color:#666">=</span>get,list,watch,update --resource<span style="color:#666">=</span>lease --resource-name<span style="color:#666">=</span>my-component
</code></pre></div></li>
</ul>
<h3 id="kubectl-create-clusterrole"><code>kubectl create clusterrole</code></h3>
<!--
Creates a ClusterRole. Examples:

* Create a ClusterRole named "pod-reader" that allows user to perform `get`, `watch` and `list` on pods:
-->
<p>创建 ClusterRole 对象。例如：</p>
<ul>
<li>
<p>创建名称为 &quot;pod-reader&quot; 的 ClusterRole<code>对象，允许用户对 Pods 对象执行 </code>get<code>、</code>watch<code>和</code>list` 操作：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl create clusterrole pod-reader --verb<span style="color:#666">=</span>get,list,watch --resource<span style="color:#666">=</span>pods
</code></pre></div></li>
</ul>
<!--
* Create a ClusterRole named "pod-reader" with resourceNames specified:
-->
<ul>
<li>
<p>创建名为 &quot;pod-reader&quot; 的 ClusterRole 对象并指定 <code>resourceNames</code>：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl create clusterrole pod-reader --verb<span style="color:#666">=</span>get --resource<span style="color:#666">=</span>pods --resource-name<span style="color:#666">=</span>readablepod --resource-name<span style="color:#666">=</span>anotherpod
</code></pre></div></li>
</ul>
<!--
* Create a ClusterRole named "foo" with apiGroups specified:
-->
<ul>
<li>
<p>创建名为 &quot;foo&quot; 的 ClusterRole 对象并指定 <code>apiGroups</code>：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl create clusterrole foo --verb<span style="color:#666">=</span>get,list,watch --resource<span style="color:#666">=</span>replicasets.apps
</code></pre></div></li>
</ul>
<!--
* Create a ClusterRole named "foo" with subresource permissions:
-->
<ul>
<li>
<p>创建名为 &quot;foo&quot; 的 ClusterRole 对象并指定子资源:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl create clusterrole foo --verb<span style="color:#666">=</span>get,list,watch --resource<span style="color:#666">=</span>pods,pods/status
</code></pre></div></li>
</ul>
<!--
* Create a ClusterRole named "foo" with nonResourceURL specified:
-->
<ul>
<li>
<p>创建名为 &quot;foo&quot; 的 ClusterRole 对象并指定 <code>nonResourceURL</code>：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl create clusterrole <span style="color:#b44">&#34;foo&#34;</span> --verb<span style="color:#666">=</span>get --non-resource-url<span style="color:#666">=</span>/logs/*
</code></pre></div></li>
</ul>
<!--
* Create a ClusterRole named "monitoring" with an aggregationRule specified:
-->
<ul>
<li>
<p>创建名为 &quot;monitoring&quot; 的 ClusterRole 对象并指定 <code>aggregationRule</code>：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl create clusterrole monitoring --aggregation-rule<span style="color:#666">=</span><span style="color:#b44">&#34;rbac.example.com/aggregate-to-monitoring=true&#34;</span>
</code></pre></div></li>
</ul>
<h3 id="kubectl-create-rolebinding"><code>kubectl create rolebinding</code></h3>
<!--
Grants a Role or ClusterRole within a specific namespace. Examples:

* Within the namespace "acme", grant the permissions in the "admin" ClusterRole to a user named "bob":
-->
<p>在特定的名字空间中对 <code>Role</code> 或 <code>ClusterRole</code> 授权。例如：</p>
<ul>
<li>
<p>在名字空间 &quot;acme&quot; 中，将名为 <code>admin</code> 的 ClusterRole 中的权限授予名称 &quot;bob&quot; 的用户:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl create rolebinding bob-admin-binding --clusterrole<span style="color:#666">=</span>admin --user<span style="color:#666">=</span>bob --namespace<span style="color:#666">=</span>acme
</code></pre></div></li>
</ul>
<!--
* Within the namespace "acme", grant the permissions in the "view" ClusterRole to the service account in the namespace "acme" named "myapp":
-->
<ul>
<li>
<p>在名字空间 &quot;acme&quot; 中，将名为 <code>view</code> 的 ClusterRole 中的权限授予名字空间 &quot;acme&quot;
中名为 <code>myapp</code> 的服务账户：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl create rolebinding myapp-view-binding --clusterrole<span style="color:#666">=</span>view --serviceaccount<span style="color:#666">=</span>acme:myapp --namespace<span style="color:#666">=</span>acme
</code></pre></div></li>
</ul>
<!--
* Within the namespace "acme", grant the permissions in the "view" ClusterRole to a service account in the namespace "myappnamespace" named "myapp":
-->
<ul>
<li>
<p>在名字空间 &quot;acme&quot; 中，将名为 <code>view</code> 的 ClusterRole 对象中的权限授予名字空间
&quot;myappnamespace&quot; 中名称为 <code>myapp</code> 的服务账户：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl create rolebinding myappnamespace-myapp-view-binding --clusterrole<span style="color:#666">=</span>view --serviceaccount<span style="color:#666">=</span>myappnamespace:myapp --namespace<span style="color:#666">=</span>acme
</code></pre></div></li>
</ul>
<h3 id="kubectl-create-clusterrolebinding"><code>kubectl create clusterrolebinding</code></h3>
<!--
Grants a ClusterRole across the entire cluster (all namespaces). Examples:

* Across the entire cluster, grant the permissions in the "cluster-admin" ClusterRole to a user named "root":
-->
<p>在整个集群（所有名字空间）中用 ClusterRole 授权。例如：</p>
<ul>
<li>
<p>在整个集群范围，将名为 <code>cluster-admin</code> 的 ClusterRole 中定义的权限授予名为
&quot;root&quot; 用户：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl create clusterrolebinding root-cluster-admin-binding --clusterrole<span style="color:#666">=</span>cluster-admin --user<span style="color:#666">=</span>root
</code></pre></div></li>
</ul>
<!--
* Across the entire cluster, grant the permissions in the "system:node-proxier" ClusterRole to a user named "system:kube-proxy":
-->
<ul>
<li>
<p>在整个集群范围内，将名为 <code>system:node-proxier</code> 的 ClusterRole 的权限授予名为
&quot;system:kube-proxy&quot; 的用户：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl create clusterrolebinding kube-proxy-binding --clusterrole<span style="color:#666">=</span>system:node-proxier --user<span style="color:#666">=</span>system:kube-proxy
</code></pre></div></li>
</ul>
<!--
* Across the entire cluster, grant the permissions in the "view" ClusterRole to a service account named "myapp" in the namespace "acme":
-->
<ul>
<li>
<p>在整个集群范围内，将名为 <code>view</code> 的 ClusterRole 中定义的权限授予 &quot;acme&quot; 名字空间中
名为 &quot;myapp&quot; 的服务账户：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl create clusterrolebinding myapp-view-binding --clusterrole<span style="color:#666">=</span>view --serviceaccount<span style="color:#666">=</span>acme:myapp
</code></pre></div></li>
</ul>
<h3 id="kubectl-auth-reconcile"><code>kubectl auth reconcile</code></h3>
<!--
Creates or updates `rbac.authorization.k8s.io/v1` API objects from a manifest file.

Missing objects are created, and the containing namespace is created for namespaced objects, if required.

Existing roles are updated to include the permissions in the input objects,
and remove extra permissions if `--remove-extra-permissions` is specified.

Existing bindings are updated to include the subjects in the input objects,
and remove extra subjects if `--remove-extra-subjects` is specified.

Examples:
-->
<p>使用清单文件来创建或者更新 <code>rbac.authorization.k8s.io/v1</code> API 对象。</p>
<p>尚不存在的对象会被创建，如果对应的名字空间也不存在，必要的话也会被创建。
已经存在的角色会被更新，使之包含输入对象中所给的权限。如果指定了
<code>--remove-extra-permissions</code>，可以删除额外的权限。</p>
<p>已经存在的绑定也会被更新，使之包含输入对象中所给的主体。如果指定了
<code>--remove-extra-permissions</code>，则可以删除多余的主体。</p>
<p>例如:</p>
<!--
* Test applying a manifest file of RBAC objects, displaying changes that would be made:
-->
<ul>
<li>
<p>测试应用 RBAC 对象的清单文件，显示将要进行的更改：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl auth reconcile -f my-rbac-rules.yaml --dry-run
</code></pre></div></li>
</ul>
<!--
* Apply a manifest file of RBAC objects, preserving any extra permissions (in roles) and any extra subjects (in bindings):
-->
<ul>
<li>
<p>应用 RBAC 对象的清单文件，保留角色中的额外权限和绑定中的其他主体：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl auth reconcile -f my-rbac-rules.yaml
</code></pre></div></li>
</ul>
<!--
* Apply a manifest file of RBAC objects, removing any extra permissions (in roles) and any extra subjects (in bindings):
-->
<ul>
<li>
<p>应用 RBAC 对象的清单文件, 删除角色中的额外权限和绑定中的其他主体：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl auth reconcile -f my-rbac-rules.yaml --remove-extra-subjects --remove-extra-permissions
</code></pre></div></li>
</ul>
<!--
See the CLI help for detailed usage.
-->
<p>查看 CLI 帮助获取详细的用法。</p>
<!--
## ServiceAccount Permissions

Default RBAC policies grant scoped permissions to control-plane components, nodes,
and controllers, but grant *no permissions* to service accounts outside the `kube-system` namespace
(beyond discovery permissions given to all authenticated users).

This allows you to grant particular roles to particular service accounts as needed.
Fine-grained role bindings provide greater security, but require more effort to administrate.
Broader grants can give unnecessary (and potentially escalating) API access to service accounts, but are easier to administrate.
-->
<h2 id="service-account-permissions">服务账户权限  </h2>
<p>默认的 RBAC 策略为控制面组件、节点和控制器授予权限。
但是不会对 <code>kube-system</code> 名字空间之外的服务账户授予权限。
（除了授予所有已认证用户的发现权限）</p>
<p>这使得你可以根据需要向特定服务账户授予特定权限。
细粒度的角色绑定可带来更好的安全性，但需要更多精力管理。
粗粒度的授权可能导致服务账户被授予不必要的 API 访问权限（甚至导致潜在的权限提升），
但更易于管理。</p>
<!--
In order from most secure to least secure, the approaches are:

1. Grant a role to an application-specific service account (best practice)
-->
<p>按从最安全到最不安全的顺序，存在以下方法：</p>
<ol>
<li>
<p>为特定应用的服务账户授予角色（最佳实践）</p>
<!--
This requires the application to specify a `serviceAccountName` in its pod spec,
and for the service account to be created (via the API, application manifest, `kubectl create serviceaccount`, etc.).

For example, grant read-only permission within "my-namespace" to the "my-sa" service account:
-->
<p>这要求应用在其 Pod 规约中指定 <code>serviceAccountName</code>，
并额外创建服务账户（包括通过 API、应用程序清单、<code>kubectl create serviceaccount</code> 等）。</p>
<p>例如，在名字空间 &quot;my-namespace&quot; 中授予服务账户 &quot;my-sa&quot; 只读权限：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl create rolebinding my-sa-view <span style="color:#b62;font-weight:bold">\
</span><span style="color:#b62;font-weight:bold"></span>  --clusterrole<span style="color:#666">=</span>view <span style="color:#b62;font-weight:bold">\
</span><span style="color:#b62;font-weight:bold"></span>  --serviceaccount<span style="color:#666">=</span>my-namespace:my-sa <span style="color:#b62;font-weight:bold">\
</span><span style="color:#b62;font-weight:bold"></span>  --namespace<span style="color:#666">=</span>my-namespace
</code></pre></div></li>
</ol>
<!--
2. Grant a role to the "default" service account in a namespace
-->
<ol start="2">
<li>
<p>将角色授予某名字空间中的 &quot;default&quot; 服务账户</p>
<!--
If an application does not specify a `serviceAccountName`, it uses the "default" service account.

<blockquote class="note callout">
  <div><strong>说明：</strong> Permissions given to the &quot;default&quot; service account are available to any pod
in the namespace that does not specify a <code>serviceAccountName</code>.</div>
</blockquote>

For example, grant read-only permission within "my-namespace" to the "default" service account:
-->
<p>如果某应用没有指定 <code>serviceAccountName</code>，那么它将使用 &quot;default&quot; 服务账户。</p>
<blockquote class="note callout">
  <div><strong>说明：</strong> &quot;default&quot; 服务账户所具有的权限会被授予给名字空间中所有未指定
<code>serviceAccountName</code> 的 Pod。</div>
</blockquote>
<p>例如，在名字空间 &quot;my-namespace&quot; 中授予服务账户 &quot;default&quot; 只读权限：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl create rolebinding default-view <span style="color:#b62;font-weight:bold">\
</span><span style="color:#b62;font-weight:bold"></span>  --clusterrole<span style="color:#666">=</span>view <span style="color:#b62;font-weight:bold">\
</span><span style="color:#b62;font-weight:bold"></span>  --serviceaccount<span style="color:#666">=</span>my-namespace:default <span style="color:#b62;font-weight:bold">\
</span><span style="color:#b62;font-weight:bold"></span>  --namespace<span style="color:#666">=</span>my-namespace
</code></pre></div><!--
Many [add-ons](/docs/concepts/cluster-administration/addons/) run as the
"default" service account in the `kube-system` namespace.
To allow those add-ons to run with super-user access, grant cluster-admin
permissions to the "default" service account in the `kube-system` namespace.

<blockquote class="note callout">
  <div><strong>说明：</strong> Enabling this means the <code>kube-system</code> namespace contains Secrets
that grant super-user access to the API.</div>
</blockquote>
-->
<p>许多<a href="/zh/docs/concepts/cluster-administration/addons/">插件组件</a> 在 <code>kube-system</code>
名字空间以 &quot;default&quot; 服务账户运行。
要允许这些插件组件以超级用户权限运行，需要将集群的 <code>cluster-admin</code> 权限授予
<code>kube-system</code> 名字空间中的 &quot;default&quot; 服务账户。</p>
<blockquote class="note callout">
  <div><strong>说明：</strong> 启用这一配置意味着在 <code>kube-system</code> 名字空间中包含以超级用户账号来访问 API
的 Secrets。</div>
</blockquote>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl create clusterrolebinding add-on-cluster-admin <span style="color:#b62;font-weight:bold">\
</span><span style="color:#b62;font-weight:bold"></span>  --clusterrole<span style="color:#666">=</span>cluster-admin <span style="color:#b62;font-weight:bold">\
</span><span style="color:#b62;font-weight:bold"></span>  --serviceaccount<span style="color:#666">=</span>kube-system:default
</code></pre></div></li>
</ol>
<!--
3. Grant a role to all service accounts in a namespace

   If you want all applications in a namespace to have a role, no matter what service account they use,
   you can grant a role to the service account group for that namespace.

   For example, grant read-only permission within "my-namespace" to all service accounts in that namespace:
-->
<ol start="3">
<li>
<p>将角色授予名字空间中所有服务账户</p>
<p>如果你想要名字空间中所有应用都具有某角色，无论它们使用的什么服务账户，
可以将角色授予该名字空间的服务账户组。</p>
<p>例如，在名字空间 &quot;my-namespace&quot; 中的只读权限授予该名字空间中的所有服务账户：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl create rolebinding serviceaccounts-view <span style="color:#b62;font-weight:bold">\
</span><span style="color:#b62;font-weight:bold"></span>  --clusterrole<span style="color:#666">=</span>view <span style="color:#b62;font-weight:bold">\
</span><span style="color:#b62;font-weight:bold"></span>  --group<span style="color:#666">=</span>system:serviceaccounts:my-namespace <span style="color:#b62;font-weight:bold">\
</span><span style="color:#b62;font-weight:bold"></span>  --namespace<span style="color:#666">=</span>my-namespace
</code></pre></div></li>
</ol>
<!--
4. Grant a limited role to all service accounts cluster-wide (discouraged)

   If you don't want to manage permissions per-namespace, you can grant a cluster-wide role to all service accounts.

   For example, grant read-only permission across all namespaces to all service accounts in the cluster:
-->
<ol start="4">
<li>
<p>在集群范围内为所有服务账户授予一个受限角色（不鼓励）</p>
<p>如果你不想管理每一个名字空间的权限，你可以向所有的服务账户授予集群范围的角色。</p>
<p>例如，为集群范围的所有服务账户授予跨所有名字空间的只读权限：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl create clusterrolebinding serviceaccounts-view <span style="color:#b62;font-weight:bold">\
</span><span style="color:#b62;font-weight:bold"></span>  --clusterrole<span style="color:#666">=</span>view <span style="color:#b62;font-weight:bold">\
</span><span style="color:#b62;font-weight:bold"></span>  --group<span style="color:#666">=</span>system:serviceaccounts
</code></pre></div></li>
</ol>
<!--
5. Grant super-user access to all service accounts cluster-wide (strongly discouraged)

   If you don't care about partitioning permissions at all, you can grant super-user access to all service accounts.

   <blockquote class="warning callout">
  <div><strong>警告：</strong> This allows any application full access to your cluster, and also grants
any user with read access to Secrets (or the ability to create any pod)
full access to your cluster.</div>
</blockquote>

-->
<ol start="5">
<li>
<p>授予超级用户访问权限给集群范围内的所有服务帐户（强烈不鼓励）</p>
<p>如果你不关心如何区分权限，你可以将超级用户访问权限授予所有服务账户。</p>
<blockquote class="warning callout">
  <div><strong>警告：</strong> 这样做会允许所有应用都对你的集群拥有完全的访问权限，并将允许所有能够读取
Secret（或创建 Pod）的用户对你的集群有完全的访问权限。</div>
</blockquote>

<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl create clusterrolebinding serviceaccounts-cluster-admin <span style="color:#b62;font-weight:bold">\
</span><span style="color:#b62;font-weight:bold"></span>  --clusterrole<span style="color:#666">=</span>cluster-admin <span style="color:#b62;font-weight:bold">\
</span><span style="color:#b62;font-weight:bold"></span>  --group<span style="color:#666">=</span>system:serviceaccounts
</code></pre></div></li>
</ol>
<!--
## Upgrading from ABAC

Clusters that originally ran older Kubernetes versions often used
permissive ABAC policies, including granting full API access to all
service accounts.

Default RBAC policies grant scoped permissions to control-plane components, nodes,
and controllers, but grant *no permissions* to service accounts outside the `kube-system` namespace
(beyond discovery permissions given to all authenticated users).

While far more secure, this can be disruptive to existing workloads expecting to automatically receive API permissions.
Here are two approaches for managing this transition:
-->
<h2 id="从-abac-升级">从 ABAC 升级</h2>
<p>原来运行较老版本 Kubernetes 的集群通常会使用限制宽松的 ABAC 策略，
包括授予所有服务帐户全权访问 API 的能力。</p>
<p>默认的 RBAC 策略为控制面组件、节点和控制器等授予有限的权限，但不会为
<code>kube-system</code> 名字空间外的服务账户授权
（除了授予所有认证用户的发现权限之外）。</p>
<p>这样做虽然安全得多，但可能会干扰期望自动获得 API 权限的现有工作负载。
这里有两种方法来完成这种转换:</p>
<!--
### Parallel Authorizers

Run both the RBAC and ABAC authorizers, and specify a policy file that contains
[the legacy ABAC policy](/docs/reference/access-authn-authz/abac/#policy-file-format):
-->
<h3 id="parallel-authorizers">并行鉴权   </h3>
<p>同时运行 RBAC 和 ABAC 鉴权模式, 并指定包含
<a href="/zh/docs/reference/access-authn-authz/abac/#policy-file-format">现有的 ABAC 策略</a>
的策略文件：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">--authorization-mode<span style="color:#666">=</span>RBAC,ABAC --authorization-policy-file<span style="color:#666">=</span>mypolicy.json
</code></pre></div><!--
To explain that first command line option in detail: if earlier authorizers, such as Node,
deny a request, then the RBAC authorizer attempts to authorize the API request. If RBAC
also denies that API request, the ABAC authorizer is then run. This means that any request
allowed by *either* the RBAC or ABAC policies is allowed.
-->
<p>关于命令行中的第一个选项：如果早期的鉴权组件，例如 Node，拒绝了某个请求，则
RBAC 鉴权组件尝试对该 API 请求鉴权。如果 RBAC 也拒绝了该 API 请求，则运行 ABAC
鉴权组件。这意味着被 RBAC 或 ABAC 策略所允许的任何请求都是被允许的请求。</p>
<!--
When the apiserver is run with a log level of 5 or higher for the RBAC component
(`--vmodule=rbac*=5` or `--v=5`), you can see RBAC details in the apiserver log
(prefixed with `RBAC:`).
You can use that information to determine which roles need to be granted to which users, groups, or service accounts.
-->
<p>如果 API 服务器启动时，RBAC 组件的日志级别为 5 或更高（<code>--vmodule=rbac*=5</code> 或 <code>--v=5</code>），
你可以在 API 服务器的日志中看到 RBAC 的细节 （前缀 <code>RBAC:</code>）
你可以使用这些信息来确定需要将哪些角色授予哪些用户、组或服务帐户。</p>
<!--
Once you have [granted roles to service accounts](#service-account-permissions) and workloads
are running with no RBAC denial messages in the server logs, you can remove the ABAC authorizer.
-->
<p>一旦你<a href="#service-account-permissions">将角色授予服务账户</a> ，工作负载运行时
在服务器日志中没有出现 RBAC 拒绝消息，就可以删除 ABAC 鉴权器。</p>
<!--
## Permissive RBAC Permissions

You can replicate a permissive policy using RBAC role bindings.
-->
<h2 id="permissive-rbac-permissions">宽松的 RBAC 权限  </h2>
<p>你可以使用 RBAC 角色绑定在多个场合使用宽松的策略。</p>
<blockquote class="warning callout">
  <div><strong>警告：</strong> <!--
The following policy allows **ALL** service accounts to act as cluster administrators.
Any application running in a container receives service account credentials automatically,
and could perform any action against the API, including viewing secrets and modifying permissions.
This is not a recommended policy.
-->
<p>下面的策略允许 <strong>所有</strong> 服务帐户充当集群管理员。
容器中运行的所有应用程序都会自动收到服务帐户的凭据，可以对 API 执行任何操作，
包括查看 Secrets 和修改权限。这一策略是不被推荐的。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl create clusterrolebinding permissive-binding <span style="color:#b62;font-weight:bold">\
</span><span style="color:#b62;font-weight:bold"></span>  --clusterrole<span style="color:#666">=</span>cluster-admin <span style="color:#b62;font-weight:bold">\
</span><span style="color:#b62;font-weight:bold"></span>  --user<span style="color:#666">=</span>admin <span style="color:#b62;font-weight:bold">\
</span><span style="color:#b62;font-weight:bold"></span>  --user<span style="color:#666">=</span>kubelet <span style="color:#b62;font-weight:bold">\
</span><span style="color:#b62;font-weight:bold"></span>  --group<span style="color:#666">=</span>system:serviceaccounts
</code></pre></div></div>
</blockquote>

<!--
After you have transitioned to use RBAC, you should adjust the access controls
for your cluster to ensure that these meet your information security needs.
-->
<p>在你完成到 RBAC 的迁移后，应该调整集群的访问控制，确保相关的策略满足你的
信息安全需求。</p>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-9cbb97d4d9f08d67931a1baae4e6519c">4.9 - 使用 Node 鉴权</h1>
    
	<!--
---
reviewers:
- timstclair
- deads2k
- liggitt
- ericchiang
title: Using Node Authorization
content_type: concept
weight: 90
---
-->
<!-- overview -->
<p>节点鉴权是一种特殊用途的鉴权模式，专门对 kubelet 发出的 API 请求进行鉴权。</p>
<!--
Node authorization is a special-purpose authorization mode that specifically authorizes API requests made by kubelets.
-->
<!-- body -->
<h2 id="概述">概述</h2>
<!--
## Overview
-->
<p>节点鉴权器允许 kubelet 执行 API 操作。包括：</p>
<!--
The Node authorizer allows a kubelet to perform API operations. This includes:
-->
<p>读取操作：</p>
<!--
Read operations:
-->
<ul>
<li>services</li>
<li>endpoints</li>
<li>nodes</li>
<li>pods</li>
<li>secrets、configmaps、pvcs 以及绑定到 kubelet 节点的与 pod 相关的持久卷</li>
</ul>
<!--
* services
* endpoints
* nodes
* pods
* secrets, configmaps, persistent volume claims and persistent volumes related to pods bound to the kubelet's node
-->
<p>写入操作：</p>
<!--
Write operations:
-->
<ul>
<li>节点和节点状态（启用 <code>NodeRestriction</code> 准入插件以限制 kubelet 只能修改自己的节点）</li>
<li>Pod 和 Pod 状态 (启用 <code>NodeRestriction</code> 准入插件以限制 kubelet 只能修改绑定到自身的 Pod)</li>
<li>事件</li>
</ul>
<!--
* nodes and node status (enable the `NodeRestriction` admission plugin to limit a kubelet to modify its own node)
* pods and pod status (enable the `NodeRestriction` admission plugin to limit a kubelet to modify pods bound to itself)
* events
-->
<p>鉴权相关操作：</p>
<!--
Auth-related operations:
-->
<ul>
<li>对于基于 TLS 的启动引导过程时使用的 certificationsigningrequests API 的读/写权限</li>
<li>为委派的身份验证/授权检查创建 tokenreviews 和 subjectaccessreviews 的能力</li>
</ul>
<!--
* read/write access to the certificationsigningrequests API for TLS bootstrapping
* the ability to create tokenreviews and subjectaccessreviews for delegated authentication/authorization checks
-->
<p>在将来的版本中，节点鉴权器可能会添加或删除权限，以确保 kubelet 具有正确操作所需的最小权限集。</p>
<!--
In future releases, the node authorizer may add or remove permissions to ensure kubelets
have the minimal set of permissions required to operate correctly.
-->
<p>为了获得节点鉴权器的授权，kubelet 必须使用一个凭证以表示它在 <code>system:nodes</code> 组中，用户名为 <code>system:node:&lt;nodeName&gt;</code>。
上述的组名和用户名格式要与 <a href="/zh/docs/reference/command-line-tools-reference/kubelet-tls-bootstrapping/">kubelet TLS 启动引导</a>过程中为每个 kubelet 创建的标识相匹配。</p>
<!--
In order to be authorized by the Node authorizer, kubelets must use a credential that identifies them as
being in the `system:nodes` group, with a username of `system:node:<nodeName>`.
This group and user name format match the identity created for each kubelet as part of
[kubelet TLS bootstrapping](/docs/reference/command-line-tools-reference/kubelet-tls-bootstrapping/).
-->
<p>要启用节点授权器，请使用 <code>--authorization-mode = Node</code> 启动 apiserver。</p>
<!--
To enable the Node authorizer, start the apiserver with `--authorization-mode=Node`.
-->
<p>要限制 kubelet 具有写入权限的 API 对象，请使用 <code>--enable-admission-plugins=...,NodeRestriction,...</code> 启动 apiserver，从而启用 <a href="/zh/docs/reference/access-authn-authz/admission-controllers#NodeRestriction">NodeRestriction</a> 准入插件。</p>
<!--
To limit the API objects kubelets are able to write, enable the [NodeRestriction](/docs/reference/access-authn-authz/admission-controllers#NodeRestriction) admission plugin by starting the apiserver with `--enable-admission-plugins=...,NodeRestriction,...`
 -->
<h2 id="迁移考虑因素">迁移考虑因素</h2>
<!--
## Migration considerations
-->
<h3 id="在-system-nodes-组之外的-kubelet">在 <code>system:nodes</code> 组之外的 Kubelet</h3>
<!--
### Kubelets outside the `system:nodes` group
-->
<p><code>system:nodes</code> 组之外的 kubelet 不会被 <code>Node</code> 鉴权模式授权，并且需要继续通过当前授权它们的机制来授权。
节点准入插件不会限制来自这些 kubelet 的请求。</p>
<!--
Kubelets outside the `system:nodes` group would not be authorized by the `Node` authorization mode,
and would need to continue to be authorized via whatever mechanism currently authorizes them.
The node admission plugin would not restrict requests from these kubelets.
-->
<h3 id="具有无差别用户名的-kubelet">具有无差别用户名的 Kubelet</h3>
<!--
### Kubelets with undifferentiated usernames
-->
<p>在一些部署中，kubelet 具有 <code>system:nodes</code> 组的凭证，但是无法给出它们所关联的节点的标识，因为它们没有 <code>system:node:...</code> 格式的用户名。
这些 kubelet 不会被 <code>Node</code> 授权模式授权，并且需要继续通过当前授权它们的任何机制来授权。</p>
<!--
In some deployments, kubelets have credentials that place them in the `system:nodes` group,
but do not identify the particular node they are associated with,
because they do not have a username in the `system:node:...` format.
These kubelets would not be authorized by the `Node` authorization mode,
and would need to continue to be authorized via whatever mechanism currently authorizes them.
-->
<p>因为默认的节点标识符实现不会把它当作节点身份标识，<code>NodeRestriction</code> 准入插件会忽略来自这些 kubelet 的请求。</p>
<!--
The `NodeRestriction` admission plugin would ignore requests from these kubelets,
since the default node identifier implementation would not consider that a node identity.
-->
<h3 id="相对于以前使用-rbac-的版本的更新">相对于以前使用 RBAC 的版本的更新</h3>
<!--
### Upgrades from previous versions using RBAC
-->
<p>升级的 1.7 之前的使用 <a href="/zh/docs/reference/access-authn-authz/rbac/">RBAC</a> 的集群将继续按原样运行，因为 <code>system:nodes</code> 组绑定已经存在。</p>
<!--
Upgraded pre-1.7 clusters using [RBAC](/docs/reference/access-authn-authz/rbac/) will continue functioning as-is because the `system:nodes` group binding will already exist.
-->
<p>如果集群管理员希望开始使用 <code>Node</code> 鉴权器和 <code>NodeRestriction</code> 准入插件来限制节点对 API 的访问，这一需求可以通过下列操作来完成且不会影响已部署的应用：</p>
<!--
If a cluster admin wishes to start using the `Node` authorizer and `NodeRestriction` admission plugin
to limit node access to the API, that can be done non-disruptively:
 -->
<ol>
<li>启用 <code>Node</code> 鉴权模式 (<code>--authorization-mode=Node,RBAC</code>) 和 <code>NodeRestriction</code> 准入插件</li>
<li>确保所有 kubelet 的凭据符合组/用户名要求</li>
<li>审核 apiserver 日志以确保 <code>Node</code> 鉴权器不会拒绝来自 kubelet 的请求（日志中没有持续的 <code>NODE DENY</code> 消息）</li>
<li>删除 <code>system:node</code> 集群角色绑定</li>
</ol>
<!--
1. Enable the `Node` authorization mode (`--authorization-mode=Node,RBAC`) and the `NodeRestriction` admission plugin
2. Ensure all kubelets' credentials conform to the group/username requirements
3. Audit apiserver logs to ensure the `Node` authorizer is not rejecting requests from kubelets (no persistent `NODE DENY` messages logged)
4. Delete the `system:node` cluster role binding
-->
<h3 id="rbac-节点权限">RBAC 节点权限</h3>
<!--
### RBAC Node Permissions
-->
<p>在 1.6 版本中，当使用 <a href="/zh/docs/reference/access-authn-authz/rbac/">RBAC 鉴权模式</a> 时，<code>system:nodes</code> 集群角色会被自动绑定到 <code>system:node</code> 组。</p>
<!--
In 1.6, the `system:node` cluster role was automatically bound to the `system:nodes` group when using the [RBAC Authorization mode](/docs/reference/access-authn-authz/rbac/).
-->
<p>在 1.7 版本中，不再推荐将 <code>system:nodes</code> 组自动绑定到 <code>system:node</code> 角色，因为节点鉴权器通过对 secret 和 configmap 访问的额外限制完成了相同的任务。
如果同时启用了 <code>Node</code> 和 <code>RBAC</code> 授权模式，1.7 版本则不会创建 <code>system:nodes</code> 组到 <code>system:node</code> 角色的自动绑定。</p>
<!--
In 1.7, the automatic binding of the `system:nodes` group to the `system:node` role is deprecated
because the node authorizer accomplishes the same purpose with the benefit of additional restrictions
on secret and configmap access. If the `Node` and `RBAC` authorization modes are both enabled,
the automatic binding of the `system:nodes` group to the `system:node` role is not created in 1.7.
-->
<p>在 1.8 版本中，绑定将根本不会被创建。</p>
<!--
In 1.8, the binding will not be created at all.
-->
<p>使用 RBAC 时，将继续创建 <code>system:node</code> 集群角色，以便与将其他用户或组绑定到该角色的部署方法兼容。</p>
<!--
When using RBAC, the `system:node` cluster role will continue to be created,
for compatibility with deployment methods that bind other users or groups to that role.
-->

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-215c25173044b8f97e9b0494b0c7e53f">4.10 - Webhook 模式</h1>
    
	<!--
---
reviewers:
- erictune
- lavalamp
- deads2k
- liggitt
title: Webhook Mode
content_type: concept
weight: 95
---
-->
<!-- overview -->
<!--
A WebHook is an HTTP callback: an HTTP POST that occurs when something happens; a simple event-notification via HTTP POST. A web application implementing WebHooks will POST a message to a URL when certain things happen.
-->
<p>WebHook 是一种 HTTP 回调：某些条件下触发的 HTTP POST 请求；通过 HTTP POST 发送的简单事件通知。一个基于 web 应用实现的 WebHook 会在特定事件发生时把消息发送给特定的 URL。</p>
<!-- body -->
<!--
When specified, mode `Webhook` causes Kubernetes to query an outside REST
service when determining user privileges.
-->
<p>具体来说，当在判断用户权限时，<code>Webhook</code> 模式会使 Kubernetes 查询外部的 REST 服务。</p>
<!--
## Configuration File Format
-->
<h2 id="配置文件格式">配置文件格式</h2>
<!--
Mode `Webhook` requires a file for HTTP configuration, specify by the
`--authorization-webhook-config-file=SOME_FILENAME` flag.
-->
<p><code>Webhook</code> 模式需要一个 HTTP 配置文件，通过 <code>--authorization-webhook-config-file=SOME_FILENAME</code> 的参数声明。</p>
<!--
The configuration file uses the [kubeconfig](/docs/tasks/access-application-cluster/configure-access-multiple-clusters/)
file format. Within the file "users" refers to the API Server webhook and
"clusters" refers to the remote service.
-->
<p>配置文件的格式使用 <a href="/zh/docs/tasks/access-application-cluster/configure-access-multiple-clusters/">kubeconfig</a>。在文件中，&quot;users&quot; 代表着 API 服务器的 webhook，而 &quot;cluster&quot; 代表着远程服务。</p>
<!--
A configuration example which uses HTTPS client auth:
-->
<p>使用 HTTPS 客户端认证的配置例子：</p>
<!--
```yaml
# Kubernetes API version
apiVersion: v1
# kind of the API object
kind: Config
# clusters refers to the remote service.
clusters:
  - name: name-of-remote-authz-service
    cluster:
      # CA for verifying the remote service.
      certificate-authority: /path/to/ca.pem
      # URL of remote service to query. Must use 'https'. May not include parameters.
      server: https://authz.example.com/authorize

# users refers to the API Server's webhook configuration.
users:
  - name: name-of-api-server
    user:
      client-certificate: /path/to/cert.pem # cert for the webhook plugin to use
      client-key: /path/to/key.pem          # key matching the cert

# kubeconfig files require a context. Provide one for the API Server.
current-context: webhook
contexts:
- context:
    cluster: name-of-remote-authz-service
    user: name-of-api-server
  name: webhook
```
-->
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#080;font-style:italic"># Kubernetes API 版本</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#080;font-style:italic"># API 对象种类</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>Config<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#080;font-style:italic"># clusters 代表远程服务。</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">clusters</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>name-of-remote-authz-service<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">cluster</span>:<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#080;font-style:italic"># 对远程服务进行身份认证的 CA。</span><span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">certificate-authority</span>:<span style="color:#bbb"> </span>/path/to/ca.pem<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#080;font-style:italic"># 远程服务的查询 URL。必须使用 &#39;https&#39;。</span><span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">server</span>:<span style="color:#bbb"> </span>https://authz.example.com/authorize<span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#080;font-style:italic"># users 代表 API 服务器的 webhook 配置</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">users</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>name-of-api-server<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">user</span>:<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">client-certificate</span>:<span style="color:#bbb"> </span>/path/to/cert.pem<span style="color:#bbb"> </span><span style="color:#080;font-style:italic"># webhook plugin 使用 cert</span><span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">client-key</span>:<span style="color:#bbb"> </span>/path/to/key.pem         <span style="color:#bbb"> </span><span style="color:#080;font-style:italic"># cert 所对应的 key</span><span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#080;font-style:italic"># kubeconfig 文件必须有 context。需要提供一个给 API 服务器。</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">current-context</span>:<span style="color:#bbb"> </span>webhook<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">contexts</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">context</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">cluster</span>:<span style="color:#bbb"> </span>name-of-remote-authz-service<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">user</span>:<span style="color:#bbb"> </span>name-of-api-server<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>webhook<span style="color:#bbb">
</span></code></pre></div><!--
## Request Payloads
-->
<h2 id="请求载荷">请求载荷</h2>
<!--
When faced with an authorization decision, the API Server POSTs a JSON-
serialized `authorization.k8s.io/v1beta1` `SubjectAccessReview` object describing the
action. This object contains fields describing the user attempting to make the
request, and either details about the resource being accessed or requests
attributes.
-->
<p>在做认证决策时，API 服务器会 POST 一个 JSON 序列化的 <code>authorization.k8s.io/v1beta1</code> <code>SubjectAccessReview</code> 对象来描述这个动作。这个对象包含了描述用户请求的字段，同时也包含了需要被访问资源或请求特征的具体信息。</p>
<!--
Note that webhook API objects are subject to the same [versioning compatibility rules](/docs/concepts/overview/kubernetes-api/)
as other Kubernetes API objects. Implementers should be aware of looser
compatibility promises for beta objects and check the "apiVersion" field of the
request to ensure correct deserialization. Additionally, the API Server must
enable the `authorization.k8s.io/v1beta1` API extensions group (`--runtime-config=authorization.k8s.io/v1beta1=true`).
-->
<p>需要注意的是 webhook API 对象与其他 Kubernetes API 对象一样都同样都服从<a href="/zh/docs/concepts/overview/kubernetes-api/">版本兼容规则</a>。实施人员应该了解 beta 对象的更宽松的兼容性承诺，同时确认请求的 &quot;apiVersion&quot; 字段能被正确地反序列化。此外，API 服务器还必须启用 <code>authorization.k8s.io/v1beta1</code> API 扩展组 (<code>--runtime-config=authorization.k8s.io/v1beta1=true</code>)。</p>
<!--
An example request body:
-->
<p>一个请求内容的例子：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-json" data-lang="json">{
  <span style="color:#008000;font-weight:bold">&#34;apiVersion&#34;</span>: <span style="color:#b44">&#34;authorization.k8s.io/v1beta1&#34;</span>,
  <span style="color:#008000;font-weight:bold">&#34;kind&#34;</span>: <span style="color:#b44">&#34;SubjectAccessReview&#34;</span>,
  <span style="color:#008000;font-weight:bold">&#34;spec&#34;</span>: {
    <span style="color:#008000;font-weight:bold">&#34;resourceAttributes&#34;</span>: {
      <span style="color:#008000;font-weight:bold">&#34;namespace&#34;</span>: <span style="color:#b44">&#34;kittensandponies&#34;</span>,
      <span style="color:#008000;font-weight:bold">&#34;verb&#34;</span>: <span style="color:#b44">&#34;get&#34;</span>,
      <span style="color:#008000;font-weight:bold">&#34;group&#34;</span>: <span style="color:#b44">&#34;unicorn.example.org&#34;</span>,
      <span style="color:#008000;font-weight:bold">&#34;resource&#34;</span>: <span style="color:#b44">&#34;pods&#34;</span>
    },
    <span style="color:#008000;font-weight:bold">&#34;user&#34;</span>: <span style="color:#b44">&#34;jane&#34;</span>,
    <span style="color:#008000;font-weight:bold">&#34;group&#34;</span>: [
      <span style="color:#b44">&#34;group1&#34;</span>,
      <span style="color:#b44">&#34;group2&#34;</span>
    ]
  }
}
</code></pre></div><!--
The remote service is expected to fill the `status` field of
the request and respond to either allow or disallow access. The response body's
`spec` field is ignored and may be omitted. A permissive response would return:
-->
<p>期待远程服务填充请求的 <code>status</code> 字段并响应允许或禁止访问。响应主体的 <code>spec</code> 字段被忽略，可以省略。允许的响应将返回:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-json" data-lang="json">{
  <span style="color:#008000;font-weight:bold">&#34;apiVersion&#34;</span>: <span style="color:#b44">&#34;authorization.k8s.io/v1beta1&#34;</span>,
  <span style="color:#008000;font-weight:bold">&#34;kind&#34;</span>: <span style="color:#b44">&#34;SubjectAccessReview&#34;</span>,
  <span style="color:#008000;font-weight:bold">&#34;status&#34;</span>: {
    <span style="color:#008000;font-weight:bold">&#34;allowed&#34;</span>: <span style="color:#a2f;font-weight:bold">true</span>
  }
}
</code></pre></div><!--
For disallowing access there are two methods.
-->
<p>为了禁止访问，有两种方法。</p>
<!--
The first method is preferred in most cases, and indicates the authorization
webhook does not allow, or has "no opinion" about the request, but if other
authorizers are configured, they are given a chance to allow the request.
If there are no other authorizers, or none of them allow the request, the
request is forbidden. The webhook would return:
-->
<p>在大多数情况下，第一种方法是首选方法，它指示授权 webhook 不允许或对请求&quot;无意见&quot;，但是，如果配置了其他授权者，则可以给他们机会允许请求。如果没有其他授权者，或者没有一个授权者，则该请求被禁止。webhook 将返回:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-json" data-lang="json">{
  <span style="color:#008000;font-weight:bold">&#34;apiVersion&#34;</span>: <span style="color:#b44">&#34;authorization.k8s.io/v1beta1&#34;</span>,
  <span style="color:#008000;font-weight:bold">&#34;kind&#34;</span>: <span style="color:#b44">&#34;SubjectAccessReview&#34;</span>,
  <span style="color:#008000;font-weight:bold">&#34;status&#34;</span>: {
    <span style="color:#008000;font-weight:bold">&#34;allowed&#34;</span>: <span style="color:#a2f;font-weight:bold">false</span>,
    <span style="color:#008000;font-weight:bold">&#34;reason&#34;</span>: <span style="color:#b44">&#34;user does not have read access to the namespace&#34;</span>
  }
}
</code></pre></div><!--
The second method denies immediately, short-circuiting evaluation by other
configured authorizers. This should only be used by webhooks that have
detailed knowledge of the full authorizer configuration of the cluster.
The webhook would return:
-->
<p>第二种方法立即拒绝其他配置的授权者进行短路评估。仅应由对集群的完整授权者配置有详细了解的 webhook 使用。webhook 将返回:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-json" data-lang="json">{
  <span style="color:#008000;font-weight:bold">&#34;apiVersion&#34;</span>: <span style="color:#b44">&#34;authorization.k8s.io/v1beta1&#34;</span>,
  <span style="color:#008000;font-weight:bold">&#34;kind&#34;</span>: <span style="color:#b44">&#34;SubjectAccessReview&#34;</span>,
  <span style="color:#008000;font-weight:bold">&#34;status&#34;</span>: {
    <span style="color:#008000;font-weight:bold">&#34;allowed&#34;</span>: <span style="color:#a2f;font-weight:bold">false</span>,
    <span style="color:#008000;font-weight:bold">&#34;denied&#34;</span>: <span style="color:#a2f;font-weight:bold">true</span>,
    <span style="color:#008000;font-weight:bold">&#34;reason&#34;</span>: <span style="color:#b44">&#34;user does not have read access to the namespace&#34;</span>
  }
}
</code></pre></div><!--
Access to non-resource paths are sent as:
-->
<p>对于非资源的路径访问是这么发送的:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-json" data-lang="json">{
  <span style="color:#008000;font-weight:bold">&#34;apiVersion&#34;</span>: <span style="color:#b44">&#34;authorization.k8s.io/v1beta1&#34;</span>,
  <span style="color:#008000;font-weight:bold">&#34;kind&#34;</span>: <span style="color:#b44">&#34;SubjectAccessReview&#34;</span>,
  <span style="color:#008000;font-weight:bold">&#34;spec&#34;</span>: {
    <span style="color:#008000;font-weight:bold">&#34;nonResourceAttributes&#34;</span>: {
      <span style="color:#008000;font-weight:bold">&#34;path&#34;</span>: <span style="color:#b44">&#34;/debug&#34;</span>,
      <span style="color:#008000;font-weight:bold">&#34;verb&#34;</span>: <span style="color:#b44">&#34;get&#34;</span>
    },
    <span style="color:#008000;font-weight:bold">&#34;user&#34;</span>: <span style="color:#b44">&#34;jane&#34;</span>,
    <span style="color:#008000;font-weight:bold">&#34;group&#34;</span>: [
      <span style="color:#b44">&#34;group1&#34;</span>,
      <span style="color:#b44">&#34;group2&#34;</span>
    ]
  }
}
</code></pre></div><!--
Non-resource paths include: `/api`, `/apis`, `/metrics`, `/resetMetrics`,
`/logs`, `/debug`, `/healthz`, `/swagger-ui/`, `/swaggerapi/`, `/ui`, and
`/version.` Clients require access to `/api`, `/api/*`, `/apis`, `/apis/*`,
and `/version` to discover what resources and versions are present on the server.
Access to other non-resource paths can be disallowed without restricting access
to the REST api.
-->
<p>非资源类的路径包括：<code>/api</code>, <code>/apis</code>, <code>/metrics</code>, <code>/resetMetrics</code>,
<code>/logs</code>, <code>/debug</code>, <code>/healthz</code>, <code>/swagger-ui/</code>, <code>/swaggerapi/</code>, <code>/ui</code>, 和
<code>/version</code>。客户端需要访问 <code>/api</code>, <code>/api/*</code>, <code>/apis</code>, <code>/apis/*</code>, 和 <code>/version</code> 以便
能发现服务器上有什么资源和版本。对于其他非资源类的路径访问在没有 REST API 访问限制的情况下拒绝。</p>
<!--
For further documentation refer to the authorization.v1beta1 API objects and
[webhook.go](https://github.com/kubernetes/kubernetes/blob/main/staging/src/k8s.io/apiserver/plugin/pkg/authorizer/webhook/webhook.go).
-->
<p>更多信息可以参考 authorization.v1beta1 API 对象和<a href="https://github.com/kubernetes/kubernetes/blob/main/staging/src/k8s.io/apiserver/plugin/pkg/authorizer/webhook/webhook.go">webhook.go</a>。</p>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-a5bdc757c01991e5e6ab1a82b90639ea">4.11 - 使用 ABAC 鉴权</h1>
    
	<!--
---
reviewers:
- erictune
- lavalamp
- deads2k
- liggitt
title: Using ABAC Authorization
content_type: concept
weight: 80
---
-->
<!-- overview -->
<!--
Attribute-based access control (ABAC) defines an access control paradigm whereby access rights are granted to users through the use of policies which combine attributes together.
-->
<p>基于属性的访问控制（Attribute-based access control - ABAC）定义了访问控制范例，其中通过使用将属性组合在一起的策略来向用户授予访问权限。</p>
<!-- body -->
<!--
## Policy File Format

To enable `ABAC` mode, specify `--authorization-policy-file=SOME_FILENAME` and `--authorization-mode=ABAC` on startup.

The file format is [one JSON object per line](http://jsonlines.org/).  There
should be no enclosing list or map, just one map per line.

Each line is a "policy object", where each such object is a map with the following
properties:

  - Versioning properties:
    - `apiVersion`, type string; valid values are "abac.authorization.kubernetes.io/v1beta1". Allows versioning and conversion of the policy format.
    - `kind`, type string: valid values are "Policy". Allows versioning and conversion of the policy format.
  - `spec` property set to a map with the following properties:
    - Subject-matching properties:
      - `user`, type string; the user-string from `--token-auth-file`. If you specify `user`, it must match the username of the authenticated user.
      - `group`, type string; if you specify `group`, it must match one of the groups of the authenticated user. `system:authenticated` matches all authenticated requests. `system:unauthenticated` matches all unauthenticated requests.
    - Resource-matching properties:
      - `apiGroup`, type string; an API group.
        - Ex: `extensions`
        - Wildcard: `*` matches all API groups.
      - `namespace`, type string; a namespace.
        - Ex: `kube-system`
        - Wildcard: `*` matches all resource requests.
      - `resource`, type string; a resource type
        - Ex: `pods`
        - Wildcard: `*` matches all resource requests.
    - Non-resource-matching properties:
      - `nonResourcePath`, type string; non-resource request paths.
        - Ex: `/version` or `/apis`
        - Wildcard:
          - `*` matches all non-resource requests.
          - `/foo/*` matches all subpaths of `/foo/`.
    - `readonly`, type boolean, when true, means that the Resource-matching policy only applies to get, list, and watch operations, Non-resource-matching policy only applies to get operation.
-->
<h2 id="策略文件格式">策略文件格式</h2>
<p>基于 <code>ABAC</code> 模式，可以这样指定策略文件 <code>--authorization-policy-file=SOME_FILENAME</code>。</p>
<p>此文件格式是 <a href="https://jsonlines.org/">JSON Lines</a>，不应存在封闭的列表或映射，每行一个映射。</p>
<p>每一行都是一个策略对象，策略对象是具有以下属性的映射：</p>
<ul>
<li>版本控制属性：
<ul>
<li><code>apiVersion</code>，字符串类型：有效值为<code>abac.authorization.kubernetes.io/v1beta1</code>，允许对策略格式进行版本控制和转换。</li>
<li><code>kind</code>，字符串类型：有效值为 <code>Policy</code>，允许对策略格式进行版本控制和转换。</li>
</ul>
</li>
<li><code>spec</code> 配置为具有以下映射的属性：
<ul>
<li>主体匹配属性：
<ul>
<li><code>user</code>，字符串类型；来自 <code>--token-auth-file</code> 的用户字符串，如果你指定 <code>user</code>，它必须与验证用户的用户名匹配。</li>
<li><code>group</code>，字符串类型；如果指定 <code>group</code>，它必须与经过身份验证的用户的一个组匹配，<code>system:authenticated</code>匹配所有经过身份验证的请求。<code>system:unauthenticated</code>匹配所有未经过身份验证的请求。</li>
</ul>
</li>
</ul>
</li>
<li>资源匹配属性：
<ul>
<li><code>apiGroup</code>，字符串类型；一个 API 组。
<ul>
<li>例： <code>extensions</code></li>
<li>通配符：<code>*</code>匹配所有 API 组。</li>
</ul>
</li>
<li><code>namespace</code>，字符串类型；一个命名空间。
<ul>
<li>例如：<code>kube-system</code></li>
<li>通配符：<code>*</code>匹配所有资源请求。</li>
</ul>
</li>
<li><code>resource</code>，字符串类型；资源类型。
<ul>
<li>例：<code>pods</code></li>
<li>通配符：<code>*</code>匹配所有资源请求。</li>
</ul>
</li>
</ul>
</li>
<li>非资源匹配属性：
<ul>
<li><code>nonResourcePath</code>，字符串类型；非资源请求路径。
<ul>
<li>例如：<code>/version</code>或 <code>/apis</code></li>
<li>通配符：
<ul>
<li><code>*</code> 匹配所有非资源请求。</li>
<li><code>/foo/*</code> 匹配 <code>/foo/</code> 的所有子路径。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><code>readonly</code>，键入布尔值，如果为 true，则表示该策略仅适用于 get、list 和 watch 操作。</li>
</ul>
<blockquote class="note callout">
  <div><strong>说明：</strong> <!--
An unset property is the same as a property set to the zero value for its type
(e.g. empty string, 0, false). However, unset should be preferred for
readability.

In the future, policies may be expressed in a JSON format, and managed via a
REST interface.
-->
<p>属性未设置等效于属性被设置为对应类型的零值( 例如空字符串、0、false)，然而，出于可读性考虑，应尽量选择不设置这类属性。</p>
<p>在将来，策略可能以 JSON 格式表示，并通过 REST 界面进行管理。</p>
</div>
</blockquote>
<!--
## Authorization Algorithm

A request has attributes which correspond to the properties of a policy object.

When a request is received, the attributes are determined.  Unknown attributes
are set to the zero value of its type (e.g. empty string, 0, false).

A property set to `"*"` will match any value of the corresponding attribute.

The tuple of attributes is checked for a match against every policy in the
policy file. If at least one line matches the request attributes, then the
request is authorized (but may fail later validation).

To permit any authenticated user to do something, write a policy with the
group property set to `"system:authenticated"`.

To permit any unauthenticated user to do something, write a policy with the
group property set to `"system:unauthenticated"`.

To permit a user to do anything, write a policy with the apiGroup, namespace,
resource, and nonResourcePath properties set to `"*"`.
-->
<h2 id="鉴权算法">鉴权算法</h2>
<p>请求具有与策略对象的属性对应的属性。</p>
<p>当接收到请求时，确定属性。未知属性设置为其类型的零值（例如：空字符串，0，false）。</p>
<p>设置为 <code>&quot;*&quot;</code> 的属性将匹配相应属性的任何值。</p>
<p>检查属性的元组，以匹配策略文件中的每个策略。如果至少有一行匹配请求属性，则请求被鉴权（但仍可能无法通过稍后的合法性检查）。</p>
<p>要允许任何经过身份验证的用户执行某些操作，请将策略组属性设置为 <code>&quot;system:authenticated&quot;</code>。</p>
<p>要允许任何未经身份验证的用户执行某些操作，请将策略组属性设置为 <code>&quot;system:authentication&quot;</code>。</p>
<p>要允许用户执行任何操作，请使用 apiGroup，命名空间，
资源和 nonResourcePath 属性设置为 <code>&quot;*&quot;</code> 的策略。</p>
<p>要允许用户执行任何操作，请使用设置为 <code>&quot;*&quot;</code> 的 apiGroup，namespace，resource 和 nonResourcePath 属性编写策略。</p>
<!--
## Kubectl

Kubectl uses the `/api` and `/apis` endpoints of api-server to discover
served resource types, and validates objects sent to the API by create/update
operations using schema information located at `/openapi/v2`.

When using ABAC authorization, those special resources have to be explicitly
exposed via the `nonResourcePath` property in a policy (see [examples](#examples) below):

* `/api`, `/api/*`, `/apis`, and `/apis/*` for API version negotiation.
* `/version` for retrieving the server version via `kubectl version`.
* `/swaggerapi/*` for create/update operations.

To inspect the HTTP calls involved in a specific kubectl operation you can turn
up the verbosity:

    kubectl --v=8 version
-->
<h2 id="kubectl">Kubectl</h2>
<p>Kubectl 使用 api-server 的 <code>/api</code> 和 <code>/apis</code> 端点来发现服务资源类型，并使用位于 <code>/openapi/v2</code> 的模式信息来验证通过创建/更新操作发送到 API 的对象。</p>
<p>当使用 ABAC 鉴权时，这些特殊资源必须显式地通过策略中的 <code>nonResourcePath</code> 属性暴露出来（参见下面的 <a href="#examples">示例</a>）：</p>
<ul>
<li><code>/api</code>，<code>/api/*</code>，<code>/apis</code>和 <code>/apis/*</code> 用于 API 版本协商。</li>
<li><code>/version</code> 通过 <code>kubectl version</code> 检索服务器版本。</li>
<li><code>/swaggerapi/*</code> 用于创建 / 更新操作。</li>
</ul>
<p>要检查涉及到特定 kubectl 操作的 HTTP 调用，您可以调整详细程度：
kubectl --v=8 version</p>
<!--
## Examples

 1. Alice can do anything to all resources:

    ```json
    {"apiVersion": "abac.authorization.kubernetes.io/v1beta1", "kind": "Policy", "spec": {"user": "alice", "namespace": "*", "resource": "*", "apiGroup": "*"}}
    ```
 2. The Kubelet can read any pods:

    ```json
    {"apiVersion": "abac.authorization.kubernetes.io/v1beta1", "kind": "Policy", "spec": {"user": "kubelet", "namespace": "*", "resource": "pods", "readonly": true}}
    ```
 3. The Kubelet can read and write events:

    ```json
    {"apiVersion": "abac.authorization.kubernetes.io/v1beta1", "kind": "Policy", "spec": {"user": "kubelet", "namespace": "*", "resource": "events"}}
    ```
 -->
<h2 id="examples">例子</h2>
<ol>
<li>
<p>Alice 可以对所有资源做任何事情：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-json" data-lang="json">{<span style="color:#008000;font-weight:bold">&#34;apiVersion&#34;</span>: <span style="color:#b44">&#34;abac.authorization.kubernetes.io/v1beta1&#34;</span>, <span style="color:#008000;font-weight:bold">&#34;kind&#34;</span>: <span style="color:#b44">&#34;Policy&#34;</span>, <span style="color:#008000;font-weight:bold">&#34;spec&#34;</span>: {<span style="color:#008000;font-weight:bold">&#34;user&#34;</span>: <span style="color:#b44">&#34;alice&#34;</span>, <span style="color:#008000;font-weight:bold">&#34;namespace&#34;</span>: <span style="color:#b44">&#34;*&#34;</span>, <span style="color:#008000;font-weight:bold">&#34;resource&#34;</span>: <span style="color:#b44">&#34;*&#34;</span>, <span style="color:#008000;font-weight:bold">&#34;apiGroup&#34;</span>: <span style="color:#b44">&#34;*&#34;</span>}}
</code></pre></div></li>
<li>
<p>Kubelet 可以读取任何 pod：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-json" data-lang="json">{<span style="color:#008000;font-weight:bold">&#34;apiVersion&#34;</span>: <span style="color:#b44">&#34;abac.authorization.kubernetes.io/v1beta1&#34;</span>, <span style="color:#008000;font-weight:bold">&#34;kind&#34;</span>: <span style="color:#b44">&#34;Policy&#34;</span>, <span style="color:#008000;font-weight:bold">&#34;spec&#34;</span>: {<span style="color:#008000;font-weight:bold">&#34;user&#34;</span>: <span style="color:#b44">&#34;kubelet&#34;</span>, <span style="color:#008000;font-weight:bold">&#34;namespace&#34;</span>: <span style="color:#b44">&#34;*&#34;</span>, <span style="color:#008000;font-weight:bold">&#34;resource&#34;</span>: <span style="color:#b44">&#34;pods&#34;</span>, <span style="color:#008000;font-weight:bold">&#34;readonly&#34;</span>: <span style="color:#a2f;font-weight:bold">true</span>}}
</code></pre></div></li>
<li>
<p>Kubelet 可以读写事件：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-json" data-lang="json">{<span style="color:#008000;font-weight:bold">&#34;apiVersion&#34;</span>: <span style="color:#b44">&#34;abac.authorization.kubernetes.io/v1beta1&#34;</span>, <span style="color:#008000;font-weight:bold">&#34;kind&#34;</span>: <span style="color:#b44">&#34;Policy&#34;</span>, <span style="color:#008000;font-weight:bold">&#34;spec&#34;</span>: {<span style="color:#008000;font-weight:bold">&#34;user&#34;</span>: <span style="color:#b44">&#34;kubelet&#34;</span>, <span style="color:#008000;font-weight:bold">&#34;namespace&#34;</span>: <span style="color:#b44">&#34;*&#34;</span>, <span style="color:#008000;font-weight:bold">&#34;resource&#34;</span>: <span style="color:#b44">&#34;events&#34;</span>}}
</code></pre></div></li>
</ol>
 <!--
 4. Bob can just read pods in namespace "projectCaribou":

    ```json
    {"apiVersion": "abac.authorization.kubernetes.io/v1beta1", "kind": "Policy", "spec": {"user": "bob", "namespace": "projectCaribou", "resource": "pods", "readonly": true}}
    ```
 5. Anyone can make read-only requests to all non-resource paths:

    ```json
    {"apiVersion": "abac.authorization.kubernetes.io/v1beta1", "kind": "Policy", "spec": {"group": "system:authenticated", "readonly": true, "nonResourcePath": "*"}}
    {"apiVersion": "abac.authorization.kubernetes.io/v1beta1", "kind": "Policy", "spec": {"group": "system:unauthenticated", "readonly": true, "nonResourcePath": "*"}}
    ```
-->
<ol start="4">
<li>
<p>Bob 可以在命名空间 <code>projectCaribou</code> 中读取 pod：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-json" data-lang="json">{<span style="color:#008000;font-weight:bold">&#34;apiVersion&#34;</span>: <span style="color:#b44">&#34;abac.authorization.kubernetes.io/v1beta1&#34;</span>, <span style="color:#008000;font-weight:bold">&#34;kind&#34;</span>: <span style="color:#b44">&#34;Policy&#34;</span>, <span style="color:#008000;font-weight:bold">&#34;spec&#34;</span>: {<span style="color:#008000;font-weight:bold">&#34;user&#34;</span>: <span style="color:#b44">&#34;bob&#34;</span>, <span style="color:#008000;font-weight:bold">&#34;namespace&#34;</span>: <span style="color:#b44">&#34;projectCaribou&#34;</span>, <span style="color:#008000;font-weight:bold">&#34;resource&#34;</span>: <span style="color:#b44">&#34;pods&#34;</span>, <span style="color:#008000;font-weight:bold">&#34;readonly&#34;</span>: <span style="color:#a2f;font-weight:bold">true</span>}}
</code></pre></div></li>
<li>
<p>任何人都可以对所有非资源路径进行只读请求：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-json" data-lang="json">{<span style="color:#008000;font-weight:bold">&#34;apiVersion&#34;</span>: <span style="color:#b44">&#34;abac.authorization.kubernetes.io/v1beta1&#34;</span>, <span style="color:#008000;font-weight:bold">&#34;kind&#34;</span>: <span style="color:#b44">&#34;Policy&#34;</span>, <span style="color:#008000;font-weight:bold">&#34;spec&#34;</span>: {<span style="color:#008000;font-weight:bold">&#34;group&#34;</span>: <span style="color:#b44">&#34;system:authenticated&#34;</span>, <span style="color:#008000;font-weight:bold">&#34;readonly&#34;</span>: <span style="color:#a2f;font-weight:bold">true</span>, <span style="color:#008000;font-weight:bold">&#34;nonResourcePath&#34;</span>: <span style="color:#b44">&#34;*&#34;</span>}}
{<span style="color:#008000;font-weight:bold">&#34;apiVersion&#34;</span>: <span style="color:#b44">&#34;abac.authorization.kubernetes.io/v1beta1&#34;</span>, <span style="color:#008000;font-weight:bold">&#34;kind&#34;</span>: <span style="color:#b44">&#34;Policy&#34;</span>, <span style="color:#008000;font-weight:bold">&#34;spec&#34;</span>: {<span style="color:#008000;font-weight:bold">&#34;group&#34;</span>: <span style="color:#b44">&#34;system:unauthenticated&#34;</span>, <span style="color:#008000;font-weight:bold">&#34;readonly&#34;</span>: <span style="color:#a2f;font-weight:bold">true</span>, <span style="color:#008000;font-weight:bold">&#34;nonResourcePath&#34;</span>: <span style="color:#b44">&#34;*&#34;</span>}}
</code></pre></div></li>
</ol>
<!--
[Complete file example](http://releases.k8s.io/main/pkg/auth/authorizer/abac/example_policy_file.jsonl)

## A quick note on service accounts

Every service account has a corresponding ABAC username, and that service account's user name is generated according to the naming convention:

```shell
system:serviceaccount:<namespace>:<serviceaccountname>
```

-->
<p><a href="https://releases.k8s.io/main/pkg/auth/authorizer/abac/example_policy_file.jsonl">完整文件示例</a></p>
<h2 id="服务帐户的快速说明">服务帐户的快速说明</h2>
<p>服务帐户自动生成用户。用户名是根据命名约定生成的：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">system:serviceaccount:&lt;namespace&gt;:&lt;serviceaccountname&gt;
</code></pre></div><!--
Creating a new namespace leads to the creation of a new service account in the following format:

```shell
system:serviceaccount:<namespace>:default
```

For example, if you wanted to grant the default service account (in the `kube-system` namespace) full
privilege to the API using ABAC, you would add this line to your policy file:

```json
{"apiVersion":"abac.authorization.kubernetes.io/v1beta1","kind":"Policy","spec":{"user":"system:serviceaccount:kube-system:default","namespace":"*","resource":"*","apiGroup":"*"}}
```

The apiserver will need to be restarted to pickup the new policy lines.
-->
<p>创建新的命名空间也会导致创建一个新的服务帐户：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">system:serviceaccount:&lt;namespace&gt;:default
</code></pre></div><p>例如，如果要将 API 的 kube-system 完整权限中的默认服务帐户授予，则可以将此行添加到策略文件中：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-json" data-lang="json">{<span style="color:#008000;font-weight:bold">&#34;apiVersion&#34;</span>:<span style="color:#b44">&#34;abac.authorization.kubernetes.io/v1beta1&#34;</span>,<span style="color:#008000;font-weight:bold">&#34;kind&#34;</span>:<span style="color:#b44">&#34;Policy&#34;</span>,<span style="color:#008000;font-weight:bold">&#34;spec&#34;</span>:{<span style="color:#008000;font-weight:bold">&#34;user&#34;</span>:<span style="color:#b44">&#34;system:serviceaccount:kube-system:default&#34;</span>,<span style="color:#008000;font-weight:bold">&#34;namespace&#34;</span>:<span style="color:#b44">&#34;*&#34;</span>,<span style="color:#008000;font-weight:bold">&#34;resource&#34;</span>:<span style="color:#b44">&#34;*&#34;</span>,<span style="color:#008000;font-weight:bold">&#34;apiGroup&#34;</span>:<span style="color:#b44">&#34;*&#34;</span>}}
</code></pre></div><p>需要重新启动 apiserver 以获取新的策略行。</p>

</div>



    
	
  

    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-60a16da3955f1de774f1f8dd756f2251">5 - Kubernetes API</h1>
    
	<!-- overview -->
<!--
---
title: Kubernetes API
id: kubernetes-api
date: 2018-04-12
full_link: /docs/concepts/overview/kubernetes-api/
short_description: >
  The application that serves Kubernetes functionality through a RESTful interface and stores the state of the cluster.

aka: 
tags:
- fundamental
- architecture
---
-->
<!--
 The application that serves Kubernetes functionality through a RESTful interface and stores the state of the cluster.
-->
<p>Kubernetes API 是通过 RESTful 接口提供 Kubernetes 功能服务并负责集群状态存储的应用程序。</p>
<!--
Kubernetes resources and "records of intent" are all stored as API objects, and modified via RESTful calls to the API. The API allows configuration to be managed in a declarative way. Users can interact with the Kubernetes API directly, or via tools like `kubectl`. The core Kubernetes API is flexible and can also be extended to support custom resources.
-->
<p>Kubernetes 资源和&quot;意向记录&quot;都是作为 API 对象储存的，并可以通过调用 RESTful 风格的 API 进行修改。
API 允许以声明方式管理配置。
用户可以直接和 Kubernetes API 交互，也可以通过 <code>kubectl</code> 这样的工具进行交互。
核心的 Kubernetes API 是很灵活的，可以扩展以支持定制资源。</p>

</div>



    
      
  
  
  
  

  
  

  

    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-af7c1f9168ec67f957edc504f43faf9a">6 - Kubernetes 问题和安全</h1>
    
	
</div>



    
      
  
  
  
  

  
  

  
    
    
	
    

<div class="td-content" style="">
    
	<h1 id="pg-980c0542a3b195a20cfd4358792e2a38">6.1 - Kubernetes 问题追踪</h1>
    
	<!--
title: Kubernetes Issue Tracker
weight: 10
aliases: [/cve/,/cves/]
-->
<!--
To report a security issue, please follow the [Kubernetes security disclosure process](/docs/reference/issues-security/security/#report-a-vulnerability).
-->
<p>要报告安全问题，请遵循
<a href="/zh/docs/reference/issues-security/security/#report-a-vulnerability">Kubernetes 安全问题公开流程</a>。</p>
<!--
Work on Kubernetes code and public issues are tracked using [GitHub Issues](https://github.com/kubernetes/kubernetes/issues/).
-->
<p>使用 <a href="https://github.com/kubernetes/kubernetes/issues/">GitHub Issues</a>
跟踪 Kubernetes 编码工作和公开问题。</p>
<!--
* [CVE-related issues](https://github.com/kubernetes/kubernetes/issues?utf8=%E2%9C%93&q=is%3Aissue+label%3Aarea%2Fsecurity+in%3Atitle+CVE)
-->
<ul>
<li><a href="https://github.com/kubernetes/kubernetes/issues?utf8=%E2%9C%93&amp;q=is%3Aissue+label%3Aarea%2Fsecurity+in%3Atitle+CVE">CVE 相关问题</a></li>
</ul>
<!--
Security-related announcements are sent to the [kubernetes-security-announce@googlegroups.com](https://groups.google.com/forum/#!forum/kubernetes-security-announce) mailing list.
-->
<p>与安全性相关的公告请发送到
<a href="https://groups.google.com/forum/#!forum/kubernetes-security-announce">kubernetes-security-announce@googlegroups.com</a>
邮件列表。</p>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-1f7dc06f1cc1ea2cdde4480e54d5fb34">6.2 - Kubernetes 安全和信息披露</h1>
    
	<!--
title: Kubernetes Security and Disclosure Information
aliases: [/security/]
reviewers:
- eparis
- erictune
- philips
- jessfraz
content_type: concept
weight: 20
-->
<!-- overview -->
<!--
This page describes Kubernetes security and disclosure information.
-->
<p>本页面介绍 Kubernetes 安全和信息披露相关的内容。</p>
<!-- body -->
<!--
## Security Announcements
-->
<h2 id="安全公告">安全公告</h2>
<!--
Join the [kubernetes-security-announce](https://groups.google.com/forum/#!forum/kubernetes-security-announce) group for emails about security and major API announcements.
-->
<p>加入 <a href="https://groups.google.com/forum/#!forum/kubernetes-security-announce">kubernetes-security-announce</a> 组，以获取关于安全性和主要 API 公告的电子邮件。</p>
<!--
You can also subscribe to an RSS feed of the above using [this link](https://groups.google.com/forum/feed/kubernetes-security-announce/msgs/rss_v2_0.xml?num=50).
-->
<p>你也可以使用<a href="https://groups.google.com/forum/feed/kubernetes-security-announce/msgs/rss_v2_0.xml?num=50">此链接</a> 订阅上述的 RSS 反馈。</p>
<!--
## Report a Vulnerability
-->
<h2 id="报告一个漏洞">报告一个漏洞</h2>
<!--
We’re extremely grateful for security researchers and users that report vulnerabilities to the Kubernetes Open Source Community. All reports are thoroughly investigated by a set of community volunteers.
-->
<p>我们非常感谢向 Kubernetes 开源社区报告漏洞的安全研究人员和用户。
所有的报告都由社区志愿者进行彻底调查。</p>
<!--
To make a report, please email the private [security@kubernetes.io](mailto:security@kubernetes.io) list with the security details and the details expected for [all Kubernetes bug reports](https://git.k8s.io/kubernetes/.github/ISSUE_TEMPLATE/bug-report.md).
-->
<p>如需报告，请连同安全细节以及预期的<a href="https://git.k8s.io/kubernetes/.github/ISSUE_TEMPLATE/bug-report.md">所有 Kubernetes bug 报告</a>
详细信息电子邮件到<a href="mailto:security@kubernetes.io">security@kubernetes.io</a>列表。</p>
<!--
You can also email the private [security@kubernetes.io](mailto:security@kubernetes.io) list with the security details and the details expected for [all Kubernetes bug reports](https://git.k8s.io/kubernetes/.github/ISSUE_TEMPLATE/bug-report.md).
-->
<p>你还可以通过电子邮件向私有 <a href="mailto:security@kubernetes.io">security@kubernetes.io</a> 列表发送电子邮件，邮件中应该包含<a href="https://git.k8s.io/kubernetes/.github/ISSUE_TEMPLATE/bug-report.md">所有 Kubernetes 错误报告</a>所需的详细信息。</p>
<!--
You may encrypt your email to this list using the GPG keys of the [Product Security Committee members](https://git.k8s.io/security/README.md#product-security-committee-psc). Encryption using GPG is NOT required to make a disclosure.
-->
<p>你可以使用<a href="https://git.k8s.io/security/README.md#product-security-committee-psc">产品安全团队成员</a>
的 GPG 密钥加密你的电子邮件到此列表。使用 GPG 加密不需要公开。</p>
<!--
### When Should I Report a Vulnerability?
-->
<h3 id="我应该在什么时候报告漏洞">我应该在什么时候报告漏洞？</h3>
<!--
- You think you discovered a potential security vulnerability in Kubernetes
- You are unsure how a vulnerability affects Kubernetes
- You think you discovered a vulnerability in another project that Kubernetes depends on
   - For projects with their own vulnerability reporting and disclosure process, please report it directly there
-->
<ul>
<li>你认为在 Kubernetes 中发现了一个潜在的安全漏洞</li>
<li>你不确定漏洞如何影响 Kubernetes</li>
<li>你认为你在 Kubernetes 依赖的另一个项目中发现了一个漏洞</li>
<li>对于具有漏洞报告和披露流程的项目，请直接在该项目处报告</li>
</ul>
<!--
### When Should I NOT Report a Vulnerability?
-->
<h3 id="我什么时候不应该报告漏洞">我什么时候不应该报告漏洞？</h3>
<!--
- You need help tuning Kubernetes components for security
- You need help applying security related updates
- Your issue is not security related
-->
<ul>
<li>你需要帮助调整 Kubernetes 组件的安全性</li>
<li>你需要帮助应用与安全相关的更新</li>
<li>你的问题与安全无关</li>
</ul>
<!--
## Security Vulnerability Response
-->
<h2 id="安全漏洞响应">安全漏洞响应</h2>
<!--
Each report is acknowledged and analyzed by Product Security Team members within 3 working days. This will set off the [Security Release Process](https://git.k8s.io/sig-release/security-release-process-documentation/security-release-process.md#disclosures).
-->
<p>每个报告在 3 个工作日内由产品安全团队成员确认和分析。这将启动<a href="https://git.k8s.io/sig-release/security-release-process-documentation/security-release-process.md#disclosures">安全发布过程</a>。</p>
<!--
Any vulnerability information shared with Product Security Team stays within Kubernetes project and will not be disseminated to other projects unless it is necessary to get the issue fixed.
-->
<p>与产品安全团队共享的任何漏洞信息都保留在 Kubernetes 项目中，除非有必要修复该问题，否则不会传播到其他项目。</p>
<!--
As the security issue moves from triage, to identified fix, to release planning we will keep the reporter updated.
-->
<p>随着安全问题从分类、识别修复、发布计划等方面的进展，我们将不断更新报告。</p>
<!--
## Public Disclosure Timing
-->
<h2 id="公开披露时间">公开披露时间</h2>
<!--
A public disclosure date is negotiated by the Kubernetes product security team and the bug submitter. We prefer to fully disclose the bug as soon as possible once a user mitigation is available.
-->
<p>公开披露日期由 Kubernetes 产品安全团队和 bug 提交者协商。我们倾向于在用户缓解措施可用时尽快完全披露该 bug。</p>
<!--
It is reasonable to delay disclosure when the bug or the fix is not yet fully understood, the solution is not well-tested, or for vendor coordination.
-->
<p>当 bug 或其修复还没有被完全理解，解决方案没有经过良好的测试，或者为了处理供应商协调问题时，延迟披露是合理的。</p>
<!--
The timeframe for disclosure is from immediate (especially if it's already publicly known) to a few weeks. As a basic default, we expect report date to disclosure date to be on the order of 7 days. The Kubernetes product security team holds the final say when setting a disclosure date.
-->
<p>信息披露的时间范围从即时（尤其是已经公开的）到几周。作为一个基本的约定，我们希望报告日期到披露日期的间隔是 7 天。在设置披露日期时，Kubernetes 产品安全团队拥有最终决定权。</p>

</div>



    
	
  

    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-5bbbc5163b35431b3bff029ab9ec57d3">7 - 安装工具</h1>
    
	<!--
title: Setup tools
weight: 50
-->

</div>



    
      
  
  
  
  

  
  

  
    
    
	
    

<div class="td-content" style="">
    
	<h1 id="pg-f351ced098abbb076bc8c4be1053672b">7.1 - Kubeadm</h1>
    
	<img src="/images/kubeadm-stacked-color.png" align="right" width="150px">
<!-- 
Kubeadm is a tool built to provide `kubeadm init` and `kubeadm join` as best-practice "fast paths" for creating Kubernetes clusters.
 -->
<p>Kubeadm 是一个提供了 <code>kubeadm init</code> 和 <code>kubeadm join</code> 的工具，
作为创建 Kubernetes 集群的 “快捷途径” 的最佳实践。</p>
<!-- 
kubeadm performs the actions necessary to get a minimum viable cluster up and running. By design, it cares only about bootstrapping,
not about provisioning machines. Likewise, installing various nice-to-have addons, like the Kubernetes Dashboard, monitoring solutions, and cloud-specific addons, is not in scope.
 -->
<p>kubeadm 通过执行必要的操作来启动和运行最小可用集群。
按照设计，它只关注启动引导，而非配置机器。同样的，
安装各种 “锦上添花” 的扩展，例如 Kubernetes Dashboard、
监控方案、以及特定云平台的扩展，都不在讨论范围内。</p>
<!-- 
Instead, we expect higher-level and more tailored tooling to be built on top of kubeadm, and ideally, using kubeadm as the basis of all deployments will make it easier to create conformant clusters.
 -->
<p>相反，我们希望在 kubeadm 之上构建更高级别以及更加合规的工具，
理想情况下，使用 kubeadm 作为所有部署工作的基准将会更加易于创建一致性集群。</p>
<!-- 
## How to install
 -->
<h2 id="如何安装">如何安装</h2>
<!-- 
To install kubeadm, see the [installation guide](/docs/setup/production-environment/tools/kubeadm/install-kubeadm).
-->
<p>要安装 kubeadm, 请查阅
<a href="/zh/docs/setup/production-environment/tools/kubeadm/install-kubeadm/">安装指南</a>.</p>
<h2 id="接下来">接下来</h2>
<!-- 
* [kubeadm init](/docs/reference/setup-tools/kubeadm/kubeadm-init) to bootstrap a Kubernetes control-plane node
* [kubeadm join](/docs/reference/setup-tools/kubeadm/kubeadm-join) to bootstrap a Kubernetes worker node and join it to the cluster
* [kubeadm upgrade](/docs/reference/setup-tools/kubeadm/kubeadm-upgrade) to upgrade a Kubernetes cluster to a newer version
* [kubeadm config](/docs/reference/setup-tools/kubeadm/kubeadm-config) if you initialized your cluster using kubeadm v1.7.x or lower, to configure your cluster for `kubeadm upgrade`
* [kubeadm token](/docs/reference/setup-tools/kubeadm/kubeadm-token) to manage tokens for `kubeadm join`
* [kubeadm reset](/docs/reference/setup-tools/kubeadm/kubeadm-reset) to revert any changes made to this host by `kubeadm init` or `kubeadm join`
* [kubeadm certs](/docs/reference/setup-tools/kubeadm/kubeadm-certs) to manage Kubernetes certificates
* [kubeadm kubeconfig](/docs/reference/setup-tools/kubeadm/kubeadm-kubeconfig) to manage kubeconfig files
* [kubeadm version](/docs/reference/setup-tools/kubeadm/kubeadm-version) to print the kubeadm version
* [kubeadm alpha](/docs/reference/setup-tools/kubeadm/kubeadm-alpha) to preview a set of features made available for gathering feedback from the community
 -->
<ul>
<li><a href="/zh/docs/reference/setup-tools/kubeadm/kubeadm-init">kubeadm init</a>
用于搭建控制平面节点</li>
<li><a href="/zh/docs/reference/setup-tools/kubeadm/kubeadm-join">kubeadm join</a>
用于搭建工作节点并将其加入到集群中</li>
<li><a href="/zh/docs/reference/setup-tools/kubeadm/kubeadm-upgrade">kubeadm upgrade</a>
用于升级 Kubernetes 集群到新版本</li>
<li><a href="/zh/docs/reference/setup-tools/kubeadm/kubeadm-config">kubeadm config</a>
如果你使用了 v1.7.x 或更低版本的 kubeadm 版本初始化你的集群，则使用
<code>kubeadm upgrade</code> 来配置你的集群</li>
<li><a href="/zh/docs/reference/setup-tools/kubeadm/kubeadm-token">kubeadm token</a>
用于管理 <code>kubeadm join</code> 使用的令牌</li>
<li><a href="/zh/docs/reference/setup-tools/kubeadm/kubeadm-reset">kubeadm reset</a>
用于恢复通过 <code>kubeadm init</code> 或者 <code>kubeadm join</code> 命令对节点进行的任何变更</li>
<li><a href="/zh/docs/reference/setup-tools/kubeadm/kubeadm-certs">kubeadm certs</a>
用于管理 Kubernetes 证书</li>
<li><a href="/docs/reference/setup-tools/kubeadm/kubeadm-kubeconfig">kubeadm kubeconfig</a>
用于管理 kubeconfig 文件</li>
<li><a href="/zh/docs/reference/setup-tools/kubeadm/kubeadm-version">kubeadm version</a>
用于打印 kubeadm 的版本信息</li>
<li><a href="/zh/docs/reference/setup-tools/kubeadm/kubeadm-alpha">kubeadm alpha</a>
用于预览一组可用于收集社区反馈的特性</li>
</ul>

</div>



    
      
  
  
  
  

  
  

  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-36c22b52e8447eb3d2452d4f56fbea9b">7.1.1 - 创建 Kubeadm</h1>
    
	
</div>



    
      
  
  
  
  

  
  

  
    
    
	
    

<div class="td-content" style="">
    
	<h1 id="pg-fd3ad295c1f10bfa333f841bbdffba81">7.1.1.1 - </h1>
    
	<h3 id="摘要">摘要</h3>
<!--
    ┌──────────────────────────────────────────────────────────┐
    │ KUBEADM                                                  │
    │ Easily bootstrap a secure Kubernetes cluster             │
    │                                                          │
    │ Please give us feedback at:                              │
    │ https://github.com/kubernetes/kubeadm/issues             │
    └──────────────────────────────────────────────────────────┘
-->
<pre tabindex="0"><code>┌──────────────────────────────────────────────────────────┐
│ KUBEADM                                                  │
│ 轻松创建一个安全的 Kubernetes 集群                       │
│                                                          │
│ 给我们反馈意见的地址：                                   │
│ https://github.com/kubernetes/kubeadm/issues             │
└──────────────────────────────────────────────────────────┘
</code></pre><!-- 
Example usage: 
-->
<p>用途示例：</p>
<!-- 
    Create a two-machine cluster with one control-plane node
    (which controls the cluster), and one worker node
    (where your workloads, like Pods and Deployments run). 
-->
<p>创建一个有两台机器的集群，包含一个主节点（用来控制集群），和一个工作节点（运行您的工作负载，像 Pod 和 Deployment）。</p>
<!--
    ┌──────────────────────────────────────────────────────────┐
    │ On the first machine:                                    │
    ├──────────────────────────────────────────────────────────┤
    │ control-plane# kubeadm init                              │
    └──────────────────────────────────────────────────────────┘

    ┌──────────────────────────────────────────────────────────┐
    │ On the second machine:                                   │
    ├──────────────────────────────────────────────────────────┤
    │ worker# kubeadm join &lt;arguments-returned-from-init&gt;      │
    └──────────────────────────────────────────────────────────┘

    You can then repeat the second step on as many other machines as you like.
-->
<pre tabindex="0"><code>┌──────────────────────────────────────────────────────────┐
│ 在第一台机器上：                                         │
├──────────────────────────────────────────────────────────┤
│ control-plane# kubeadm init                              │
└──────────────────────────────────────────────────────────┘

┌──────────────────────────────────────────────────────────┐
│ 在第二台机器上：                                         │
├──────────────────────────────────────────────────────────┤
│ worker# kubeadm join &amp;lt;arguments-returned-from-init&amp;gt;│
└──────────────────────────────────────────────────────────┘
</code></pre><p>您可以重复第二步，向集群添加更多机器。</p>
<!-- 
### Options 
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for kubeadm
-->
kubeadm 操作的帮助信息 
</td>
</tr>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-185ec44b69a851237e5cbde8b34d60b8">7.1.1.2 - </h1>
    
	<h3 id="概要">概要</h3>
<!--
Kubeadm experimental sub-commands
-->
<p>kubeadm 实验子命令</p>
<!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for alpha
-->
alpha 操作的帮助命令
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 指向 '真实' 宿主机的根文件系统的路径。
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-5106075da35b6c976e6f8d7d225df0ff">7.1.1.3 - </h1>
    
	<h3 id="概要">概要</h3>
<!--
Kubeconfig file utilities.
-->
<p>kubeconfig 文件应用程序。</p>
<!-- Alpha Disclaimer: this command is currently alpha.  -->
<p>Alpha 免责声明：此命令当前为 alpha 功能。</p>
<!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- help for kubeconfig -->
kubeconfig 操作的帮助命令
</td>
</tr>
</tbody>
</table>
<!-- ### Options inherited from parent commands -->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-d7af99919faca6010658b893fa2a6890">7.1.1.4 - </h1>
    
	<h3 id="概要">概要</h3>
<!--
Output a kubeconfig file for an additional user.
-->
<p>为其他用户输出 kubeconfig 文件。</p>
<!--
Alpha Disclaimer: this command is currently alpha.
-->
<p>Alpha 免责声明：此命令当前为 Alpha 功能。</p>
<pre tabindex="0"><code>kubeadm alpha kubeconfig user [flags]
</code></pre><!--
### Examples # Output a kubeconfig file for an additional user named foo

```
  # Output a kubeconfig file for an additional user named foo using a kubeadm config file bar
  kubeadm alpha kubeconfig user --client-name=foo --config=bar
```
-->
<h3 id="示例">示例</h3>
<pre tabindex="0"><code># 使用名为 bar 的 kubeadm 配置文件为名为 foo 的另一用户输出 kubeconfig 文件
kubeadm alpha kubeconfig user --client-name=foo --config=bar
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--client-name string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The name of user. It will be used as the CN if client certificates are created
-->
用户名。如果生成客户端证书，则用作其 CN。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to a kubeadm configuration file.
-->
指向 kubeadm 配置文件的路径
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for user
-->
user 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">--org stringSlice</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The orgnizations of the client certificate. It will be used as the O if client certificates are created
-->
客户端证书的组织。如果创建客户端证书，此值将用作其 O 字段值。
</td>
</tr>
<tr>
<td colspan="2">--token string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The token that should be used as the authentication mechanism for this kubeconfig, instead of client certificates
-->
应该用此 kubeconfig 的身份验证机制的令牌，而不是客户端证书
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 指向 '真实' 宿主机的根目录。
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-8df9aba508b2736a6712ef46227eea7d">7.1.1.5 - </h1>
    
	<h3 id="概要">概要</h3>
<!--
Commands related to handling kubernetes certificates
-->
<p>与处理 kubernetes 证书相关的命令</p>
<!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<!-- td></td><td style="line-height: 130%; word-wrap: break-word;">help for certs</td -->
<td></td><td style="line-height: 130%; word-wrap: break-word;"><!-- help for certs-->certs 命令的帮助</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="继承于父命令的选项">继承于父命令的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<!-- td></td><td style="line-height: 130%; word-wrap: break-word;">[EXPERIMENTAL] The path to the 'real' host root filesystem.</td -->
<td></td><td style="line-height: 130%; word-wrap: break-word;">[实验] 到'真实'主机根文件系统的路径。</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-018648dfc6f28bc9b969f45af0563cae">7.1.1.6 - </h1>
    
	<h3 id="概要">概要</h3>
<!--
This command will print out a secure randomly-generated certificate key that can be used with
the "init" command.
-->
<p>该命令将打印出可以与 &quot;init&quot; 命令一起使用的安全的随机生成的证书密钥。</p>
<!--
You can also use "kubeadm init -upload-certs" without specifying a certificate key and it will generate and print one for you.
-->
<p>你也可以使用 <code>kubeadm init --upload-certs</code> 而无需指定证书密钥；
命令将为你生成并打印一个证书密钥。</p>
<pre tabindex="0"><code>kubeadm certs certificate-key [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for certificate-key
-->
certificate-key 操作的帮助命令
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-4a1ff27cdf01c1c47d034278048e776b">7.1.1.7 - </h1>
    
	<h3 id="概要">概要</h3>
<!-- 
Checks expiration for the certificates in the local PKI managed by kubeadm.
-->
<p>检查 kubeadm 管理的本地 PKI 中证书的到期时间。</p>
<pre tabindex="0"><code>kubeadm certs check-expiration [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<!--
<td colspan="2">--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"</td> 
-->
<td colspan="2">--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值: "/etc/kubernetes/pki"</td>
</tr>
<tr>
<!--
<td></td><td style="line-height: 130%; word-wrap: break-word;">The path where to save the certificates</td>
-->
<td></td><td style="line-height: 130%; word-wrap: break-word;">保存证书的路径</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<!-- td></td><td style="line-height: 130%; word-wrap: break-word;">Path to a kubeadm configuration file.</td -->
<td></td><td style="line-height: 130%; word-wrap: break-word;">kubeadm 配置文件的路径</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<!-- td></td><td style="line-height: 130%; word-wrap: break-word;">help for check-expiration</td -->
<td></td><td style="line-height: 130%; word-wrap: break-word;">check-expiration 的帮助命令</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="继承于父命令的选项">继承于父命令的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<!-- td></td><td style="line-height: 130%; word-wrap: break-word;">[EXPERIMENTAL] The path to the 'real' host root filesystem.</td -->
<td></td><td style="line-height: 130%; word-wrap: break-word;">[实验] 到'真实'主机根文件系统的路径。</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-5d6b2999153cd86f56329534249fc4ec">7.1.1.8 - </h1>
    
	<p>为运行控制平面所需的所有证书生成密钥和证书签名请求（CSR）。该命令会生成部分 kubeconfig 文件，
其中 &quot;users &gt; user &gt; client-key-data&quot; 字段包含私钥数据，并为每个 kubeconfig
文件创建一个随附的 &quot;.csr&quot; 文件。</p>
<!--  
This command is designed for use in [Kubeadm External CA Mode](https://kubernetes.io/docs/tasks/administer-cluster/kubeadm/kubeadm-certs/#external-ca-mode). It generates CSRs which you can then submit to your external certificate authority for signing.
-->
<p>此命令设计用于
<a href="https://kubernetes.io/zh/docs/tasks/administer-cluster/kubeadm/kubeadm-certs/#external-ca-mode">Kubeadm 外部 CA 模式</a>。 
它生成你可以提交给外部证书颁发机构进行签名的 CSR。</p>
<!--  
The PEM encoded signed certificates should then be saved alongside the key files, using ".crt" as the file extension, or in the case of kubeconfig files, the PEM encoded signed certificate should be base64 encoded and added to the kubeconfig file in the "users &gt; user &gt; client-certificate-data" field.
-->
<p>应使用 &quot;.crt&quot; 作为文件扩展名将 PEM 编码的签名证书与密钥文件一起保存。
或者，对于 kubeconfig 文件，PEM 编码的签名证书应使用 base64 编码，
并添加到 &quot;users &gt; user &gt; client-certificate-data&quot; 字段。</p>
<pre tabindex="0"><code>kubeadm certs generate-csr [flags]
</code></pre><!--
### Examples
-->
<h3 id="示例">示例</h3>
<!-- 
```
  # The following command will generate keys and CSRs for all control-plane certificates and kubeconfig files:
  kubeadm certs generate-csr --kubeconfig-dir /tmp/etc-k8s --cert-dir /tmp/etc-k8s/pki
```
-->
<pre tabindex="0"><code># 以下命令将为所有控制平面证书和 kubeconfig 文件生成密钥和 CSR :
kubeadm certs generate-csr --kubeconfig-dir /tmp/etc-k8s --cert-dir /tmp/etc-k8s/pki
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--cert-dir string</td>
</tr>
<tr>
<!-- td></td><td style="line-height: 130%; word-wrap: break-word;">The path where to save the certificates</td-->
<td></td><td style="line-height: 130%; word-wrap: break-word;">保存证书的路径</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<!-- td></td><td style="line-height: 130%; word-wrap: break-word;">Path to a kubeadm configuration file.</td -->
<td></td><td style="line-height: 130%; word-wrap: break-word;">kubeadm 配置文件的路径。</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<!-- td></td><td style="line-height: 130%; word-wrap: break-word;">help for generate-csr</td -->
<td></td><td style="line-height: 130%; word-wrap: break-word;">generate-csr 命令的帮助</td>
</tr>
<tr>
<!-- td colspan="2">-kubeconfig-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes"</td -->
<td colspan="2">--kubeconfig-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes"</td>
</tr>
<tr>
<!-- td></td><td style="line-height: 130%; word-wrap: break-word;">The path where to save the kubeconfig file.</td-->
<td></td><td style="line-height: 130%; word-wrap: break-word;">保存 kubeconfig 文件的路径。</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="继承于父命令的选项">继承于父命令的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<!-- <td></td><td style="line-height: 130%; word-wrap: break-word;">[EXPERIMENTAL] The path to the 'real' host root filesystem.</td> -->
<td></td><td style="line-height: 130%; word-wrap: break-word;">[实验] 到'真实'主机根文件系统的路径。</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-adb5eecdc351074cc2e0cc2b1b4f04a8">7.1.1.9 - </h1>
    
	<h3 id="概要">概要</h3>
<!--
This command is not meant to be run on its own. See list of available subcommands.
-->
<p>此命令并非设计用来单独运行。请参阅可用子命令列表。</p>
<pre tabindex="0"><code>kubeadm certs renew [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for renew
-->
renew 操作的帮助命令
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-df4c2dc6cba0be90d8d7de2fca9b87f7">7.1.1.10 - </h1>
    
	<h3 id="概要">概要</h3>
<!--
Renew the certificate embedded in the kubeconfig file for the admin to use and for kubeadm itself.
-->
<p>续订 kubeconfig 文件中嵌入的证书，供管理员 和 kubeadm 自身使用。</p>
<!--
Renewals run unconditionally, regardless of certificate expiration date; extra attributes such as SANs will be based on the existing file/certificates, there is no need to resupply them.
-->
<p>无论证书的到期日期如何，续订都是无条件进行的；SAN 等额外属性将基于现有文件/证书，因此无需重新提供它们。</p>
<!--
Renewal by default tries to use the certificate authority in the local PKI managed by kubeadm; as alternative it is possible to use K8s certificate API for certificate renewal, or as a last option, to generate a CSR request.
-->
<p>默认情况下，续订会尝试使用由 kubeadm 管理的本地 PKI 中的证书机构；作为替代方案，
也可以使用 K8s 证书 API 进行证书续订，或者（作为最后一种选择）生成 CSR 请求。</p>
<!--
After renewal, in order to make changes effective, is is required to restart control-plane components and eventually re-distribute the renewed certificate in case the file is used elsewhere.
-->
<p>续订后，为了使更改生效，需要重新启动控制平面组件，并最终重新分发更新的证书，以防证书文件在其他地方使用。</p>
<pre tabindex="0"><code>kubeadm certs renew admin.conf [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">
<!-- --cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki" -->
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The path where to save the certificates.
-->
保存证书的路径。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- Path to a kubeadm configuration file.  -->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">--csr-dir string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- The path to output the CSRs and private keys to -->
CSR 和私钥的输出路径
</td>
</tr>
<tr>
<td colspan="2">--csr-only</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Create CSRs instead of generating certificates
-->
创建 CSR 而不是生成证书
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- help for admin.conf -->
admin.conf 子操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.  -->
与集群通信时使用的 kubeconfig 文件。
如果未设置该参数，则可以在一组标准位置中搜索现有的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan="2">--use-api</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Use the Kubernetes certificate API to renew certificates
-->
使用 Kubernetes 证书 API 续订证书
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-6d6746e8ac1f1602f7dab1056b27e5c2">7.1.1.11 - </h1>
    
	<h3 id="概要">概要</h3>
<!--
Renew all known certificates necessary to run the control plane. Renewals are run unconditionally, regardless of expiration date. Renewals can also be run individually for more control.
-->
<p>续订运行控制平面所需的所有已知证书。续订是无条件进行的，与到期日期无关。续订也可以单独运行以进行更多控制。</p>
<pre tabindex="0"><code>kubeadm certs renew all [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">
<!--
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"
-->
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The path where to save and store the certificates.
-->
存储证书的路径。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to a kubeadm configuration file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">--csr-dir string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The path to output the CSRs and private keys to
-->
输出 CSR 和私钥的路径
</td>
</tr>
<tr>
<td colspan="2">--csr-only</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Create CSRs instead of generating certificates
-->
创建 CSR 而不是生成证书
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for all
-->
all 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"
-->
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.
-->
与集群通信时使用的 kubeconfig 文件。
如果未设置该参数，则可以在一组标准位置中搜索现有的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan="2">--use-api</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Use the Kubernetes certificate API to renew certificates
-->
使用 Kubernetes 证书 API 续订证书
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-7449c7fa06f25b967cf531e937b0f4b2">7.1.1.12 - </h1>
    
	<h3 id="概要">概要</h3>
<!--
Renew the certificate the apiserver uses to access etcd.
-->
<p>续订 apiserver 用于访问 etcd 的证书。</p>
<!--
Renewals run unconditionally, regardless of certificate expiration date; extra attributes such as SANs will be based on the existing file/certificates, there is no need to resupply them.
-->
<p>无论证书的到期日期如何，续订都会无条件地进行；SAN 等额外属性将基于现有文件/证书，因此无需重新提供它们。</p>
<!--
Renewal by default tries to use the certificate authority in the local PKI managed by kubeadm; as alternative it is possible to use K8s certificate API for certificate renewal, or as a last option, to generate a CSR request.
-->
<p>默认情况下，续订尝试使用在 kubeadm 所管理的本地 PKI 中的证书颁发机构；作为替代方案，
可以使用 K8s 证书 API 进行证书更新，或者作为最后一个选择来生成 CSR 请求。</p>
<!--
After renewal, in order to make changes effective, is is required to restart control-plane components and eventually re-distribute the renewed certificate in case the file is used elsewhere.
-->
<p>续订后，为了使更改生效，需要重新启动控制平面组件，并最终重新分发更新的证书，以防文件在其他地方使用。</p>
<pre tabindex="0"><code>kubeadm certs renew apiserver-etcd-client [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">
<!-- cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki" -->
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- The path where to save and store the certificates.  -->
存储证书的路径。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- Path to a kubeadm configuration file.  -->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">--csr-dir string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- The path to output the CSRs and private keys to -->
输出 CSR 和私钥的路径
</td>
</tr>
<tr>
<td colspan="2">--csr-only</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- Create CSRs instead of generating certificates -->
创建 CSR 而不是生成证书
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- help for apiserver-etcd-client -->
apiserver-etcd-client 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"
-->
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.
-->
与集群通信时使用的 kubeconfig 文件。
如果未设置该参数，则可以在一组标准位置中搜索现有的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan="2">--use-api</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- Use the Kubernetes certificate API to renew certificates -->
使用 Kubernetes 证书 API 续订证书
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- [EXPERIMENTAL] The path to the 'real' host root filesystem.  -->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-b5c6ae77d3be9bd358c68667006cfc18">7.1.1.13 - </h1>
    
	<h3 id="概要">概要</h3>
<!--
Renew the certificate for the API server to connect to kubelet.
-->
<p>续订 apiserver 用于连接 kubelet 的证书。</p>
<!--
Renewals run unconditionally, regardless of certificate expiration date; extra attributes such as SANs will be based on the existing file/certificates, there is no need to resupply them.
-->
<p>无论证书的到期日期如何，续订都会无条件地进行；SAN 等额外属性将基于现有文件/证书，因此无需重新提供它们。</p>
<!--
Renewal by default tries to use the certificate authority in the local PKI managed by kubeadm; as alternative it is possible to use K8s certificate API for certificate renewal, or as a last option, to generate a CSR request.
-->
<p>默认情况下，续订尝试使用位于 kubeadm 所管理的本地 PKI 中的证书颁发机构；作为替代方案，
也可能调用 K8s 证书 API 进行证书更新；亦或者，作为最后一个选择，生成 CSR 请求。</p>
<!--
After renewal, in order to make changes effective, is is required to restart control-plane components and eventually re-distribute the renewed certificate in case the file is used elsewhere.
-->
<p>续订后，为了使更改生效，需要重新启动控制平面组件，并最终重新分发更新的证书，以防文件在其他地方使用。</p>
<pre tabindex="0"><code>kubeadm certs renew apiserver-kubelet-client [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">
<!--
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"
-->
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The path where to save and store the certificates.
-->
存储证书的路径。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to a kubeadm configuration file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">--csr-dir string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The path to output the CSRs and private keys to
-->
输出 CSR 和私钥的路径
</td>
</tr>
<tr>
<td colspan="2">--csr-only</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Create CSRs instead of generating certificates
-->
创建 CSR 而不是生成证书
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for apiserver-kubelet-client
-->
apiserver-kubelet-client 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"
-->
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.
-->
与集群通信时使用的 kubeconfig 文件。
如果未设置该参数，则可以在一组标准位置中搜索现有的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan="2">--use-api</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Use the Kubernetes certificate API to renew certificates
-->
使用 Kubernetes 证书 API 续订证书
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-4f804e59ec1739e733807d2b591d771f">7.1.1.14 - </h1>
    
	<h3 id="概要">概要</h3>
<!--
Renew the certificate for serving the Kubernetes API.
-->
<p>续订用于提供 Kubernetes API 的证书。</p>
<!--
Renewals run unconditionally, regardless of certificate expiration date; extra attributes such as SANs will be based on the existing file/certificates, there is no need to resupply them.
-->
<p>无论证书的到期日期如何，续订都会无条件地进行；SAN 等额外属性将基于现有文件/证书，因此无需重新提供它们。</p>
<!--
Renewal by default tries to use the certificate authority in the local PKI managed by kubeadm; as alternative it is possible to use K8s certificate API for certificate renewal, or as a last option, to generate a CSR request.
-->
<p>默认情况下，续订尝试在 kubeadm 管理的本地 PKI 中使用证书颁发机构；作为替代方案，
可以使用 K8s 证书 API 进行证书更新，或者作为最后一个选择来生成 CSR 请求。</p>
<!--
After renewal, in order to make changes effective, is is required to restart control-plane components and eventually re-distribute the renewed certificate in case the file is used elsewhere.
-->
<p>续订后，为了使更改生效，需要重新启动控制平面组件，并最终重新分发更新的证书，以防文件在其他地方使用。</p>
<pre tabindex="0"><code>kubeadm certs renew apiserver [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">
<!--
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"
-->
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The path where to save the certificates.
-->
保存证书的路径。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to a kubeadm configuration file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">--csr-dir string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;"> 
<!--
The path to output the CSRs and private keys to
-->
CSR 和私钥的输出路径
</td>
</tr>
<tr>
<td colspan="2">--csr-only</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Create CSRs instead of generating certificates
-->
创建 CSR 而不是生成证书
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for apiserver
-->
apiserver 子操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"
-->
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.
-->
与集群通信时使用的 kubeconfig 文件。
如果未设置该参数，则可以在一组标准位置中搜索现有的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan="2">--use-api</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Use the Kubernetes certificate API to renew certificates
-->
使用 Kubernetes 证书 API 续订证书
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-f5cf8caa95834803b133d53c321ab4a9">7.1.1.15 - </h1>
    
	<h3 id="概要">概要</h3>
<!--
Renew the certificate embedded in the kubeconfig file for the controller manager to use.
-->
<p>续订 kubeconfig 文件中嵌入的证书，以供控制器管理器（Controller Manager）使用。</p>
<!--
Renewals run unconditionally, regardless of certificate expiration date; extra attributes such as SANs will be based on the existing file/certificates, there is no need to resupply them.
-->
<p>续订无条件地进行，与证书的到期日期无关；SAN 等额外属性将基于现有的文件/证书，因此无需重新提供它们。</p>
<!--
Renewal by default tries to use the certificate authority in the local PKI managed by kubeadm; as alternative it is possible to use K8s certificate API for certificate renewal, or as a last option, to generate a CSR request.
-->
<p>默认情况下，续订会尝试使用 kubeadm 管理的本地 PKI 中的证书颁发机构；作为替代方案，
可以使用 K8s 证书 API 进行证书续订；亦或者，作为最后一种选择，生成 CSR 请求。</p>
<!--
After renewal, in order to make changes effective, is is required to restart control-plane components and eventually re-distribute the renewed certificate in case the file is used elsewhere.
-->
<p>续订后，为了使更改生效，需要重新启动控制平面组件，并最终重新分发更新的证书，以防文件在其他地方使用。</p>
<pre tabindex="0"><code>kubeadm alpha renew controller-manager.conf [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">
<!--
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"
-->
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The path where to save the certificates.
-->
保存证书的路径。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to a kubeadm configuration file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">--csr-dir string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The path to output the CSRs and private keys to
-->
CSR 和私钥的输出路径
</td>
</tr>
<tr>
<td colspan="2">--csr-only</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Create CSRs instead of generating certificates
-->
创建 CSR 而不是生成证书
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for controller-manager.conf
-->
controller-manager.conf 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"
-->
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.
-->
与集群通信时使用的 kubeconfig 文件。
如果未设置该参数，则可以在一组标准位置中搜索现有的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan="2">--use-api</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Use the Kubernetes certificate API to renew certificates
-->
使用 Kubernetes 证书 API 续订证书
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-ee770858e2bb767b79d572b4882af656">7.1.1.16 - </h1>
    
	<h3 id="概要">概要</h3>
<!--
Renew the certificate for liveness probes to healthcheck etcd.
-->
<p>续订存活态探针的证书，用于对 etcd 执行健康检查。</p>
<!--
Renewals run unconditionally, regardless of certificate expiration date; extra attributes such as SANs will be based on the existing file/certificates, there is no need to resupply them.
-->
<p>无论证书的到期日期如何，续订都是无条件进行的；SAN 等额外属性将基于现有文件/证书，因此无需重新提供它们。</p>
<!--
Renewal by default tries to use the certificate authority in the local PKI managed by kubeadm; as alternative it is possible to use K8s certificate API for certificate renewal, or as a last option, to generate a CSR request.
-->
<p>默认情况下，续订会尝试使用由 kubeadm 管理的本地 PKI 中的证书机构；作为替代方案，
也可以使用 K8s certificate API 进行证书续订，或者（作为最后一种选择）生成 CSR 请求。</p>
<!--
After renewal, in order to make changes effective, is is required to restart control-plane components and eventually re-distribute the renewed certificate in case the file is used elsewhere.
-->
<p>续订后，为了使更改生效，需要重新启动控制平面组件，并最终重新分发更新的证书，以防证书文件在其他地方使用。</p>
<pre tabindex="0"><code>kubeadm certs renew etcd-healthcheck-client [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">
<!--
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"
-->
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The path where to save the certificates.
-->
保存证书的路径。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to a kubeadm configuration file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">--csr-dir string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The path to output the CSRs and private keys to
-->
CSR 和私钥的输出路径
</td>
</tr>
<tr>
<td colspan="2">--csr-only</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Create CSRs instead of generating certificates
-->
创建 CSR 而不是生成证书
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for etcd-healthcheck-client
-->
etcd-healthcheck-client 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"
-->
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.
-->
与集群通信时使用的 kubeconfig 文件。
如果未设置该参数，则可以在一组标准位置中搜索现有的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan="2">--use-api</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Use the Kubernetes certificate API to renew certificates
-->
使用 Kubernetes 证书 API 续订证书
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-7484bf11b6183f4c329b1f66734cc886">7.1.1.17 - </h1>
    
	<h3 id="概要">概要</h3>
<!--
Renew the certificate for etcd nodes to communicate with each other.
-->
<p>续订 etcd 节点间用来相互通信的证书。</p>
<!--
Renewals run unconditionally, regardless of certificate expiration date; extra attributes such as SANs will be based on the existing file/certificates, there is no need to resupply them.
-->
<p>无论证书的到期日期如何，续订都是无条件进行的；SAN 等额外属性将基于现有文件/证书，因此无需重新提供它们。</p>
<!--
Renewal by default tries to use the certificate authority in the local PKI managed by kubeadm; as alternative it is possible to use K8s certificate API for certificate renewal, or as a last option, to generate a CSR request.
-->
<p>默认情况下，续订会尝试使用由 kubeadm 管理的本地 PKI 中的证书机构；
作为替代方案，也可以使用 K8s certificate API 进行证书续订，或者（作为最后一种选择）生成 CSR 请求。</p>
<!--
After renewal, in order to make changes effective, is is required to restart control-plane components and eventually re-distribute the renewed certificate in case the file is used elsewhere.
-->
<p>续订后，为了使更改生效，需要重新启动控制平面组件，并最终重新分发更新的证书，以防证书文件在其他地方使用。</p>
<pre tabindex="0"><code>kubeadm certs renew etcd-peer [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">
<!--
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"
-->
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The path where to save the certificates.
-->
保存证书的路径。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to a kubeadm configuration file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">--csr-dir string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The path to output the CSRs and private keys to
-->
CSR 和私钥的输出路径
</td>
</tr>
<tr>
<td colspan="2">--csr-only</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Create CSRs instead of generating certificates
-->
创建 CSR 而不是生成证书
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for etcd-peer
-->
etcd-peer 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"
-->
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.
-->
与集群通信时使用的 kubeconfig 文件。
如果未设置该参数，则可以在一组标准位置中搜索现有的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan="2">--use-api</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Use the Kubernetes certificate API to renew certificates
-->
使用 Kubernetes 证书 API 续订证书
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-bf444d915ab856dba693c36294c5427b">7.1.1.18 - </h1>
    
	<h3 id="概要">概要</h3>
<!--
Renew the certificate for serving etcd.
-->
<p>续订用于提供 etcd 服务的证书。</p>
<!--
Renewals run unconditionally, regardless of certificate expiration date; extra attributes such as SANs will be based on the existing file/certificates, there is no need to resupply them.
-->
<p>续订无条件地进行，与证书的到期日期无关；SAN 等额外属性将基于现有的文件/证书，因此无需重新提供它们。</p>
<!--
Renewal by default tries to use the certificate authority in the local PKI managed by kubeadm; as alternative it is possible to use K8s certificate API for certificate renewal, or as a last option, to generate a CSR request.
-->
<p>默认情况下，续订会尝试在 kubeadm 管理的本地 PKI 中使用证书颁发机构；作为替代方案，
可以使用 K8s 证书 API 进行证书续订，或者作为最后一种选择来生成 CSR 请求。</p>
<!--
After renewal, in order to make changes effective, is is required to restart control-plane components and eventually re-distribute the renewed certificate in case the file is used elsewhere.
-->
<p>续订后，为了使更改生效，需要重新启动控制平面组件，并最终重新分发更新的证书，以防文件在其他地方使用。</p>
<pre tabindex="0"><code>kubeadm certs renew etcd-server [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">
<!--
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"
-->
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The path where to save the certificates.
-->
保存证书的路径。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to a kubeadm configuration file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">--csr-dir string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The path to output the CSRs and private keys to
-->
CSR 和私钥的输出路径
</td>
</tr>
<tr>
<td colspan="2">--csr-only</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Create CSRs instead of generating certificates
-->
创建 CSR 而不是生成证书
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for etcd-server
-->
etcd-server 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"
-->
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.
-->
与集群通信时使用的 kubeconfig 文件。
如果未设置该参数，则可以在一组标准位置中搜索现有的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan="2">--use-api</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Use the Kubernetes certificate API to renew certificates
-->
使用 Kubernetes 证书 API 续订证书
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-f5c087e087714c5290b4967dd7924b3b">7.1.1.19 - </h1>
    
	<h3 id="概要">概要</h3>
<!--
Renew the certificate for the front proxy client.
-->
<p>为前端代理客户端续订证书。</p>
<!--
Renewals run unconditionally, regardless of certificate expiration date; extra attributes such as SANs will be based on the existing file/certificates, there is no need to resupply them.
-->
<p>无论证书的到期日期如何，续订都会无条件地进行；SAN 等额外属性将基于现有文件/证书，因此无需重新提供它们。</p>
<!--
Renewal by default tries to use the certificate authority in the local PKI managed by kubeadm; as alternative it is possible to use K8s certificate API for certificate renewal, or as a last option, to generate a CSR request.
-->
<p>默认情况下，续订尝试使用位于 kubeadm 所管理的本地 PKI 中的证书颁发机构；作为替代方案，
也可以使用 K8s 证书 API 进行证书续订；亦或者，作为最后一种方案，生成 CSR 请求。</p>
<!--
After renewal, in order to make changes effective, is is required to restart control-plane components and eventually re-distribute the renewed certificate in case the file is used elsewhere.
-->
<p>续订后，为了使更改生效，需要重新启动控制平面组件，并最终重新分发更新的证书，以防文件在其他地方使用。</p>
<pre tabindex="0"><code>kubeadm certs renew front-proxy-client [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<!-- td colspan="2">--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"</td -->
<td colspan="2">--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The path where to save the certificates
-->
存储证书的路径。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to a kubeadm configuration file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">--csr-dir string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The path to output the CSRs and private keys to
-->
输出 CSR 和私钥的路径
</td>
</tr>
<tr>
<td colspan="2">--csr-only</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Create CSRs instead of generating certificates
-->
创建 CSR 而不是生成证书
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for front-proxy-client
-->
front-proxy-client 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"
-->
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.
-->
与集群通信时使用的 kubeconfig 文件。
如果未设置该参数，则可以在一组标准位置中搜索现有的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan="2">--use-api</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Use the Kubernetes certificate API to renew certificates
-->
使用 Kubernetes 证书 API 续订证书
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-20703ce1c236264ad78cb1ad7244723e">7.1.1.20 - </h1>
    
	<h3 id="概要">概要</h3>
<!--
Renew the certificate embedded in the kubeconfig file for the scheduler manager to use.
-->
<p>续订 kubeconfig 文件中嵌入的证书，以供调度管理器使用。</p>
<!--
Renewals run unconditionally, regardless of certificate expiration date; extra attributes such as SANs will be based on the existing file/certificates, there is no need to resupply them.
-->
<p>续订无条件地进行，与证书的到期日期无关；SAN 等额外属性将基于现有的文件/证书，因此无需重新提供它们。</p>
<!--
Renewal by default tries to use the certificate authority in the local PKI managed by kubeadm; as alternative it is possible to use K8s certificate API for certificate renewal, or as a last option, to generate a CSR request.
-->
<p>默认情况下，续订会尝试使用在 kubeadm 所管理的本地 PKI 中的证书颁发机构；作为替代方案，
也可以使用 K8s 证书 API 进行证书续订；亦或者，作为最后一种选择，生成 CSR 请求。</p>
<!--
After renewal, in order to make changes effective, is is required to restart control-plane components and eventually re-distribute the renewed certificate in case the file is used elsewhere.
-->
<p>续订后，为了使更改生效，需要重新启动控制平面组件，并最终重新分发更新的证书，以防文件在其他地方使用。</p>
<pre tabindex="0"><code>kubeadm certs renew scheduler.conf [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">
<!--
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"
-->
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The path where to save the certificates.
-->
保存证书的路径。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to a kubeadm configuration file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">--csr-dir string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The path to output the CSRs and private keys to
-->
CSR 和私钥的输出路径
</td>
</tr>
<tr>
<td colspan="2">--csr-only</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Create CSRs instead of generating certificates
-->
创建 CSR 而不是生成证书
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for scheduler.conf
-->
scheduler.conf 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"
-->
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.
-->
与集群通信时使用的 kubeconfig 文件。
如果未设置该参数，则可以在一组标准位置中搜索现有的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan="2">--use-api</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Use the Kubernetes certificate API to renew certificates
-->
使用 Kubernetes 证书 API 续订证书
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-49aaa494ef75de67609987a43e5ee520">7.1.1.21 - </h1>
    
	<h3 id="概要">概要</h3>
<!--
Output shell completion code for the specified shell (bash or zsh).
The shell code must be evaluated to provide interactive
completion of kubeadm commands. This can be done by sourcing it from
the .bash_profile.
-->
<p>为指定的 shell（bash 或 zsh）输出 shell 自动补全代码。
必须激活 shell 代码以提供交互式 kubeadm 命令补全。这可以通过加载 .bash_profile 文件完成。</p>
<!--
Note: this requires the bash-completion framework.
-->
<p>注意: 此功能依赖于 <code>bash-completion</code> 框架。</p>
<!--
To install it on Mac use homebrew:
    $ brew install bash-completion
Once installed, bash_completion must be evaluated. This can be done by adding the
following line to the .bash_profile
    $ source $(brew --prefix)/etc/bash_completion
-->
<p>在 Mac 上使用 homebrew 安装:</p>
<pre tabindex="0"><code>brew install bash-completion
</code></pre><p>安装后，必须激活 bash_completion。这可以通过在 .bash_profile 文件中添加下面的命令行来完成</p>
<pre tabindex="0"><code>source $(brew --prefix)/etc/bash_completion
</code></pre><!--
If bash-completion is not installed on Linux, please install the 'bash-completion' package
via your distribution's package manager.
-->
<p>如果在 Linux 上没有安装 bash-completion，请通过您的发行版的包管理器安装 <code>bash-completion</code> 软件包。</p>
<!--
Note for zsh users: [1] zsh completions are only supported in versions of zsh &gt;= 5.2
-->
<p>zsh 用户注意事项：[1] zsh 自动补全仅在 &gt;=v5.2 及以上版本中支持。</p>
<pre tabindex="0"><code>kubeadm completion SHELL [flags]
</code></pre><!--
### Examples
-->
<h3 id="示例">示例</h3>
<!--
# Install bash completion on a Mac using homebrew
brew install bash-completion
printf "\n# Bash completion support\nsource $(brew --prefix)/etc/bash_completion\n" >> $HOME/.bash_profile
source $HOME/.bash_profile

# Load the kubeadm completion code for bash into the current shell
source <(kubeadm completion bash)

# Write bash completion code to a file and source if from .bash_profile
kubeadm completion bash > ~/.kube/kubeadm_completion.bash.inc
printf "\n# Kubeadm shell completion\nsource '$HOME/.kube/kubeadm_completion.bash.inc'\n" >> $HOME/.bash_profile
source $HOME/.bash_profile

# Load the kubeadm completion code for zsh[1] into the current shell
source <(kubeadm completion zsh)
-->
<pre tabindex="0"><code># 在 Mac 上使用 homebrew 安装 bash completion
brew install bash-completion
printf &quot;\n# Bash completion support\nsource $(brew --prefix)/etc/bash_completion\n&quot; &gt;&gt; $HOME/.bash_profile
source $HOME/.bash_profile

# 将 bash 版本的 kubeadm 自动补全代码加载到当前 shell 中
source &lt;(kubeadm completion bash)

# 将 bash 自动补全完成代码写入文件并且从 .bash_profile 文件加载它
printf &quot;\n# Kubeadm shell completion\nsource '$HOME/.kube/kubeadm_completion.bash.inc'\n&quot; &gt;&gt; $HOME/.bash_profile
source $HOME/.bash_profile

# 将 zsh 版本的 kubeadm 自动补全代码加载到当前 shell 中
source &lt;(kubeadm completion zsh)
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- help for completion -->
completion 操作的帮助命令
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-d63311c16e6468f5a5940aadd902faa7">7.1.1.22 - </h1>
    
	<h3 id="概要">概要</h3>
<!--
There is a ConfigMap in the kube-system namespace called "kubeadm-config" that kubeadm
uses to store internal configuration about the cluster. kubeadm CLI v1.8.0+ automatically
creates this ConfigMap with the config used with 'kubeadm init', but if you
initialized your cluster using kubeadm v1.7.x or lower, you must use the 'config upload'
command to create this ConfigMap. This is required so that 'kubeadm upgrade' can configure
your upgraded cluster correctly.
-->
<p>kube-system 命名空间里有一个名为 &quot;kubeadm-config&quot; 的 ConfigMap，kubeadm 用它来存储有关集群的内部配置。
kubeadm CLI v1.8.0+ 通过一个配置自动创建该 ConfigMap，这个配置是和 'kubeadm init' 共用的。
但是您如果使用 kubeadm v1.7.x 或更低的版本初始化集群，那么必须使用 'config upload' 命令创建该 ConfigMap。
这是必要的操作，目的是使 'kubeadm upgrade' 能够正确地配置升级后的集群。</p>
<pre tabindex="0"><code>kubeadm config [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- help for config -->
config 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"
-->
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- The kubeconfig file to use when talking to the cluster.
If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.
-->
用于和集群通信的 kubeconfig 文件。如果它没有被设置，那么 kubeadm 将会搜索一个已经存在于标准路径的 kubeconfig 文件
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- [EXPERIMENTAL] The path to the 'real' host root filesystem.  -->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-6678a79b85306310066616185153377d">7.1.1.23 - </h1>
    
	<h3 id="概要">概要</h3>
<!--
Interact with container images used by kubeadm.
-->
<p>与 kubeadm 使用的容器镜像交互。</p>
<pre tabindex="0"><code>kubeadm config images [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for images
-->
images 的帮助命令
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">
<!--
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"
-->
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.
-->
用于和集群通信的 kubeconfig 文件。如果它没有被设置，那么 kubeadm 将会搜索一个已经存在于标准路径的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-8f73e208cc67d221165f6294393881a7">7.1.1.24 - </h1>
    
	<h3 id="概要">概要</h3>
<!--
Print a list of images kubeadm will use. The configuration file is used in case any images or image repositories are customized.
-->
<p>打印 kubeadm 要使用的镜像列表。配置文件用于自定义任何镜像或镜像存储库。</p>
<pre tabindex="0"><code>kubeadm config images list [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">
<!-- --allow-missing-template-keys&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: true -->
--allow-missing-template-keys&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：true
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- 
If true, ignore any errors in templates when a field or map key is missing in the template. Only applies to golang and jsonpath output formats.
-->
如果设置为 true，则在模板中缺少字段或哈希表的键时忽略模板中的任何错误。
仅适用于 golang 和 jsonpath 输出格式。
</td>
</tr>
<tr>
<td colspan="2">
<!-- -o, --experimental-output string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "text" -->
-o, --experimental-output string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："text"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--  
Output format. One of: text|json|yaml|go-template|go-template-file|template|templatefile|jsonpath|jsonpath-as-json|jsonpath-file.
-->
输出格式：text|json|yaml|go-template|go-template-file|template|templatefile|jsonpath|jsonpath-as-json|jsonpath-file 其中之一
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to a kubeadm configuration file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">--feature-gates string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
A set of key=value pairs that describe feature gates for various features. Options are:<br/>IPv6DualStack=true|false (ALPHA - default=false)
-->
一组键值对（key=value），用于描述各种特征。选项是：
<br/>Auditing=true|false (ALPHA - 默认=false)
<br/>CoreDNS=true|false (默认=true)
<br/>DynamicKubeletConfig=true|false (BETA - 默认=false)
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for list
-->
list 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">
<!-- --image-repository string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "k8s.gcr.io" -->
--image-repository string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："k8s.gcr.io"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- Choose a container registry to pull control plane images from -->
选择要从中拉取控制平面镜像的容器仓库
</td>
</tr>
<tr>
<td colspan="2">
<!--
--image-repository string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "k8s.gcr.io"
-->
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Choose a container registry to pull control plane images from
-->
为控制平面选择一个特定的 Kubernetes 版本
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">
<!--
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"
-->
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.
-->
用于和集群通信的 kubeconfig 文件。如果它没有被设置，那么 kubeadm 将会搜索一个已经存在于标准路径的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-9aec3477159c105a46f4479de1c21418">7.1.1.25 - </h1>
    
	<h3 id="概要">概要</h3>
<!--
Pull images used by kubeadm.
-->
<p>拉取 kubeadm 使用的镜像。</p>
<pre tabindex="0"><code>kubeadm config images pull [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to a kubeadm configuration file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">--cri-socket string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to the CRI socket to connect. If empty kubeadm will try to auto-detect this value; use this option only if you have more than one CRI installed or if you have non-standard CRI socket.
-->
要连接的 CRI 套接字的路径。如果为空，则 kubeadm 将尝试自动检测此值；仅当安装了多个 CRI 或具有非标准 CRI 插槽时，才使用此选项。
</td>
</tr>
<tr>
<td colspan="2">--feature-gates string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
A set of key=value pairs that describe feature gates for various features. Options are:<br/>IPv6DualStack=true|false (ALPHA - default=false)
-->
一系列键值对（key=value），用于描述各种特征。可选项是：<br/>IPv6DualStack=true|false (ALPHA - 默认值=false)
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for pull
-->
pull 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">
<!--
--image-repository string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "k8s.gcr.io"
-->
--image-repository string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："k8s.gcr.io"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Choose a container registry to pull control plane images from
-->
选择用于拉取控制平面镜像的容器仓库
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "stable-1"
-->
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Choose a specific Kubernetes version for the control plane.
-->
为控制平面选择一个特定的 Kubernetes 版本。
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">
<!--
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"
-->
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.
-->
用于和集群通信的 kubeconfig 文件。如果它没有被设置，那么 kubeadm 将会搜索一个已经存在于标准路径的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-045e41c28798930e21f77a90c3a90263">7.1.1.26 - </h1>
    
	<h3 id="概要">概要</h3>
<!--
This command lets you convert configuration objects of older versions to the latest supported version,
locally in the CLI tool without ever touching anything in the cluster.
In this version of kubeadm, the following API versions are supported:
- kubeadm.k8s.io/v1beta2
-->
<p>此命令允许您在 CLI 工具中将本地旧版本的配置对象转换为最新支持的版本，而无需变更集群中的任何内容。在此版本的 kubeadm 中，支持以下 API 版本：</p>
<ul>
<li>kubeadm.k8s.io/v1beta2</li>
</ul>
<!--
Further, kubeadm can only write out config of version "kubeadm.k8s.io/v1beta2", but read both types.
So regardless of what version you pass to the --old-config parameter here, the API object will be
read, deserialized, defaulted, converted, validated, and re-serialized when written to stdout or
--new-config if specified.
-->
<p>因此，无论您在此处传递 --old-config 参数的版本是什么，当写入到 stdout 或 --new-config （如果已指定）时，
都会读取、反序列化、默认、转换、验证和重新序列化 API 对象。</p>
<!--
In other words, the output of this command is what kubeadm actually would read internally if you
submitted this file to "kubeadm init"
-->
<p>换句话说，如果您将此文件传递给 &quot;kubeadm init&quot;，则该命令的输出就是 kubeadm 实际上在内部读取的内容。</p>
<pre tabindex="0"><code>kubeadm config migrate [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- help for migrate -->
migrate 操作的帮助信息
</td>
</tr>
<tr>
<td colspan="2">--new-config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to the resulting equivalent kubeadm config file using the new API version. Optional, if not specified output will be sent to STDOUT.
-->
使用新的 API 版本生成的 kubeadm 配置文件的路径。这个路径是可选的。如果没有指定，输出将被写到 stdout。
</td>
</tr>
<tr>
<td colspan="2">--old-config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to the kubeadm config file that is using an old API version and should be converted. This flag is mandatory.
-->
使用旧 API 版本且应转换的 kubeadm 配置文件的路径。此参数是必需的。
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">
<!-- kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf" -->
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.
-->
用于和集群通信的 kubeconfig 文件。如果未设置，那么 kubeadm 将会搜索一个已经存在于标准路径的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- [EXPERIMENTAL] The path to the 'real' host root filesystem.  -->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-e7d83478123771ad14f475ee44440303">7.1.1.27 - </h1>
    
	<!--
Print configuration
-->
<p>打印配置</p>
<!--
### Synopsis
-->
<h3 id="概要">概要</h3>
<!--
This command prints configurations for subcommands provided.
For details, see: https://godoc.org/k8s.io/kubernetes/cmd/kubeadm/app/apis/kubeadm/v1beta2
-->
<p>此命令打印子命令所提供的配置信息。
相关细节可参阅 <a href="https://godoc.org/k8s.io/kubernetes/cmd/kubeadm/app/apis/kubeadm/v1beta2">https://godoc.org/k8s.io/kubernetes/cmd/kubeadm/app/apis/kubeadm/v1beta2</a></p>
<pre tabindex="0"><code>kubeadm config print [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;"><p><!--help for print-->print 命令的帮助信息</p></td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承而来的选项">从父命令继承而来的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值："/etc/kubernetes/admin.conf"</td>
</tr>
<tr>
<!--td></td><td style="line-height: 130%; word-wrap: break-word;"><p>The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.</p></td -->
<td></td><td style="line-height: 130%; word-wrap: break-word;"><p>与集群通信时使用的 kubeconfig 文件。如此标志未设置，将在一组标准位置中搜索现有的kubeconfig 文件。</p></td>
</tr>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<!--td></td><td style="line-height: 130%; word-wrap: break-word;"><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td-->
<td></td><td style="line-height: 130%; word-wrap: break-word;"><p>[试验性] 指向“真实”宿主根文件系统的路径。</p></td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-57a6b20d9571220989a7a445d4459468">7.1.1.28 - </h1>
    
	<h3 id="概要">概要</h3>
<!--
This command prints objects such as the default init configuration that is used for 'kubeadm init'.
-->
<p>此命令打印对象，例如用于 'kubeadm init' 的默认 init 配置对象。</p>
<!--
Note that sensitive values like the Bootstrap Token fields are replaced with placeholder values like {"abcdef.0123456789abcdef" "" "nil" &lt;nil&gt; [] []} in order to pass validation but
not perform the real computation for creating a token.
-->
<p>请注意，Bootstrap Token 字段之类的敏感值已替换为 {&quot;abcdef.0123456789abcdef&quot; &quot;&quot; &quot;nil&quot; &lt;nil&gt; [] []} 之类的占位符值以通过验证，但不执行创建令牌的实际计算。</p>
<pre tabindex="0"><code>kubeadm config print init-defaults [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--component-configs stringSlice</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
A comma-separated list for component config API objects to print the default values for. Available values: [KubeProxyConfiguration KubeletConfiguration]. If this flag is not set, no component configs will be printed.
-->
组件配置 API 对象的逗号分隔列表，打印其默认值。可用值：[KubeProxyConfiguration KubeletConfiguration]。如果未设置此参数，则不会打印任何组件配置。
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for init-defaults
-->
init-defaults 操作的帮助命令
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">
<!--
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"
-->
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.
-->
与集群通信时使用的 kubeconfig 文件。如果未设置该参数，则可以在一组标准位置中搜索现有的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-92a2c11eef37937af846b55d9b87a544">7.1.1.29 - </h1>
    
	<h3 id="概要">概要</h3>
<!--
This command prints objects such as the default join configuration that is used for 'kubeadm join'.
-->
<p>此命令打印对象，例如用于 'kubeadm join' 的默认 join 配置对象。</p>
<!--
Note that sensitive values like the Bootstrap Token fields are replaced with placeholder values like {"abcdef.0123456789abcdef" "" "nil" &lt;nil&gt; [] []} in order to pass validation but
not perform the real computation for creating a token.
-->
<p>请注意，诸如启动引导令牌字段之类的敏感值已替换为 {&quot;abcdef.0123456789abcdef&quot; &quot;&quot; &quot;nil&quot; &lt;nil&gt; [] []}
之类的占位符值以通过验证，但不执行创建令牌的实际计算。</p>
<pre tabindex="0"><code>kubeadm config print join-defaults [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--component-configs stringSlice</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
A comma-separated list for component config API objects to print the default values for. Available values: [KubeProxyConfiguration KubeletConfiguration]. If this flag is not set, no component configs will be printed.
-->
组件配置 API 对象的逗号分隔列表，打印其默认值。可用值：[KubeProxyConfiguration KubeletConfiguration]。如果未设置此参数，则不会打印任何组件配置。
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for join-defaults
-->
join-defaults 操作的帮助命令
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">
<!--
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"
-->
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.
-->
与集群通信时使用的 kubeconfig 文件。如果未设置该参数，则可以在一组标准位置中搜索现有的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-dcfffcaafb438cd650475945ddc129ee">7.1.1.30 - </h1>
    
	<h3 id="概要">概要</h3>
<!--
Run this command in order to set up the Kubernetes control plane
-->
<p>运行此命令来搭建 Kubernetes 控制平面节点。</p>
<!--
The "init" command executes the following phases: 
-->
<p>&quot;init&quot; 命令执行以下阶段：</p>
<pre tabindex="0"><code>preflight                    Run pre-flight checks
certs                        Certificate generation
  /ca                          Generate the self-signed Kubernetes CA to provision identities for other Kubernetes components
  /apiserver                   Generate the certificate for serving the Kubernetes API
  /apiserver-kubelet-client    Generate the certificate for the API server to connect to kubelet
  /front-proxy-ca              Generate the self-signed CA to provision identities for front proxy
  /front-proxy-client          Generate the certificate for the front proxy client
  /etcd-ca                     Generate the self-signed CA to provision identities for etcd
  /etcd-server                 Generate the certificate for serving etcd
  /etcd-peer                   Generate the certificate for etcd nodes to communicate with each other
  /etcd-healthcheck-client     Generate the certificate for liveness probes to healthcheck etcd
  /apiserver-etcd-client       Generate the certificate the apiserver uses to access etcd
  /sa                          Generate a private key for signing service account tokens along with its public key
kubeconfig                   Generate all kubeconfig files necessary to establish the control plane and the admin kubeconfig file
  /admin                       Generate a kubeconfig file for the admin to use and for kubeadm itself
  /kubelet                     Generate a kubeconfig file for the kubelet to use *only* for cluster bootstrapping purposes
  /controller-manager          Generate a kubeconfig file for the controller manager to use
  /scheduler                   Generate a kubeconfig file for the scheduler to use
kubelet-start                Write kubelet settings and (re)start the kubelet
control-plane                Generate all static Pod manifest files necessary to establish the control plane
  /apiserver                   Generates the kube-apiserver static Pod manifest
  /controller-manager          Generates the kube-controller-manager static Pod manifest
  /scheduler                   Generates the kube-scheduler static Pod manifest
etcd                         Generate static Pod manifest file for local etcd
  /local                       Generate the static Pod manifest file for a local, single-node local etcd instance
upload-config                Upload the kubeadm and kubelet configuration to a ConfigMap
  /kubeadm                     Upload the kubeadm ClusterConfiguration to a ConfigMap
  /kubelet                     Upload the kubelet component config to a ConfigMap
upload-certs                 Upload certificates to kubeadm-certs
mark-control-plane           Mark a node as a control-plane
bootstrap-token              Generates bootstrap tokens used to join a node to a cluster
kubelet-finalize             Updates settings relevant to the kubelet after TLS bootstrap
  /experimental-cert-rotation  Enable kubelet client certificate rotation
addon                        Install required addons for passing Conformance tests
  /coredns                     Install the CoreDNS addon to a Kubernetes cluster
  /kube-proxy                  Install the kube-proxy addon to a Kubernetes cluster
</code></pre><pre tabindex="0"><code>kubeadm init [flags]
</code></pre><!-- 
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--apiserver-advertise-address string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The IP address the API Server will advertise it's listening on. If not set the default network interface will be used.
-->
API 服务器所公布的其正在监听的 IP 地址。如果未设置，则使用默认网络接口。
</td>
</tr>
<tr>
<td colspan="2">
<!--
--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: 6443
-->
--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：6443
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Port for the API Server to bind to.
-->
API 服务器绑定的端口。
</td>
</tr>
<tr>
<td colspan="2">--apiserver-cert-extra-sans stringSlice</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Optional extra Subject Alternative Names (SANs) to use for the API Server serving certificate. Can be both IP addresses and DNS names.
-->
用于 API Server 服务证书的可选附加主题备用名称（SAN）。可以是 IP 地址和 DNS 名称。
</td>
</tr>
<tr>
<td colspan="2">
<!--
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"
-->
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The path where to save and store the certificates.
-->
保存和存储证书的路径。
</td>
</tr>
<tr>
<td colspan="2">--certificate-key string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Key used to encrypt the control-plane certificates in the kubeadm-certs Secret.
-->
用于加密 kubeadm-certs Secret 中的控制平面证书的密钥。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to a kubeadm configuration file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">--control-plane-endpoint string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Specify a stable IP address or DNS name for the control plane.
-->
为控制平面指定一个稳定的 IP 地址或 DNS 名称。
</td>
</tr>
<tr>
<td colspan="2">--cri-socket string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to the CRI socket to connect. If empty kubeadm will try to auto-detect this value; use this option only if you have more than one CRI installed or if you have non-standard CRI socket.
-->
要连接的 CRI 套接字的路径。如果为空，则 kubeadm 将尝试自动检测此值；仅当安装了多个 CRI 或具有非标准 CRI 插槽时，才使用此选项。
</td>
</tr>
<tr>
<td colspan="2">--dry-run</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Don't apply any changes; just output what would be done.
-->
不要应用任何更改；只是输出将要执行的操作。
</td>
</tr>
<tr>
<td colspan="2">--experimental-patches string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--  
Path to a directory that contains files named "target[suffix][+patchtype].extension". For example, "kube-apiserver0+merge.yaml" or just "etcd.json". "patchtype" can be one of "strategic", "merge" or "json" and they match the patch formats supported by kubectl. The default "patchtype" is "strategic". "extension" must be either "json" or "yaml". "suffix" is an optional string that can be used to determine which patches are applied first alpha-numerically.
-->
包含名为 "target[suffix][+patchtype].extension" 的文件的目录路径。
例如，"kube-apiserver0+merge.yaml" 或仅仅是 "etcd.json"。
"patchtype" 可以是 "strategic"、"merge" 或 "json" 之一，并且它们与 kubectl 支持的补丁格式匹配。
默认的 "patchtype" 为 "strategic"。 "extension" 必须为 "json" 或 "yaml"。 
"suffix" 是一个可选字符串，可用于确定首先按字母顺序应用哪些补丁。
</td>
</tr>
<tr>
<td colspan="2">--feature-gates string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
A set of key=value pairs that describe feature gates for various features. Options are:<br/>IPv6DualStack=true|false (ALPHA - default=false)
-->
一组用来描述各种功能特性的键值（key=value）对。选项是：<br/>IPv6DualStack=true|false (ALPHA - default=false)
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for init
-->
init 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">--ignore-preflight-errors stringSlice</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
A list of checks whose errors will be shown as warnings. Example: 'IsPrivilegedUser,Swap'. Value 'all' ignores errors from all checks.
-->
错误将显示为警告的检查列表；例如：'IsPrivilegedUser,Swap'。取值为 'all' 时将忽略检查中的所有错误。
</td>
</tr>
<tr>
<td colspan="2">
<!--
--image-repository string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "k8s.gcr.io"
-->
--image-repository string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："k8s.gcr.io"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Choose a container registry to pull control plane images from
-->
选择用于拉取控制平面镜像的容器仓库
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "stable-1"
-->
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Choose a specific Kubernetes version for the control plane.
-->
为控制平面选择一个特定的 Kubernetes 版本。
</td>
</tr>
<tr>
<td colspan="2">--node-name string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Specify the node name.
-->
指定节点的名称。
</td>
</tr>
<tr>
<td colspan="2">--pod-network-cidr string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Specify range of IP addresses for the pod network. If set, the control plane will automatically allocate CIDRs for every node.
-->
指明 pod 网络可以使用的 IP 地址段。如果设置了这个参数，控制平面将会为每一个节点自动分配 CIDRs。
</td>
</tr>
<tr>
<td colspan="2">
<!--
--service-cidr string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "10.96.0.0/12"
-->
--service-cidr string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："10.96.0.0/12"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Use alternative range of IP address for service VIPs.
-->
为服务的虚拟 IP 地址另外指定 IP 地址段
</td>
</tr>
<tr>
<td colspan="2">
<!--
--service-dns-domain string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "cluster.local"
-->
--service-dns-domain string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："cluster.local"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Use alternative domain for services, e.g. "myorg.internal".
-->
为服务另外指定域名，例如："myorg.internal"。
</td>
</tr>
<tr>
<td colspan="2">--skip-certificate-key-print</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Don't print the key used to encrypt the control-plane certificates.
-->
不要打印用于加密控制平面证书的密钥。
</td>
</tr>
<tr>
<td colspan="2">--skip-phases stringSlice</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
List of phases to be skipped
-->
要跳过的阶段列表
</td>
</tr>
<tr>
<td colspan="2">--skip-token-print</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Skip printing of the default bootstrap token generated by 'kubeadm init'.
-->
跳过打印 'kubeadm init' 生成的默认引导令牌。
</td>
</tr>
<tr>
<td colspan="2">--token string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The token to use for establishing bidirectional trust between nodes and control-plane nodes. The format is [a-z0-9]{6}\.[a-z0-9]{16} - e.g. abcdef.0123456789abcdef
-->
这个令牌用于建立控制平面节点与工作节点间的双向通信。格式为 [a-z0-9]{6}\.[a-z0-9]{16} - 示例：abcdef.0123456789abcdef
</td>
</tr>
<tr>
<td colspan="2">
<!--
--token-ttl duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: 24h0m0s
-->
--token-ttl duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：24h0m0s
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The duration before the token is automatically deleted (e.g. 1s, 2m, 3h). If set to '0', the token will never expire
-->
令牌被自动删除之前的持续时间（例如 1 s，2 m，3 h）。如果设置为 '0'，则令牌将永不过期
</td>
</tr>
<tr>
<td colspan="2">--upload-certs</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Upload control-plane certificates to the kubeadm-certs Secret.
-->
将控制平面证书上传到 kubeadm-certs Secret。
</td>
</tr>
</tbody>
</table>
<!-- 
### Options inherited from parent commands 
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-6eaa2624c512051ff2a9cdbc6ee54949">7.1.1.31 - </h1>
    
	<h3 id="概要">概要</h3>
<!--
Use this command to invoke single phase of the init workflow
-->
<p>使用此命令可以调用 init 工作流程的单个阶段</p>
<!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- help for phase -->
phase 操作的帮助命令
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="继承于父命令的选择项">继承于父命令的选择项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-4b7ada30e3923594b2907dcb8b431080">7.1.1.32 - </h1>
    
	<h3 id="概要">概要</h3>
<!--
This command is not meant to be run on its own. See list of available subcommands.
-->
<p>此命令并非设计用来单独运行。请参阅可用子命令列表。</p>
<pre tabindex="0"><code>kubeadm init phase addon [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for addon
-->
addon 操作的帮助命令
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="继承于父命令的选项">继承于父命令的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-6d1154da2e554de858cf4e7b37c054fa">7.1.1.33 - </h1>
    
	<h3 id="概要">概要</h3>
<!--
Install all the addons
-->
<p>安装所有插件（addon）</p>
<pre tabindex="0"><code>kubeadm init phase addon all [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--apiserver-advertise-address string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The IP address the API Server will advertise it's listening on. If not set the default network interface will be used.
-->
API 服务器所公布的其正在监听的 IP 地址。如果未设置，则将使用默认网络接口。
</td>
</tr>
<tr>
<td colspan="2">
<!--
--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: 6443
-->
--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：6443
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Port for the API Server to bind to.
-->
API 服务器绑定的端口。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to a kubeadm configuration file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">--control-plane-endpoint string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Specify a stable IP address or DNS name for the control plane.
-->
为控制平面指定一个稳定的 IP 地址或 DNS 名称。
</td>
</tr>
<tr>
<td colspan="2">--feature-gates string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
A set of key=value pairs that describe feature gates for various features. Options are:<br/>IPv6DualStack=true|false (ALPHA - default=false)
-->
一组键值对（key=value），描述了各种特征。选项包括：<br/>IPv6DualStack=true|false (ALPHA - 默认值=false)
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for all
all 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">
<!--
--image-repository string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "k8s.gcr.io"
-->
--image-repository string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："k8s.gcr.io"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Choose a container registry to pull control plane images from
-->
选择用于拉取控制平面镜像的容器仓库
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"
-->
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.
-->
与集群通信时使用的 kubeconfig 文件。如果未设置该参数，则可以在一组标准位置中搜索现有的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "stable-1"
-->
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Choose a specific Kubernetes version for the control plane.
-->
为控制平面选择特定的 Kubernetes 版本。
</td>
</tr>
<tr>
<td colspan="2">--pod-network-cidr string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Specify range of IP addresses for the pod network. If set, the control plane will automatically allocate CIDRs for every node.
-->
指定 Pod 网络的 IP 地址范围。如果已设置，控制平面将自动为每个节点分配 CIDR。
</td>
</tr>
<tr>
<td colspan="2">
<!--
--service-cidr string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "10.96.0.0/12"
-->
--service-cidr string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："10.96.0.0/12"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Use alternative range of IP address for service VIPs.
-->
为服务 VIP 使用 IP 地址的其他范围。
</td>
</tr>
<tr>
<td colspan="2">
<!--
--service-dns-domain string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "cluster.local"
-->
--service-dns-domain string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："cluster.local"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Use alternative domain for services, e.g. "myorg.internal".
-->
为服务使用其他域名，例如 "myorg.internal"。
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="继承于父命令的选项">继承于父命令的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-d3a16914ddc849435ed864163978ddbf">7.1.1.34 - </h1>
    
	<h3 id="概要">概要</h3>
<!--
Install the CoreDNS addon components via the API server. Please note that although the DNS server is deployed, it will not be scheduled until CNI is installed.
-->
<p>通过 API 服务器安装 CoreDNS 附加组件。请注意，即使 DNS 服务器已部署，在安装 CNI 之前 DNS 服务器不会被调度执行。</p>
<pre tabindex="0"><code>kubeadm init phase addon coredns [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to kubeadm config file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">--feature-gates string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
A set of key=value pairs that describe feature gates for various features. Options are:<br/>IPv6DualStack=true|false (ALPHA - default=false)
-->
一组用来描述各种功能特性的键值（key=value）对。选项是：<br/>IPv6DualStack=true|false (ALPHA - 默认值=false)
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- help for coredns -->
coredns 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">
<!--
--image-repository string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "k8s.gcr.io"
-->
--image-repository string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："k8s.gcr.io"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Choose a container registry to pull control plane images from
-->
选择用于拉取控制平面镜像的容器仓库
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"
-->
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.
-->
与集群通信时使用的 kubeconfig 文件。如果未设置该参数，则可以在一组标准位置中搜索现有的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "stable-1"
-->
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- Choose a specific Kubernetes version for the control plane.  -->
为控制平面选择特定的 Kubernetes 版本。
</td>
</tr>
<tr>
<td colspan="2">
<!--
--service-cidr string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "10.96.0.0/12"
-->
--service-cidr string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："10.96.0.0/12"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- Use alternative range of IP address for service VIPs.  -->
为服务 VIP 选择 IP 地址范围。
</td>
</tr>
<tr>
<td colspan="2">
<!--
--service-dns-domain string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "cluster.local"
-->
--service-dns-domain string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："cluster.local"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- Use alternative domain for services, e.g. "myorg.internal".  -->
服务使用其它的域名，例如："myorg.internal"。
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="继承于父命令的选项">继承于父命令的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-8a257337ea78e5d9a0c54aa971eaf991">7.1.1.35 - </h1>
    
	<h3 id="概要">概要</h3>
<!--
Install the kube-proxy addon components via the API server.
-->
<p>通过 API 服务器安装 kube-proxy 附加组件。</p>
<pre tabindex="0"><code>kubeadm init phase addon kube-proxy [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--apiserver-advertise-address string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The IP address the API Server will advertise it's listening on. If not set the default network interface will be used.
-->
API 服务器所公布的其正在监听的 IP 地址。如果未设置，则将使用默认网络接口。
</td>
</tr>
<tr>
<td colspan="2">
<!--
--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: 6443
-->
--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值: 6443
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Port for the API Server to bind to.
-->
API 服务器绑定的端口。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to kubeadm config file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">--control-plane-endpoint string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Specify a stable IP address or DNS name for the control plane.
-->
为控制平面指定一个稳定的 IP 地址或 DNS 名称。
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for kube-proxy
-->
kube-proxy 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">
<!--
--image-repository string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "k8s.gcr.io"
-->
--image-repository string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："k8s.gcr.io"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Choose a container registry to pull control plane images from
-->
选择用于拉取控制平面镜像的容器仓库
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"
-->
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.
-->
与集群通信时使用的 kubeconfig 文件。如果未设置该参数，则可以在一组标准位置中搜索现有的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "stable-1"
-->
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Choose a specific Kubernetes version for the control plane.
-->
为控制平面选择特定的 Kubernetes 版本。
</td>
</tr>
<tr>
<td colspan="2">--pod-network-cidr string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Specify range of IP addresses for the pod network. If set, the control plane will automatically allocate CIDRs for every node.
-->
指定 Pod 网络的 IP 地址范围。如果已设置，控制平面将自动为每个节点分配 CIDR。
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="继承于父命令的选项">继承于父命令的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-77759011117e7974cbfee9694b6f8801">7.1.1.36 - </h1>
    
	<h3 id="概要">概要</h3>
<!--
Bootstrap tokens are used for establishing bidirectional trust between a node joining the cluster and a control-plane node.
-->
<p>启动引导令牌（bootstrap token）用于在即将加入集群的节点和控制平面节点之间建立双向信任。</p>
<!--
This command makes all the configurations required to make bootstrap tokens works and then creates an initial token.
-->
<p>该命令使启动引导令牌（bootstrap token）所需的所有配置生效，然后创建初始令牌。</p>
<pre tabindex="0"><code>kubeadm init phase bootstrap-token [flags]
</code></pre><!--
### Examples
-->
<h3 id="示例">示例</h3>
<!--
# Make all the bootstrap token configurations and create an initial token, functionally equivalent to what generated by kubeadm init.
-->
<pre tabindex="0"><code># 进行所有引导令牌配置，并创建一个初始令牌，功能上与 kubeadm init 生成的令牌等效。
kubeadm init phase bootstrap-token
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to a kubeadm configuration file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for bootstrap-token
-->
bootstrap-token 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"
-->
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.
-->
用于和集群通信的 kubeconfig 文件。如果它没有被设置，那么 kubeadm 将会搜索一个已经存在于标准路径的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan="2">--skip-token-print</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Skip printing of the default bootstrap token generated by 'kubeadm init'.
-->
跳过打印 'kubeadm init' 生成的默认引导令牌。
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="继承于父命令的选项">继承于父命令的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-8e1920b2caaa8de839cd3997edca80e9">7.1.1.37 - </h1>
    
	<h3 id="概要">概要</h3>
<!--
This command is not meant to be run on its own. See list of available subcommands.
-->
<p>此命令并非设计用来单独运行。请参阅可用子命令列表。</p>
<pre tabindex="0"><code>kubeadm init phase certs [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for certs
-->
certs 操作的帮助命令
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父指令中继承的选项">从父指令中继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-00aa8c2e4b3b2fd3a4b7986976b7bfda">7.1.1.38 - </h1>
    
	<h3 id="概要">概要</h3>
<!--
Generate all certificates
-->
<p>生成所有证书</p>
<pre tabindex="0"><code>kubeadm init phase certs all [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--apiserver-advertise-address string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The IP address the API Server will advertise it's listening on. If not set the default network interface will be used.
-->
API 服务器所公布的其正在监听的 IP 地址。如果未设置，将使用默认网络接口。
</td>
</tr>
<tr>
<td colspan="2">--apiserver-cert-extra-sans stringSlice</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Optional extra Subject Alternative Names (SANs) to use for the API Server serving certificate. Can be both IP addresses and DNS names.
-->
用于 API 服务器服务证书的可选额外替代名称（SAN）。可以同时使用 IP 地址和 DNS 名称。
</td>
</tr>
<tr>
<td colspan="2">
<!--
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"
-->
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The path where to save and store the certificates.
-->
证书的存储路径。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to a kubeadm configuration file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">--control-plane-endpoint string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Specify a stable IP address or DNS name for the control plane.
-->
为控制平面指定一个稳定的 IP 地址或 DNS 名称。
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for all
-->
all 操作的帮助命令 
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "stable-1"
-->
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Choose a specific Kubernetes version for the control plane.
-->
为控制平面选择特定的 Kubernetes 版本。
</td>
</tr>
<tr>
<td colspan="2">
<!--
--service-cidr string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "10.96.0.0/12"
-->
--service-cidr string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："10.96.0.0/12"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Use alternative range of IP address for service VIPs.
-->
VIP 服务使用其它的 IP 地址范围。
</td>
</tr>
<tr>
<td colspan="2">
<!--
--service-dns-domain string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "cluster.local"
-->
--service-dns-domain string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："cluster.local"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Use alternative domain for services, e.g. "myorg.internal".
-->
服务使用其它的域名，例如："myorg.internal"。
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="继承于父命令的选项">继承于父命令的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-316aa97ee5719be5a723ac1b77c44f5a">7.1.1.39 - </h1>
    
	<h3 id="概要">概要</h3>
<!--
Generate the certificate the apiserver uses to access etcd, and save them into apiserver-etcd-client.cert and apiserver-etcd-client.key files.
-->
<p>生成 apiserver 用于访问 etcd 的证书，并将其保存到 apiserver-etcd-client.cert 和 apiserver-etcd-client.key 文件中。</p>
<!--
If both files already exist, kubeadm skips the generation step and existing files will be used.
-->
<p>如果两个文件都已存在，则 kubeadm 将跳过生成步骤，使用现有文件。</p>
<!--
Alpha Disclaimer: this command is currently alpha.
-->
<p>Alpha 免责声明：此命令当前为 Alpha 功能。</p>
<pre tabindex="0"><code>kubeadm init phase certs apiserver-etcd-client [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">
<!--
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"
-->
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- The path where to save and store the certificates.  -->
证书的存储路径。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- Path to a kubeadm configuration file.  -->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- help for apiserver-etcd-client -->
apiserver-etcd-client 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">
<!-- kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "stable-1" -->
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Choose a specific Kubernetes version for the control plane.
-->
为控制平面指定特定的 Kubernetes 版本。
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="继承于父命令的选项">继承于父命令的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- [EXPERIMENTAL] The path to the 'real' host root filesystem. -->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-759e85e62b32c0697ab37c214e99a864">7.1.1.40 - </h1>
    
	<h3 id="概要">概要</h3>
<!--
Generate the certificate for the API server to connect to kubelet, and save them into apiserver-kubelet-client.cert and apiserver-kubelet-client.key files.
-->
<p>生成供 API 服务器连接 kubelet 的证书，并将其保存到 apiserver-kubelet-client.cert 和 apiserver-kubelet-client.key 文件中。</p>
<!--
If both files already exist, kubeadm skips the generation step and existing files will be used.
-->
<p>如果两个文件都已存在，则 kubeadm 将跳过生成步骤，使用现有文件。</p>
<!--
Alpha Disclaimer: this command is currently alpha.
-->
<p>Alpha 免责声明：此命令当前为 Alpha 功能。</p>
<pre tabindex="0"><code>kubeadm init phase certs apiserver-kubelet-client [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">
<!--
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"
-->
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The path where to save and store the certificates.
-->
存储证书的路径。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to a kubeadm configuration file.
-->
kubeadm 配置文件路径。
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for apiserver-kubelet-client
-->
apiserver-kubelet-client 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "stable-1"
-->
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Choose a specific Kubernetes version for the control plane.
-->
为控制平面指定特定的 Kubernetes 版本。
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="继承于父命令的选项">继承于父命令的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 指向宿主机上的 '实际' 根文件系统的路径。
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-2e7091074560abc2a8e7b897cdd8a7b6">7.1.1.41 - </h1>
    
	<h3 id="概要">概要</h3>
<!--
Generate the certificate for serving the Kubernetes API, and save them into apiserver.cert and apiserver.key files.
-->
<p>生成用于服务 Kubernetes API 的证书，并将其保存到 apiserver.cert 和 apiserver.key 文件中。</p>
<!--
Default SANs are kubernetes, kubernetes.default, kubernetes.default.svc, kubernetes.default.svc.cluster.local, 10.96.0.1, 127.0.0.1
-->
<p>默认 SAN 是 kubernetes、kubernetes.default、kubernetes.default.svc、kubernetes.default.svc.cluster.local、10.96.0.1、127.0.0.1。</p>
<!--
If both files already exist, kubeadm skips the generation step and existing files will be used.
-->
<p>如果两个文件都已存在，则 kubeadm 将跳过生成步骤，使用现有文件。</p>
<!--
Alpha Disclaimer: this command is currently alpha.
-->
<p>Alpha 免责声明：此命令当前为 Alpha 功能。</p>
<pre tabindex="0"><code>kubeadm init phase certs apiserver [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--apiserver-advertise-address string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The IP address the API Server will advertise it's listening on. If not set the default network interface will be used.
-->
API 服务器所公布的其正在监听的 IP 地址。如果未设置，则使用默认的网络接口。
</td>
</tr>
<tr>
<td colspan="2">--apiserver-cert-extra-sans stringSlice</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Optional extra Subject Alternative Names (SANs) to use for the API Server serving certificate. Can be both IP addresses and DNS names.
-->
用于 API Server 服务证书的可选附加主体备用名称（SAN）。可以是 IP 地址和 DNS 名称。
</td>
</tr>
<tr>
<td colspan="2">
<!--
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"
-->
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The path where to save and store the certificates.
-->
证书的存储路径。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to a kubeadm configuration file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">--control-plane-endpoint string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Specify a stable IP address or DNS name for the control plane.
-->
为控制平面指定一个稳定的 IP 地址或 DNS 名称。
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for apiserver
-->
apiserver 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "stable-1"
-->
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Choose a specific Kubernetes version for the control plane.
-->
为控制平面指定特定的 Kubernetes 版本。
</td>
</tr>
<tr>
<td colspan="2">
<!--
--service-cidr string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "10.96.0.0/12"
-->
--service-cidr string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："10.96.0.0/12"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Use alternative range of IP address for service VIPs.
-->
指定服务 VIP 可使用的其他 IP 地址段。
</td>
</tr>
<tr>
<td colspan="2">
<!--
--service-dns-domain string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "cluster.local"
-->
--service-dns-domain string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："cluster.local"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Use alternative domain for services, e.g. "myorg.internal".
-->
为服务使用其他域名，例如 "myorg.internal"。
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="继承于父命令的选项">继承于父命令的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-eedb8f5a6ed4cff1dfb1a5d14176b5b3">7.1.1.42 - </h1>
    
	<h3 id="概要">概要</h3>
<!--
Generate the self-signed Kubernetes CA to provision identities for other Kubernetes components, and save them into ca.cert and ca.key files.
-->
<p>生成自签名的 Kubernetes CA 以提供其他 Kubernetes 组件的身份，并将其保存到 ca.cert 和 ca.key 文件中。</p>
<!--
If both files already exist, kubeadm skips the generation step and existing files will be used.
-->
<p>如果两个文件都已存在，则 kubeadm 将跳过生成步骤，使用现有文件。</p>
<!--
Alpha Disclaimer: this command is currently alpha.
-->
<p>Alpha 免责声明：此命令当前为 Alpha 功能。</p>
<pre tabindex="0"><code>kubeadm init phase certs ca [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">
<!--
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"
-->
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The path where to save and store the certificates.
-->
证书的存储路径。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to a kubeadm configuration file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for ca
-->
ca 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "stable-1"
-->
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Choose a specific Kubernetes version for the control plane.
-->
为控制平面选择特定的 Kubernetes 版本。
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="继承于父命令的选项">继承于父命令的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-c55f2fa6bdaa124b37da090a3ef90902">7.1.1.43 - </h1>
    
	<h3 id="概要">概要</h3>
<!--
Generate the self-signed CA to provision identities for etcd, and save them into etcd/ca.cert and etcd/ca.key files.
-->
<p>生成用于为 etcd 设置身份的自签名 CA，并将其保存到 etcd/ca.cert 和 etcd/ca.key 文件中。</p>
<!--
If both files already exist, kubeadm skips the generation step and existing files will be used.
-->
<p>如果两个文件都已存在，则 kubeadm 将跳过生成步骤，使用现有文件。</p>
<!--
Alpha Disclaimer: this command is currently alpha.
-->
<p>Alpha 免责声明：此命令当前为 Alpha 功能。</p>
<pre tabindex="0"><code>kubeadm init phase certs etcd-ca [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">
<!--
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"
-->
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The path where to save and store the certificates.
-->
证书的存储路径。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to a kubeadm configuration file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for etcd-ca
-->
etcd-ca 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "stable-1"
-->
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Choose a specific Kubernetes version for the control plane.
-->
为控制平面选择特定的 Kubernetes 版本。
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="继承于父命令的选项">继承于父命令的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-10f416336efdcee22d691869e7585b9f">7.1.1.44 - </h1>
    
	<h3 id="概要">概要</h3>
<!--
Generate the certificate for liveness probes to healthcheck etcd, and save them into etcd/healthcheck-client.cert and etcd/healthcheck-client.key files.
-->
<p>生成用于 etcd 健康检查的活跃性探针的证书，并将其保存到 healthcheck-client.cert 和 etcd/healthcheck-client.key 文件中。</p>
<!--
If both files already exist, kubeadm skips the generation step and existing files will be used.
-->
<p>如果两个文件都已存在，则 kubeadm 将跳过生成步骤，使用现有文件。</p>
<!--
Alpha Disclaimer: this command is currently alpha.
-->
<p>Alpha 免责声明：此命令当前为 alpha 功能。</p>
<pre tabindex="0"><code>kubeadm init phase certs etcd-healthcheck-client [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">
<!--
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"
-->
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The path where to save and store the certificates.
-->
证书存储的路径。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to a kubeadm configuration file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for etcd-healthcheck-client
-->
etcd-healthcheck-client 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "stable-1"
-->
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Choose a specific Kubernetes version for the control plane.
-->
为控制平面选择特定的 Kubernetes 版本。
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="继承于父命令的选项">继承于父命令的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-c4b6d149cda7cac896f4374c821b7fc6">7.1.1.45 - </h1>
    
	<h3 id="概要">概要</h3>
<!--
Generate the certificate for etcd nodes to communicate with each other, and save them into etcd/peer.cert and etcd/peer.key files.
-->
<p>生成 etcd 节点相互通信的证书，并将其保存到 etcd/peer.cert 和 etcd/peer.key 文件中。</p>
<!--
Default SANs are localhost, 127.0.0.1, 127.0.0.1, ::1
-->
<p>默认 SAN 为 localhost、127.0.0.1、127.0.0.1、:: 1</p>
<!--
If both files already exist, kubeadm skips the generation step and existing files will be used.
-->
<p>如果两个文件都已存在，则 kubeadm 将跳过生成步骤，使用现有文件。</p>
<!--
Alpha Disclaimer: this command is currently alpha.
-->
<p>Alpha 免责声明：此命令当前为 alpha 功能。</p>
<pre tabindex="0"><code>kubeadm init phase certs etcd-peer [flags]
</code></pre><!-- 
### Options 
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">
<!--
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"
-->
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- The path where to save and store the certificates.  -->
保存和存储证书的路径。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- Path to kubeadm configuration file.  -->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- help for etcd-peer -->
etcd-peer 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "stable-1"
-->
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- Choose a specific Kubernetes version for the control plane.  -->
为控制平面指定特定的 Kubernetes 版本。
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="继承于父命令的选项">继承于父命令的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-1db087626f4f368e932df6f12993a5ab">7.1.1.46 - </h1>
    
	<h3 id="概要">概要</h3>
<!--
Generate the certificate for serving etcd, and save them into etcd/server.cert and etcd/server.key files.
-->
<p>生成用于提供 etcd 服务的证书，并将其保存到 etcd/server.cert 和 etcd/server.key 文件中。</p>
<!--
Default SANs are localhost, 127.0.0.1, 127.0.0.1, ::1
-->
<p>默认 SAN 为 localhost、127.0.0.1、127.0.0.1、:: 1</p>
<!--
If both files already exist, kubeadm skips the generation step and existing files will be used.
-->
<p>如果两个文件都已存在，则 kubeadm 将跳过生成步骤，使用现有文件。</p>
<!--
Alpha Disclaimer: this command is currently alpha.
-->
<p>Alpha 免责声明：此命令当前为 alpha 功能。</p>
<pre tabindex="0"><code>kubeadm init phase certs etcd-server [flags]
</code></pre><!-- 
### Options 
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">
<!--
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"
-->
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The path where to save and store the certificates.
-->
保存和存储证书的路径。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to kubeadm configuration file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for etcd-server
-->
etcd-server 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "stable-1"
-->
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Choose a specific Kubernetes version for the control plane.
-->
为控制平面指定特定的 Kubernetes 版本。
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="继承于父命令的选项">继承于父命令的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-e85da83e18a50e472eb56320af55768a">7.1.1.47 - </h1>
    
	<h3 id="概要">概要</h3>
<!--
Generate the self-signed CA to provision identities for front proxy, and save them into front-proxy-ca.cert and front-proxy-ca.key files.
-->
<p>生成自签名 CA 来提供前端代理的身份，并将其保存到 front-proxy-ca.cert 和 front-proxy-ca.key 文件中。</p>
<!--
If both files already exist, kubeadm skips the generation step and existing files will be used.
-->
<p>如果两个文件都已存在，kubeadm 将跳过生成步骤并将使用现有文件。</p>
<!--
Alpha Disclaimer: this command is currently alpha.
-->
<p>Alpha 免责声明：此命令目前是 alpha 阶段。</p>
<pre tabindex="0"><code>kubeadm init phase certs front-proxy-ca [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">
<!--
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"
-->
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The path where to save and store the certificates.
-->
存储证书的路径。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to a kubeadm configuration file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for front-proxy-ca
-->
front-proxy-ca 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "stable-1"
-->
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Choose a specific Kubernetes version for the control plane.
-->
为控制平面选择特定的 Kubernetes 版本。
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-eb911bdcb8bb53ceb8b253089ab0d814">7.1.1.48 - </h1>
    
	<h3 id="概要">概要</h3>
<!--
Generate the certificate for the front proxy client, and save them into front-proxy-client.cert and front-proxy-client.key files.
If both files already exist, kubeadm skips the generation step and existing files will be used.
Alpha Disclaimer: this command is currently alpha.
-->
<p>为前端代理客户端生成证书，并将其保存到 front-proxy-client.cert 和 front-proxy-client.key 文件中。
如果两个文件都已存在，kubeadm 将跳过生成步骤并将使用现有文件。
Alpha 免责声明：此命令目前是 alpha 阶段。</p>
<pre tabindex="0"><code>kubeadm init phase certs front-proxy-client [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">
<!--
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"
-->
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认："/etc/kubernetes/pki"</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The path where to save and store the certificates.
-->
存储证书的路径。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to a kubeadm configuration file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for front-proxy-client
-->
front-proxy-client 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "stable-1"
-->
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Choose a specific Kubernetes version for the control plane.
-->
为控制平面选择特定的 Kubernetes 版本。
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-62c5dc89c39f3ecd6aee57545d12891a">7.1.1.49 - </h1>
    
	<h3 id="概要">概要</h3>
<!--
Generate the private key for signing service account tokens along with its public key, and save them into sa.key and sa.pub files. If both files already exist, kubeadm skips the generation step and existing files will be used.
-->
<p>生成用于签名 service account 令牌的私钥及其公钥，并将其保存到 sa.key 和 sa.pub 文件中。如果两个文件都已存在，则 kubeadm 会跳过生成步骤，而将使用现有文件。</p>
<!--
Alpha Disclaimer: this command is currently alpha.
-->
<p>Alpha 免责声明：此命令当前为 alpha 阶段。</p>
<pre tabindex="0"><code>kubeadm init phase certs sa [flags]
</code></pre><!-- ### Options -->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">
<!--
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"
-->
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The path where to save and store the certificates.
-->
保存和存储证书的路径。
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for sa
-->
sa 操作的帮助命令
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="继承于父命令的选项">继承于父命令的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-2a79e12b9455f0ca1a6d5b00a9841249">7.1.1.50 - </h1>
    
	<h3 id="概要">概要</h3>
<!--
This command is not meant to be run on its own. See list of available subcommands.
-->
<p>此命令并非设计用来单独运行。请参阅可用子命令列表。</p>
<pre tabindex="0"><code>kubeadm init phase control-plane [flags]
</code></pre><!-- 
### Options 
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- help for control-plane -->
control-plane 操作的帮助命令
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="继承于父命令的选项">继承于父命令的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- [EXPERIMENTAL] The path to the 'real' host root filesystem.  -->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-a2c8efac328fcf416e558bf167ef417d">7.1.1.51 - </h1>
    
	<h3 id="概要">概要</h3>
<!--
Generate all static Pod manifest files
-->
<p>生成所有的静态 Pod 清单文件</p>
<pre tabindex="0"><code>kubeadm init phase control-plane all [flags]
</code></pre><!--
### Examples


```
# Generates all static Pod manifest files for control plane components,
# functionally equivalent to what is generated by kubeadm init.
# Generates all static Pod manifest files using options read from a configuration file.
```
-->
<h3 id="示例">示例</h3>
<pre tabindex="0"><code># 为控制平面组件生成静态 Pod 清单文件，其功能等效于 kubeadm init 生成的文件。
kubeadm init phase control-plane all

# 使用从某配置文件中读取的选项为生成静态 Pod 清单文件。
kubeadm init phase control-plane all --config config.yaml
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--apiserver-advertise-address string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The IP address the API Server will advertise it's listening on. If not set the default network interface will be used.
-->
API 服务器所公布的其正在监听的 IP 地址。如果未设置，将使用默认的网络接口。
</td>
</tr>
<tr>
<!-- td colspan="2">--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: 6443</td -->
<td colspan="2">--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：6443</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Port for the API Server to bind to.
-->
API 服务器要绑定的端口。
</td>
</tr>
<tr>
<td colspan="2">--apiserver-extra-args mapStringString</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
A set of extra flags to pass to the API Server or override default ones in form of &lt;flagname&gt;=&lt;value&gt;
-->
形式为 &lt;flagname&gt;=&lt;value&gt; 的一组额外参数，用来传递给 API 服务器，
或者覆盖其默认配置值
</td>
</tr>
<tr>
<td colspan="2">
<!--
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"
-->
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The path where to save and store the certificates.
-->
存储证书的路径。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to a kubeadm configuration file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">--control-plane-endpoint string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Specify a stable IP address or DNS name for the control plane.
-->
为控制平面选择一个稳定的 IP 地址或者 DNS 名称。
</td>
</tr>
<tr>
<td colspan="2">--controller-manager-extra-args mapStringString</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
A set of extra flags to pass to the Controller Manager or override default ones in form of &lt;flagname&gt;=&lt;value&gt;
-->
一组形式为 &lt;flagname&gt;=&lt;value&gt; 的额外参数，用来传递给控制管理器（Controller Manager）
或覆盖其默认设置值
</td>
</tr>
<tr>
<td colspan="2">--experimental-patches string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to a directory that contains files named "target[suffix][+patchtype].extension". For example, "kube-apiserver0+merge.yaml" or just "etcd.json". "patchtype" can be one of "strategic", "merge" or "json" and they match the patch formats supported by kubectl. The default "patchtype" is "strategic". "extension" must be either "json" or "yaml". "suffix" is an optional string that can be used to determine which patches are applied first alpha-numerically.
-->
包含名为 "target[suffix][+patchtype].extension" 的文件的目录。
例如，"kube-apiserver0+merge.yaml" 或者 "etcd.json"。
"patchtype" 可以是 "strategic"、"merge" 或 "json" 之一，分别与 kubectl
所支持的 patch 格式相匹配。默认的 "patchtype" 是 "strategic"。
"extension" 必须是 "json" 或 "yaml"。
"suffix" 是一个可选的字符串，用来确定按字母顺序排序时首先应用哪些 patch。
</td>
</tr>
<tr>
<td colspan="2">--feature-gates string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
A set of key=value pairs that describe feature gates for various features. Options are:<br/>IPv6DualStack=true|false (ALPHA - default=false)<br/>PublicKeysECDSA=true|false (ALPHA - default=false)
-->
一组用来描述各种特性门控的键值（key=value）对。选项是：
<br/>IPv6DualStack=true|false (ALPHA - 默认=false)
<br/>PublicKeysECDSA=true|false (ALPHA - 默认=false)
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for all
-->
all 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">
<!--
--image-repository string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "k8s.gcr.io"
-->
--image-repository string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："k8s.gcr.io"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Choose a container registry to pull control plane images from
-->
选择用于拉取控制平面镜像的容器仓库
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "stable-1"
-->
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Choose a specific Kubernetes version for the control plane.
-->
为控制平面选择指定的 Kubernetes 版本。
</td>
</tr>
<tr>
<td colspan="2">--pod-network-cidr string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Specify range of IP addresses for the pod network. If set, the control plane will automatically allocate CIDRs for every node.
-->
指定 Pod 网络的 IP 地址范围。如果设置了此标志，控制平面将自动地为每个节点分配 CIDR。
</td>
</tr>
<tr>
<td colspan="2">--scheduler-extra-args mapStringString</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
A set of extra flags to pass to the Scheduler or override default ones in form of &lt;flagname&gt;=&lt;value&gt;
-->
一组形式为 &lt;flagname&gt;=&lt;value&gt; 的额外参数，用来传递给调度器（Scheduler）
或覆盖其默认设置值
<p>传递给调度器（scheduler）一组额外的参数或者以 &lt;flagname&gt;=&lt;value&gt; 形式覆盖其默认值。</p>
</td>
</tr>
<tr>
<td colspan="2">
<!--
--service-cidr string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "10.96.0.0/12"
-->
--service-cidr string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："10.96.0.0/12"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Use alternative range of IP address for service VIPs.
-->
为服务 VIP 选择 IP 地址范围。
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父指令继承的选项">从父指令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 指向 '真实' 宿主机的根文件系统的路径。
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-d93bd37094201bdefdb3908c9a6c86b3">7.1.1.52 - </h1>
    
	<h3 id="概要">概要</h3>
<!-- 
Generates the kube-apiserver static Pod manifest 
-->
<p>生成 kube-apiserver 静态 Pod 清单</p>
<pre tabindex="0"><code>kubeadm init phase control-plane apiserver [flags]
</code></pre><!-- 
### Options 
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--apiserver-advertise-address string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The IP address the API Server will advertise it's listening on. If not set the default network interface will be used.
-->
API 服务器所公布的其正在监听的 IP 地址。如果未设置，将使用默认网络接口。
</td>
</tr>
<tr>
<td colspan="2">
<!--
--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: 6443
-->
--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值： 6443
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Port for the API Server to bind to.
-->
要绑定到 API 服务器的端口。
</td>
</tr>
<tr>
<td colspan="2">--apiserver-extra-args mapStringString</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
A set of extra flags to pass to the API Server or override default ones in form of &lt;flagname&gt;=&lt;value&gt;
-->
一组 &lt;flagname&gt;=&lt;value&gt; 形式的额外参数，用来传递给 API 服务器
或者覆盖其默认参数配置
</td>
</tr>
<tr>
<td colspan="2">
<!--
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"
-->
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The path where to save and store the certificates.
-->
保存和存储证书的路径。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to a kubeadm configuration file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">--control-plane-endpoint string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Specify a stable IP address or DNS name for the control plane.
-->
为控制平面指定一个稳定的 IP 地址或 DNS 名称。
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--Path to a directory that contains files named "target[suffix][+patchtype].extension". For example, "kube-apiserver0+merge.yaml" or just "etcd.json". "patchtype" can be one of "strategic", "merge" or "json" and they match the patch formats supported by kubectl. The default "patchtype" is "strategic". "extension" must be either "json" or "yaml". "suffix" is an optional string that can be used to determine which patches are applied first alpha-numerically.-->
包含名为 "target[suffix][+patchtype].extension" 的文件的目录。
例如，"kube-apiserver0+merge.yaml" 或者 "etcd.json"。
"patchtype" 可以是 "strategic"、"merge" 或 "json" 之一，分别与 kubectl
所支持的 patch 格式相匹配。默认的 "patchtype" 是 "strategic"。
"extension" 必须是 "json" 或 "yaml"。
"suffix" 是一个可选的字符串，用来确定按字母顺序排序时首先应用哪些 patch。
</td>
</tr>
<tr>
<td colspan="2">--feature-gates string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
A set of key=value pairs that describe feature gates for various features. Options are:<br/>IPv6DualStack=true|false (ALPHA - default=false)<br/>PublicKeysECDSA=true|false (ALPHA - default=false)
-->
一组键值对，用于描述各种功能特性的特性门控。选项是：
<br/>IPv6DualStack=true|false (ALPHA - 默认=false)
<br/>PublicKeysECDSA=true|false (ALPHA - 默认=false)
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for apiserver
-->
apiserver 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">
<!--
--image-repository string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "k8s.gcr.io"
-->
--image-repository string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："k8s.gcr.io"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Choose a container registry to pull control plane images from
-->
选择要从中拉取控制平面镜像的容器仓库
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "stable-1"
-->
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Choose a specific Kubernetes version for the control plane.
-->
为控制平面选择特定的 Kubernetes 版本
</td>
</tr>
<tr>
<td colspan="2">
<!--
--service-cidr string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "10.96.0.0/12"
-->
--service-cidr string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："10.96.0.0/12"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Use alternative range of IP address for service VIPs.
-->
指定服务 VIP 使用 IP 地址的其他范围。
</td>
</tr>
</tbody>
</table>
<!-- 
### Options inherited from parent commands 
-->
<h3 id="继承于父命令的选项">继承于父命令的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统路径。
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-efa9ae4c92ed1c26dc04bb049db38cec">7.1.1.53 - </h1>
    
	<h3 id="概要">概要</h3>
<!--
Generates the kube-controller-manager static Pod manifest
-->
<p>生成 kube-controller-manager 静态 Pod 清单</p>
<pre tabindex="0"><code>kubeadm init phase control-plane controller-manager [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<!-- td colspan="2">--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"</td -->
<td colspan="2">--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The path where to save and store the certificates.
-->
存储证书的路径。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to a kubeadm configuration file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">--controller-manager-extra-args mapStringString</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
A set of extra flags to pass to the Controller Manager or override default ones in form of &lt;flagname&gt;=&lt;value&gt;
-->
一组 &lt;flagname&gt;=&lt; 形式的额外参数，传递给控制器管理器（Controller Manager）
或者覆盖其默认配置值
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--Path to a directory that contains files named "target[suffix][+patchtype].extension". For example, "kube-apiserver0+merge.yaml" or just "etcd.json". "patchtype" can be one of "strategic", "merge" or "json" and they match the patch formats supported by kubectl. The default "patchtype" is "strategic". "extension" must be either "json" or "yaml". "suffix" is an optional string that can be used to determine which patches are applied first alpha-numerically.-->
包含名为 "target[suffix][+patchtype].extension" 的文件的目录。
例如，"kube-apiserver0+merge.yaml" 或者 "etcd.json"。
"patchtype" 可以是 "strategic"、"merge" 或 "json" 之一，分别与 kubectl
所支持的 patch 格式相匹配。默认的 "patchtype" 是 "strategic"。
"extension" 必须是 "json" 或 "yaml"。
"suffix" 是一个可选的字符串，用来确定按字母顺序排序时首先应用哪些 patch。
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for controller-manager
-->
controller-manager 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">
<!--
--image-repository string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "k8s.gcr.io"
-->
--image-repository string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："k8s.gcr.io"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Choose a container registry to pull control plane images from
-->
选择要从中拉取控制平面镜像的容器仓库
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "stable-1"
-->
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Choose a specific Kubernetes version for the control plane.
-->
为控制平面选择特定的 Kubernetes 版本。
</td>
</tr>
<tr>
<td colspan="2">--pod-network-cidr string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Specify range of IP addresses for the pod network. If set, the control plane will automatically allocate CIDRs for every node.
-->
指定 Pod 网络的 IP 地址范围。如果设置，控制平面将自动为每个节点分配 CIDR。
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-576c00359074987304b3b418cec9a5b1">7.1.1.54 - </h1>
    
	<h3 id="概要">概要</h3>
<!--
Generates the kube-scheduler static Pod manifest
-->
<p>生成 kube-scheduler 静态 Pod 清单</p>
<pre tabindex="0"><code>kubeadm init phase control-plane scheduler [flags]
</code></pre><!-- 
### Options 
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">
<!--
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"
-->
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The path where to save and store the certificates.
-->
存储证书的路径。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to a kubeadm configuration file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">--experimental-patches string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--Path to a directory that contains files named "target[suffix][+patchtype].extension". For example, "kube-apiserver0+merge.yaml" or just "etcd.json". "patchtype" can be one of "strategic", "merge" or "json" and they match the patch formats supported by kubectl. The default "patchtype" is "strategic". "extension" must be either "json" or "yaml". "suffix" is an optional string that can be used to determine which patches are applied first alpha-numerically.-->
包含名为 "target[suffix][+patchtype].extension" 的文件的目录。
例如，"kube-apiserver0+merge.yaml" 或者 "etcd.json"。
"patchtype" 可以是 "strategic"、"merge" 或 "json" 之一，分别与 kubectl
所支持的 patch 格式相匹配。默认的 "patchtype" 是 "strategic"。
"extension" 必须是 "json" 或 "yaml"。
"suffix" 是一个可选的字符串，用来确定按字母顺序排序时首先应用哪些 patch。
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for scheduler
-->
scheduler 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">
<!--
--image-repository string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "k8s.gcr.io"
-->
--image-repository string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值:"k8s.gcr.io"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Choose a container registry to pull control plane images from
-->
选择要从中拉取控制平面镜像的容器仓库
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "stable-1"
-->
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Choose a specific Kubernetes version for the control plane.
-->
为控制平面选择特定的 Kubernetes 版本。
</td>
</tr>
<tr>
<td colspan="2">--scheduler-extra-args mapStringString</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
A set of extra flags to pass to the Scheduler or override default ones in form of &lt;flagname&gt;=&lt;value&gt;
-->
一组 &lt;flagname&gt;=&lt;value&gt; 形式的额外参数，用来传递给调度器
或者覆盖其默认参数配置
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="继承于父命令的选项">继承于父命令的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-e6097fe5dd013abd9f356c2566ef7b63">7.1.1.55 - </h1>
    
	<h3 id="概要">概要</h3>
<!--
This command is not meant to be run on its own. See list of available subcommands.
-->
<p>此命令并非设计用来单独运行。请参阅可用子命令列表。</p>
<pre tabindex="0"><code>kubeadm init phase etcd [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- help for etcd -->
etcd 操作的帮助命令
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="继承于父命令的选项">继承于父命令的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-5ab65eab2498cc1893af5b3bf8fe08fc">7.1.1.56 - </h1>
    
	<h3 id="概要">概要</h3>
<!--
Generate the static Pod manifest file for a local, single-node local etcd instance
-->
<p>为本地单节点 etcd 实例生成静态 Pod 清单文件</p>
<pre tabindex="0"><code>kubeadm init phase etcd local [flags]
</code></pre><!--
### Examples
-->
<h3 id="示例">示例</h3>
<!--
# Generates the static Pod manifest file for etcd, functionally
# equivalent to what is generated by kubeadm init.
# Generates the static Pod manifest file for etcd using options
# read from a configuration file.
-->
<pre tabindex="0"><code># 为 etcd 生成静态 Pod 清单文件，其功能等效于 kubeadm init 生成的文件。
kubeadm init phase etcd local

# 使用从配置文件读取的选项为 etcd 生成静态 Pod 清单文件。
kubeadm init phase etcd local --config config.yaml
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">
<!--
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"
-->
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- The path where to save and store the certificates.  -->
存储证书的路径。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- Path to a kubeadm configuration file.  -->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">--experimental-patches string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--  
Path to a directory that contains files named "target[suffix][+patchtype].extension". For example, "kube-apiserver0+merge.yaml" or just "etcd.json". "patchtype" can be one of "strategic", "merge" or "json" and they match the patch formats supported by kubectl. The default "patchtype" is "strategic". "extension" must be either "json" or "yaml". "suffix" is an optional string that can be used to determine which patches are applied first alpha-numerically.
-->
包含名为 "target[suffix][+patchtype].extension" 的文件的目录的路径。
例如，"kube-apiserver0+merge.yaml" 或仅仅是 "etcd.json"。
"patchtype" 可以是 "strategic"、"merge" 或 "json" 之一，并且它们与 kubectl 支持的补丁格式匹配。
默认的 "patchtype" 为 "strategic"。 "extension" 必须为 "json" 或 "yaml"。 
"suffix" 是一个可选字符串，可用于确定首先按字母顺序应用哪些补丁。
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- help for local -->
local 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">
<!--
--image-repository string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "k8s.gcr.io"
-->
--image-repository string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："k8s.gcr.io"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- Choose a container registry to pull control plane images from -->
选择要从中拉取控制平面镜像的容器仓库
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="继承于父命令的选项">继承于父命令的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- [EXPERIMENTAL] The path to the 'real' host root filesystem.  -->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-fcb78718510a9d3027d1bb9d379c0c17">7.1.1.57 - </h1>
    
	<h3 id="概要">概要</h3>
<!-- 
This command is not meant to be run on its own. See list of available subcommands. 
-->
<p>此命令并非设计用来单独运行。请阅读可用子命令列表。</p>
<pre tabindex="0"><code>kubeadm init phase kubeconfig [flags]
</code></pre><!-- 
### Options 
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for kubeconfig
-->
kubeconfig 操作的帮助命令
</td>
</tr>
</tbody>
</table>
<!-- 
### Options inherited from parent commands 
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-a0e1457f667eb757f82f8c42901aa6c5">7.1.1.58 - </h1>
    
	<h3 id="概要">概要</h3>
<!--
Generate the kubeconfig file for the admin and for kubeadm itself, and save it to admin.conf file.
-->
<p>为管理员和 kubeadm 本身生成 kubeconfig 文件，并将其保存到 admin.conf 文件中。</p>
<pre tabindex="0"><code>kubeadm init phase kubeconfig admin [flags]
</code></pre><!-- 
### Options 
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--apiserver-advertise-address string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The IP address the API Server will advertise it's listening on. If not set the default network interface will be used.
-->
API 服务器所公布的其正在监听的 IP 地址。如果未设置，则使用默认的网络接口。
</td>
</tr>
<tr>
<td colspan="2">
<!--
--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;default: 6443
-->
--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：6443
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Port for the API Server to bind to.
-->
要绑定到 API 服务器的端口。
</td>
</tr>
<tr>
<td colspan="2">
<!--
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"
-->
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The path where to save and store the certificates.
-->
保存和存储证书的路径。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to kubeadm configuration file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">--control-plane-endpoint string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Specify a stable IP address or DNS name for the control plane.
-->
为控制平面指定一个稳定的 IP 地址或 DNS 名称。
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for admin
-->
admin 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubeconfig-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes"
-->
--kubeconfig-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The path where to save the kubeconfig file.
-->
kubeconfig 文件的保存路径。
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "stable-1"
-->
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Choose a specific Kubernetes version for the control plane.
-->
为控制平面指定特定的 Kubernetes 版本。
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="继承于父命令的选项">继承于父命令的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-59e362bf565041872395d165e99eafc1">7.1.1.59 - </h1>
    
	<h3 id="概要">概要</h3>
<!--
Generate all kubeconfig files
-->
<p>生成所有 kubeconfig 文件</p>
<pre tabindex="0"><code>kubeadm init phase kubeconfig all [flags]
</code></pre><!-- 
### Options 
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--apiserver-advertise-address string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The IP address the API Server will advertise it's listening on. If not set the default network interface will be used.
-->
API 服务器所公布的其正在监听的 IP 地址。如果没有设置，将使用默认的网络接口。
</td>
</tr>
<tr>
<td colspan="2">
<!--
--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;default: 6443
-->
--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：6443
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Port for the API Server to bind to.
-->
要绑定到 API 服务器的端口。
</td>
</tr>
<tr>
<td colspan="2">
<!--
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"
-->
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The path where to save and store the certificates.
-->
保存和存储证书的路径。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to kubeadm configuration file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">--control-plane-endpoint string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Specify a stable IP address or DNS name for the control plane.
-->
为控制平面指定一个稳定的 IP 地址或 DNS 名称。
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for all
-->
all 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubeconfig-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes"
-->
--kubeconfig-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The path where to save the kubeconfig file.
-->
kubeconfig 文件的保存路径。
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "stable-1"
-->
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Choose a specific Kubernetes version for the control plane.
-->
为控制平面指定特定的 Kubernetes 版本。
</td>
</tr>
<tr>
<td colspan="2">--node-name string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Specify the node name.
-->
指定节点名称。
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="继承于父命令的选项">继承于父命令的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-2a5040747a02ae2b2326c9901f1725d3">7.1.1.60 - </h1>
    
	<h3 id="概要">概要</h3>
<!--
Generate the kubeconfig file for the controller manager to use and save it to controller-manager.conf file
-->
<p>生成控制器管理器要使用的 kubeconfig 文件，并保存到 controller-manager.conf 文件中。</p>
<pre tabindex="0"><code>kubeadm init phase kubeconfig controller-manager [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--apiserver-advertise-address string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The IP address the API Server will advertise it's listening on. If not set the default network interface will be used.
-->
API 服务器所公布的其正在监听的 IP 地址。如果未设置，则使用默认的网络接口。
</td>
</tr>
<tr>
<td colspan="2">
<!--
--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;default: 6443
-->
--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：6443
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Port for the API Server to bind to.
-->
要绑定到 API 服务器的端口。
</td>
</tr>
<tr>
<td colspan="2">
<!--
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"
-->
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The path where to save and store the certificates.
-->
保存和存储证书的路径。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to kubeadm configuration file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">--control-plane-endpoint string</td>
</tr>
</tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Specify a stable IP address or DNS name for the control plane.
-->
为控制平面指定一个稳定的 IP 地址或 DNS 名称。
</td>
</tr>    
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;"> 
<!--
help for controller-manager
-->
controller-manager 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubeconfig-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes"
-->
--kubeconfig-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The path where to save the kubeconfig file.
-->
kubeconfig 文件的保存路径。
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "stable-1"
-->
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Choose a specific Kubernetes version for the control plane.
-->
为控制平面指定特定的 Kubernetes 版本。
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="继承于父命令的选项">继承于父命令的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs 字符串</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-043bd19497eefb77a6ed30a4d704fe7c">7.1.1.61 - </h1>
    
	<h3 id="概要">概要</h3>
<!--
Generate the kubeconfig file for the kubelet to use and save it to kubelet.conf file.
-->
<p>生成 kubelet 要使用的 kubeconfig 文件，并将其保存到 kubelet.conf 文件。</p>
<!--
Please note that this should *only* be used for cluster bootstrapping purposes. After your control plane is up, you should request all kubelet credentials from the CSR API.
-->
<p>请注意，该操作目的是<em>仅</em>应用于引导集群。在控制平面启动之后，应该从 CSR API 请求所有 kubelet 凭据。</p>
<pre tabindex="0"><code>kubeadm init phase kubeconfig kubelet [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--apiserver-advertise-address string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The IP address the API Server will advertise it's listening on. If not set the default network interface will be used.
-->
API 服务器所公布的其正在监听的 IP 地址。如果未设置，则使用默认的网络接口。
</td>
</tr>
<tr>
<td colspan="2">
<!--
--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;default: 6443
-->
--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：6443
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Port for the API Server to bind to.
-->
要绑定到 API 服务器的端口。
</td>
</tr>
<tr>
<td colspan="2">
<!--
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"
-->
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The path where to save and store the certificates.
-->
保存和存储证书的路径。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to kubeadm configuration file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">--control-plane-endpoint string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Specify a stable IP address or DNS name for the control plane.
-->
为控制平面指定一个稳定的 IP 地址或 DNS 名称。
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for kubelet
-->
kubelet 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubeconfig-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes"
-->
--kubeconfig-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The path where to save the kubeconfig file.
-->
kubeconfig 文件的保存路径。
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "stable-1"
-->
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Choose a specific Kubernetes version for the control plane.
-->
为控制平面选择特定的 Kubernetes 版本。
</td>
</tr>
<tr>
<td colspan="2">--node-name string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Specify the node name.
-->
指定节点的名称。
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="继承于父命令的选项">继承于父命令的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-bffb0d67824e75ade7232d09754b9718">7.1.1.62 - </h1>
    
	<h3 id="概要">概要</h3>
<!--
Generate the kubeconfig file for the scheduler to use and save it to scheduler.conf file.
-->
<p>生成调度器（scheduler）要使用的 kubeconfig 文件，并保存到 scheduler.conf 文件中。</p>
<pre tabindex="0"><code>kubeadm init phase kubeconfig scheduler [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--apiserver-advertise-address string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The IP address the API Server will advertise it's listening on. If not set the default network interface will be used.
-->
API 服务器所公布的其正在监听的 IP 地址。如果未设置，则使用默认的网络接口。
</td>
</tr>
<tr>
<td colspan="2">
<!--
--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;default: 6443
-->
--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：6443
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Port for the API Server to bind to.
-->
要绑定到 API 服务器的端口。
</td>
</tr>
<tr>
<td colspan="2">
<!--
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"
-->
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The path where to save and store the certificates.
-->
保存和存储证书的路径。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to kubeadm configuration file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">--control-plane-endpoint string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Specify a stable IP address or DNS name for the control plane.
-->
为控制平面指定一个稳定的 IP 地址或 DNS 名称。
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for scheduler
-->
scheduler 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubeconfig-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes"
-->
--kubeconfig-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The path where to save the kubeconfig file.
-->
kubeconfig 文件的保存路径。
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "stable-1"
-->
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Choose a specific Kubernetes version for the control plane.
-->
为控制平面指定特定的 Kubernetes 版本。
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="继承于父命令的选项">继承于父命令的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-a37b5872c572c71775e389df50fca215">7.1.1.63 - </h1>
    
	<p>TLS 引导后更新与 kubelet 相关的设置</p>
<pre tabindex="0"><code>kubeadm init phase kubelet-finalize [flags]
</code></pre><!-- ### Examples -->
<h3 id="示例">示例</h3>
<!--  
```
  # Updates settings relevant to the kubelet after TLS bootstrap
  kubeadm init phase kubelet-finalize all --config
```
-->
<pre tabindex="0"><code>  # 在 TLS 引导后更新与 kubelet 相关的设置
  kubeadm init phase kubelet-finalize all --config
</code></pre><!-- ### Options -->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<!-- <td></td><td style="line-height: 130%; word-wrap: break-word;">help for kubelet-finalize</td> -->
<td></td><td style="line-height: 130%; word-wrap: break-word;">kubelet-finalize 操作的帮助命令</td>
</tr>
</tbody>
</table>
<!-- ### Options inherited from parent commands -->
<h3 id="继承于父命令的选项">继承于父命令的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<!-- <td></td><td style="line-height: 130%; word-wrap: break-word;">[EXPERIMENTAL] The path to the 'real' host root filesystem.</td> -->
<td></td><td style="line-height: 130%; word-wrap: break-word;">[实验] 到'真实'主机根文件系统的路径。</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-3f49598c499c3356d89d98fdc8c8ad79">7.1.1.64 - </h1>
    
	<p>运行所有 kubelet-finalize 阶段</p>
<pre tabindex="0"><code>kubeadm init phase kubelet-finalize all [flags]
</code></pre><!-- ### Examples -->
<h3 id="示例">示例</h3>
<!--  
```
  # Updates settings relevant to the kubelet after TLS bootstrap
  kubeadm init phase kubelet-finalize all --config
```
-->
<pre tabindex="0"><code>  # 在 TLS 引导后更新与 kubelet 相关的设置
  kubeadm init phase kubelet-finalize all --config
</code></pre><!-- ### Options -->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<!-- <td colspan="2">--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"</td> -->
<td colspan="2">--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值: "/etc/kubernetes/pki"</td>
</tr>
<tr>
<!-- <td></td><td style="line-height: 130%; word-wrap: break-word;">The path where to save and store the certificates.</td> -->
<td></td><td style="line-height: 130%; word-wrap: break-word;">保存和存储证书的路径。</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<!-- <td></td><td style="line-height: 130%; word-wrap: break-word;">Path to a kubeadm configuration file.</td> -->
<td></td><td style="line-height: 130%; word-wrap: break-word;">kubeadm 配置文件的路径。</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<!-- <td></td><td style="line-height: 130%; word-wrap: break-word;">help for all</td> -->
<td></td><td style="line-height: 130%; word-wrap: break-word;">all 操作的帮助命令</td>
</tr>
</tbody>
</table>
<!-- ### Options inherited from parent commands -->
<h3 id="继承于父命令的选项">继承于父命令的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<!-- <td></td><td style="line-height: 130%; word-wrap: break-word;">[EXPERIMENTAL] The path to the 'real' host root filesystem.</td> -->
<td></td><td style="line-height: 130%; word-wrap: break-word;">[实验] 到'真实'主机根文件系统的路径。</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-7d68ac74e5301f789ddd2e25dd36218e">7.1.1.65 - </h1>
    
	<p>启用 kubelet 客户端证书轮换</p>
<pre tabindex="0"><code>kubeadm init phase kubelet-finalize experimental-cert-rotation [flags]
</code></pre><!-- ### Options -->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"</td>
</tr>
<tr>
<!-- <td></td><td style="line-height: 130%; word-wrap: break-word;">The path where to save and store the certificates.</td> -->
<td></td><td style="line-height: 130%; word-wrap: break-word;">保存和存储证书的路径。</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<!-- <td></td><td style="line-height: 130%; word-wrap: break-word;">Path to a kubeadm configuration file.</td> -->
<td></td><td style="line-height: 130%; word-wrap: break-word;">kubeadm 配置文件的路径。</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<!-- <td></td><td style="line-height: 130%; word-wrap: break-word;">help for experimental-cert-rotation</td> -->
<td></td><td style="line-height: 130%; word-wrap: break-word;">experimental-cert-rotation 操作的帮助命令</td>
</tr>
</tbody>
</table>
<!-- ### Options inherited from parent commands -->
<h3 id="继承于父命令的选项">继承于父命令的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<!-- <td></td><td style="line-height: 130%; word-wrap: break-word;">[EXPERIMENTAL] The path to the 'real' host root filesystem.</td> -->
<td></td><td style="line-height: 130%; word-wrap: break-word;">[实验] 到'真实'主机根文件系统的路径。</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-e7c1ae3d905d9b6854216e26651955cd">7.1.1.66 - </h1>
    
	<h3 id="概要">概要</h3>
<!--
Write a file with KubeletConfiguration and an environment file with node specific kubelet settings, and then (re)start kubelet.
-->
<p>使用 kubelet 配置文件编写一个文件，并使用特定节点的 kubelet 设置编写一个环境文件，然后（重新）启动 kubelet。</p>
<pre tabindex="0"><code>kubeadm init phase kubelet-start [flags]
</code></pre><!--
### Examples
-->
<h3 id="示例">示例</h3>
<!--
# Writes a dynamic environment file with kubelet flags from a InitConfiguration file.
-->
<pre tabindex="0"><code># 从 InitConfiguration 文件中写入带有 kubelet 参数的动态环境文件。
kubeadm init phase kubelet-start --config config.yaml
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to a kubeadm configuration file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">--cri-socket string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to the CRI socket to connect. If empty kubeadm will try to auto-detect this value; use this option only if you have more than one CRI installed or if you have non-standard CRI socket.
-->
连接到 CRI 套接字的路径。如果为空，则 kubeadm 将尝试自动检测该值；仅当安装了多个 CRI 或具有非标准 CRI 套接字时，才使用此选项。
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for kubelet-start
-->
kubelet-start 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">--node-name string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Specify the node name.
-->
指定节点名称。
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-967a98823c19c8338bfc0e1338a20fb1">7.1.1.67 - </h1>
    
	<h3 id="概要">概要</h3>
<!--
Mark a node as a control-plane
-->
<p>标记 Node 节点为控制平面节点</p>
<pre tabindex="0"><code>kubeadm init phase mark-control-plane [flags]
</code></pre><!--
### Examples

# Applies control-plane label and taint to the current node, functionally equivalent to what executed by kubeadm init.
# Applies control-plane label and taint to a specific node
-->
<h3 id="示例">示例</h3>
<pre tabindex="0"><code># 将控制平面标签和污点应用于当前节点，其功能等效于 kubeadm init执行的操作。
kubeadm init phase mark-control-plane --config config.yml

# 将控制平面标签和污点应用于特定节点
kubeadm init phase mark-control-plane --node-name myNode
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to a kubeadm configuration file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for mark-control-plane
-->
mark-control-plane 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">--node-name string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Specify the node name.
-->
指定节点名称。
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs 字符串</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-b5838cc93a3fdb37b61afd201a71edd9">7.1.1.68 - </h1>
    
	<h3 id="概要">概要</h3>
<!--
Run pre-flight checks for kubeadm init.
-->
<p>运行 kubeadm init 前的启动检查。</p>
<pre tabindex="0"><code>kubeadm init phase preflight [flags]
</code></pre><!--
### Examples
-->
<h3 id="案例">案例</h3>
<!--
# Run pre-flight checks for kubeadm init using a config file.
-->
<pre tabindex="0"><code># 使用配置文件对 kubeadm init 进行启动检查。
kubeadm init phase preflight --config kubeadm-config.yml
</code></pre><!-- 
### Options 
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to a kubeadm configuration file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for preflight
-->
preflight 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">--ignore-preflight-errors stringSlice</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
A list of checks whose errors will be shown as warnings. Example: 'IsPrivilegedUser,Swap'. Value 'all' ignores errors from all checks.
-->
错误将显示为警告的检查列表：例如：'IsPrivilegedUser,Swap'。取值为 'all' 时将忽略检查中的所有错误。
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="继承于父命令的选项">继承于父命令的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-f54c84a0fdada369a87b2ced6ccfc38f">7.1.1.69 - </h1>
    
	<h3 id="概要">概要</h3>
<!--
This command is not meant to be run on its own. See list of available subcommands.
-->
<p>此命令并非设计用来单独运行。请参阅可用子命令列表。</p>
<pre tabindex="0"><code>kubeadm init phase upload-certs [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--certificate-key string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Key used to encrypt the control-plane certificates in the kubeadm-certs Secret.
-->
用于加密 kubeadm-certs Secret 中的控制平面证书的密钥。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to a kubeadm configuration file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for upload-certs
-->
upload-certs 操作的帮助命令
</td>
</tr>
<tr>
<!-- td colspan="2">--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"</td -->
<td colspan="2">--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"</td>
</tr>
<tr>
<!-- td></td><td style="line-height: 130%; word-wrap: break-word;">The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.</td -->
<td></td><td style="line-height: 130%; word-wrap: break-word;">
用来与集群通信的 kubeconfig 文件。
如果此标志未设置，则可以在一组标准的位置搜索现有的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan="2">--skip-certificate-key-print</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Don't print the key used to encrypt the control-plane certificates.
-->
不要打印输出用于加密控制平面证书的密钥。
</td>
</tr>
<tr>
<td colspan="2">--upload-certs</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Upload control-plane certificates to the kubeadm-certs Secret.
-->
将控制平面证书上传到 kubeadm-certs Secret。
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-0d96e214c09a8f014e984a6b980522b3">7.1.1.70 - </h1>
    
	<h3 id="概要">概要</h3>
<!--
This command is not meant to be run on its own. See list of available subcommands.
-->
<p>此命令并非设计用来单独运行。请参阅可用的子命令列表。</p>
<pre tabindex="0"><code>kubeadm init phase upload-config [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for upload-config
-->
upload-config 操作的帮助命令
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令中继承的选项">从父命令中继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-48afa88840a20edf1ad613c18480d4fc">7.1.1.71 - </h1>
    
	<h3 id="概要">概要</h3>
<!--
Upload all configuration to a config map
-->
<p>将所有配置上传到 ConfigMap</p>
<pre tabindex="0"><code>kubeadm init phase upload-config all [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to a kubeadm configuration file.
-->
kubeadm 配置文件的路径。
</td>
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for all
-->
all 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"
-->
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.
-->
与集群通信时使用的 kubeconfig 文件。如果未设置该参数，则可以在一组标准位置中搜索现有的 kubeconfig 文件。
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-14da359f76a0f36af507d289dd4a5050">7.1.1.72 - </h1>
    
	<h3 id="概要">概要</h3>
<!--
Upload the kubeadm ClusterConfiguration to a ConfigMap called kubeadm-config in the kube-system namespace. This enables correct configuration of system components and a seamless user experience when upgrading.
-->
<p>将 kubeadm ClusterConfiguration 上传到 kube-system 命名空间中名为 kubeadm-config 的 ConfigMap 中。
这样就可以正确配置系统组件，并在升级时提供无缝的用户体验。</p>
<!--
Alternatively, you can use kubeadm config.
-->
<p>另外，可以使用 kubeadm 配置。</p>
<pre tabindex="0"><code>kubeadm init phase upload-config kubeadm [flags]
</code></pre><!--
### Examples
-->
<h3 id="示例">示例</h3>
<!--
# upload the configuration of your cluster
-->
<pre tabindex="0"><code># 上传集群配置
kubeadm init phase upload-config --config=myConfig.yaml
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to a kubeadm configuration file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for kubeadm
-->
kubeadm 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"
-->
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.
-->
与集群通信时使用的 kubeconfig 文件。如果未设置该参数，则可以在一组标准位置中搜索现有的 kubeconfig 文件。
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-3fda282409b804a14879b9c65c035797">7.1.1.73 - </h1>
    
	<h3 id="概要">概要</h3>
<!--
Upload kubelet configuration extracted from the kubeadm InitConfiguration object to a ConfigMap of the form kubelet-config-1.X in the cluster, where X is the minor version of the current (API Server) Kubernetes version.
-->
<p>将从 kubeadm InitConfiguration 对象提取的 kubelet 配置上传到集群中 kubelet-config-1.X 形式的
ConfigMap，其中 X 是当前（API 服务器）Kubernetes 版本的次要版本。</p>
<pre tabindex="0"><code>kubeadm init phase upload-config kubelet [flags]
</code></pre><!--
### Examples
-->
<h3 id="示例">示例</h3>
<!--
```
  # Upload the kubelet configuration from the kubeadm Config file to a ConfigMap in the cluster.
  kubeadm init phase upload-config kubelet --config kubeadm.yaml
```
-->
<pre tabindex="0"><code># 将 kubelet 配置从 kubeadm 配置文件上传到集群中的 ConfigMap。
kubeadm init phase upload-config kubelet --config kubeadm.yaml
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- Path to a kubeadm configuration file.  -->
到 kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- help for kubelet -->
kubelet 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">
<!-- kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf" -->
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.
-->
与集群通信时使用的 kubeconfig 文件。如果未设置该标签，则可以通过一组标准路径来寻找已有的 kubeconfig 文件。
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-e044e6c69c2b1512c8d89430e0400771">7.1.1.74 - </h1>
    
	<h3 id="摘要">摘要</h3>
<!--
When joining a kubeadm initialized cluster, we need to establish
bidirectional trust. This is split into discovery (having the Node
trust the Kubernetes Control Plane) and TLS bootstrap (having the
Kubernetes Control Plane trust the Node).
-->
<p>当节点加入 kubeadm 初始化的集群时，我们需要建立双向信任。
这个过程可以分解为发现（让待加入节点信任 Kubernetes 控制平面节点）和 TLS 引导（让Kubernetes 控制平面节点信任待加入节点）两个部分。</p>
<!--
There are 2 main schemes for discovery. The first is to use a shared
token along with the IP address of the API server. The second is to
provide a file - a subset of the standard kubeconfig file. This file
can be a local file or downloaded via an HTTPS URL. The forms are
kubeadm join --discovery-token abcdef.1234567890abcdef 1.2.3.4:6443,
kubeadm join --discovery-file path/to/file.conf, or kubeadm join
--discovery-file https://url/file.conf. Only one form can be used. If
the discovery information is loaded from a URL, HTTPS must be used.
Also, in that case the host installed CA bundle is used to verify
the connection.
-->
<p>有两种主要的发现方案。
第一种方法是使用共享令牌和 API 服务器的 IP 地址。
第二种是提供一个文件 - 标准 kubeconfig 文件的一个子集。
该文件可以是本地文件，也可以通过 HTTPS URL 下载。
格式是 <code>kubeadm join --discovery-token abcdef.1234567890abcdef 1.2.3.4:6443</code>、<code>kubeadm join--discovery-file path/to/file.conf</code> 或者<code>kubeadm join --discovery-file https://url/file.conf</code>。
只能使用其中一种。
如果发现信息是从 URL 加载的，必须使用 HTTPS。
此外，在这种情况下，主机安装的 CA 包用于验证连接。</p>
<!--
If you use a shared token for discovery, you should also pass the
--discovery-token-ca-cert-hash flag to validate the public key of the
root certificate authority (CA) presented by the Kubernetes Control Plane.
The value of this flag is specified as "&lt;hash-type&gt;:&lt;hex-encoded-value&gt;",
where the supported hash type is "sha256". The hash is calculated over
the bytes of the Subject Public Key Info (SPKI) object (as in RFC7469).
This value is available in the output of "kubeadm init" or can be
calculated using standard tools. The --discovery-token-ca-cert-hash flag
may be repeated multiple times to allow more than one public key.
-->
<p>如果使用共享令牌进行发现，还应该传递 --discovery-token-ca-cert-hash 参数来验证 Kubernetes 控制平面节点提供的根证书颁发机构（CA）的公钥。
此参数的值指定为 &quot;&lt;hash-type&gt;:&lt;hex-encoded-value&gt;&quot;，其中支持的哈希类型为 &quot;sha256&quot;。哈希是通过 Subject Public Key Info（SPKI）对象的字节计算的（如 RFC7469）。
这个值可以从 &quot;kubeadm init&quot; 的输出中获得，或者可以使用标准工具进行计算。
可以多次重复 --discovery-token-ca-cert-hash 参数以允许多个公钥。</p>
<!--
If you cannot know the CA public key hash ahead of time, you can pass
the --discovery-token-unsafe-skip-ca-verification flag to disable this
verification. This weakens the kubeadm security model since other nodes
can potentially impersonate the Kubernetes Control Plane.
-->
<p>如果无法提前知道 CA 公钥哈希，则可以通过 --discovery-token-unsafe-skip-ca-verification 参数禁用此验证。
这削弱了kubeadm 安全模型，因为其他节点可能会模仿 Kubernetes 控制平面节点。</p>
<!--
The TLS bootstrap mechanism is also driven via a shared token. This is
used to temporarily authenticate with the Kubernetes Control Plane to submit a
certificate signing request (CSR) for a locally created key pair. By
default, kubeadm will set up the Kubernetes Control Plane to automatically
approve these signing requests. This token is passed in with the
--tls-bootstrap-token abcdef.1234567890abcdef flag.

Often times the same token is used for both parts. In this case, the
--token flag can be used instead of specifying each token individually.
-->
<p>TLS 引导机制也通过共享令牌驱动。
这用于向 Kubernetes 控制平面节点进行临时的身份验证，以提交本地创建的密钥对的证书签名请求（CSR）。
默认情况下，kubeadm 将设置 Kubernetes 控制平面节点自动批准这些签名请求。
这个令牌通过 --tls-bootstrap-token abcdef.1234567890abcdef 参数传入。</p>
<p>通常两个部分会使用相同的令牌。
在这种情况下可以使用 --token 参数，而不是单独指定每个令牌。</p>
<!-- 
The "join [api-server-endpoint]" command executes the following phases:
-->
<p>&quot;join [api-server-endpoint]&quot; 命令执行下列阶段：</p>
<pre tabindex="0"><code>preflight              Run join pre-flight checks
control-plane-prepare  Prepare the machine for serving a control plane
  /download-certs        [EXPERIMENTAL] Download certificates shared among control-plane nodes from the kubeadm-certs Secret
  /certs                 Generate the certificates for the new control plane components
  /kubeconfig            Generate the kubeconfig for the new control plane components
  /control-plane         Generate the manifests for the new control plane components
kubelet-start          Write kubelet settings, certificates and (re)start the kubelet
control-plane-join     Join a machine as a control plane instance
  /etcd                  Add a new local etcd member
  /update-status         Register the new control-plane node into the ClusterStatus maintained in the kubeadm-config ConfigMap
  /mark-control-plane    Mark a node as a control-plane
</code></pre><pre tabindex="0"><code>kubeadm join [api-server-endpoint] [flags]
</code></pre><!-- 
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--apiserver-advertise-address string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
If the node should host a new control plane instance, the IP address the API Server will advertise it's listening on. If not set the default network interface will be used.
-->
如果该节点托管一个新的控制平面实例，则 API 服务器将公布其正在侦听的 IP 地址。如果未设置，则使用默认网络接口。
</td>
</tr>
<tr>
<td colspan="2">
<!--
--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: 6443
-->
--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值: 6443
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
If the node should host a new control plane instance, the port for the API Server to bind to.
-->
如果节点应该托管新的控制平面实例，则为 API 服务器要绑定的端口。
</td>
</tr>
<tr>
<td colspan="2">--certificate-key string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Use this key to decrypt the certificate secrets uploaded by init.
-->
使用此密钥可以解密由 init 上传的证书 secret。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to kubeadm config file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">--control-plane</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Create a new control plane instance on this node
-->
在此节点上创建一个新的控制平面实例
</td>
</tr>
<tr>
<td colspan="2">--cri-socket string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to the CRI socket to connect. If empty kubeadm will try to auto-detect this value; use this option only if you have more than one CRI installed or if you have non-standard CRI socket.
-->
要连接的 CRI 套接字的路径。如果为空，则 kubeadm 将尝试自动检测此值；仅当安装了多个 CRI 或具有非标准 CRI 插槽时，才使用此选项。
</td>
</tr>
<tr>
<td colspan="2">--discovery-file string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
For file-based discovery, a file or URL from which to load cluster information.
-->
对于基于文件的发现，给出用于加载集群信息的文件或者 URL。
</td>
</tr>
<tr>
<td colspan="2">--discovery-token string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
For token-based discovery, the token used to validate cluster information fetched from the API server.
-->
对于基于令牌的发现，该令牌用于验证从 API 服务器获取的集群信息。
</td>
</tr>
<tr>
<td colspan="2">--discovery-token-ca-cert-hash stringSlice</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
For token-based discovery, validate that the root CA public key matches this hash (format: "&lt;type&gt;:&lt;value&gt;").
-->
对基于令牌的发现，验证根 CA 公钥是否与此哈希匹配 (格式: "&lt;type&gt;:&lt;value&gt;")。
</td>
</tr>
<tr>
<td colspan="2">--discovery-token-unsafe-skip-ca-verification</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
For token-based discovery, allow joining without --discovery-token-ca-cert-hash pinning.
-->
对于基于令牌的发现，允许在未关联 --discovery-token-ca-cert-hash 参数的情况下添加节点。
</td>
</tr>
<tr>
<td colspan="2">--experimental-patches string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--  
Path to a directory that contains files named "target[suffix][+patchtype].extension". For example, "kube-apiserver0+merge.yaml" or just "etcd.json". "patchtype" can be one of "strategic", "merge" or "json" and they match the patch formats supported by kubectl. The default "patchtype" is "strategic". "extension" must be either "json" or "yaml". "suffix" is an optional string that can be used to determine which patches are applied first alpha-numerically.
-->
包含名为 "target[suffix][+patchtype].extension" 的文件的目录的路径。
例如，"kube-apiserver0+merge.yaml" 或仅仅是 "etcd.json"。
"patchtype" 可以是 "strategic"、"merge" 或 "json" 之一，并且它们与 kubectl 支持的补丁格式匹配。
默认的 "patchtype" 为 "strategic"。 "extension" 必须为 "json" 或 "yaml"。 
"suffix" 是一个可选字符串，可用于确定首先按字母顺序应用哪些补丁。
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for join
-->
join 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">--ignore-preflight-errors stringSlice</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
A list of checks whose errors will be shown as warnings. Example: 'IsPrivilegedUser,Swap'. Value 'all' ignores errors from all checks.
-->
错误将显示为警告的检查列表；例如：'IsPrivilegedUser,Swap'。取值为 'all' 时将忽略检查中的所有错误。
</td>
</tr>
<tr>
<td colspan="2">--node-name string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Specify the node name.
-->
指定节点的名称
</td>
</tr>
<tr>
<td colspan="2">--skip-phases stringSlice</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
List of phases to be skipped
-->
要跳过的阶段列表
</td>
</tr>
<tr>
<td colspan="2">--tls-bootstrap-token string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Specify the token used to temporarily authenticate with the Kubernetes Control Plane while joining the node.
-->
指定在加入节点时用于临时通过 Kubernetes 控制平面进行身份验证的令牌。
</td>
</tr>
<tr>
<td colspan="2">--token string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Use this token for both discovery-token and tls-bootstrap-token when those values are not provided.
-->
如果未提供这些值，则将它们用于 discovery-token 令牌和 tls-bootstrap 令牌。
</td>
</tr>
</tbody>
</table>
<!-- 
### Options inherited from parent commands 
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-9f968809f867b76728697577492429e8">7.1.1.75 - </h1>
    
	<h3 id="概要">概要</h3>
<!--
Use this command to invoke single phase of the join workflow
-->
<p>使用此命令来调用 <code>join</code> 工作流程的某个阶段</p>
<!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- help for phase -->
phase 操作的帮助命令
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令中继承的选项">从父命令中继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- [EXPERIMENTAL] The path to the 'real' host root filesystem.  -->
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-c3c506c1683aed34398a34ab66d609da">7.1.1.76 - </h1>
    
	<h3 id="概要">概要</h3>
<!--
Join a machine as a control plane instance
-->
<p>添加作为控制平面实例的机器</p>
<pre tabindex="0"><code>kubeadm join phase control-plane-join [flags]
</code></pre><!--
### Examples
-->
<h3 id="示例">示例</h3>
<!--
```
# Joins a machine as a control plane instance
kubeadm join phase control-plane-join all
```
-->
<pre tabindex="0"><code># 将机器作为控制平面实例加入
kubeadm join phase control-plane-join all
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for control-plane-join
-->
control-plane-join 操作的帮助命令
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令中继承的选项">从父命令中继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-2c1a5a4405dca745ef50b4e86f5977c7">7.1.1.77 - </h1>
    
	<h3 id="概要">概要</h3>
<!--
Joins a machine as a control plane instance
-->
<p>添加作为控制平面实例的机器</p>
<pre tabindex="0"><code>kubeadm join phase control-plane-join all [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--apiserver-advertise-address string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
If the node should host a new control plane instance, the IP address the API Server will advertise it's listening on. If not set the default network interface will be used.
-->
如果该节点托管一个新的控制平面实例，则 API 服务器将公布其正在侦听的 IP 地址。如果未设置，则使用默认网络接口。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to kubeadm config file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">--experimental-control-plane</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Create a new control plane instance on this node
-->
在此节点上创建一个新的控制平面实例
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for all
-->
all 操作的帮助命令      
</td>
</tr>
<tr>
<td colspan="2">--node-name string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Specify the node name.
-->
指定节点名称。
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-003aaef561d065ecdaeb2c325b6b9253">7.1.1.78 - </h1>
    
	<h3 id="概要">概要</h3>
<!--
Add a new local etcd member
-->
<p>添加新的本地 etcd 成员</p>
<pre tabindex="0"><code>kubeadm join phase control-plane-join etcd [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--apiserver-advertise-address string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
If the node should host a new control plane instance, the IP address the API Server will advertise it's listening on. If not set the default network interface will be used.
-->
如果该节点托管一个新的控制平面实例，则 API 服务器将公布其正在侦听的 IP 地址。如果未设置，则使用默认网络接口。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to kubeadm configuration file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">--control-plane</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Create a new control plane instance on this node
-->
在此节点上创建一个新的控制平面实例
</td>
</tr>
<tr>
<td colspan="2">--experimental-patches string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--  
Path to a directory that contains files named "target[suffix][+patchtype].extension". For example, "kube-apiserver0+merge.yaml" or just "etcd.json". "patchtype" can be one of "strategic", "merge" or "json" and they match the patch formats supported by kubectl. The default "patchtype" is "strategic". "extension" must be either "json" or "yaml". "suffix" is an optional string that can be used to determine which patches are applied first alpha-numerically.
-->
包含名为 "target[suffix][+patchtype].extension" 的文件的目录的路径。
例如，"kube-apiserver0+merge.yaml" 或仅仅是 "etcd.json"。
"patchtype" 可以是"strategic"、"merge" 或 "json" 之一，并且它们与 kubectl 支持的补丁格式匹配。
默认的 "patchtype" 为 "strategic"。 "extension" 必须为 "json" 或 "yaml"。 
"suffix" 是一个可选字符串，可用于确定首先按字母顺序应用哪些补丁。
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for etcd
-->
etcd 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">--node-name string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Specify the node name.
-->
指定节点的名称
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令中继承的选项">从父命令中继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-535f050663a6d8db3a61df2b19a0714b">7.1.1.79 - </h1>
    
	<h3 id="概要">概要</h3>
<!--
Mark a node as a control-plane
-->
<p>将 Node 节点标记为控制平面节点</p>
<pre tabindex="0"><code>kubeadm join phase control-plane-join mark-control-plane [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to kubeadm configuration file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">--control-plane</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Create a new control plane instance on this node
-->
在此节点上创建一个新的控制平面实例
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for mark-control-plane
-->
mark-control-plane 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">--node-name string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Specify the node name.
-->
指定节点的名称
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令中继承的选项">从父命令中继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-2f0a684baffe3cdf830c16693412f8e0">7.1.1.80 - </h1>
    
	<h2 id="概要">概要</h2>
<!-- 
Register the new control-plane node into the ClusterStatus maintained in the kubeadm-config ConfigMap 
-->
<p>将新的控制平面节点注册到 kubeadm-config ConfigMap 维护的 ClusterStatus 中</p>
<pre tabindex="0"><code>kubeadm join phase control-plane-join update-status [flags]
</code></pre><!-- 
### Options 
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--apiserver-advertise-address string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
If the node should host a new control plane instance, the IP address the API Server will advertise it's listening on. If not set the default network interface will be used.
-->
如果该节点托管一个新的控制平面实例，则 API 服务器将公布其正在侦听的 IP 地址。如果未设置，则使用默认网络接口。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- Path to kubeadm config file.  -->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">--control-plane</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- Create a new control plane instance on this node -->
在此节点上创建一个新的控制平面实例
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- help for update-status -->
update-status 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">--node-name string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- Specify the node name.  -->
指定节点名称。
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令中继承的选项">从父命令中继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- [EXPERIMENTAL] The path to the 'real' host root filesystem.  -->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-aba528e06c437710b269f4e41f854fdd">7.1.1.81 - </h1>
    
	<h3 id="概要">概要</h3>
<!--
Prepare the machine for serving a control plane
-->
<p>准备为控制平面服务的机器</p>
<pre tabindex="0"><code>kubeadm join phase control-plane-prepare [flags]
</code></pre><!--
### Examples
-->
<!--
# Prepares the machine for serving a control plane
-->
<h3 id="示例">示例</h3>
<pre tabindex="0"><code># 准备为控制平面服务的机器
kubeadm join phase control-plane-prepare all
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for control-plane-prepare
-->
control-plane-prepare 操作的帮助命令
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令中继承的选项">从父命令中继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-1d7987a759cd1519def4d433710cdff1">7.1.1.82 - </h1>
    
	<h3 id="概要">概要</h3>
<!--
Prepare the machine for serving a control plane
-->
<p>准备为控制平面服务的机器</p>
<pre tabindex="0"><code>kubeadm join phase control-plane-prepare all [api-server-endpoint] [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--apiserver-advertise-address string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
If the node should host a new control plane instance, the IP address the API Server will advertise it's listening on. If not set the default network interface will be used.
-->
如果该节点托管一个新的控制平面实例，则 API 服务器将公布其正在侦听的 IP 地址。如果未设置，则使用默认网络接口。
</td>
</tr>
<tr>
<td colspan="2">
<!--
--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: 6443
-->
--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：6443
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
If the node should host a new control plane instance, the port for the API Server to bind to.
-->
如果该节点托管一个新的控制平面实例，则为 API 服务器要绑定的端口。
</td>
</tr>
<tr>
<td colspan="2">--certificate-key string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Use this key to decrypt the certificate secrets uploaded by init.
-->
使用此密钥解密由 init 上传的证书 secrets。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to kubeadm config file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">--control-plane</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Create a new control plane instance on this node
-->
在此节点上创建一个新的控制平面实例
</td>
</tr>
<tr>
<td colspan="2">--discovery-file string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
For file-based discovery, a file or URL from which to load cluster information.
-->
对于基于文件的发现，给出用于加载集群信息的文件或者 URL。
</td>
</tr>
<tr>
<td colspan="2">--discovery-token string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
For token-based discovery, the token used to validate cluster information fetched from the API server.
-->
对于基于令牌的发现，该令牌用于验证从 API 服务器获取的集群信息。
</td>
</tr>
<tr>
<td colspan="2">--discovery-token-ca-cert-hash stringSlice</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
For token-based discovery, validate that the root CA public key matches this hash (format: "&lt;type&gt;:&lt;value&gt;").
-->
对于基于令牌的发现，请验证根 CA 公钥是否匹配此哈希值（格式："&lt;type&gt;:&lt;value&gt;"）。
</td>
</tr>
<tr>
<td colspan="2">--discovery-token-unsafe-skip-ca-verification</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
For token-based discovery, allow joining without --discovery-token-ca-cert-hash pinning.
-->
对于基于令牌的发现，允许在未关联 --discovery-token-ca-cert-hash 参数的情况下添加节点。
</td>
</tr>
<tr>
<td colspan="2">--experimental-patches string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--  
Path to a directory that contains files named "target[suffix][+patchtype].extension". For example, "kube-apiserver0+merge.yaml" or just "etcd.json". "patchtype" can be one of "strategic", "merge" or "json" and they match the patch formats supported by kubectl. The default "patchtype" is "strategic". "extension" must be either "json" or "yaml". "suffix" is an optional string that can be used to determine which patches are applied first alpha-numerically.
-->
包含名为 "target[suffix][+patchtype].extension" 的文件的目录的路径。
例如，"kube-apiserver0+merge.yaml" 或仅仅是 "etcd.json"。
"patchtype" 可以是 "strategic"、"merge" 或 "json" 之一，并且它们与 kubectl 支持的补丁格式匹配。
默认的 "patchtype" 为 "strategic"。 "extension" 必须为 "json" 或 "yaml"。 
"suffix" 是一个可选字符串，可用于确定首先按字母顺序应用哪些补丁。
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for all
-->
all 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">--node-name string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Specify the node name.
-->
指定节点名称。
</td>
</tr>
<tr>
<td colspan="2">--tls-bootstrap-token string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Specify the token used to temporarily authenticate with the Kubernetes Control Plane while joining the node.
-->
指定在加入节点时用于临时通过 Kubernetes 控制平面进行身份验证的令牌。
</td>
</tr>
<tr>
<td colspan="2">--token string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Use this token for both discovery-token and tls-bootstrap-token when those values are not provided.
-->
如果未提供这些值，则将它们用于 discovery-token 令牌和 tls-bootstrap 令牌。
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-33216a69b333c330cb8b305a119abc7c">7.1.1.83 - </h1>
    
	<h3 id="概要">概要</h3>
<!--
Generate the certificates for the new control plane components
-->
<p>为新的控制平面组件生成证书</p>
<pre tabindex="0"><code>kubeadm join phase control-plane-prepare certs [api-server-endpoint] [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--apiserver-advertise-address string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
If the node should host a new control plane instance, the IP address the API Server will advertise it's listening on. If not set the default network interface will be used.
-->
如果该节点托管一个新的控制平面实例，则 API 服务器将公布其正在侦听的 IP 地址。如果未设置，则使用默认网络接口。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to kubeadm config file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">--control-plane</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Create a new control plane instance on this node
-->
在此节点上创建一个新的控制平面实例
</td>
</tr>
<tr>
<td colspan="2">--discovery-file string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
For file-based discovery, a file or URL from which to load cluster information.
-->
对于基于文件的发现，给出用于加载集群信息的文件或者 URL。
</td>
</tr>
<tr>
<td colspan="2">--discovery-token string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
For token-based discovery, the token used to validate cluster information fetched from the API server.
-->
对于基于令牌的发现，该令牌用于验证从 API 服务器获取的集群信息。
</td>
</tr>
<tr>
<td colspan="2">--discovery-token-ca-cert-hash stringSlice</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
For token-based discovery, validate that the root CA public key matches this hash (format: "&lt;type&gt;:&lt;value&gt;").
-->
对于基于令牌的发现，请验证根 CA 公钥是否匹配此哈希值（格式："&lt;type&gt;:&lt;value&gt;"）。
</td>
</tr>
<tr>
<td colspan="2">--discovery-token-unsafe-skip-ca-verification</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
For token-based discovery, allow joining without --discovery-token-ca-cert-hash pinning.
-->
对于基于令牌的发现，允许在未关联 --discovery-token-ca-cert-hash 参数的情况下添加节点。
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for certs
-->
certs 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">--node-name string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Specify the node name.
-->
指定节点名称。
</td>
</tr>
<tr>
<td colspan="2">--tls-bootstrap-token string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Specify the token used to temporarily authenticate with the Kubernetes Control Plane while joining the node.
-->
指定在加入节点时用于临时通过 Kubernetes 控制平面进行身份验证的令牌。
</td>
</tr>
<tr>
<td colspan="2">--token string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Use this token for both discovery-token and tls-bootstrap-token when those values are not provided.
-->
如果未提供这些值，则将它们用于 discovery-token 令牌和 tls-bootstrap 令牌。
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-53abd743076fc859067264f3e8e676e0">7.1.1.84 - </h1>
    
	<h3 id="概要">概要</h3>
<!--
Generate the manifests for the new control plane components
-->
<p>为新的控制平面组件生成清单（manifest）</p>
<pre tabindex="0"><code>kubeadm join phase control-plane-prepare control-plane [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--apiserver-advertise-address string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
If the node should host a new control plane instance, the IP address the API Server will advertise it's listening on. If not set the default network interface will be used.
-->
对于将要托管新的控制平面实例的节点，指定 API 服务器将公布的其正在侦听的 IP 地址。如果未设置，则使用默认网络接口。
</td>
</tr>
<tr>
<td colspan="2">
<!--
--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: 6443
-->
--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：6443
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
If the node should host a new control plane instance, the port for the API Server to bind to.
-->
针对将要托管新的控制平面实例的节点，设置 API 服务器要绑定的端口。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to kubeadm config file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">--control-plane</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Create a new control plane instance on this node
-->
在此节点上创建一个新的控制平面实例
</td>
</tr>
<tr>
<td colspan="2">--experimental-patches string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--  
Path to a directory that contains files named "target[suffix][+patchtype].extension". For example, "kube-apiserver0+merge.yaml" or just "etcd.json". "patchtype" can be one of "strategic", "merge" or "json" and they match the patch formats supported by kubectl. The default "patchtype" is "strategic". "extension" must be either "json" or "yaml". "suffix" is an optional string that can be used to determine which patches are applied first alpha-numerically.
-->
包含名为 "target[suffix][+patchtype].extension" 的文件的目录的路径。
例如，"kube-apiserver0+merge.yaml" 或仅仅是 "etcd.json"。
"patchtype" 可以是 "strategic"、"merge" 或 "json" 之一，并且它们与 kubectl 支持的补丁格式匹配。
默认的 "patchtype" 为 "strategic"。 "extension" 必须为 "json" 或 "yaml"。 
"suffix" 是一个可选字符串，可用于确定首先按字母顺序应用哪些补丁。
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for control-plane
-->
control-plane 操作的帮助命令
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令中继承的选项">从父命令中继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-3a08eb202d572e417768a942ad24c59f">7.1.1.85 - </h1>
    
	<h3 id="概要">概要</h3>
<!--
[EXPERIMENTAL] Download certificates shared among control-plane nodes from the kubeadm-certs Secret
-->
<p>[实验]从 kubeadm-certs Secret 下载控制平面节点之间共享的证书</p>
<pre tabindex="0"><code>kubeadm join phase control-plane-prepare download-certs [api-server-endpoint] [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--certificate-key string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Use this key to decrypt the certificate secrets uploaded by init.
-->
使用此密钥可以解密由 init 上传的证书 secret。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to kubeadm config file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">--control-plane</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Create a new control plane instance on this node
-->
在此节点上创建一个新的控制平面实例
</td>
</tr>
<tr>
<td colspan="2">--discovery-file string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
For file-based discovery, a file or URL from which to load cluster information.
-->
对于基于文件的发现，给出用于加载集群信息的文件或者 URL。
</td>
</tr>
<tr>
<td colspan="2">--discovery-token string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
For token-based discovery, the token used to validate cluster information fetched from the API server.
-->
对于基于令牌的发现，该令牌用于验证从 API 服务器获取的集群信息。
</td>
</tr>
<tr>
<td colspan="2">--discovery-token-ca-cert-hash stringSlice</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
For token-based discovery, validate that the root CA public key matches this hash (format: "&lt;type&gt;:&lt;value&gt;").
-->
对于基于令牌的发现，请验证根 CA 公钥是否匹配此哈希值（格式："&lt;type&gt;:&lt;value&gt;"）。
</td>
</tr>
<tr>
<td colspan="2">--discovery-token-unsafe-skip-ca-verification</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
For token-based discovery, allow joining without --discovery-token-ca-cert-hash pinning.
-->
对于基于令牌的发现，允许在未关联 --discovery-token-ca-cert-hash 参数的情况下添加节点。
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for kubeconfig
-->
kubeconfig 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">--tls-bootstrap-token string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Specify the token used to temporarily authenticate with the Kubernetes Control Plane while joining the node.
-->
指定在加入节点时用于临时通过 Kubernetes 控制平面进行身份验证的令牌。
</td>
</tr>
<tr>
<td colspan="2">--token string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Use this token for both discovery-token and tls-bootstrap-token when those values are not provided.
-->
如果未提供这些值，则将它们用于 discovery-token 令牌和 tls-bootstrap 令牌。
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令中继承的选项">从父命令中继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-11ed4820a6c3b411d9c4b87163cf0ae7">7.1.1.86 - </h1>
    
	<h3 id="概要">概要</h3>
<!--
Generate the kubeconfig for the new control plane components
-->
<p>为新的控制平面组件生成 kubeconfig</p>
<pre tabindex="0"><code>kubeadm join phase control-plane-prepare kubeconfig [api-server-endpoint] [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--certificate-key string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Use this key to decrypt the certificate secrets uploaded by init.
-->
使用此密钥可以解密由 init 上传的证书 secret。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to kubeadm config file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">--control-plane</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Create a new control plane instance on this node
-->
在此节点上创建一个新的控制平面实例
</td>
</tr>
<tr>
<td colspan="2">--discovery-file string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
For file-based discovery, a file or URL from which to load cluster information.
-->
对于基于文件的发现，给出用于加载集群信息的文件或者 URL。
</td>
</tr>
<tr>
<td colspan="2">--discovery-token string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
For token-based discovery, the token used to validate cluster information fetched from the API server.
-->
对于基于令牌的发现，该令牌用于验证从 API 服务器获取的集群信息。
</td>
</tr>
<tr>
<td colspan="2">--discovery-token-ca-cert-hash stringSlice</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
For token-based discovery, validate that the root CA public key matches this hash (format: "&lt;type&gt;:&lt;value&gt;").
-->
对于基于令牌的发现，请验证根 CA 公钥是否匹配此哈希值（格式："&lt;type&gt;:&lt;value&gt;"）。
</td>
</tr>
<tr>
<td colspan="2">--discovery-token-unsafe-skip-ca-verification</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
For token-based discovery, allow joining without --discovery-token-ca-cert-hash pinning.
-->
对于基于令牌的发现，允许在未关联 --discovery-token-ca-cert-hash 参数的情况下添加节点。
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for kubeconfig
-->
kubeconfig 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">--tls-bootstrap-token string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Specify the token used to temporarily authenticate with the Kubernetes Control Plane while joining the node.
-->
指定在加入节点时用于临时通过 Kubernetes 控制平面进行身份验证的令牌。
</td>
</tr>
<tr>
<td colspan="2">--token string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Use this token for both discovery-token and tls-bootstrap-token when those values are not provided.
-->
如果未提供这些值，则将它们用于 discovery-token 令牌和 tls-bootstrap 令牌。
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令中继承的选项">从父命令中继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-e81c9d9320242b5ed4b063beea6696f8">7.1.1.87 - </h1>
    
	<h3 id="概要">概要</h3>
<!--
Write a file with KubeletConfiguration and an environment file with node specific kubelet settings, and then (re)start kubelet.
-->
<p>生成一个包含 KubeletConfiguration 的文件和一个包含特定于节点的 kubelet 配置的环境文件，然后（重新）启动 kubelet。</p>
<pre tabindex="0"><code>kubeadm join phase kubelet-start [api-server-endpoint] [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to kubeadm config file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">--cri-socket string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to the CRI socket to connect. If empty kubeadm will try to auto-detect this value; use this option only if you have more than one CRI installed or if you have non-standard CRI socket.
-->
提供给 CRI 套接字建立连接的路径。如果为空，则 kubeadm 将尝试自动检测该值；仅当安装了多个 CRI 或具有非标准 CRI 套接字时，才使用此选项。
</td>
</tr>
<tr>
<td colspan="2">--discovery-file string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
For file-based discovery, a file or URL from which to load cluster information.
<!--
For file-based discovery, a file or URL from which to load cluster information.
-->
对于基于文件的发现，给出用于加载集群信息的文件或者 URL。
</td>
</tr>
<tr>
<td colspan="2">--discovery-token string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
For token-based discovery, the token used to validate cluster information fetched from the API server.
-->
对于基于令牌的发现，该令牌用于验证从 API 服务器获取的集群信息。
</td>
</tr>
<tr>
<td colspan="2">--discovery-token-ca-cert-hash stringSlice</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
For token-based discovery, validate that the root CA public key matches this hash (format: "&lt;type&gt;:&lt;value&gt;").
-->
对于基于令牌的发现，验证根 CA 公钥是否匹配此哈希值（格式："&lt;type&gt;:&lt;value&gt;"）。
</td>
</tr>
<tr>
<td colspan="2">--discovery-token-unsafe-skip-ca-verification</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
For token-based discovery, allow joining without --discovery-token-ca-cert-hash pinning.
-->
对于基于令牌的发现，允许在未关联 --discovery-token-ca-cert-hash 参数的情况下添加节点。
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for kubelet-start
-->
kubelet-start 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">--node-name string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Specify the node name.
-->
指定节点名称。
</td>
</tr>
<tr>
<td colspan="2">--tls-bootstrap-token string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Specify the token used to temporarily authenticate with the Kubernetes Control Plane while joining the node.
-->
指定在加入节点时用于临时通过 Kubernetes 控制平面进行身份验证的令牌。
</td>
</tr>
<tr>
<td colspan="2">--token string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Use this token for both discovery-token and tls-bootstrap-token when those values are not provided.
-->
如果未提供这些值，则将它们用于 discovery-token 令牌和 tls-bootstrap 令牌。
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-47f2d404188d6eb1fbf6fffd7fba4e48">7.1.1.88 - </h1>
    
	<h3 id="概要">概要</h3>
<!--
Run pre-flight checks for kubeadm join.
-->
<p>运行 kubeadm join 命令添加节点前检查。</p>
<pre tabindex="0"><code>kubeadm join phase preflight [api-server-endpoint] [flags]
</code></pre><!--
### Examples
# Run join pre-flight checks using a config file.
-->
<h3 id="示例">示例</h3>
<pre tabindex="0"><code># 使用配置文件运行 kubeadm join 命令添加节点前检查。
kubeadm join phase preflight --config kubeadm-config.yml
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--apiserver-advertise-address string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
If the node should host a new control plane instance, the IP address the API Server will advertise it's listening on. If not set the default network interface will be used.
-->
对于将要托管新的控制平面实例的节点，指定 API 服务器将公布的其正在侦听的 IP 地址。如果未设置，则使用默认网络接口。
</td>
</tr>
<tr>
<td colspan="2">
<!--
--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: 6443
-->
--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：6443
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
If the node should host a new control plane instance, the port for the API Server to bind to.
-->
针对将要托管新的控制平面实例的节点，设置 API 服务器要绑定的端口。
</td>
</tr>
<tr>
<td colspan="2">--certificate-key string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Use this key to decrypt the certificate secrets uploaded by init.
-->
使用此密钥可以解密由 `init` 操作上传的证书 secret。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to kubeadm config file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">--control-plane</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Create a new control plane instance on this node
-->
在此节点上创建一个新的控制平面实例
</td>
</tr>
<tr>
<td colspan="2">--cri-socket string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to the CRI socket to connect. If empty kubeadm will try to auto-detect this value; use this option only if you have more than one CRI installed or if you have non-standard CRI socket.
-->
提供给 CRI 套接字建立连接的路径。如果为空，则 kubeadm 将尝试自动检测该值；仅当安装了多个 CRI 或具有非标准 CRI 套接字时，才使用此选项。
</td>
</tr>
<tr>
<td colspan="2">--discovery-file string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
For file-based discovery, a file or URL from which to load cluster information.
-->
对于基于文件的发现，给出用于加载集群信息的文件或者 URL。
</td>
</tr>
<tr>
<td colspan="2">--discovery-token string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
For token-based discovery, the token used to validate cluster information fetched from the API server.
-->
对于基于令牌的发现，该令牌用于验证从 API 服务器获取的集群信息。
</td>
</tr>
<tr>
<td colspan="2">--discovery-token-ca-cert-hash stringSlice</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
For token-based discovery, validate that the root CA public key matches this hash (format: "&lt;type&gt;:&lt;value&gt;").
-->
对于基于令牌的发现，验证根 CA 公钥是否匹配此哈希值（格式："&lt;type&gt;:&lt;value&gt;"）。
</td>
</tr>
<tr>
<td colspan="2">--discovery-token-unsafe-skip-ca-verification</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
For token-based discovery, allow joining without --discovery-token-ca-cert-hash pinning.
-->
对于基于令牌的发现，允许在未关联 --discovery-token-ca-cert-hash 参数的情况下添加节点。
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for preflight
-->
preflight 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">--ignore-preflight-errors stringSlice</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
A list of checks whose errors will be shown as warnings. Example: 'IsPrivilegedUser,Swap'. Value 'all' ignores errors from all checks.
-->
错误将显示为警告的检查列表；例如：'IsPrivilegedUser,Swap'。取值为 'all' 时将忽略检查中的所有错误。
</td>
</tr>
<tr>
<td colspan="2">--node-name string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Specify the node name.
-->
指定节点名称。
</td>
</tr>
<tr>
<td colspan="2">--tls-bootstrap-token string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Specify the token used to temporarily authenticate with the Kubernetes Control Plane while joining the node.
-->
指定在加入节点时用于临时通过 Kubernetes 控制平面进行身份验证的令牌。
</td>
</tr>
<tr>
<td colspan="2">--token string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Use this token for both discovery-token and tls-bootstrap-token when those values are not provided.
-->
如果未提供这些值，则将它们用于 discovery-token 令牌和 tls-bootstrap 令牌。
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-a46a193f2322aa88cb3b2de2447b0461">7.1.1.89 - </h1>
    
	<h3 id="概要">概要</h3>
<!--
Performs a best effort revert of changes made to this host by 'kubeadm init' or 'kubeadm join'
-->
<p>尽最大努力还原通过 'kubeadm init' 或者 'kubeadm join' 操作对主机所做的更改</p>
<!--
The "reset" command executes the following phases:
-->
<p>&quot;reset&quot; 命令执行以下阶段：</p>
<pre tabindex="0"><code>preflight              Run reset pre-flight checks
update-cluster-status  Remove this node from the ClusterStatus object.
remove-etcd-member     Remove a local etcd member.
cleanup-node           Run cleanup node.
</code></pre><pre tabindex="0"><code>kubeadm reset [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">
<!--
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"
-->
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The path to the directory where the certificates are stored. If specified, clean this directory.
-->
存储证书的目录路径。如果已指定，则需要清空此目录。
</td>
</tr>
<tr>
<td colspan="2">--cri-socket string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to the CRI socket to connect. If empty kubeadm will try to auto-detect this value; use this option only if you have more than one CRI installed or if you have non-standard CRI socket.
-->
要连接的 CRI 套接字的路径。如果为空，则 kubeadm 将尝试自动检测此值；仅当安装了多个CRI 或具有非标准 CRI 插槽时，才使用此选项。
</td>
</tr>
<tr>
<td colspan="2">-f, --force</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Reset the node without prompting for confirmation.
-->
在不提示确认的情况下重置节点。
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for reset
-->
reset 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">--ignore-preflight-errors stringSlice</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
A list of checks whose errors will be shown as warnings. Example: 'IsPrivilegedUser,Swap'. Value 'all' ignores errors from all checks.
-->
错误将显示为警告的检查列表；例如：'IsPrivilegedUser,Swap'。取值为 'all' 时将忽略检查中的所有错误。
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"
-->
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.
-->
与集群通信时使用的 kubeconfig 文件。如果未设置该标志，则可以在一组标准位置中搜索现有的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan="2">--skip-phases stringSlice</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- List of phases to be skipped -->
要跳过的阶段列表
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-f5b27d7bd0eeed918f8635c68d220dc5">7.1.1.90 - </h1>
    
	<h3 id="概要">概要</h3>
<!--
Use this command to invoke single phase of the reset workflow
-->
<p>使用此命令来调用 <code>reset</code> 工作流程的某个阶段</p>
<!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for phase
-->
phase 操作的帮助命令
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-370e9ffda66b4c48dfa54ea37c3aad21">7.1.1.91 - </h1>
    
	<h3 id="概要">概要</h3>
<!--
Run cleanup node.
-->
<p>执行 cleanup node（清理节点）操作。</p>
<pre tabindex="0"><code>kubeadm reset phase cleanup-node [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">
<!--
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"
-->
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The path to the directory where the certificates are stored. If specified, clean this directory.
-->
存储证书的目录路径。如果已指定，则需要清空此目录。
</td>
</tr>
<tr>
<td colspan="2">--cri-socket string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to the CRI socket to connect. If empty kubeadm will try to auto-detect this value; use this option only if you have more than one CRI installed or if you have non-standard CRI socket.
-->
要连接的 CRI 套接字的路径。如果为空，则 kubeadm 将尝试自动检测此值；仅当安装了多个CRI 或具有非标准 CRI 插槽时，才使用此选项。
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for cleanup-node
-->
cleanup-node 操作的帮助命令
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-6bd27042c883aa5c498647d37762392c">7.1.1.92 - </h1>
    
	<h3 id="概要">概要</h3>
<!--
Run pre-flight checks for kubeadm reset.
-->
<p>kubeadm reset（重置）前运行启动前检查。</p>
<pre tabindex="0"><code>kubeadm reset phase preflight [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">-f, --force</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Reset the node without prompting for confirmation.
-->
在不提示确认的情况下重置节点。
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for preflight
-->
preflight 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">--ignore-preflight-errors stringSlice</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
A list of checks whose errors will be shown as warnings. Example: 'IsPrivilegedUser,Swap'. Value 'all' ignores errors from all checks.
-->
错误将显示为警告的检查列表；例如：'IsPrivilegedUser,Swap'。取值为 'all' 时将忽略检查中的所有错误。
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-3a000435e1cca0be398b44b487f530c8">7.1.1.93 - </h1>
    
	<h3 id="概要">概要</h3>
<!--
Upload configuration about the current state, so that 'kubeadm upgrade' can later know how to configure the upgraded cluster.
-->
<p>上传关于当前状态的配置，以便 'kubeadm upgrade' 以后可以知道如何配置升级后的集群。</p>
<pre tabindex="0"><code>kubeadm config upload [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">upload 操作的帮助信息</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<!-- td colspan="2">kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"</td -->
<td colspan="2">--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值： "/etc/kubernetes/admin.conf"</td>
</tr>
<tr>
<!-- td></td><td style="line-height: 130%; word-wrap: break-word;">The KubeConfig file to use when talking to the cluster. If the flag is not set, a set of standard locations are searched for an existing KubeConfig file.</td -->
<td></td><td style="line-height: 130%; word-wrap: break-word;">用于和集群通信的 KubeConfig 文件。如果它没有被设置，那么 kubeadm 将会搜索一个已经存在于标准路径的 KubeConfig 文件。</td>
</tr>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<!-- td></td><td style="line-height: 130%; word-wrap: break-word;">[EXPERIMENTAL] The path to the 'real' host root filesystem.</td -->
<td></td><td style="line-height: 130%; word-wrap: break-word;">[实验] 到'真实'主机根文件系统的路径。</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-97fbe97ca22de377e7fbf2517e0451b6">7.1.1.94 - </h1>
    
	<h3 id="概要">概要</h3>
<!--
Remove this node from the ClusterStatus object if the node is a control plane node.
-->
<p>如果该节点是控制平面节点，从 ClusterStatus 对象中删除该节点。</p>
<pre tabindex="0"><code>kubeadm reset phase update-cluster-status [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- help for update-cluster-status -->
update-cluster-status 操作的帮助命令
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- [EXPERIMENTAL] The path to the 'real' host root filesystem.  -->
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-bee6749065a369c2ab5b311eb43c40ba">7.1.1.95 - </h1>
    
	<h3 id="概要">概要</h3>
<!--
This command manages bootstrap tokens. It is optional and needed only for advanced use cases.
-->
<p>此命令管理引导令牌（bootstrap token）。它是可选的，仅适用于高级用例。</p>
<!--
In short, bootstrap tokens are used for establishing bidirectional trust between a client and a server.
A bootstrap token can be used when a client (for example a node that is about to join the cluster) needs
to trust the server it is talking to. Then a bootstrap token with the "signing" usage can be used.
-->
<p>简而言之，引导令牌（bootstrap token）用于在客户端和服务器之间建立双向信任。
当客户端（例如，即将加入集群的节点）需要时，可以使用引导令牌相信正在与之通信的服务器。
然后可以使用具有 “签名” 的引导令牌。</p>
<!--
bootstrap tokens can also function as a way to allow short-lived authentication to the API Server
(the token serves as a way for the API Server to trust the client), for example for doing the TLS Bootstrap.
-->
<p>引导令牌还可以作为一种允许对 API 服务器进行短期身份验证的方法（令牌用作 API 服务器信任客户端的方式），例如用于执行 TLS 引导程序。</p>
<!--
What is a bootstrap token more exactly?
 - It is a Secret in the kube-system namespace of type "bootstrap.kubernetes.io/token".
 - A bootstrap token must be of the form "[a-z0-9]{6}.[a-z0-9]{16}". The former part is the public token ID,
   while the latter is the Token Secret and it must be kept private at all circumstances!
 - The name of the Secret must be named "bootstrap-token-(token-id)".
 -->
<p>引导令牌准确来说是什么？</p>
<ul>
<li>它是位于 kube-system 命名空间中类型为 “bootstrap.kubernetes.io/token” 的一个 Secret。</li>
<li>引导令牌的格式必须为 “[a-z0-9]{6}.[a-z0-9]{16}”，前一部分是公共令牌 ID，而后者是令牌秘钥，必须在任何情况下都保密！</li>
<li>必须将 Secret 的名称命名为 “bootstrap-token-(token-id)”。</li>
</ul>
<!--
You can read more about bootstrap tokens here:
  /docs/admin/bootstrap-tokens/
-->
<p>您可以在此处阅读有关引导令牌（bootstrap token）的更多信息：
/docs/admin/bootstrap-tokens/</p>
<pre tabindex="0"><code>kubeadm token [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--dry-run</td>
</tr>
<tr>
<!--
<td></td><td style="line-height: 130%; word-wrap: break-word;">Whether to enable dry-run mode or not</td>
-->
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Whether to enable dry-run mode or not
-->
是否启用 `dry-run` 模式
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<!--
<td></td><td style="line-height: 130%; word-wrap: break-word;">help for token</td>
-->
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for token
-->
token 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"
-->
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<!--
<td></td><td style="line-height: 130%; word-wrap: break-word;">The KubeConfig file to use when talking to the cluster. If the flag is not set, a set of standard locations are searched for an existing KubeConfig file.</td>
-->
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.
-->
与集群通信时使用的 kubeconfig 文件。如果未设置，则搜索一组标准位置以查找现有 kubeconfig 文件。
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-bdd9680ec894593d17f782d5e5665fd4">7.1.1.96 - </h1>
    
	<h3 id="概要">概要</h3>
<!--
This command will create a bootstrap token for you.
You can specify the usages for this token, the "time to live" and an optional human friendly description.

The [token] is the actual token to write.
This should be a securely generated random token of the form "[a-z0-9]{6}.[a-z0-9]{16}".
If no [token] is given, kubeadm will generate a random token instead.
-->
<p>这个命令将为你创建一个引导令牌。
您可以设置此令牌的用途，&quot;有效时间&quot; 和可选的人性化的描述。</p>
<p>这里的 [token] 是指将要生成的实际令牌。
该令牌应该是一个通过安全机制生成的随机令牌，形式为 &quot;[a-z0-9]{6}.[a-z0-9]{16}&quot;。
如果没有给出 [token]，kubeadm 将生成一个随机令牌。</p>
<pre tabindex="0"><code>kubeadm token create [token]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to a kubeadm configuration file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">--description string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
A human friendly description of how this token is used.
-->
针对令牌用途的人性化的描述。
</td>
</tr>
<tr>
<td colspan="2">
<!--
--groups stringSlice&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: [system:bootstrappers:kubeadm:default-node-token]
-->
--groups stringSlice&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：[system:bootstrappers:kubeadm:default-node-token]
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Extra groups that this token will authenticate as when used for authentication. Must match "\\Asystem:bootstrappers:[a-z0-9:-]{0,255}[a-z0-9]\\z"
-->
此令牌用于身份验证时将进行身份验证的其他组。必须匹配  "\\Asystem:bootstrappers:[a-z0-9:-]{0,255}[a-z0-9]\\z"
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for create
-->
create 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">--print-join-command</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Instead of printing only the token, print the full 'kubeadm join' flag needed to join the cluster using the token.
-->
不仅仅打印令牌，而是打印使用令牌加入集群所需的完整 'kubeadm join' 参数。
</td>
</tr>
<tr>
<td colspan="2">
<!--
--ttl duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: 24h0m0s
-->
--ttl duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：24h0m0s
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The duration before the token is automatically deleted (e.g. 1s, 2m, 3h). If set to '0', the token will never expire
-->
令牌有效时间，超过该时间令牌被自动删除。(例如： 1s, 2m, 3h)。如果设置为 '0'，令牌将永远不过期。
</td>
</tr>
<tr>
<td colspan="2">
<!--
--usages stringSlice&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: [signing,authentication]
-->
--usages stringSlice&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：[signing,authentication]
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Describes the ways in which this token can be used. You can pass --usages multiple times or provide a comma separated list of options. Valid options: [signing,authentication]
-->
描述可以使用此令牌的方式。你可以多次使用 `--usages` 或者提供一个以逗号分隔的选项列表。合法选项有: [signing,authentication]
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--dry-run</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Whether to enable dry-run mode or not
-->
是否启用 `dry-run` 运行模式
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"
-->
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.
-->
用于和集群通信的 KubeConfig 文件。如果它没有被设置，那么 kubeadm 将会搜索一个已经存在于标准路径的 KubeConfig 文件。
</td>
</tr>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-1d005baad1a1e217d7ae0210fec96c3f">7.1.1.97 - </h1>
    
	<h3 id="概要">概要</h3>
<!--
This command will delete a list of bootstrap tokens for you.

The [token-value] is the full Token of the form "[a-z0-9]{6}.[a-z0-9]{16}" or the
Token ID of the form "[a-z0-9]{6}" to delete.
-->
<p>这个命令将为你删除指定的引导令牌列表。</p>
<p><code>[token-value]</code> 是要删除的 &quot;[a-z0-9]{6}.[a-z0-9]{16}&quot; 形式的完整令牌或者是 &quot;[a-z0-9]{6}&quot; 形式的的令牌 ID。</p>
<pre tabindex="0"><code>kubeadm token delete [token-value] ...
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for delete
-->
delete 操作的帮助命令
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--dry-run</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Whether to enable dry-run mode or not
-->
是否启用 `dry-run` 运行模式
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"
-->
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.
-->
用于和集群通信的 KubeConfig 文件。如果它没有被设置，那么 kubeadm 将会搜索一个已经存在于标准路径的 KubeConfig 文件。
</td>
</tr>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-c79d11d27bed54caac743c93e0b2fb24">7.1.1.98 - </h1>
    
	<h3 id="概要">概要</h3>
<!--
This command will print out a randomly-generated bootstrap token that can be used with
the "init" and "join" commands.

You don't have to use this command in order to generate a token. You can do so
yourself as long as it is in the format "[a-z0-9]{6}.[a-z0-9]{16}". This
command is provided for convenience to generate tokens in the given format.

You can also use "kubeadm init" without specifying a token and it will
generate and print one for you.
-->
<p>此命令将打印一个随机生成的可以被 &quot;init&quot; 和 &quot;join&quot; 命令使用的引导令牌。
您不必使用此命令来生成令牌。你可以自己设定，只要格式符合 &quot;[a-z0-9]{6}.[a-z0-9]{16}&quot;。这个命令提供是为了方便生成规定格式的令牌。
您也可以使用 &quot;kubeadm init&quot; 并且不指定令牌，该命令会生成一个令牌并打印出来。</p>
<pre tabindex="0"><code>kubeadm token generate [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for generate
-->
generate 操作的帮助命令
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--dry-run</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- Whether to enable dry-run mode or not -->
是否启用 `dry-run` 运行模式</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"
-->
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.
-->
用于和集群通信的 KubeConfig 文件。如果它没有被设置，那么 kubeadm 将会搜索一个已经存在于标准路径的 KubeConfig 文件。
</td>
</tr>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- [EXPERIMENTAL] The path to the 'real' host root filesystem.  -->
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-ba78e64c325e4131dd741235e2a1b2c0">7.1.1.99 - </h1>
    
	<h3 id="概要">概要</h3>
<!--
This command will list all bootstrap tokens for you.
-->
<p>此命令将为您列出所有的引导令牌。</p>
<pre tabindex="0"><code>kubeadm token list [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">
<!-- --allow-missing-template-keys&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: true -->
--allow-missing-template-keys&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：true
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- 
If true, ignore any errors in templates when a field or map key is missing in the template. Only applies to golang and jsonpath output formats.
-->
如果设置为 true，则在模板中缺少字段或哈希表的键时忽略模板中的任何错误。
仅适用于 golang 和 jsonpath 输出格式。
</td>
</tr>
<tr>
<td colspan="2">
<!-- -o, --experimental-output string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "text" -->
-o, --experimental-output string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："text"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--  
Output format. One of: text|json|yaml|go-template|go-template-file|template|templatefile|jsonpath|jsonpath-as-json|jsonpath-file.
-->
输出格式：text|json|yaml|go-template|go-template-file|template|templatefile|jsonpath|jsonpath-as-json|jsonpath-file 其中之一
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- help for list -->
list 操作的帮助命令
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--dry-run</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- Whether to enable dry-run mode or not -->
是否启用 `dry-run` 模式
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"
-->
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.
-->
用于和集群通信的 kubeconfig 文件。如果它没有被设置，那么 kubeadm 将会搜索一个已经存在于标准路径的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- [EXPERIMENTAL] The path to the 'real' host root filesystem.  -->
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-872d33f1fbc83cb2f0bf89b4bd545174">7.1.1.100 - </h1>
    
	<h3 id="概要">概要</h3>
<!--
Upgrade your cluster smoothly to a newer version with this command
-->
<p>此命令能将集群平滑升级到新版本</p>
<pre tabindex="0"><code>kubeadm upgrade [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for upgrade
-->
upgrade 操作的帮助命令
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="继承于父命令的选项">继承于父命令的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-7d8c1710684742ca940f580674225d9d">7.1.1.101 - </h1>
    
	<h3 id="概要">概要</h3>
<!--
Upgrade your Kubernetes cluster to the specified version
-->
<p>将 Kubernetes 集群升级到指定版本</p>
<pre tabindex="0"><code>kubeadm upgrade apply [version]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--allow-experimental-upgrades</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Show unstable versions of Kubernetes as an upgrade alternative and allow upgrading to an alpha/beta/release candidate versions of Kubernetes.
-->
显示 Kubernetes 的不稳定版本作为升级替代方案，并允许升级到 Kubernetes 的 alpha/beta 或 RC 版本。
</td>
</tr>
<tr>
<td colspan="2">--allow-release-candidate-upgrades</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Show release candidate versions of Kubernetes as an upgrade alternative and allow upgrading to a release candidate versions of Kubernetes.
-->
显示 Kubernetes 的候选版本作为升级替代方案，并允许升级到 Kubernetes 的 RC 版本。
</td>
</tr>
<tr>
<td colspan="2">--certificate-renewal&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: true</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Perform the renewal of certificates used by component changed during upgrades.
-->
执行升级期间更改的组件所使用的证书的更新。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to a kubeadm configuration file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">--dry-run</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Do not change any state, just output what actions would be performed.
-->
不要更改任何状态，只输出要执行的操作。
</td>
</tr>
<tr>
<td colspan="2">
<!--
--etcd-upgrade&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: true
-->
--etcd-upgrade&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值: true
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Perform the upgrade of etcd.
-->
执行 etcd 的升级。
</td>
</tr>
<tr>
<td colspan="2">--experimental-patches string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--  
Path to a directory that contains files named "target[suffix][+patchtype].extension". For example, "kube-apiserver0+merge.yaml" or just "etcd.json". "patchtype" can be one of "strategic", "merge" or "json" and they match the patch formats supported by kubectl. The default "patchtype" is "strategic". "extension" must be either "json" or "yaml". "suffix" is an optional string that can be used to determine which patches are applied first alpha-numerically.
-->
包含名为 "target[suffix][+patchtype].extension" 的文件的目录的路径。
例如，"kube-apiserver0+merge.yaml" 或仅仅是 "etcd.json"。
"patchtype" 可以是 "strategic"、"merge" 或 "json" 之一，并且它们与 kubectl 支持的补丁格式匹配。
默认的 "patchtype" 为 "strategic"。 "extension" 必须为 "json" 或 "yaml"。 
"suffix" 是一个可选字符串，可用于确定首先按字母顺序应用哪些补丁。
</td>
</tr>
<tr>
<td colspan="2">--feature-gates string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
A set of key=value pairs that describe feature gates for various features. Options are:<br/>IPv6DualStack=true|false (ALPHA - default=false)
-->
一组键值对，用于描述各种功能。选项包括：
<br/>IPv6DualStack=true|false (ALPHA - 默认=false)
<br/>PublicKeysECDSA=true|false (ALPHA - 默认=false)
</td>
</tr>
<tr>
<td colspan="2">-f, --force</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Force upgrading although some requirements might not be met. This also implies non-interactive mode.
-->
强制升级，但可能无法满足某些要求。这也意味着非交互模式。
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for apply
-->
apply 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">--ignore-preflight-errors stringSlice</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
A list of checks whose errors will be shown as warnings. Example: 'IsPrivilegedUser,Swap'. Value 'all' ignores errors from all checks.
-->
错误将显示为警告的检查列表；例如：'IsPrivilegedUser,Swap'。取值为 'all' 时将忽略检查中的所有错误。
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"
-->
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.
-->
与集群通信时使用的 kubeconfig 文件。如果未设置标志，则在相关目录下搜索以查找现有 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan="2">--print-config</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Specifies whether the configuration file that will be used in the upgrade should be printed or not.
-->
指定是否应打印将在升级中使用的配置文件。
</td>
</tr>
<tr>
<td colspan="2">-y, --yes</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Perform the upgrade and do not prompt for confirmation (non-interactive mode).
-->
执行升级，不提示确认（非交互模式）。
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-28dcf20d89c7bb1c8e7a3873d7703d5d">7.1.1.102 - </h1>
    
	<h3 id="概述">概述</h3>
<p>显示哪些差异将被应用于现有的静态 pod 资源清单。参考: kubeadm upgrade apply --dry-run</p>
<pre tabindex="0"><code>kubeadm upgrade diff [version] [flags]
</code></pre><!--

### Options

   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>

<tr>
<td colspan="2">--api-server-manifest string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/manifests/kube-apiserver.yaml"</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">path to API server manifest</td>
</tr>
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--api-server-manifest string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/manifests/kube-apiserver.yaml"</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">API服务器清单的路径</td>
</tr>
<!--
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">Path to a kubeadm configuration file.</td>
</tr>
-->
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">kubeadm 配置文件的路径</td>
</tr>
<!--
<tr>
<td colspan="2">-c, --context-lines int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: 3</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">How many lines of context in the diff</td>
</tr>
-->
<tr>
<td colspan="2">-c, --context-lines int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：3</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">差异中有多少行上下文</td>
</tr>
<!--
<tr>
<td colspan="2">--controller-manager-manifest string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/manifests/kube-controller-manager.yaml"</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">path to controller manifest</td>
</tr>
-->
<tr>
<td colspan="2">--controller-manager-manifest string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值： "/etc/kubernetes/manifests/kube-controller-manager.yaml"</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">控制器清单的路径</td>
</tr>
<!--
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">help for diff</td>
</tr>
-->
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">帮助</td>
</tr>
<!--
<tr>
<td colspan="2">--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.</td>
</tr>
-->
<tr>
<td colspan="2">--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">与集群通信时使用的 kubeconfig 文件，如果标志是未设置，则可以在一组标准位置中搜索现有的 kubeconfig 文件。</td>
</tr>
<!--
<tr>
<td colspan="2">--scheduler-manifest string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/manifests/kube-scheduler.yaml"</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">path to scheduler manifest</td>
</tr>
</tbody>
</table>
-->
<tr>
<td colspan="2">--scheduler-manifest string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/manifests/kube-scheduler.yaml"</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">调度程序清单的路径</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands

   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>

<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">[EXPERIMENTAL] The path to the 'real' host root filesystem.</td>
</tr>

</tbody>
</table>

-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">[EXPERIMENTAL] “真实”主机根文件系统的路径。</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-f869b6331e40c6f9eb01314f96d3113e">7.1.1.103 - </h1>
    
	<h3 id="概要">概要</h3>
<!--
Upgrade commands for a node in the cluster
-->
<p>升级集群中某个节点的命令</p>
<!--
The "node" command executes the following phases:
-->
<p>&quot;node&quot; 命令执行以下阶段：</p>
<!--
```
preflight       Run upgrade node pre-flight checks
control-plane   Upgrade the control plane instance deployed on this node, if any
kubelet-config  Upgrade the kubelet configuration for this node
```
-->
<pre tabindex="0"><code>preflight       执行节点升级前检查
control-plane   如果存在的话，升级部署在该节点上的管理面实例
kubelet-config  更新该节点上的 kubelet 配置
</code></pre><pre tabindex="0"><code>kubeadm upgrade node [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--certificate-renewal</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Perform the renewal of certificates used by component changed during upgrades.
-->
对升级期间变化的组件所使用的证书执行更新。
</td>
</tr>
<tr>
<td colspan="2">--dry-run</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Do not change any state, just output the actions that would be performed.
-->
不更改任何状态，只输出将要执行的操作。
</td>
</tr>
<tr>
<!-- 
<td colspan="2">--etcd-upgrade&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: true</td>
-->
<td colspan="2">--etcd-upgrade&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值: true</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Perform the upgrade of etcd.
-->
执行 etcd 的升级。
</td>
</tr>
<tr>
<td colspan="2">--experimental-patches string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--  
Path to a directory that contains files named "target[suffix][+patchtype].extension". For example, "kube-apiserver0+merge.yaml" or just "etcd.json". "patchtype" can be one of "strategic", "merge" or "json" and they match the patch formats supported by kubectl. The default "patchtype" is "strategic". "extension" must be either "json" or "yaml". "suffix" is an optional string that can be used to determine which patches are applied first alpha-numerically.
-->
包含名为 "target[suffix][+patchtype].extension" 的文件的目录的路径。
例如，"kube-apiserver0+merge.yaml" 或仅仅是 "etcd.json"。
"patchtype" 可以是 "strategic"、"merge" 或 "json" 之一，并且它们与 kubectl 支持的补丁格式匹配。
默认的 "patchtype" 为 "strategic"。 "extension" 必须为 "json" 或 "yaml"。 
"suffix" 是一个可选字符串，可用于确定首先按字母顺序应用哪些补丁。
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for node
-->
node 操作的帮助命令
</td>
</tr>
<tr>
<!-- 
<td colspan="2">--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"</td>
-->
<td colspan="2">--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值: "/etc/kubernetes/admin.conf"</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.
-->
用于与集群交互的 kubeconfig 文件。如果参数未指定，将从一系列标准位置检索存在的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan="2">--kubelet-version string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The *desired* version for the kubelet config after the upgrade. If not specified, the KubernetesVersion from the kubeadm-config ConfigMap will be used
-->
升级后 *期望的* kubelet 配置版本。如未指定，将使用 kubeadm-config ConfigMap 中的 KubernetesVersion
</td>
</tr>
<tr>
<td colspan="2">--skip-phases stringSlice</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
List of phases to be skipped
-->
要跳过的阶段的列表
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-19a94d2f7649959b218952cef00729f4">7.1.1.104 - </h1>
    
	<h3 id="概要">概要</h3>
<!--
Use this command to invoke single phase of the node workflow
-->
<p>使用此命令调用 node 工作流的某个阶段</p>
<!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for phase
-->
phase 操作的帮助命令
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-b22d3ed181fb7f926ae2081f8fc8c14d">7.1.1.105 - </h1>
    
	<h3 id="概要">概要</h3>
<!--
Upgrade the control plane instance deployed on this node, if any
-->
<p>升级部署在此节点上的控制平面实例，如果有的话</p>
<pre tabindex="0"><code>kubeadm upgrade node phase control-plane [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--certificate-renewal</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">更新在升级期间变更的组件使用的证书。</td>
</tr>
<!-- 
<td></td><td style="line-height: 130%; word-wrap: break-word;">Perform the renewal of certificates used by component changed during upgrades.</td>
-->
<tr>
<td colspan="2">--dry-run</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">不改变任何状态，只输出将要执行的动作。</td>
</tr>
<!--
<td></td><td style="line-height: 130%; word-wrap: break-word;">Do not change any state, just output the actions that would be performed.</td>
-->
<tr>
<td colspan="2">--etcd-upgrade&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值: true</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">执行 etcd 的升级。</td>
</tr>
<!--
<td colspan="2">--etcd-upgrade&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: true</td> 
-->
<!--
<td></td><td style="line-height: 130%; word-wrap: break-word;">Perform the upgrade of etcd.</td>
-->
<tr>
<td colspan="2">--experimental-patches string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--  
Path to a directory that contains files named "target[suffix][+patchtype].extension". For example, "kube-apiserver0+merge.yaml" or just "etcd.json". "patchtype" can be one of "strategic", "merge" or "json" and they match the patch formats supported by kubectl. The default "patchtype" is "strategic". "extension" must be either "json" or "yaml". "suffix" is an optional string that can be used to determine which patches are applied first alpha-numerically.
-->
包含名为 "target[suffix][+patchtype].extension" 的文件的目录的路径。
例如，"kube-apiserver0+merge.yaml" 或仅仅是 "etcd.json"。
"patchtype" 可以是 "strategic"、"merge" 或 "json" 之一，并且它们与 kubectl 支持的补丁格式匹配。
默认的 "patchtype" 为 "strategic"。 "extension" 必须为 "json" 或 "yaml"。 
"suffix" 是一个可选字符串，可用于确定首先按字母顺序应用哪些补丁。
</td>
</tr>
<!--
<td></td><td style="line-height: 130%; word-wrap: break-word;">The path where kustomize patches for static pod manifests are stored.</td>
-->
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">control-plane 的帮助信息</td>
</tr>
<!--
<td></td><td style="line-height: 130%; word-wrap: break-word;">help for control-plane</td>
-->
<tr>
<td colspan="2">--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值: "/etc/kubernetes/admin.conf"</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">用于和集群通信的 KubeConfig 文件。如果它没有被设置，那么 kubeadm 将会搜索一个已经存在于标准路径的 KubeConfig 文件。</td>
</tr>
<!--
<td colspan="2">--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"</td>
-->
<!--
<td></td><td style="line-height: 130%; word-wrap: break-word;">The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.</td>
-->
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">[实验] 到'真实'主机根文件系统的路径。</td>
</tr>
<!--
<td></td><td style="line-height: 130%; word-wrap: break-word;">[EXPERIMENTAL] The path to the 'real' host root filesystem.</td>
-->
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-ae1ea74c2c21b25a3c1eacdaf549274b">7.1.1.106 - </h1>
    
	<p>从群集中 &quot;kubelet-config-1.X&quot; 的 ConfigMap 下载 kubelet 配置，其中 X 是kubelet 的次要版本。
kubeadm 使用 --kubelet-version 参数来确定所需的 kubelet 版本。</p>
<pre tabindex="0"><code>kubeadm upgrade node phase kubelet-config [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--dry-run</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">不改变任何状态，只输出将要执行的操作</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">配置操作的帮助信息</td>
</tr>
<tr>
<td colspan="2">--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值： "/etc/kubernetes/kubelet.conf"</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">用于和集群通信的 KubeConfig 文件。如果它没有被设置，那么 kubeadm 将会搜索一个已经存在于标准路径的 KubeConfig 文件。</td>
</tr>
<tr>
<td colspan="2">--kubelet-version string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">升级后的 kubelet 的*期望*版本。</td>
</tr>
</tbody>
</table>
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
<!--
### Options inherited from parent commands
-->
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">[实验] 到'真实'主机根文件系统的路径。</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-633020ef232bc34f60c82153578a6c9b">7.1.1.107 - </h1>
    
	<p>执行 kubeadm 升级节点的预检。</p>
<pre tabindex="0"><code>kubeadm upgrade node phase preflight [flags]
</code></pre><!-- ### Options -->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<!-- <td></td><td style="line-height: 130%; word-wrap: break-word;">help for preflight</td> -->
<td></td><td style="line-height: 130%; word-wrap: break-word;">preflight 操作的帮助命令</td>
</tr>
<tr>
<td colspan="2">--ignore-preflight-errors stringSlice</td>
</tr>
<tr>
<!-- 
<td></td><td style="line-height: 130%; word-wrap: break-word;">A list of checks whose errors will be shown as warnings. Example: 'IsPrivilegedUser,Swap'. Value 'all' ignores errors from all checks.</td> 
-->
<td></td><td style="line-height: 130%; word-wrap: break-word;">错误将显示为警告的检查清单。示例：'IsPrivilegedUser,Swap'。值为'all'表示忽略所有检查的错误。</td>
</tr>
</tbody>
</table>
<!-- ### Options inherited from parent commands -->
<h3 id="继承于父命令的选项">继承于父命令的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<!-- <td></td><td style="line-height: 130%; word-wrap: break-word;">[EXPERIMENTAL] The path to the 'real' host root filesystem.</td> -->
<td></td><td style="line-height: 130%; word-wrap: break-word;">[实验] 到'真实'主机根文件系统的路径。</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-e938edeb3d824f9b364de617a1f10a93">7.1.1.108 - </h1>
    
	<h3 id="概述">概述</h3>
<p>检查可升级到哪些版本，并验证您当前的集群是否可升级。 要跳过互联网检查，请传递可选的 [version] 参数</p>
<pre tabindex="0"><code>kubeadm upgrade plan [version] [flags]
</code></pre><h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--allow-experimental-upgrades</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">显示不稳定版本的 Kubernetes 作为升级替代方案，并允许升级到 Kubernetes 的 Alpha/Beta/发行候选版本。</td>
</tr>
<tr>
<td colspan="2">--allow-release-candidate-upgrades</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">显示 Kubernetes 的发行候选版本作为升级选择，并允许升级到 Kubernetes 的发行候选版本。</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">配置文件的路径。</td>
</tr>
<tr>
<td colspan="2">--feature-gates string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">一组描述各种特征特性门控的键值对。选项有：IPv6DualStack=true|false (ALPHA - default=false) PublicKeysECDSA=true|false (ALPHA - default=false)</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">帮助</td>
</tr>
<tr>
<td colspan="2">--ignore-preflight-errors stringSlice</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">检查清单，其错误将显示为警告。 例如：“IsPrivilegedUser，Swap”。 值 “all” 忽略所有检查的错误。</td>
</tr>
<tr>
<td colspan="2">--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">与集群通信时使用的 kubeconfig 文件。 如果标志为未设置，则可以在一组标准位置中搜索现有的 kubeconfig 文件。</td>
</tr>
<tr>
<td colspan="2">--print-config</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">指定是否打印将在升级中使用的配置文件。</td>
</tr>
</tbody>
</table>
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">[EXPERIMENTAL] “真实”主机根文件系统的路径。</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-aa9f718186487df2ab6885cae45f5d37">7.1.1.109 - </h1>
    
	<h3 id="概要">概要</h3>
<!--
Print the version of kubeadm
-->
<p>打印 kubeadm 的版本</p>
<pre tabindex="0"><code>kubeadm version [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for version
-->
version 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">-o, --output string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Output format; available options are 'yaml', 'json' and 'short'
-->
输出格式；可用的选项有 'yaml', 'json' 和 'short'
</td>
</tr>
</tbody>
</table>
<!-- 
### Options inherited from parent commands 
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-60d816e74ec8e0301cc484b19d7694e6">7.1.1.110 - </h1>
    
	<p>此目录下的所有文件都是从其他仓库自动生成的。 <strong>不要人工编辑它们。 您必须在上游仓库中编辑它们</strong></p>

</div>



    
	
  

    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-82b2fcf985bae77dcb754387a9fcc64f">7.1.2 - kubeadm init</h1>
    
	<!--
reviewers:
- luxas
- jbeda
title: kubeadm init
content_type: concept
weight: 20
-->
<!-- overview -->
<!--
This command initializes a Kubernetes control-plane node.
-->
<p>此命令初始化一个 Kubernetes 控制平面节点。</p>
<!-- body -->

	<h3 id="概要">概要</h3>
<!--
Run this command in order to set up the Kubernetes control plane
-->
<p>运行此命令来搭建 Kubernetes 控制平面节点。</p>
<!--
The "init" command executes the following phases: 
-->
<p>&quot;init&quot; 命令执行以下阶段：</p>
<pre tabindex="0"><code>preflight                    Run pre-flight checks
certs                        Certificate generation
  /ca                          Generate the self-signed Kubernetes CA to provision identities for other Kubernetes components
  /apiserver                   Generate the certificate for serving the Kubernetes API
  /apiserver-kubelet-client    Generate the certificate for the API server to connect to kubelet
  /front-proxy-ca              Generate the self-signed CA to provision identities for front proxy
  /front-proxy-client          Generate the certificate for the front proxy client
  /etcd-ca                     Generate the self-signed CA to provision identities for etcd
  /etcd-server                 Generate the certificate for serving etcd
  /etcd-peer                   Generate the certificate for etcd nodes to communicate with each other
  /etcd-healthcheck-client     Generate the certificate for liveness probes to healthcheck etcd
  /apiserver-etcd-client       Generate the certificate the apiserver uses to access etcd
  /sa                          Generate a private key for signing service account tokens along with its public key
kubeconfig                   Generate all kubeconfig files necessary to establish the control plane and the admin kubeconfig file
  /admin                       Generate a kubeconfig file for the admin to use and for kubeadm itself
  /kubelet                     Generate a kubeconfig file for the kubelet to use *only* for cluster bootstrapping purposes
  /controller-manager          Generate a kubeconfig file for the controller manager to use
  /scheduler                   Generate a kubeconfig file for the scheduler to use
kubelet-start                Write kubelet settings and (re)start the kubelet
control-plane                Generate all static Pod manifest files necessary to establish the control plane
  /apiserver                   Generates the kube-apiserver static Pod manifest
  /controller-manager          Generates the kube-controller-manager static Pod manifest
  /scheduler                   Generates the kube-scheduler static Pod manifest
etcd                         Generate static Pod manifest file for local etcd
  /local                       Generate the static Pod manifest file for a local, single-node local etcd instance
upload-config                Upload the kubeadm and kubelet configuration to a ConfigMap
  /kubeadm                     Upload the kubeadm ClusterConfiguration to a ConfigMap
  /kubelet                     Upload the kubelet component config to a ConfigMap
upload-certs                 Upload certificates to kubeadm-certs
mark-control-plane           Mark a node as a control-plane
bootstrap-token              Generates bootstrap tokens used to join a node to a cluster
kubelet-finalize             Updates settings relevant to the kubelet after TLS bootstrap
  /experimental-cert-rotation  Enable kubelet client certificate rotation
addon                        Install required addons for passing Conformance tests
  /coredns                     Install the CoreDNS addon to a Kubernetes cluster
  /kube-proxy                  Install the kube-proxy addon to a Kubernetes cluster
</code></pre><pre tabindex="0"><code>kubeadm init [flags]
</code></pre><!-- 
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--apiserver-advertise-address string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The IP address the API Server will advertise it's listening on. If not set the default network interface will be used.
-->
API 服务器所公布的其正在监听的 IP 地址。如果未设置，则使用默认网络接口。
</td>
</tr>
<tr>
<td colspan="2">
<!--
--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: 6443
-->
--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：6443
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Port for the API Server to bind to.
-->
API 服务器绑定的端口。
</td>
</tr>
<tr>
<td colspan="2">--apiserver-cert-extra-sans stringSlice</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Optional extra Subject Alternative Names (SANs) to use for the API Server serving certificate. Can be both IP addresses and DNS names.
-->
用于 API Server 服务证书的可选附加主题备用名称（SAN）。可以是 IP 地址和 DNS 名称。
</td>
</tr>
<tr>
<td colspan="2">
<!--
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"
-->
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The path where to save and store the certificates.
-->
保存和存储证书的路径。
</td>
</tr>
<tr>
<td colspan="2">--certificate-key string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Key used to encrypt the control-plane certificates in the kubeadm-certs Secret.
-->
用于加密 kubeadm-certs Secret 中的控制平面证书的密钥。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to a kubeadm configuration file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">--control-plane-endpoint string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Specify a stable IP address or DNS name for the control plane.
-->
为控制平面指定一个稳定的 IP 地址或 DNS 名称。
</td>
</tr>
<tr>
<td colspan="2">--cri-socket string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to the CRI socket to connect. If empty kubeadm will try to auto-detect this value; use this option only if you have more than one CRI installed or if you have non-standard CRI socket.
-->
要连接的 CRI 套接字的路径。如果为空，则 kubeadm 将尝试自动检测此值；仅当安装了多个 CRI 或具有非标准 CRI 插槽时，才使用此选项。
</td>
</tr>
<tr>
<td colspan="2">--dry-run</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Don't apply any changes; just output what would be done.
-->
不要应用任何更改；只是输出将要执行的操作。
</td>
</tr>
<tr>
<td colspan="2">--experimental-patches string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--  
Path to a directory that contains files named "target[suffix][+patchtype].extension". For example, "kube-apiserver0+merge.yaml" or just "etcd.json". "patchtype" can be one of "strategic", "merge" or "json" and they match the patch formats supported by kubectl. The default "patchtype" is "strategic". "extension" must be either "json" or "yaml". "suffix" is an optional string that can be used to determine which patches are applied first alpha-numerically.
-->
包含名为 "target[suffix][+patchtype].extension" 的文件的目录路径。
例如，"kube-apiserver0+merge.yaml" 或仅仅是 "etcd.json"。
"patchtype" 可以是 "strategic"、"merge" 或 "json" 之一，并且它们与 kubectl 支持的补丁格式匹配。
默认的 "patchtype" 为 "strategic"。 "extension" 必须为 "json" 或 "yaml"。 
"suffix" 是一个可选字符串，可用于确定首先按字母顺序应用哪些补丁。
</td>
</tr>
<tr>
<td colspan="2">--feature-gates string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
A set of key=value pairs that describe feature gates for various features. Options are:<br/>IPv6DualStack=true|false (ALPHA - default=false)
-->
一组用来描述各种功能特性的键值（key=value）对。选项是：<br/>IPv6DualStack=true|false (ALPHA - default=false)
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for init
-->
init 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">--ignore-preflight-errors stringSlice</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
A list of checks whose errors will be shown as warnings. Example: 'IsPrivilegedUser,Swap'. Value 'all' ignores errors from all checks.
-->
错误将显示为警告的检查列表；例如：'IsPrivilegedUser,Swap'。取值为 'all' 时将忽略检查中的所有错误。
</td>
</tr>
<tr>
<td colspan="2">
<!--
--image-repository string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "k8s.gcr.io"
-->
--image-repository string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："k8s.gcr.io"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Choose a container registry to pull control plane images from
-->
选择用于拉取控制平面镜像的容器仓库
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "stable-1"
-->
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Choose a specific Kubernetes version for the control plane.
-->
为控制平面选择一个特定的 Kubernetes 版本。
</td>
</tr>
<tr>
<td colspan="2">--node-name string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Specify the node name.
-->
指定节点的名称。
</td>
</tr>
<tr>
<td colspan="2">--pod-network-cidr string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Specify range of IP addresses for the pod network. If set, the control plane will automatically allocate CIDRs for every node.
-->
指明 pod 网络可以使用的 IP 地址段。如果设置了这个参数，控制平面将会为每一个节点自动分配 CIDRs。
</td>
</tr>
<tr>
<td colspan="2">
<!--
--service-cidr string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "10.96.0.0/12"
-->
--service-cidr string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："10.96.0.0/12"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Use alternative range of IP address for service VIPs.
-->
为服务的虚拟 IP 地址另外指定 IP 地址段
</td>
</tr>
<tr>
<td colspan="2">
<!--
--service-dns-domain string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "cluster.local"
-->
--service-dns-domain string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："cluster.local"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Use alternative domain for services, e.g. "myorg.internal".
-->
为服务另外指定域名，例如："myorg.internal"。
</td>
</tr>
<tr>
<td colspan="2">--skip-certificate-key-print</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Don't print the key used to encrypt the control-plane certificates.
-->
不要打印用于加密控制平面证书的密钥。
</td>
</tr>
<tr>
<td colspan="2">--skip-phases stringSlice</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
List of phases to be skipped
-->
要跳过的阶段列表
</td>
</tr>
<tr>
<td colspan="2">--skip-token-print</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Skip printing of the default bootstrap token generated by 'kubeadm init'.
-->
跳过打印 'kubeadm init' 生成的默认引导令牌。
</td>
</tr>
<tr>
<td colspan="2">--token string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The token to use for establishing bidirectional trust between nodes and control-plane nodes. The format is [a-z0-9]{6}\.[a-z0-9]{16} - e.g. abcdef.0123456789abcdef
-->
这个令牌用于建立控制平面节点与工作节点间的双向通信。格式为 [a-z0-9]{6}\.[a-z0-9]{16} - 示例：abcdef.0123456789abcdef
</td>
</tr>
<tr>
<td colspan="2">
<!--
--token-ttl duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: 24h0m0s
-->
--token-ttl duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：24h0m0s
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The duration before the token is automatically deleted (e.g. 1s, 2m, 3h). If set to '0', the token will never expire
-->
令牌被自动删除之前的持续时间（例如 1 s，2 m，3 h）。如果设置为 '0'，则令牌将永不过期
</td>
</tr>
<tr>
<td colspan="2">--upload-certs</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Upload control-plane certificates to the kubeadm-certs Secret.
-->
将控制平面证书上传到 kubeadm-certs Secret。
</td>
</tr>
</tbody>
</table>
<!-- 
### Options inherited from parent commands 
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

<!--
### Init workflow {#init-workflow}
-->
<h3 id="init-workflow">Init 命令的工作流程</h3>
<!--
`kubeadm init` bootstraps a Kubernetes control-plane node by executing the
following steps:
-->
<p><code>kubeadm init</code> 命令通过执行下列步骤来启动一个 Kubernetes 控制平面节点。</p>
<!--
1. Runs a series of pre-flight checks to validate the system state
   before making changes. Some checks only trigger warnings, others are
   considered errors and will exit kubeadm until the problem is corrected or the
   user specifies `--ignore-preflight-errors=<list-of-errors>`.
-->
<ol>
<li>在做出变更前运行一系列的预检项来验证系统状态。一些检查项目仅仅触发警告，
其它的则会被视为错误并且退出 kubeadm，除非问题得到解决或者用户指定了
<code>--ignore-preflight-errors=&lt;错误列表&gt;</code> 参数。</li>
</ol>
<!--
1. Generates a self-signed CA to set up identities for each component in the cluster. The user can provide their
   own CA cert and/or key by dropping it in the cert directory configured via `--cert-dir`
   (`/etc/kubernetes/pki` by default).
   The APIServer certs will have additional SAN entries for any `--apiserver-cert-extra-sans` arguments, lowercased if necessary.
-->
<ol start="2">
<li>生成一个自签名的 CA 证书来为集群中的每一个组件建立身份标识。
用户可以通过将其放入 <code>--cert-dir</code> 配置的证书目录中（默认为 <code>/etc/kubernetes/pki</code>）
来提供他们自己的 CA 证书以及/或者密钥。
APIServer 证书将为任何 <code>--apiserver-cert-extra-sans</code> 参数值提供附加的 SAN 条目，必要时将其小写。</li>
</ol>
<!--
1. Writes kubeconfig files in `/etc/kubernetes/`  for
   the kubelet, the controller-manager and the scheduler to use to connect to the
   API server, each with its own identity, as well as an additional
   kubeconfig file for administration named `admin.conf`.
-->
<ol start="3">
<li>将 kubeconfig 文件写入 <code>/etc/kubernetes/</code> 目录以便 kubelet、控制器管理器和调度器用来连接到
API 服务器，它们每一个都有自己的身份标识，同时生成一个名为 <code>admin.conf</code> 的独立的 kubeconfig
文件，用于管理操作。</li>
</ol>
<!--
1. Generates static Pod manifests for the API server,
   controller-manager and scheduler. In case an external etcd is not provided,
   an additional static Pod manifest is generated for etcd.

   Static Pod manifests are written to `/etc/kubernetes/manifests`; the kubelet
   watches this directory for Pods to create on startup.

   Once control plane Pods are up and running, the `kubeadm init` sequence can continue.
-->
<ol start="4">
<li>
<p>为 API 服务器、控制器管理器和调度器生成静态 Pod 的清单文件。假使没有提供一个外部的 etcd
服务的话，也会为 etcd 生成一份额外的静态 Pod 清单文件。</p>
<p>静态 Pod 的清单文件被写入到 <code>/etc/kubernetes/manifests</code> 目录;
kubelet 会监视这个目录以便在系统启动的时候创建 Pod。</p>
<p>一旦控制平面的 Pod 都运行起来， <code>kubeadm init</code> 的工作流程就继续往下执行。</p>
</li>
</ol>
<!--
1. Apply labels and taints to the control-plane node so that no additional workloads will
   run there.
-->
<ol start="5">
<li>对控制平面节点应用标签和污点标记以便不会在它上面运行其它的工作负载。</li>
</ol>
<!--
1. Generates the token that additional nodes can use to register
   themselves with a control-plane in the future. Optionally, the user can provide a
   token via `--token`, as described in the
   [kubeadm token](/docs/reference/setup-tools/kubeadm/kubeadm-token/) docs.
-->
<ol start="6">
<li>生成令牌，将来其他节点可使用该令牌向控制平面注册自己。
如 <a href="/zh/docs/reference/setup-tools/kubeadm/kubeadm-token/">kubeadm token</a> 文档所述，
用户可以选择通过 <code>--token</code> 提供令牌。</li>
</ol>
<!--
1. Makes all the necessary configurations for allowing node joining with the
   [Bootstrap Tokens](/docs/reference/access-authn-authz/bootstrap-tokens/) and
   [TLS Bootstrap](/docs/reference/command-line-tools-reference/kubelet-tls-bootstrapping/)
   mechanism:

   - Write a ConfigMap for making available all the information required
     for joining, and set up related RBAC access rules.

   - Let Bootstrap Tokens access the CSR signing API.

   - Configure auto-approval for new CSR requests.

   See [kubeadm join](/docs/reference/setup-tools/kubeadm/kubeadm-join/) for additional info.
-->
<ol start="7">
<li>
<p>为了使得节点能够遵照<a href="/zh/docs/reference/access-authn-authz/bootstrap-tokens/">启动引导令牌</a>
和 <a href="/zh/docs/reference/command-line-tools-reference/kubelet-tls-bootstrapping/">TLS 启动引导</a>
这两份文档中描述的机制加入到集群中，kubeadm 会执行所有的必要配置：</p>
<ul>
<li>
<p>创建一个 ConfigMap 提供添加集群节点所需的信息，并为该 ConfigMap 设置相关的 RBAC 访问规则。</p>
</li>
<li>
<p>允许启动引导令牌访问 CSR 签名 API。</p>
</li>
<li>
<p>配置自动签发新的 CSR 请求。</p>
</li>
</ul>
<p>更多相关信息，请查看 <a href="/zh/docs/reference/setup-tools/kubeadm/kubeadm-join/">kubeadm join</a>。</p>
</li>
</ol>
<!-- 
1. Installs a DNS server (CoreDNS) and the kube-proxy addon components via the API server.
   In Kubernetes version 1.11 and later CoreDNS is the default DNS server.
   Please note that although the DNS server is deployed, it will not be scheduled until CNI is installed.

   <blockquote class="warning callout">
  <div><strong>警告：</strong> kube-dns usage with kubeadm is deprecated as of v1.18 and is removed in v1.21.</div>
</blockquote>

-->
<ol start="8">
<li>
<p>通过 API 服务器安装一个 DNS 服务器 (CoreDNS) 和 kube-proxy 附加组件。
在 Kubernetes 版本 1.11 和更高版本中，CoreDNS 是默认的 DNS 服务器。
请注意，尽管已部署 DNS 服务器，但直到安装 CNI 时才调度它。</p>
<blockquote class="warning callout">
  <div><strong>警告：</strong> 从 v1.18 开始，在 kubeadm 中使用 kube-dns 的支持已被废弃，并已在 v1.21 版本中删除。</div>
</blockquote>

</li>
</ol>
<!--
### Using init phases with kubeadm {#init-phases}

Kubeadm allows you to create a control-plane node in phases using the `kubeadm init phase` command.
-->
<h3 id="init-phases">在 kubeadm 中使用 init phases</h3>
<p>Kubeadm 允许你使用 <code>kubeadm init phase</code> 命令分阶段创建控制平面节点。</p>
<!--
To view the ordered list of phases and sub-phases you can call `kubeadm init -help`. The list will be located at the top of the help screen and each phase will have a description next to it.
Note that by calling `kubeadm init` all of the phases and sub-phases will be executed in this exact order.
-->
<p>要查看阶段和子阶段的有序列表，可以调用 <code>kubeadm init --help</code>。
该列表将位于帮助屏幕的顶部，每个阶段旁边都有一个描述。
注意，通过调用 <code>kubeadm init</code>，所有阶段和子阶段都将按照此确切顺序执行。</p>
<!--
Some phases have unique flags, so if you want to have a look at the list of available options add `-help`, for example:
-->
<p>某些阶段具有唯一的标志，因此，如果要查看可用选项的列表，请添加 <code>--help</code>，例如：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">sudo kubeadm init phase control-plane controller-manager --help
</code></pre></div><!--
You can also use `-help` to see the list of sub-phases for a certain parent phase:
-->
<p>你也可以使用 <code>--help</code> 查看特定父阶段的子阶段列表：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">sudo kubeadm init phase control-plane --help
</code></pre></div><!--
`kubeadm init` also exposes a flag called `-skip-phases` that can be used to skip certain phases. The flag accepts a list of phase names and the names can be taken from the above ordered list.
-->
<p><code>kubeadm init</code> 还公开了一个名为 <code>--skip-phases</code> 的参数，该参数可用于跳过某些阶段。
参数接受阶段名称列表，并且这些名称可以从上面的有序列表中获取。</p>
<!--
An example:
-->
<p>例如：</p>
<!--
# you can now modify the control plane and etcd manifest files
-->
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">sudo kubeadm init phase control-plane all --config<span style="color:#666">=</span>configfile.yaml
sudo kubeadm init phase etcd <span style="color:#a2f">local</span> --config<span style="color:#666">=</span>configfile.yaml
<span style="color:#080;font-style:italic"># 你现在可以修改控制平面和 etcd 清单文件</span>
sudo kubeadm init --skip-phases<span style="color:#666">=</span>control-plane,etcd --config<span style="color:#666">=</span>configfile.yaml
</code></pre></div><!--
What this example would do is write the manifest files for the control plane and etcd in `/etc/kubernetes/manifests` based on the configuration in `configfile.yaml`. This allows you to modify the files and then skip these phases using `-skip-phases`. By calling the last command you will create a control plane node with the custom manifest files.
-->
<p>该示例将执行的操作是基于 <code>configfile.yaml</code> 中的配置在 <code>/etc/kubernetes/manifests</code>
中写入控制平面和 etcd 的清单文件。
这允许你修改文件，然后使用 <code>--skip-phases</code> 跳过这些阶段。
通过调用最后一个命令，你将使用自定义清单文件创建一个控制平面节点。</p>
<!--
### Using kubeadm init with a configuration file {#config-file}
-->
<h3 id="config-file">结合一份配置文件来使用 kubeadm init</h3>
<!--
The config file is still considered beta and may change in future versions.
-->
<blockquote class="caution callout">
  <div><strong>注意：</strong> 配置文件的功能仍然处于 alpha 状态并且在将来的版本中可能会改变。</div>
</blockquote>

<!--
It's possible to configure `kubeadm init` with a configuration file instead of command
line flags, and some more advanced features may only be available as
configuration file options. This file is passed using the `--config` flag and it must
contain a `ClusterConfiguration` structure and optionally more structures separated by `---\n`
Mixing `--config` with others flags may not be allowed in some cases.
-->
<p>通过一份配置文件而不是使用命令行参数来配置 <code>kubeadm init</code> 命令是可能的，
但是一些更加高级的功能只能够通过配置文件设定。
这份配置文件通过 <code>--config</code> 选项参数指定的，
它必须包含 <code>ClusterConfiguration</code> 结构，并可能包含更多由 <code>---\n</code> 分隔的结构。
在某些情况下，可能不允许将 <code>--config</code> 与其他标志混合使用。</p>
<!--
The default configuration can be printed out using the
[kubeadm config print](/docs/reference/setup-tools/kubeadm/kubeadm-config/) command.

If your configuration is not using the latest version it is **recommended** that you migrate using
the [kubeadm config migrate](/docs/reference/setup-tools/kubeadm/kubeadm-config/) command.

For more information on the fields and usage of the configuration you can navigate to our API reference
page and pick a version from [the list](https://pkg.go.dev/k8s.io/kubernetes/cmd/kubeadm/app/apis/kubeadm#section-directories).
-->
<p>可以使用 <a href="/zh/docs/reference/setup-tools/kubeadm/kubeadm-config/">kubeadm config print</a>
命令打印出默认配置。</p>
<p>如果你的配置没有使用最新版本，
<strong>推荐</strong>使用 <a href="/zh/docs/reference/setup-tools/kubeadm/kubeadm-config/">kubeadm config migrate</a>
命令进行迁移。</p>
<p>有关配置的字段和用法的更多信息，
你可以访问 API 参考页面并从
<a href="https://pkg.go.dev/k8s.io/kubernetes/cmd/kubeadm/app/apis/kubeadm#section-directories">列表</a>
中选择一个版本。</p>
<!--
### Adding kube-proxy parameters {#kube-proxy}
-->
<h3 id="kube-proxy">添加 kube-proxy 参数</h3>
<!--
For information about kube-proxy parameters in the kubeadm configuration see:
- [kube-proxy reference](/docs/reference/config-api/kube-proxy-config.v1alpha1/)

For information about enabling IPVS mode with kubeadm see:
- [IPVS](https://github.com/kubernetes/kubernetes/blob/master/pkg/proxy/ipvs/README.md)
-->
<p>kubeadm 配置中有关 kube-proxy 的说明请查看：</p>
<ul>
<li><a href="/zh/docs/reference/config-api/kube-proxy-config.v1alpha1/">kube-proxy 参考</a></li>
</ul>
<p>使用 kubeadm 启用 IPVS 模式的说明请查看：</p>
<ul>
<li><a href="https://github.com/kubernetes/kubernetes/blob/master/pkg/proxy/ipvs/README.md">IPVS</a></li>
</ul>
<!--
### Passing custom flags to control plane components {#control-plane-flags}
-->
<h3 id="control-plane-flags">向控制平面组件传递自定义的命令行参数</h3>
<!--
For information about passing flags to control plane components see:
- [control-plane-flags](/docs/setup/production-environment/tools/kubeadm/control-plane-flags/) -->
<p>有关向控制平面组件传递命令行参数的说明请查看：
<a href="/zh/docs/setup/production-environment/tools/kubeadm/control-plane-flags/">控制平面命令行参数</a></p>
<!--
### Using custom images {#custom-images}
-->
<h3 id="custom-images">使用自定义的镜像</h3>
<!--
By default, kubeadm pulls images from `k8s.gcr.io`. If the
requested Kubernetes version is a CI label (such as `ci/latest`)
`gcr.io/k8s-staging-ci-images` is used.
-->
<p>默认情况下, kubeadm 会从 <code>k8s.gcr.io</code> 仓库拉取镜像。如果请求的 Kubernetes 版本是 CI 标签
（例如 <code>ci/latest</code>），则使用 <code>gcr.io/k8s-staging-ci-images</code>。</p>
<!--
You can override this behavior by using [kubeadm with a configuration file](#config-file).
-->
<p>你可以通过使用<a href="#config-file">带有配置文件的 kubeadm</a> 来重写此操作。</p>
<!--
Allowed customization are:

* To provide an alternative `imageRepository` to be used instead of
  `k8s.gcr.io`.
* To set `useHyperKubeImage` to `true` to use the HyperKube image.
* To provide a specific `imageRepository` and `imageTag` for etcd or DNS add-on.
-->
<p>允许的自定义功能有：</p>
<ul>
<li>使用其他的 <code>imageRepository</code> 来代替 <code>k8s.gcr.io</code>。</li>
<li>将 <code>useHyperKubeImage</code> 设置为 <code>true</code>，使用 HyperKube 镜像。</li>
<li>为 etcd 或 DNS 附件提供特定的 <code>imageRepository</code> 和 <code>imageTag</code>。</li>
</ul>
<!--
Please note that the configuration field `kubernetesVersion` or the command line flag
`-kubernetes-version` affect the version of the images.
-->
<p>请注意配置文件中的配置项 <code>kubernetesVersion</code> 或者命令行参数 <code>--kubernetes-version</code>
会影响到镜像的版本。</p>
<!--
### Uploading control-plane certificates to the cluster
-->
<h3 id="将控制平面证书上传到集群">将控制平面证书上传到集群</h3>
<!--
By adding the flag `-upload-certs` to `kubeadm init` you can temporary upload
the control-plane certificates to a Secret in the cluster. Please note that this Secret
will expire automatically after 2 hours. The certificates are encrypted using
a 32byte key that can be specified using `-certificate-key`. The same key can be used
to download the certificates when additional control-plane nodes are joining, by passing
`-control-plane` and `-certificate-key` to `kubeadm join`.
-->
<p>通过将参数 <code>--upload-certs</code> 添加到 <code>kubeadm init</code>，你可以将控制平面证书临时上传到集群中的 Secret。
请注意，此 Secret 将在 2 小时后自动过期。证书使用 32 字节密钥加密，可以使用 <code>--certificate-key</code> 指定。
通过将 <code>--control-plane</code> 和 <code>--certificate-key</code> 传递给 <code>kubeadm join</code>，
可以在添加其他控制平面节点时使用相同的密钥下载证书。</p>
<!--
The following phase command can be used to re-upload the certificates after expiration:
-->
<p>以下阶段命令可用于证书到期后重新上传证书：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubeadm init phase upload-certs --upload-certs --certificate-key<span style="color:#666">=</span>SOME_VALUE --config<span style="color:#666">=</span>SOME_YAML_FILE
</code></pre></div><!--
If the flag `-certificate-key` is not passed to `kubeadm init` and
`kubeadm init phase upload-certs` a new key will be generated automatically.
-->
<p>如果未将参数 <code>--certificate-key</code> 传递给 <code>kubeadm init</code> 和 <code>kubeadm init phase upload-certs</code>，
则会自动生成一个新密钥。</p>
<!--
The following command can be used to generate a new key on demand:
-->
<p>以下命令可用于按需生成新密钥：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubeadm certs certificate-key
</code></pre></div><!-- ### Certificate management with kubeadm -->
<h3 id="使用-kubeadm-管理证书">使用 kubeadm 管理证书</h3>
<!--  
For detailed information on certificate management with kubeadm see
[Certificate Management with kubeadm](/docs/tasks/administer-cluster/kubeadm/kubeadm-certs/).
The document includes information about using external CA, custom certificates
and certificate renewal.
-->
<p>有关使用 kubeadm 进行证书管理的详细信息，请参阅
<a href="/zh/docs/tasks/administer-cluster/kubeadm/kubeadm-certs/">使用 kubeadm 进行证书管理</a>。
该文档包括有关使用外部 CA，自定义证书和证书更新的信息。</p>
<!--
### Managing the kubeadm drop-in file for the kubelet {#kubelet-drop-in}
-->
<h3 id="kubelet-drop-in">管理 kubeadm 为 kubelet 提供的 systemd 配置文件</h3>
<!--
The `kubeadm` package ships with a configuration file for running the `kubelet` by `systemd`. Note that the kubeadm CLI never touches this drop-in file. This drop-in file is part of the kubeadm DEB/RPM package.
-->
<p><code>kubeadm</code> 包自带了关于 <code>systemd</code> 如何运行 <code>kubelet</code> 的配置文件。
请注意 <code>kubeadm</code> 客户端命令行工具永远不会修改这份 <code>systemd</code> 配置文件。
这份 <code>systemd</code> 配置文件属于 kubeadm DEB/RPM 包。</p>
<!--
For further information, see [Managing the kubeadm drop-in file for systemd](/docs/setup/production-environment/tools/kubeadm/kubelet-integration/#the-kubelet-drop-in-file-for-systemd).
-->
<p>有关更多信息，请阅读
<a href="/zh/docs/setup/production-environment/tools/kubeadm/kubelet-integration/#the-kubelet-drop-in-file-for-systemd">管理 systemd 的 kubeadm 内嵌文件</a>。</p>
<!--
### Use kubeadm with CRI runtimes
-->
<h3 id="结合-cri-运行时使用-kubeadm">结合 CRI 运行时使用 kubeadm</h3>
<!--
By default kubeadm attempts to detect your container runtime. For more details on this detection, see
the [kubeadm CRI installation guide](/docs/setup/production-environment/tools/kubeadm/install-kubeadm/#installing-runtime).
-->
<p>默认情况下，kubeadm 尝试检测你的容器运行环境。有关此检测的更多详细信息，请参见
<a href="/zh/docs/setup/production-environment/tools/kubeadm/install-kubeadm/#installing-runtime">kubeadm CRI 安装指南</a>。</p>
<!--
### Setting the node name
-->
<h3 id="设置节点的名称">设置节点的名称</h3>
<!--
By default, `kubeadm` assigns a node name based on a machine's host address. You can override this setting with the `-node-name` flag.
The flag passes the appropriate [`-hostname-override`](/docs/reference/command-line-tools-reference/kubelet/#options)
value to the kubelet.
-->
<p>默认情况下, <code>kubeadm</code> 基于机器的主机地址分配一个节点名称。你可以使用 <code>--node-name</code> 参数覆盖此设置。
此标识将合适的
<a href="/zh/docs/reference/command-line-tools-reference/kubelet/#options"><code>--hostname-override</code></a>
值传递给 kubelet。</p>
<!--
### Running kubeadm without an internet connection
-->
<h3 id="在没有互联网连接的情况下运行-kubeadm">在没有互联网连接的情况下运行 kubeadm</h3>
<!--
For running kubeadm without an internet connection you have to pre-pull the required control-plane images.
-->
<p>要在没有互联网连接的情况下运行 kubeadm，你必须提前拉取所需的控制平面镜像。</p>
<!--
You can list and pull the images using the `kubeadm config images` sub-command:
-->
<p>你可以使用 <code>kubeadm config images</code> 子命令列出并拉取镜像：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubeadm config images list
kubeadm config images pull
</code></pre></div><!--
All images that kubeadm requires such as `k8s.gcr.io/kube-*`, `k8s.gcr.io/etcd` and `k8s.gcr.io/pause` support multiple architectures.
-->
<p>kubeadm 需要的所有镜像，例如 <code>k8s.gcr.io/kube-*</code>、<code>k8s.gcr.io/etcd</code> 和 <code>k8s.gcr.io/pause</code>
都支持多种架构。</p>
<!--
### Automating kubeadm
-->
<h3 id="kubeadm-自动化">kubeadm 自动化</h3>
<!--
Rather than copying the token you obtained from `kubeadm init` to each node, as
in the [basic kubeadm tutorial](/docs/setup/production-environment/tools/kubeadm/create-cluster-kubeadm/), you can parallelize the
token distribution for easier automation. To implement this automation, you must
know the IP address that the control-plane node will have after it is started,
or use a DNS name or an address of a load balancer.
-->
<p>除了像文档 <a href="/zh/docs/setup/production-environment/tools/kubeadm/create-cluster-kubeadm/">kubeadm 基础教程</a>
中所描述的那样，将从 <code>kubeadm init</code> 取得的令牌复制到每个节点，
你还可以并行地分发令牌以实现简单自动化。
要实现自动化，你必须知道控制平面节点启动后将拥有的 IP 地址，或使用 DNS 名称或负载均衡器的地址。</p>
<!--
1.  Generate a token. This token must have the form  `<6 character string>.<16
character string>`. More formally, it must match the regex: `[a-z0-9]{6}\.[a-z0-9]{16}`.
kubeadm can generate a token for you:
-->
<ol>
<li>
<p>生成一个令牌。这个令牌必须具有以下格式：<code>&lt; 6 个字符的字符串&gt;.&lt; 16 个字符的字符串&gt;</code>。
更加正式的说法是，它必须符合以下正则表达式：<code>[a-z0-9]{6}\.[a-z0-9]{16}</code>。</p>
<p>kubeadm 可以为你生成一个令牌：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubeadm token generate
</code></pre></div></li>
</ol>
<!--
2.  Start both the control-plane node and the worker nodes concurrently with this token.
As they come up they should find each other and form the cluster. The same `-token` argument can be used on both `kubeadm init` and `kubeadm join`. 
-->
<ol start="2">
<li>使用这个令牌同时启动控制平面节点和工作节点。它们一旦运行起来应该就会互相寻找对方并且建立集群。
同样的 <code>--token</code> 参数可以同时用于 <code>kubeadm init</code> 和 <code>kubeadm join</code> 命令。</li>
</ol>
<!--
3.  Similar can be done for `-certificate-key` when joining additional control-plane nodes. The key can be generated using:
-->
<ol start="3">
<li>
<p>当加入其他控制平面节点时，可以对 <code>--certificate-key</code> 执行类似的操作。可以使用以下方式生成密钥：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubeadm certs certificate-key
</code></pre></div></li>
</ol>
<!--
Once the cluster is up, you can grab the admin credentials from the control-plane node
at `/etc/kubernetes/admin.conf` and use that to talk to the cluster.
-->
<p>一旦集群启动起来，你就可以从控制平面节点的 <code>/etc/kubernetes/admin.conf</code> 文件获取管理凭证，
并使用这个凭证同集群通信。</p>
<!--
Note that this style of bootstrap has some relaxed security guarantees because
it does not allow the root CA hash to be validated with
`-discovery-token-ca-cert-hash` (since it's not generated when the nodes are
provisioned). For details, see the [kubeadm join](/docs/reference/setup-tools/kubeadm/kubeadm-join/).
-->
<p>注意这种搭建集群的方式在安全保证上会有一些宽松，因为这种方式不允许使用 <code>--discovery-token-ca-cert-hash</code>
来验证根 CA 的哈希值（因为当配置节点的时候，它还没有被生成）。
更多信息请参阅 <a href="/zh/docs/reference/setup-tools/kubeadm/kubeadm-join/">kubeadm join</a> 文档。</p>
<h2 id="接下来">接下来</h2>
<!--
* [kubeadm init phase](/docs/reference/setup-tools/kubeadm/kubeadm-init-phase/) to understand more about
`kubeadm init` phases
* [kubeadm join](/docs/reference/setup-tools/kubeadm/kubeadm-join/) to bootstrap a Kubernetes worker node and join it to the cluster
* [kubeadm upgrade](/docs/reference/setup-tools/kubeadm/kubeadm-upgrade/) to upgrade a Kubernetes cluster to a newer version
* [kubeadm reset](/docs/reference/setup-tools/kubeadm/kubeadm-reset/) to revert any changes made to this host by `kubeadm init` or `kubeadm join`
-->
<ul>
<li>进一步阅读了解 <a href="/zh/docs/reference/setup-tools/kubeadm/kubeadm-init-phase/">kubeadm init phase</a></li>
<li><a href="/zh/docs/reference/setup-tools/kubeadm/kubeadm-join/">kubeadm join</a>
启动一个 Kubernetes 工作节点并且将其加入到集群</li>
<li><a href="/zh/docs/reference/setup-tools/kubeadm/kubeadm-upgrade/">kubeadm upgrade</a>
将 Kubernetes 集群升级到新版本</li>
<li><a href="/zh/docs/reference/setup-tools/kubeadm/kubeadm-reset/">kubeadm reset</a>
恢复 <code>kubeadm init</code> 或 <code>kubeadm join</code> 命令对节点所作的变更</li>
</ul>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-2a2b5f34806b4b1bd2c12682ac170d68">7.1.3 - kubeadm join</h1>
    
	<!-- overview -->
<!--
This command initializes a Kubernetes worker node and joins it to the cluster.
-->
<p>此命令用来初始化 Kubernetes 工作节点并将其加入集群。</p>
<!-- body -->

	<h3 id="摘要">摘要</h3>
<!--
When joining a kubeadm initialized cluster, we need to establish
bidirectional trust. This is split into discovery (having the Node
trust the Kubernetes Control Plane) and TLS bootstrap (having the
Kubernetes Control Plane trust the Node).
-->
<p>当节点加入 kubeadm 初始化的集群时，我们需要建立双向信任。
这个过程可以分解为发现（让待加入节点信任 Kubernetes 控制平面节点）和 TLS 引导（让Kubernetes 控制平面节点信任待加入节点）两个部分。</p>
<!--
There are 2 main schemes for discovery. The first is to use a shared
token along with the IP address of the API server. The second is to
provide a file - a subset of the standard kubeconfig file. This file
can be a local file or downloaded via an HTTPS URL. The forms are
kubeadm join --discovery-token abcdef.1234567890abcdef 1.2.3.4:6443,
kubeadm join --discovery-file path/to/file.conf, or kubeadm join
--discovery-file https://url/file.conf. Only one form can be used. If
the discovery information is loaded from a URL, HTTPS must be used.
Also, in that case the host installed CA bundle is used to verify
the connection.
-->
<p>有两种主要的发现方案。
第一种方法是使用共享令牌和 API 服务器的 IP 地址。
第二种是提供一个文件 - 标准 kubeconfig 文件的一个子集。
该文件可以是本地文件，也可以通过 HTTPS URL 下载。
格式是 <code>kubeadm join --discovery-token abcdef.1234567890abcdef 1.2.3.4:6443</code>、<code>kubeadm join--discovery-file path/to/file.conf</code> 或者<code>kubeadm join --discovery-file https://url/file.conf</code>。
只能使用其中一种。
如果发现信息是从 URL 加载的，必须使用 HTTPS。
此外，在这种情况下，主机安装的 CA 包用于验证连接。</p>
<!--
If you use a shared token for discovery, you should also pass the
--discovery-token-ca-cert-hash flag to validate the public key of the
root certificate authority (CA) presented by the Kubernetes Control Plane.
The value of this flag is specified as "&lt;hash-type&gt;:&lt;hex-encoded-value&gt;",
where the supported hash type is "sha256". The hash is calculated over
the bytes of the Subject Public Key Info (SPKI) object (as in RFC7469).
This value is available in the output of "kubeadm init" or can be
calculated using standard tools. The --discovery-token-ca-cert-hash flag
may be repeated multiple times to allow more than one public key.
-->
<p>如果使用共享令牌进行发现，还应该传递 --discovery-token-ca-cert-hash 参数来验证 Kubernetes 控制平面节点提供的根证书颁发机构（CA）的公钥。
此参数的值指定为 &quot;&lt;hash-type&gt;:&lt;hex-encoded-value&gt;&quot;，其中支持的哈希类型为 &quot;sha256&quot;。哈希是通过 Subject Public Key Info（SPKI）对象的字节计算的（如 RFC7469）。
这个值可以从 &quot;kubeadm init&quot; 的输出中获得，或者可以使用标准工具进行计算。
可以多次重复 --discovery-token-ca-cert-hash 参数以允许多个公钥。</p>
<!--
If you cannot know the CA public key hash ahead of time, you can pass
the --discovery-token-unsafe-skip-ca-verification flag to disable this
verification. This weakens the kubeadm security model since other nodes
can potentially impersonate the Kubernetes Control Plane.
-->
<p>如果无法提前知道 CA 公钥哈希，则可以通过 --discovery-token-unsafe-skip-ca-verification 参数禁用此验证。
这削弱了kubeadm 安全模型，因为其他节点可能会模仿 Kubernetes 控制平面节点。</p>
<!--
The TLS bootstrap mechanism is also driven via a shared token. This is
used to temporarily authenticate with the Kubernetes Control Plane to submit a
certificate signing request (CSR) for a locally created key pair. By
default, kubeadm will set up the Kubernetes Control Plane to automatically
approve these signing requests. This token is passed in with the
--tls-bootstrap-token abcdef.1234567890abcdef flag.

Often times the same token is used for both parts. In this case, the
--token flag can be used instead of specifying each token individually.
-->
<p>TLS 引导机制也通过共享令牌驱动。
这用于向 Kubernetes 控制平面节点进行临时的身份验证，以提交本地创建的密钥对的证书签名请求（CSR）。
默认情况下，kubeadm 将设置 Kubernetes 控制平面节点自动批准这些签名请求。
这个令牌通过 --tls-bootstrap-token abcdef.1234567890abcdef 参数传入。</p>
<p>通常两个部分会使用相同的令牌。
在这种情况下可以使用 --token 参数，而不是单独指定每个令牌。</p>
<!-- 
The "join [api-server-endpoint]" command executes the following phases:
-->
<p>&quot;join [api-server-endpoint]&quot; 命令执行下列阶段：</p>
<pre tabindex="0"><code>preflight              Run join pre-flight checks
control-plane-prepare  Prepare the machine for serving a control plane
  /download-certs        [EXPERIMENTAL] Download certificates shared among control-plane nodes from the kubeadm-certs Secret
  /certs                 Generate the certificates for the new control plane components
  /kubeconfig            Generate the kubeconfig for the new control plane components
  /control-plane         Generate the manifests for the new control plane components
kubelet-start          Write kubelet settings, certificates and (re)start the kubelet
control-plane-join     Join a machine as a control plane instance
  /etcd                  Add a new local etcd member
  /update-status         Register the new control-plane node into the ClusterStatus maintained in the kubeadm-config ConfigMap
  /mark-control-plane    Mark a node as a control-plane
</code></pre><pre tabindex="0"><code>kubeadm join [api-server-endpoint] [flags]
</code></pre><!-- 
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--apiserver-advertise-address string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
If the node should host a new control plane instance, the IP address the API Server will advertise it's listening on. If not set the default network interface will be used.
-->
如果该节点托管一个新的控制平面实例，则 API 服务器将公布其正在侦听的 IP 地址。如果未设置，则使用默认网络接口。
</td>
</tr>
<tr>
<td colspan="2">
<!--
--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: 6443
-->
--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值: 6443
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
If the node should host a new control plane instance, the port for the API Server to bind to.
-->
如果节点应该托管新的控制平面实例，则为 API 服务器要绑定的端口。
</td>
</tr>
<tr>
<td colspan="2">--certificate-key string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Use this key to decrypt the certificate secrets uploaded by init.
-->
使用此密钥可以解密由 init 上传的证书 secret。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to kubeadm config file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">--control-plane</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Create a new control plane instance on this node
-->
在此节点上创建一个新的控制平面实例
</td>
</tr>
<tr>
<td colspan="2">--cri-socket string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to the CRI socket to connect. If empty kubeadm will try to auto-detect this value; use this option only if you have more than one CRI installed or if you have non-standard CRI socket.
-->
要连接的 CRI 套接字的路径。如果为空，则 kubeadm 将尝试自动检测此值；仅当安装了多个 CRI 或具有非标准 CRI 插槽时，才使用此选项。
</td>
</tr>
<tr>
<td colspan="2">--discovery-file string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
For file-based discovery, a file or URL from which to load cluster information.
-->
对于基于文件的发现，给出用于加载集群信息的文件或者 URL。
</td>
</tr>
<tr>
<td colspan="2">--discovery-token string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
For token-based discovery, the token used to validate cluster information fetched from the API server.
-->
对于基于令牌的发现，该令牌用于验证从 API 服务器获取的集群信息。
</td>
</tr>
<tr>
<td colspan="2">--discovery-token-ca-cert-hash stringSlice</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
For token-based discovery, validate that the root CA public key matches this hash (format: "&lt;type&gt;:&lt;value&gt;").
-->
对基于令牌的发现，验证根 CA 公钥是否与此哈希匹配 (格式: "&lt;type&gt;:&lt;value&gt;")。
</td>
</tr>
<tr>
<td colspan="2">--discovery-token-unsafe-skip-ca-verification</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
For token-based discovery, allow joining without --discovery-token-ca-cert-hash pinning.
-->
对于基于令牌的发现，允许在未关联 --discovery-token-ca-cert-hash 参数的情况下添加节点。
</td>
</tr>
<tr>
<td colspan="2">--experimental-patches string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--  
Path to a directory that contains files named "target[suffix][+patchtype].extension". For example, "kube-apiserver0+merge.yaml" or just "etcd.json". "patchtype" can be one of "strategic", "merge" or "json" and they match the patch formats supported by kubectl. The default "patchtype" is "strategic". "extension" must be either "json" or "yaml". "suffix" is an optional string that can be used to determine which patches are applied first alpha-numerically.
-->
包含名为 "target[suffix][+patchtype].extension" 的文件的目录的路径。
例如，"kube-apiserver0+merge.yaml" 或仅仅是 "etcd.json"。
"patchtype" 可以是 "strategic"、"merge" 或 "json" 之一，并且它们与 kubectl 支持的补丁格式匹配。
默认的 "patchtype" 为 "strategic"。 "extension" 必须为 "json" 或 "yaml"。 
"suffix" 是一个可选字符串，可用于确定首先按字母顺序应用哪些补丁。
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for join
-->
join 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">--ignore-preflight-errors stringSlice</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
A list of checks whose errors will be shown as warnings. Example: 'IsPrivilegedUser,Swap'. Value 'all' ignores errors from all checks.
-->
错误将显示为警告的检查列表；例如：'IsPrivilegedUser,Swap'。取值为 'all' 时将忽略检查中的所有错误。
</td>
</tr>
<tr>
<td colspan="2">--node-name string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Specify the node name.
-->
指定节点的名称
</td>
</tr>
<tr>
<td colspan="2">--skip-phases stringSlice</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
List of phases to be skipped
-->
要跳过的阶段列表
</td>
</tr>
<tr>
<td colspan="2">--tls-bootstrap-token string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Specify the token used to temporarily authenticate with the Kubernetes Control Plane while joining the node.
-->
指定在加入节点时用于临时通过 Kubernetes 控制平面进行身份验证的令牌。
</td>
</tr>
<tr>
<td colspan="2">--token string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Use this token for both discovery-token and tls-bootstrap-token when those values are not provided.
-->
如果未提供这些值，则将它们用于 discovery-token 令牌和 tls-bootstrap 令牌。
</td>
</tr>
</tbody>
</table>
<!-- 
### Options inherited from parent commands 
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

<!--
### The join workflow {#join-workflow}
-->
<h3 id="join-workflow">join 工作流</h3>
<!--  
`kubeadm join` bootstraps a Kubernetes worker node and joins it to the cluster.
This action consists of the following steps:
-->
<p><code>kubeadm join</code> 初始化 Kubernetes 工作节点并将其加入集群。
该操作过程包含下面几个步骤：</p>
<!--
1. kubeadm downloads necessary cluster information from the API server.
   By default, it uses the bootstrap token and the CA key hash to verify the
   authenticity of that data. The root CA can also be discovered directly via a
   file or URL.
-->
<ol>
<li>kubeadm 从 API 服务器下载必要的集群信息。
默认情况下，它使用引导令牌和 CA 密钥哈希来验证数据的真实性。
也可以通过文件或 URL 直接发现根 CA。</li>
</ol>
<!--  
1. Once the cluster information is known, kubelet can start the TLS bootstrapping
   process.

   The TLS bootstrap uses the shared token to temporarily authenticate
   with the Kubernetes API server to submit a certificate signing request (CSR); by
   default the control plane signs this CSR request automatically.
-->
<ol start="2">
<li>
<p>一旦知道集群信息，kubelet 就可以开始 TLS 引导过程。</p>
<p>TLS 引导程序使用共享令牌与 Kubernetes API 服务器进行临时的身份验证，以提交证书签名请求 (CSR)；
默认情况下，控制平面自动对该 CSR 请求进行签名。</p>
</li>
</ol>
<!-- 
1. Finally, kubeadm configures the local kubelet to connect to the API
   server with the definitive identity assigned to the node.
-->
<ol start="3">
<li>最后，kubeadm 配置本地 kubelet 使用分配给节点的确定标识连接到 API 服务器。</li>
</ol>
<!-- 
For control-plane nodes additional steps are performed:

1. Downloading certificates shared among control-plane nodes from the cluster
  (if explicitly requested by the user).

1. Generating control-plane component manifests, certificates and kubeconfig.

1. Adding new local etcd member.

1. Adding this node to the ClusterStatus of the kubeadm cluster.
-->
<p>对于控制平面节点，执行额外的步骤：</p>
<ol>
<li>
<p>从集群下载控制平面节点之间共享的证书（如果用户明确要求）。</p>
</li>
<li>
<p>生成控制平面组件清单、证书和 kubeconfig。</p>
</li>
<li>
<p>添加新的本地 etcd 成员。</p>
</li>
<li>
<p>将此节点添加到 kubeadm 集群的 ClusterStatus。</p>
</li>
</ol>
<!-- 
### Using join phases with kubeadm {#join-phases}
-->
<h3 id="join-phases">使用 kubeadm 的 join phase 命令</h3>
<!-- 
Kubeadm allows you join a node to the cluster in phases using `kubeadm join phase`.
-->
<p>Kubeadm 允许你使用 <code>kubeadm join phase</code> 分阶段将节点加入集群。</p>
<!--  
To view the ordered list of phases and sub-phases you can call `kubeadm join --help`. The list will be located
at the top of the help screen and each phase will have a description next to it.
Note that by calling `kubeadm join` all of the phases and sub-phases will be executed in this exact order.
-->
<p>要查看阶段和子阶段的有序列表，可以调用 <code>kubeadm join --help</code>。
该列表将位于帮助屏幕的顶部，每个阶段旁边都有一个描述。
注意，通过调用 <code>kubeadm join</code>，所有阶段和子阶段都将按照此确切顺序执行。</p>
<!--  
Some phases have unique flags, so if you want to have a look at the list of available options add `--help`, for example:
-->
<p>有些阶段具有唯一的标志，因此，如果要查看可用选项列表，请添加 <code>--help</code>，例如：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubeadm join phase kubelet-start --help
</code></pre></div><!-- 
Similar to the [kubeadm init phase](/docs/reference/setup-tools/kubeadm/kubeadm-init/#init-phases)
command, `kubeadm join phase` allows you to skip a list of phases using the `--skip-phases` flag.

For example:
-->
<p>类似于 <a href="/zh/docs/reference/setup-tools/kubeadm/kubeadm-init/#init-phases">kubeadm init phase</a>命令，
<code>kubeadm join phase</code> 允许你使用 <code>--skip-phases</code> 标志跳过阶段列表。</p>
<p>例如：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">sudo kubeadm join --skip-phases<span style="color:#666">=</span>preflight --config<span style="color:#666">=</span>config.yaml
</code></pre></div><!--
### Discovering what cluster CA to trust
-->
<h3 id="发现要信任的集群-ca">发现要信任的集群 CA</h3>
<!-- 
The kubeadm discovery has several options, each with security tradeoffs.
The right method for your environment depends on how you provision nodes and the
security expectations you have about your network and node lifecycles.
-->
<p>Kubeadm 的发现有几个选项，每个选项都有安全性上的优缺点。
适合你的环境的正确方法取决于节点是如何准备的以及你对网络的安全性期望
和节点的生命周期特点。</p>
<!--
#### Token-based discovery with CA pinning
-->
<h4 id="带-ca-锁定模式的基于令牌的发现">带 CA 锁定模式的基于令牌的发现</h4>
<!-- 
This is the default mode in Kubernetes 1.8 and above. In this mode, kubeadm downloads
the cluster configuration (including root CA) and validates it using the token
as well as validating that the root CA public key matches the provided hash and
that the API server certificate is valid under the root CA.
-->
<p>这是 Kubernetes 1.8 及以上版本中的默认模式。
在这种模式下，kubeadm 下载集群配置（包括根CA）并使用令牌验证它，
并且会验证根 CA 的公钥与所提供的哈希是否匹配，
以及 API 服务器证书在根 CA 下是否有效。</p>
<!--
The CA key hash has the format `sha256:<hex_encoded_hash>`. By default, the hash value is returned in the `kubeadm join` command printed at the end of `kubeadm init` or in the output of `kubeadm token create --print-join-command`. It is in a standard format (see [RFC7469](https://tools.ietf.org/html/rfc7469#section-2.4)) and can also be calculated by 3rd party tools or provisioning systems. For example, using the OpenSSL CLI:
-->
<p>CA 键哈希格式为 <code>sha256:&lt;hex_encoded_hash&gt;</code>。
默认情况下，在 <code>kubeadm init</code> 最后打印的 <code>kubeadm join</code> 命令
或者 <code>kubeadm token create --print-join-command</code> 的输出信息中返回哈希值。
它使用标准格式 (请参考 <a href="https://tools.ietf.org/html/rfc7469#section-2.4">RFC7469</a>)
并且也能通过第三方工具或者制备系统进行计算。
例如，使用 OpenSSL CLI：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">openssl x509 -pubkey -in /etc/kubernetes/pki/ca.crt | openssl rsa -pubin -outform der 2&gt;/dev/null | openssl dgst -sha256 -hex | sed <span style="color:#b44">&#39;s/^.* //&#39;</span>
</code></pre></div><!--
**Example `kubeadm join` command:**
-->
<p><strong><code>kubeadm join</code> 命令示例</strong></p>
<!--
For worker nodes:
-->
<p>对于工作节点：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubeadm join --discovery-token abcdef.1234567890abcdef --discovery-token-ca-cert-hash sha256:1234..cdef 1.2.3.4:6443
</code></pre></div><!--
For control-plane nodes:
-->
<p>对于控制面节点：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubeadm join --discovery-token abcdef.1234567890abcdef --discovery-token-ca-cert-hash sha256:1234..cdef --control-plane 1.2.3.4:6443
</code></pre></div><!-- 
You can also call `join` for a control-plane node with `--certificate-key` to copy certificates to this node,
if the `kubeadm init` command was called with `--upload-certs`.
-->
<p>如果使用 <code>--upload-certs</code> 调用 <code>kubeadm init</code> 命令，
你也可以对控制平面节点调用带 <code>--certificate-key</code> 参数的 <code>join</code> 命令，
将证书复制到该节点。</p>
<!--
**Advantages:**

 - Allows bootstrapping nodes to securely discover a root of trust for the
   master even if other worker nodes or the network are compromised.

 - Convenient to execute manually since all of the information required fits
   into a single `kubeadm join` command.
-->
<p><strong>优势：</strong></p>
<ul>
<li>
<p>允许引导节点安全地发现主节点的信任根，即使其他工作节点或网络受到损害。</p>
</li>
<li>
<p>方便手动执行，因为所需的所有信息都可放到一个 <code>kubeadm join</code> 命令中。</p>
</li>
</ul>
<!-- 
**Disadvantages:**

- The CA hash is not normally known until the master has been provisioned,
  which can make it more difficult to build automated provisioning tools that
  use kubeadm. By generating your CA in beforehand, you may workaround this
  limitation though.
-->
<p><strong>劣势：</strong></p>
<ul>
<li>CA 哈希通常在主节点被提供之前是不知道的，这使得构建使用 kubeadm 的自动化配置工具更加困难。
通过预先生成CA，你可以解除这个限制。</li>
</ul>
<!--   
#### Token-based discovery without CA pinning
-->
<h4 id="无-ca-锁定模式的基于令牌的发现">无 CA 锁定模式的基于令牌的发现</h4>
<!--  
_This was the default in Kubernetes 1.7 and earlier_, but comes with some
important caveats. This mode relies only on the symmetric token to sign
(HMAC-SHA256) the discovery information that establishes the root of trust for
the master. It's still possible in Kubernetes 1.8 and above using the
`--discovery-token-unsafe-skip-ca-verification` flag, but you should consider
using one of the other modes if possible.

**Example `kubeadm join` command:**
-->
<p>_这是 Kubernetes 1.7 和早期版本_中的默认设置；使用时要注意一些重要的补充说明。
此模式仅依赖于对称令牌来签名(HMAC-SHA256)发现信息，这些发现信息为主节点建立信任根。
在 Kubernetes 1.8 及以上版本中仍然可以使用 <code>--discovery-token-unsafe-skip-ca-verification</code>
参数，但是如果可能的话，你应该考虑使用一种其他模式。</p>
<p><strong><code>kubeadm join</code> 命令示例</strong></p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubeadm join --token abcdef.1234567890abcdef --discovery-token-unsafe-skip-ca-verification 1.2.3.4:6443
</code></pre></div><!--
**Advantages:**

- Still protects against many network-level attacks.

- The token can be generated ahead of time and shared with the master and
  worker nodes, which can then bootstrap in parallel without coordination. This
  allows it to be used in many provisioning scenarios.
-->
<p><strong>优势</strong></p>
<ul>
<li>
<p>仍然可以防止许多网络级攻击。</p>
</li>
<li>
<p>可以提前生成令牌并与主节点和工作节点共享，这样主节点和工作节点就可以并行引导而无需协调。
这允许它在许多配置场景中使用。</p>
</li>
</ul>
<!--
**Disadvantages:**

- If an attacker is able to steal a bootstrap token via some vulnerability,
  they can use that token (along with network-level access) to impersonate the
  master to other bootstrapping nodes. This may or may not be an appropriate
  tradeoff in your environment.
-->
<p><strong>劣势</strong></p>
<ul>
<li>如果攻击者能够通过某些漏洞窃取引导令牌，那么他们可以使用该令牌（连同网络级访问）
为其它处于引导过程中的节点提供假冒的主节点。
在你的环境中，这可能是一个适当的折衷方法，也可能不是。</li>
</ul>
<!--
#### File or HTTPS-based discovery
-->
<h4 id="基于-https-或文件发现">基于 HTTPS 或文件发现</h4>
<!-- 
This provides an out-of-band way to establish a root of trust between the control-plane node
and bootstrapping nodes. Consider using this mode if you are building automated provisioning
using kubeadm. The format of the discovery file is a regular Kubernetes
[kubeconfig](/docs/tasks/access-application-cluster/configure-access-multiple-clusters/) file.

In case the discovery file does not contain credentials, the TLS discovery token will be used.
-->
<p>这种方案提供了一种带外方式在主节点和引导节点之间建立信任根。
如果使用 kubeadm 构建自动配置，请考虑使用此模式。
发现文件的格式为常规的 Kubernetes
<a href="/zh/docs/tasks/access-application-cluster/configure-access-multiple-clusters/">kubeconfig</a> 文件。</p>
<p>如果发现文件不包含凭据，则将使用 TLS 发现令牌。</p>
<!--
**Example `kubeadm join` commands:**
-->
<p><strong><code>kubeadm join</code> 命令示例：</strong></p>
<ul>
<li>
<p><code>kubeadm join --discovery-file path/to/file.conf</code> （本地文件）</p>
</li>
<li>
<p><code>kubeadm join --discovery-file https://url/file.conf</code> (远程 HTTPS URL)</p>
</li>
</ul>
<!--
**Advantages:**

- Allows bootstrapping nodes to securely discover a root of trust for the
  master even if the network or other worker nodes are compromised.
-->
<p><strong>优势：</strong></p>
<ul>
<li>允许引导节点安全地发现主节点的信任根，即使网络或其他工作节点受到损害。</li>
</ul>
<!--
**Disadvantages:**

- Requires that you have some way to carry the discovery information from
  the master to the bootstrapping nodes. This might be possible, for example,
  via your cloud provider or provisioning tool. The information in this file is
  not secret, but HTTPS or equivalent is required to ensure its integrity.
-->
<p><strong>劣势：</strong></p>
<ul>
<li>要求你有某种方法将发现信息从主节点传送到引导节点。
例如，这可以通过云提供商或驱动工具实现。
该文件中的信息不是加密的，而是需要 HTTPS 或等效文件来保证其完整性。</li>
</ul>
<!--
### Securing your installation even more {#securing-more}
-->
<h3 id="securing-more">确保你的安装更加安全</h3>
<!-- 
The defaults for kubeadm may not work for everyone. This section documents how to tighten up a kubeadm installation
at the cost of some usability.
-->
<p>Kubeadm 的默认值可能不适用于所有人。
本节说明如何以牺牲可用性为代价来加强 kubeadm 安装。</p>
<!--
#### Turning off auto-approval of node client certificates
-->
<h4 id="关闭节点客户端证书的自动批准">关闭节点客户端证书的自动批准</h4>
<!-- 
By default, there is a CSR auto-approver enabled that basically approves any client certificate request
for a kubelet when a Bootstrap Token was used when authenticating. If you don't want the cluster to
automatically approve kubelet client certs, you can turn it off by executing this command:
-->
<p>默认情况下，Kubernetes 启用了 CSR 自动批准器，如果在身份验证时使用启动引导令牌，
它会批准对 kubelet 的任何客户端证书的请求。
如果不希望集群自动批准kubelet客户端证书，可以通过执行以下命令关闭它：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl delete clusterrolebinding kubeadm:node-autoapprove-bootstrap
</code></pre></div><!--
After that, `kubeadm join` will block until the admin has manually approved the CSR in flight:
-->
<p>关闭后，<code>kubeadm join</code> 操作将会被阻塞，直到管理员已经手动批准了在途中的 CSR 才会继续：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl get csr
</code></pre></div><!--
The output is similar to this:
-->
<p>输出类似于：</p>
<pre tabindex="0"><code>NAME                                                   AGE       REQUESTOR                 CONDITION
node-csr-c69HXe7aYcqkS1bKmH4faEnHAWxn6i2bHZ2mD04jZyQ   18s       system:bootstrap:878f07   Pending
</code></pre><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl certificate approve node-csr-c69HXe7aYcqkS1bKmH4faEnHAWxn6i2bHZ2mD04jZyQ
</code></pre></div><!--
The output is similar to this:
-->
<p>输出类似于：</p>
<pre tabindex="0"><code>certificatesigningrequest &quot;node-csr-c69HXe7aYcqkS1bKmH4faEnHAWxn6i2bHZ2mD04jZyQ&quot; approved
</code></pre><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl get csr
</code></pre></div><!--
The output is similar to this:
-->
<p>输出类似于：</p>
<pre tabindex="0"><code>NAME                                                   AGE       REQUESTOR                 CONDITION
node-csr-c69HXe7aYcqkS1bKmH4faEnHAWxn6i2bHZ2mD04jZyQ   1m        system:bootstrap:878f07   Approved,Issued
</code></pre><!--  
This forces the workflow that `kubeadm join` will only succeed if `kubectl certificate approve` has been run.
-->
<p>这迫使工作流只有在运行了 kubectl 证书批准后，kubeadm join 才能成功。</p>
<!--
#### Turning off public access to the cluster-info ConfigMap
-->
<h4 id="关闭对集群信息-configmap-的公开访问">关闭对集群信息 ConfigMap 的公开访问</h4>
<!-- 
In order to achieve the joining flow using the token as the only piece of validation information, a
 ConfigMap with some data needed for validation of the master's identity is exposed publicly by
default. While there is no private data in this ConfigMap, some users might wish to turn
it off regardless. Doing so will disable the ability to use the `--discovery-token` flag of the
`kubeadm join` flow. Here are the steps to do so:
-->
<p>为了实现使用令牌作为唯一验证信息的加入工作流，默认情况下会公开带有验证主节点标识
所需数据的 ConfigMap。
虽然此 ConfigMap 中没有私有数据，但一些用户可能希望无论如何都关闭它。
这样做需要禁用 <code>kubeadm join</code> 工作流的 <code>--discovery-token</code> 参数。
以下是实现步骤：</p>
<!-- 
* Fetch the `cluster-info` file from the API Server:
-->
<ul>
<li>从 API 服务器获取 <code>cluster-info</code> 文件：</li>
</ul>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl -n kube-public get cm cluster-info -o yaml | grep <span style="color:#b44">&#34;kubeconfig:&#34;</span> -A11 | grep <span style="color:#b44">&#34;apiVersion&#34;</span> -A10 | sed <span style="color:#b44">&#34;s/    //&#34;</span> | tee cluster-info.yaml
</code></pre></div><!--
The output is similar to this:
-->
<p>输出类似于：</p>
<pre tabindex="0"><code>apiVersion: v1
kind: Config
clusters:
- cluster:
    certificate-authority-data: &lt;ca-cert&gt;
    server: https://&lt;ip&gt;:&lt;port&gt;
  name: &quot;&quot;
contexts: []
current-context: &quot;&quot;
preferences: {}
users: []
</code></pre><!--
* Use the `cluster-info.yaml` file as an argument to `kubeadm join --discovery-file`.

* Turn off public access to the `cluster-info` ConfigMap:
-->
<ul>
<li>
<p>使用 <code>cluster-info.yaml</code> 文件作为 <code>kubeadm join --discovery-file</code> 参数。</p>
</li>
<li>
<p>关闭 <code>cluster-info</code> ConfigMap 的公开访问：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl -n kube-public delete rolebinding kubeadm:bootstrap-signer-clusterinfo
</code></pre></div></li>
</ul>
<!--
These commands should be run after `kubeadm init` but before `kubeadm join`.
-->
<p>这些命令应该在执行 <code>kubeadm init</code> 之后、在<code>kubeadm join</code> 之前执行。</p>
<!-- 
### Using kubeadm join with a configuration file {#config-file}
-->
<h3 id="使用带有配置文件的-kubeadm-join">使用带有配置文件的 kubeadm join</h3>
<blockquote class="caution callout">
  <div><strong>注意：</strong> <!--The config file is still considered alpha and may change in future versions.-->
<p>配置文件目前是 alpha 功能，在将来的版本中可能会变动。</div>
</blockquote>

<!--
It's possible to configure `kubeadm join` with a configuration file instead of command
line flags, and some more advanced features may only be available as
configuration file options. This file is passed using the `--config` flag and it must
contain a `JoinConfiguration` structure. Mixing `--config` with others flags may not be
allowed in some cases.
-->
<p>可以用配置文件替代命令行参数的方法配置 <code>kubeadm join</code>，一些高级功能也只有在使用配置文件时才可选用。
该文件通过 <code>--config</code> 参数来传递，并且文件中必须包含 <code>JoinConfiguration</code> 结构。
在某些情况下，不允许将 <code>--config</code> 与其他标志混合使用。</p>
<!--  
The default configuration can be printed out using the
[kubeadm config print](/docs/reference/setup-tools/kubeadm/kubeadm-config/) command.

If your configuration is not using the latest version it is **recommended** that you migrate using
the [kubeadm config migrate](/docs/reference/setup-tools/kubeadm/kubeadm-config/) command.
-->
<p>使用 <a href="/zh/docs/reference/setup-tools/kubeadm/kubeadm-config/">kubeadm config print</a>
命令可以打印默认配置。</p>
<p>如果你的配置没有使用最新版本，
<strong>推荐</strong>使用 <a href="/zh/docs/reference/setup-tools/kubeadm/kubeadm-config/">kubeadm config migrate</a>
命令转换。</p>
<!--
For more information on the fields and usage of the configuration you can navigate to our API reference
page and pick a version from [the list](https://godoc.org/k8s.io/kubernetes/cmd/kubeadm/app/apis/kubeadm#pkg-subdirectories).
-->
<p>有关配置的字段和用法的更多信息，你可以导航到我们的 API 参考页
并从[列表]中选择一个版本(<a href="https://godoc.org/k8s.io/kubernetes/cmd/kubeadm/app/apis/kubeadm#pkg-subdirectories">https://godoc.org/k8s.io/kubernetes/cmd/kubeadm/app/apis/kubeadm#pkg-subdirectories</a>)。</p>
<h2 id="接下来">接下来</h2>
<!--
* [kubeadm init](/docs/reference/setup-tools/kubeadm/kubeadm-init/) to bootstrap a Kubernetes master node
* [kubeadm token](/docs/reference/setup-tools/kubeadm/kubeadm-token/) to manage tokens for `kubeadm join`
* [kubeadm reset](/docs/reference/setup-tools/kubeadm/kubeadm-reset/) to revert any changes made to this host by `kubeadm init` or `kubeadm join`
-->
<ul>
<li><a href="/zh/docs/reference/setup-tools/kubeadm/kubeadm-init/">kubeadm init</a>
初始化 Kubernetes 主节点</li>
<li><a href="/zh/docs/reference/setup-tools/kubeadm/kubeadm-token/">kubeadm token</a>
管理 <code>kubeadm join</code> 的令牌</li>
<li><a href="/zh/docs/reference/setup-tools/kubeadm/kubeadm-reset/">kubeadm reset</a>
将 <code>kubeadm init</code> 或 <code>kubeadm join</code> 对主机的更改恢复到之前状态</li>
</ul>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-2c20539d9fabf5982e2dd931742714bd">7.1.4 - kubeadm upgrade</h1>
    
	<!--
reviewers:
- mikedanese
- luxas
- jbeda
title: kubeadm upgrade
content_type: concept
weight: 40
-->
<!-- overview -->
<!--
`kubeadm upgrade` is a user-friendly command that wraps complex upgrading logic
behind one command, with support for both planning an upgrade and actually performing it. -->
<p><code>kubeadm upgrade</code> 是一个对用户友好的命令，它将复杂的升级逻辑包装在一个命令后面，支持升级的规划和实际执行。</p>
<!-- body -->
<!--
## kubeadm upgrade guidance
-->
<h2 id="kubeadm-upgrade-指南">kubeadm upgrade 指南</h2>
<!--
The steps for performing a upgrade using kubeadm are outlined in [this document](/docs/tasks/administer-cluster/kubeadm/kubeadm-upgrade/).
For older versions of kubeadm, please refer to older documentation sets of the Kubernetes website.
-->
<p><a href="/zh/docs/tasks/administer-cluster/kubeadm/kubeadm-upgrade/">本文档</a>概述
使用 kubeadm 执行升级的步骤。
与 kubeadm 旧版本相关的文档，请参阅 Kubernetes 网站的旧版文档。</p>
<!--
You can use `kubeadm upgrade diff` to see the changes that would be applied to static pod manifests.
-->
<p>你可以使用 <code>kubeadm upgrade diff</code> 来查看将应用于静态 Pod 清单的更改。</p>
<!--
In Kubernetes v1.15.0 and later, `kubeadm upgrade apply` and `kubeadm upgrade node` will also
automatically renew the kubeadm managed certificates on this node, including those stored in kubeconfig files.
To opt-out, it is possible to pass the flag `--certificate-renewal=false`. For more details about certificate
renewal see the [certificate management documentation](/docs/tasks/administer-cluster/kubeadm/kubeadm-certs).
-->
<p>在 Kubernetes v1.15.0 和更高版本中，<code>kubeadm upgrade apply</code> 和 <code>kubeadm upgrade node</code>
也将自动续订该节点上的 kubeadm 托管证书，包括存储在 kubeconfig 文件中的证书。
要选择退出，可以传递参数 <code>--certificate-renewal=false</code>。
有关证书续订的更多详细信息请参见<a href="/zh/docs/tasks/administer-cluster/kubeadm/kubeadm-certs">证书管理文档</a>。</p>
<blockquote class="note callout">
  <div><strong>说明：</strong> <!-- 
The commands `kubeadm upgrade apply` and `kubeadm upgrade plan` have a legacy `--config`
flag which makes it possible to reconfigure the cluster, while performing planning or upgrade of that particular
control-plane node. Please be aware that the upgrade workflow was not designed for this scenario and there are
reports of unexpected results.
-->
<p><code>kubeadm upgrade apply</code> 和 <code>kubeadm upgrade plan</code> 命令都具有遗留的 <code>--config</code> 标志，
可以在执行特定控制平面节点的规划或升级时重新配置集群。
请注意，升级工作流不是为这种情况而设计的，并且有意外结果的报告。</div>
</blockquote>
<h2 id="cmd-upgrade-plan">kubeadm upgrade plan</h2>

	<h3 id="概述">概述</h3>
<p>检查可升级到哪些版本，并验证您当前的集群是否可升级。 要跳过互联网检查，请传递可选的 [version] 参数</p>
<pre tabindex="0"><code>kubeadm upgrade plan [version] [flags]
</code></pre><h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--allow-experimental-upgrades</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">显示不稳定版本的 Kubernetes 作为升级替代方案，并允许升级到 Kubernetes 的 Alpha/Beta/发行候选版本。</td>
</tr>
<tr>
<td colspan="2">--allow-release-candidate-upgrades</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">显示 Kubernetes 的发行候选版本作为升级选择，并允许升级到 Kubernetes 的发行候选版本。</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">配置文件的路径。</td>
</tr>
<tr>
<td colspan="2">--feature-gates string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">一组描述各种特征特性门控的键值对。选项有：IPv6DualStack=true|false (ALPHA - default=false) PublicKeysECDSA=true|false (ALPHA - default=false)</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">帮助</td>
</tr>
<tr>
<td colspan="2">--ignore-preflight-errors stringSlice</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">检查清单，其错误将显示为警告。 例如：“IsPrivilegedUser，Swap”。 值 “all” 忽略所有检查的错误。</td>
</tr>
<tr>
<td colspan="2">--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">与集群通信时使用的 kubeconfig 文件。 如果标志为未设置，则可以在一组标准位置中搜索现有的 kubeconfig 文件。</td>
</tr>
<tr>
<td colspan="2">--print-config</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">指定是否打印将在升级中使用的配置文件。</td>
</tr>
</tbody>
</table>
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">[EXPERIMENTAL] “真实”主机根文件系统的路径。</td>
</tr>
</tbody>
</table>

<h2 id="cmd-upgrade-apply">kubeadm upgrade apply </h2>

	<h3 id="概要">概要</h3>
<!--
Upgrade your Kubernetes cluster to the specified version
-->
<p>将 Kubernetes 集群升级到指定版本</p>
<pre tabindex="0"><code>kubeadm upgrade apply [version]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--allow-experimental-upgrades</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Show unstable versions of Kubernetes as an upgrade alternative and allow upgrading to an alpha/beta/release candidate versions of Kubernetes.
-->
显示 Kubernetes 的不稳定版本作为升级替代方案，并允许升级到 Kubernetes 的 alpha/beta 或 RC 版本。
</td>
</tr>
<tr>
<td colspan="2">--allow-release-candidate-upgrades</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Show release candidate versions of Kubernetes as an upgrade alternative and allow upgrading to a release candidate versions of Kubernetes.
-->
显示 Kubernetes 的候选版本作为升级替代方案，并允许升级到 Kubernetes 的 RC 版本。
</td>
</tr>
<tr>
<td colspan="2">--certificate-renewal&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: true</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Perform the renewal of certificates used by component changed during upgrades.
-->
执行升级期间更改的组件所使用的证书的更新。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to a kubeadm configuration file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">--dry-run</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Do not change any state, just output what actions would be performed.
-->
不要更改任何状态，只输出要执行的操作。
</td>
</tr>
<tr>
<td colspan="2">
<!--
--etcd-upgrade&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: true
-->
--etcd-upgrade&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值: true
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Perform the upgrade of etcd.
-->
执行 etcd 的升级。
</td>
</tr>
<tr>
<td colspan="2">--experimental-patches string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--  
Path to a directory that contains files named "target[suffix][+patchtype].extension". For example, "kube-apiserver0+merge.yaml" or just "etcd.json". "patchtype" can be one of "strategic", "merge" or "json" and they match the patch formats supported by kubectl. The default "patchtype" is "strategic". "extension" must be either "json" or "yaml". "suffix" is an optional string that can be used to determine which patches are applied first alpha-numerically.
-->
包含名为 "target[suffix][+patchtype].extension" 的文件的目录的路径。
例如，"kube-apiserver0+merge.yaml" 或仅仅是 "etcd.json"。
"patchtype" 可以是 "strategic"、"merge" 或 "json" 之一，并且它们与 kubectl 支持的补丁格式匹配。
默认的 "patchtype" 为 "strategic"。 "extension" 必须为 "json" 或 "yaml"。 
"suffix" 是一个可选字符串，可用于确定首先按字母顺序应用哪些补丁。
</td>
</tr>
<tr>
<td colspan="2">--feature-gates string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
A set of key=value pairs that describe feature gates for various features. Options are:<br/>IPv6DualStack=true|false (ALPHA - default=false)
-->
一组键值对，用于描述各种功能。选项包括：
<br/>IPv6DualStack=true|false (ALPHA - 默认=false)
<br/>PublicKeysECDSA=true|false (ALPHA - 默认=false)
</td>
</tr>
<tr>
<td colspan="2">-f, --force</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Force upgrading although some requirements might not be met. This also implies non-interactive mode.
-->
强制升级，但可能无法满足某些要求。这也意味着非交互模式。
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for apply
-->
apply 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">--ignore-preflight-errors stringSlice</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
A list of checks whose errors will be shown as warnings. Example: 'IsPrivilegedUser,Swap'. Value 'all' ignores errors from all checks.
-->
错误将显示为警告的检查列表；例如：'IsPrivilegedUser,Swap'。取值为 'all' 时将忽略检查中的所有错误。
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"
-->
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.
-->
与集群通信时使用的 kubeconfig 文件。如果未设置标志，则在相关目录下搜索以查找现有 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan="2">--print-config</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Specifies whether the configuration file that will be used in the upgrade should be printed or not.
-->
指定是否应打印将在升级中使用的配置文件。
</td>
</tr>
<tr>
<td colspan="2">-y, --yes</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Perform the upgrade and do not prompt for confirmation (non-interactive mode).
-->
执行升级，不提示确认（非交互模式）。
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

<h2 id="cmd-upgrade-diff">kubeadm upgrade diff</h2>

	<h3 id="概述">概述</h3>
<p>显示哪些差异将被应用于现有的静态 pod 资源清单。参考: kubeadm upgrade apply --dry-run</p>
<pre tabindex="0"><code>kubeadm upgrade diff [version] [flags]
</code></pre><!--

### Options

   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>

<tr>
<td colspan="2">--api-server-manifest string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/manifests/kube-apiserver.yaml"</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">path to API server manifest</td>
</tr>
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--api-server-manifest string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/manifests/kube-apiserver.yaml"</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">API服务器清单的路径</td>
</tr>
<!--
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">Path to a kubeadm configuration file.</td>
</tr>
-->
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">kubeadm 配置文件的路径</td>
</tr>
<!--
<tr>
<td colspan="2">-c, --context-lines int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: 3</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">How many lines of context in the diff</td>
</tr>
-->
<tr>
<td colspan="2">-c, --context-lines int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：3</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">差异中有多少行上下文</td>
</tr>
<!--
<tr>
<td colspan="2">--controller-manager-manifest string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/manifests/kube-controller-manager.yaml"</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">path to controller manifest</td>
</tr>
-->
<tr>
<td colspan="2">--controller-manager-manifest string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值： "/etc/kubernetes/manifests/kube-controller-manager.yaml"</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">控制器清单的路径</td>
</tr>
<!--
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">help for diff</td>
</tr>
-->
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">帮助</td>
</tr>
<!--
<tr>
<td colspan="2">--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.</td>
</tr>
-->
<tr>
<td colspan="2">--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">与集群通信时使用的 kubeconfig 文件，如果标志是未设置，则可以在一组标准位置中搜索现有的 kubeconfig 文件。</td>
</tr>
<!--
<tr>
<td colspan="2">--scheduler-manifest string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/manifests/kube-scheduler.yaml"</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">path to scheduler manifest</td>
</tr>
</tbody>
</table>
-->
<tr>
<td colspan="2">--scheduler-manifest string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/manifests/kube-scheduler.yaml"</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">调度程序清单的路径</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands

   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>

<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">[EXPERIMENTAL] The path to the 'real' host root filesystem.</td>
</tr>

</tbody>
</table>

-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">[EXPERIMENTAL] “真实”主机根文件系统的路径。</td>
</tr>
</tbody>
</table>

<h2 id="cmd-upgrade-node">kubeadm upgrade node</h2>

	<h3 id="概要">概要</h3>
<!--
Upgrade commands for a node in the cluster
-->
<p>升级集群中某个节点的命令</p>
<!--
The "node" command executes the following phases:
-->
<p>&quot;node&quot; 命令执行以下阶段：</p>
<!--
```
preflight       Run upgrade node pre-flight checks
control-plane   Upgrade the control plane instance deployed on this node, if any
kubelet-config  Upgrade the kubelet configuration for this node
```
-->
<pre tabindex="0"><code>preflight       执行节点升级前检查
control-plane   如果存在的话，升级部署在该节点上的管理面实例
kubelet-config  更新该节点上的 kubelet 配置
</code></pre><pre tabindex="0"><code>kubeadm upgrade node [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--certificate-renewal</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Perform the renewal of certificates used by component changed during upgrades.
-->
对升级期间变化的组件所使用的证书执行更新。
</td>
</tr>
<tr>
<td colspan="2">--dry-run</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Do not change any state, just output the actions that would be performed.
-->
不更改任何状态，只输出将要执行的操作。
</td>
</tr>
<tr>
<!-- 
<td colspan="2">--etcd-upgrade&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: true</td>
-->
<td colspan="2">--etcd-upgrade&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值: true</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Perform the upgrade of etcd.
-->
执行 etcd 的升级。
</td>
</tr>
<tr>
<td colspan="2">--experimental-patches string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--  
Path to a directory that contains files named "target[suffix][+patchtype].extension". For example, "kube-apiserver0+merge.yaml" or just "etcd.json". "patchtype" can be one of "strategic", "merge" or "json" and they match the patch formats supported by kubectl. The default "patchtype" is "strategic". "extension" must be either "json" or "yaml". "suffix" is an optional string that can be used to determine which patches are applied first alpha-numerically.
-->
包含名为 "target[suffix][+patchtype].extension" 的文件的目录的路径。
例如，"kube-apiserver0+merge.yaml" 或仅仅是 "etcd.json"。
"patchtype" 可以是 "strategic"、"merge" 或 "json" 之一，并且它们与 kubectl 支持的补丁格式匹配。
默认的 "patchtype" 为 "strategic"。 "extension" 必须为 "json" 或 "yaml"。 
"suffix" 是一个可选字符串，可用于确定首先按字母顺序应用哪些补丁。
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for node
-->
node 操作的帮助命令
</td>
</tr>
<tr>
<!-- 
<td colspan="2">--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"</td>
-->
<td colspan="2">--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值: "/etc/kubernetes/admin.conf"</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.
-->
用于与集群交互的 kubeconfig 文件。如果参数未指定，将从一系列标准位置检索存在的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan="2">--kubelet-version string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The *desired* version for the kubelet config after the upgrade. If not specified, the KubernetesVersion from the kubeadm-config ConfigMap will be used
-->
升级后 *期望的* kubelet 配置版本。如未指定，将使用 kubeadm-config ConfigMap 中的 KubernetesVersion
</td>
</tr>
<tr>
<td colspan="2">--skip-phases stringSlice</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
List of phases to be skipped
-->
要跳过的阶段的列表
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

<h2 id="接下来">接下来</h2>
<!--
* [kubeadm config](/docs/reference/setup-tools/kubeadm/kubeadm-config/) if you initialized your cluster using kubeadm v1.7.x or lower, to configure your cluster for `kubeadm upgrade`
-->
<ul>
<li>如果你使用 kubeadm v1.7.x 或更低版本初始化集群，则可以参考
<a href="/zh/docs/reference/setup-tools/kubeadm/kubeadm-config/">kubeadm 配置</a>
配置集群用于 <code>kubeadm upgrade</code>。</li>
</ul>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-5042dc49c5348b3674d3878f37f7670b">7.1.5 - kubeadm config</h1>
    
	<!-- overview -->
<!--
During `kubeadm init`, kubeadm uploads the `ClusterConfiguration` object to your cluster
in a ConfigMap called `kubeadm-config` in the `kube-system` namespace. This configuration is then read during
`kubeadm join`, `kubeadm reset` and `kubeadm upgrade`. To view this ConfigMap call `kubeadm config view`.
-->
<p>在 <code>kubeadm init</code> 执行期间，kubeadm 将 <code>ClusterConfiguration</code> 对象上传
到你的集群的 <code>kube-system</code> 名字空间下名为 <code>kubeadm-config</code> 的 ConfigMap 对象中。
然后在 <code>kubeadm join</code>、<code>kubeadm reset</code> 和 <code>kubeadm upgrade</code> 执行期间读取此配置。
要查看此 ConfigMap，请调用 <code>kubeadm config view</code>。</p>
<!--
You can use `kubeadm config print` to print the default configuration and `kubeadm config migrate` to
convert your old configuration files to a newer version. `kubeadm config images list` and
`kubeadm config images pull` can be used to list and pull the images that kubeadm requires.
-->
<p>你可以使用 <code>kubeadm config print</code> 命令打印默认配置，
并使用 <code>kubeadm config migrate</code> 命令将旧版本的配置转化成新版本。
<code>kubeadm config images list</code> 和 <code>kubeadm config images pull</code>
命令可以用来列出并拉取 kubeadm 所需的镜像。</p>
<!--
For more information navigate to
[Using kubeadm init with a configuration file](/docs/reference/setup-tools/kubeadm/kubeadm-init/#config-file)
or [Using kubeadm join with a configuration file](/docs/reference/setup-tools/kubeadm/kubeadm-join/#config-file).
-->
<p>更多信息请浏览<a href="/zh/docs/reference/setup-tools/kubeadm/kubeadm-init/#config-file">使用带配置文件的 kubeadm init</a>
或<a href="/zh/docs/reference/setup-tools/kubeadm/kubeadm-join/#config-file">使用带配置文件的 kubeadm join</a>.</p>
<!--
You can also configure several kubelet-configuration options with `kubeadm init`. These options will be the same on any node in your cluster. 
See [Configuring each kubelet in your cluster using kubeadm](/docs/setup/production-environment/tools/kubeadm/kubelet-integration/) for details.
-->
<p>你也可以在使用 <code>kubeadm init</code> 命令时配置若干 kubelet 配置选项。
这些选项对于集群中所有节点而言都是相同的。
参阅<a href="/zh/docs/setup/production-environment/tools/kubeadm/kubelet-integration/">使用 kubeadm 来配置集群中的各个 kubelet</a>
了解详细信息。</p>
<!--
In Kubernetes v1.13.0 and later to list/pull kube-dns images instead of the CoreDNS image
the `--config` method described [here](/docs/reference/setup-tools/kubeadm/kubeadm-init-phase/#cmd-phase-addon)
has to be used.
-->
<p>在 Kubernetes v1.13.0 及更高版本中，要列出/拉取 kube-dns 镜像而不是 CoreDNS 镜像，
必须使用<a href="/zh/docs/reference/setup-tools/kubeadm/kubeadm-init-phase/#cmd-phase-addon">这里</a>
所描述的 <code>--config</code> 方法。</p>
<!-- body -->
<h2 id="cmd-config-from-file">kubeadm config upload from-file</h2>
<h2 id="cmd-config-view">kubeadm config print</h2>

	<!--
Print configuration
-->
<p>打印配置</p>
<!--
### Synopsis
-->
<h3 id="概要">概要</h3>
<!--
This command prints configurations for subcommands provided.
For details, see: https://godoc.org/k8s.io/kubernetes/cmd/kubeadm/app/apis/kubeadm/v1beta2
-->
<p>此命令打印子命令所提供的配置信息。
相关细节可参阅 <a href="https://godoc.org/k8s.io/kubernetes/cmd/kubeadm/app/apis/kubeadm/v1beta2">https://godoc.org/k8s.io/kubernetes/cmd/kubeadm/app/apis/kubeadm/v1beta2</a></p>
<pre tabindex="0"><code>kubeadm config print [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;"><p><!--help for print-->print 命令的帮助信息</p></td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承而来的选项">从父命令继承而来的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值："/etc/kubernetes/admin.conf"</td>
</tr>
<tr>
<!--td></td><td style="line-height: 130%; word-wrap: break-word;"><p>The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.</p></td -->
<td></td><td style="line-height: 130%; word-wrap: break-word;"><p>与集群通信时使用的 kubeconfig 文件。如此标志未设置，将在一组标准位置中搜索现有的kubeconfig 文件。</p></td>
</tr>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<!--td></td><td style="line-height: 130%; word-wrap: break-word;"><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td-->
<td></td><td style="line-height: 130%; word-wrap: break-word;"><p>[试验性] 指向“真实”宿主根文件系统的路径。</p></td>
</tr>
</tbody>
</table>

<h2 id="cmd-config-print-init-defaults">kubeadm config print init-defaults</h2>

	<h3 id="概要">概要</h3>
<!--
This command prints objects such as the default init configuration that is used for 'kubeadm init'.
-->
<p>此命令打印对象，例如用于 'kubeadm init' 的默认 init 配置对象。</p>
<!--
Note that sensitive values like the Bootstrap Token fields are replaced with placeholder values like {"abcdef.0123456789abcdef" "" "nil" &lt;nil&gt; [] []} in order to pass validation but
not perform the real computation for creating a token.
-->
<p>请注意，Bootstrap Token 字段之类的敏感值已替换为 {&quot;abcdef.0123456789abcdef&quot; &quot;&quot; &quot;nil&quot; &lt;nil&gt; [] []} 之类的占位符值以通过验证，但不执行创建令牌的实际计算。</p>
<pre tabindex="0"><code>kubeadm config print init-defaults [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--component-configs stringSlice</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
A comma-separated list for component config API objects to print the default values for. Available values: [KubeProxyConfiguration KubeletConfiguration]. If this flag is not set, no component configs will be printed.
-->
组件配置 API 对象的逗号分隔列表，打印其默认值。可用值：[KubeProxyConfiguration KubeletConfiguration]。如果未设置此参数，则不会打印任何组件配置。
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for init-defaults
-->
init-defaults 操作的帮助命令
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">
<!--
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"
-->
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.
-->
与集群通信时使用的 kubeconfig 文件。如果未设置该参数，则可以在一组标准位置中搜索现有的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

<h2 id="cmd-config-print-join-defaults">kubeadm config print join-defaults</h2>

	<h3 id="概要">概要</h3>
<!--
This command prints objects such as the default join configuration that is used for 'kubeadm join'.
-->
<p>此命令打印对象，例如用于 'kubeadm join' 的默认 join 配置对象。</p>
<!--
Note that sensitive values like the Bootstrap Token fields are replaced with placeholder values like {"abcdef.0123456789abcdef" "" "nil" &lt;nil&gt; [] []} in order to pass validation but
not perform the real computation for creating a token.
-->
<p>请注意，诸如启动引导令牌字段之类的敏感值已替换为 {&quot;abcdef.0123456789abcdef&quot; &quot;&quot; &quot;nil&quot; &lt;nil&gt; [] []}
之类的占位符值以通过验证，但不执行创建令牌的实际计算。</p>
<pre tabindex="0"><code>kubeadm config print join-defaults [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--component-configs stringSlice</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
A comma-separated list for component config API objects to print the default values for. Available values: [KubeProxyConfiguration KubeletConfiguration]. If this flag is not set, no component configs will be printed.
-->
组件配置 API 对象的逗号分隔列表，打印其默认值。可用值：[KubeProxyConfiguration KubeletConfiguration]。如果未设置此参数，则不会打印任何组件配置。
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for join-defaults
-->
join-defaults 操作的帮助命令
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">
<!--
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"
-->
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.
-->
与集群通信时使用的 kubeconfig 文件。如果未设置该参数，则可以在一组标准位置中搜索现有的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

<h2 id="cmd-config-migrate">kubeadm config migrate</h2>

	<h3 id="概要">概要</h3>
<!--
This command lets you convert configuration objects of older versions to the latest supported version,
locally in the CLI tool without ever touching anything in the cluster.
In this version of kubeadm, the following API versions are supported:
- kubeadm.k8s.io/v1beta2
-->
<p>此命令允许您在 CLI 工具中将本地旧版本的配置对象转换为最新支持的版本，而无需变更集群中的任何内容。在此版本的 kubeadm 中，支持以下 API 版本：</p>
<ul>
<li>kubeadm.k8s.io/v1beta2</li>
</ul>
<!--
Further, kubeadm can only write out config of version "kubeadm.k8s.io/v1beta2", but read both types.
So regardless of what version you pass to the --old-config parameter here, the API object will be
read, deserialized, defaulted, converted, validated, and re-serialized when written to stdout or
--new-config if specified.
-->
<p>因此，无论您在此处传递 --old-config 参数的版本是什么，当写入到 stdout 或 --new-config （如果已指定）时，
都会读取、反序列化、默认、转换、验证和重新序列化 API 对象。</p>
<!--
In other words, the output of this command is what kubeadm actually would read internally if you
submitted this file to "kubeadm init"
-->
<p>换句话说，如果您将此文件传递给 &quot;kubeadm init&quot;，则该命令的输出就是 kubeadm 实际上在内部读取的内容。</p>
<pre tabindex="0"><code>kubeadm config migrate [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- help for migrate -->
migrate 操作的帮助信息
</td>
</tr>
<tr>
<td colspan="2">--new-config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to the resulting equivalent kubeadm config file using the new API version. Optional, if not specified output will be sent to STDOUT.
-->
使用新的 API 版本生成的 kubeadm 配置文件的路径。这个路径是可选的。如果没有指定，输出将被写到 stdout。
</td>
</tr>
<tr>
<td colspan="2">--old-config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to the kubeadm config file that is using an old API version and should be converted. This flag is mandatory.
-->
使用旧 API 版本且应转换的 kubeadm 配置文件的路径。此参数是必需的。
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">
<!-- kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf" -->
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.
-->
用于和集群通信的 kubeconfig 文件。如果未设置，那么 kubeadm 将会搜索一个已经存在于标准路径的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- [EXPERIMENTAL] The path to the 'real' host root filesystem.  -->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

<h2 id="cmd-config-images-list">kubeadm config images list</h2>

	<h3 id="概要">概要</h3>
<!--
Print a list of images kubeadm will use. The configuration file is used in case any images or image repositories are customized.
-->
<p>打印 kubeadm 要使用的镜像列表。配置文件用于自定义任何镜像或镜像存储库。</p>
<pre tabindex="0"><code>kubeadm config images list [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">
<!-- --allow-missing-template-keys&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: true -->
--allow-missing-template-keys&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：true
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- 
If true, ignore any errors in templates when a field or map key is missing in the template. Only applies to golang and jsonpath output formats.
-->
如果设置为 true，则在模板中缺少字段或哈希表的键时忽略模板中的任何错误。
仅适用于 golang 和 jsonpath 输出格式。
</td>
</tr>
<tr>
<td colspan="2">
<!-- -o, --experimental-output string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "text" -->
-o, --experimental-output string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："text"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--  
Output format. One of: text|json|yaml|go-template|go-template-file|template|templatefile|jsonpath|jsonpath-as-json|jsonpath-file.
-->
输出格式：text|json|yaml|go-template|go-template-file|template|templatefile|jsonpath|jsonpath-as-json|jsonpath-file 其中之一
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to a kubeadm configuration file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">--feature-gates string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
A set of key=value pairs that describe feature gates for various features. Options are:<br/>IPv6DualStack=true|false (ALPHA - default=false)
-->
一组键值对（key=value），用于描述各种特征。选项是：
<br/>Auditing=true|false (ALPHA - 默认=false)
<br/>CoreDNS=true|false (默认=true)
<br/>DynamicKubeletConfig=true|false (BETA - 默认=false)
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for list
-->
list 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">
<!-- --image-repository string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "k8s.gcr.io" -->
--image-repository string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："k8s.gcr.io"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- Choose a container registry to pull control plane images from -->
选择要从中拉取控制平面镜像的容器仓库
</td>
</tr>
<tr>
<td colspan="2">
<!--
--image-repository string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "k8s.gcr.io"
-->
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Choose a container registry to pull control plane images from
-->
为控制平面选择一个特定的 Kubernetes 版本
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">
<!--
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"
-->
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.
-->
用于和集群通信的 kubeconfig 文件。如果它没有被设置，那么 kubeadm 将会搜索一个已经存在于标准路径的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

<h2 id="cmd-config-images-pull">kubeadm config images pull</h2>

	<h3 id="概要">概要</h3>
<!--
Pull images used by kubeadm.
-->
<p>拉取 kubeadm 使用的镜像。</p>
<pre tabindex="0"><code>kubeadm config images pull [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to a kubeadm configuration file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">--cri-socket string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to the CRI socket to connect. If empty kubeadm will try to auto-detect this value; use this option only if you have more than one CRI installed or if you have non-standard CRI socket.
-->
要连接的 CRI 套接字的路径。如果为空，则 kubeadm 将尝试自动检测此值；仅当安装了多个 CRI 或具有非标准 CRI 插槽时，才使用此选项。
</td>
</tr>
<tr>
<td colspan="2">--feature-gates string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
A set of key=value pairs that describe feature gates for various features. Options are:<br/>IPv6DualStack=true|false (ALPHA - default=false)
-->
一系列键值对（key=value），用于描述各种特征。可选项是：<br/>IPv6DualStack=true|false (ALPHA - 默认值=false)
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for pull
-->
pull 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">
<!--
--image-repository string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "k8s.gcr.io"
-->
--image-repository string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："k8s.gcr.io"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Choose a container registry to pull control plane images from
-->
选择用于拉取控制平面镜像的容器仓库
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "stable-1"
-->
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Choose a specific Kubernetes version for the control plane.
-->
为控制平面选择一个特定的 Kubernetes 版本。
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">
<!--
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"
-->
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.
-->
用于和集群通信的 kubeconfig 文件。如果它没有被设置，那么 kubeadm 将会搜索一个已经存在于标准路径的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

<h2 id="接下来">接下来</h2>
<!--
* [kubeadm upgrade](/docs/reference/setup-tools/kubeadm/kubeadm-upgrade/) to upgrade a Kubernetes cluster to a newer version
-->
<ul>
<li><a href="/zh/docs/reference/setup-tools/kubeadm/kubeadm-upgrade/">kubeadm upgrade</a>
将 Kubernetes 集群升级到更新版本 [kubeadm upgrade]</li>
</ul>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-6eb5bc1e7114609930a76c683cc27c2b">7.1.6 - kubeadm reset</h1>
    
	<!-- ---
reviewers:
- mikedanese
- luxas
- jbeda
title: kubeadm reset
content_type: concept
weight: 60
--- -->
<!-- overview -->
<!-- Performs a best effort revert of changes made by `kubeadm init` or `kubeadm join`. -->
<p>该命令尽力还原由 <code>kubeadm init</code> 或 <code>kubeadm join</code> 所做的更改。</p>
<!-- body -->

	<h3 id="概要">概要</h3>
<!--
Performs a best effort revert of changes made to this host by 'kubeadm init' or 'kubeadm join'
-->
<p>尽最大努力还原通过 'kubeadm init' 或者 'kubeadm join' 操作对主机所做的更改</p>
<!--
The "reset" command executes the following phases:
-->
<p>&quot;reset&quot; 命令执行以下阶段：</p>
<pre tabindex="0"><code>preflight              Run reset pre-flight checks
update-cluster-status  Remove this node from the ClusterStatus object.
remove-etcd-member     Remove a local etcd member.
cleanup-node           Run cleanup node.
</code></pre><pre tabindex="0"><code>kubeadm reset [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">
<!--
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"
-->
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The path to the directory where the certificates are stored. If specified, clean this directory.
-->
存储证书的目录路径。如果已指定，则需要清空此目录。
</td>
</tr>
<tr>
<td colspan="2">--cri-socket string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to the CRI socket to connect. If empty kubeadm will try to auto-detect this value; use this option only if you have more than one CRI installed or if you have non-standard CRI socket.
-->
要连接的 CRI 套接字的路径。如果为空，则 kubeadm 将尝试自动检测此值；仅当安装了多个CRI 或具有非标准 CRI 插槽时，才使用此选项。
</td>
</tr>
<tr>
<td colspan="2">-f, --force</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Reset the node without prompting for confirmation.
-->
在不提示确认的情况下重置节点。
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for reset
-->
reset 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">--ignore-preflight-errors stringSlice</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
A list of checks whose errors will be shown as warnings. Example: 'IsPrivilegedUser,Swap'. Value 'all' ignores errors from all checks.
-->
错误将显示为警告的检查列表；例如：'IsPrivilegedUser,Swap'。取值为 'all' 时将忽略检查中的所有错误。
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"
-->
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.
-->
与集群通信时使用的 kubeconfig 文件。如果未设置该标志，则可以在一组标准位置中搜索现有的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan="2">--skip-phases stringSlice</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- List of phases to be skipped -->
要跳过的阶段列表
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

<!-- ### Reset workflow {#reset-workflow} -->
<h3 id="reset-workflow">Reset 工作流程</h3>
<!-- `kubeadm reset` is responsible for cleaning up a node local file system from files that were created using
the `kubeadm init` or `kubeadm join` commands. For control-plane nodes `reset` also removes the local stacked
etcd member of this node from the etcd cluster and also removes this node's information from the kubeadm
`ClusterStatus` object. `ClusterStatus` is a kubeadm managed Kubernetes API object that holds a list of kube-apiserver endpoints. -->
<p><code>kubeadm reset</code> 负责从使用 <code>kubeadm init</code> 或 <code>kubeadm join</code> 命令创建的文件中清除节点本地文件系统。对于控制平面节点，<code>reset</code> 还从 etcd 集群中删除该节点的本地 etcd 堆成员，还从 kubeadm <code>ClusterStatus</code> 对象中删除该节点的信息。
<code>ClusterStatus</code> 是一个 kubeadm 管理的 Kubernetes API 对象，该对象包含 kube-apiserver 端点列表。</p>
<!-- `kubeadm reset phase` can be used to execute the separate phases of the above workflow.
To skip a list of phases you can use the `--skip-phases` flag, which works in a similar way to
the `kubeadm join` and `kubeadm init` phase runners. -->
<p><code>kubeadm reset phase</code> 可用于执行上述工作流程的各个阶段。
要跳过阶段列表，你可以使用 <code>--skip-phases</code> 参数，该参数的工作方式类似于 <code>kubeadm join</code> 和 <code>kubeadm init</code> 阶段运行器。</p>
<!-- ### External etcd clean up -->
<h3 id="外部-etcd-清理">外部 etcd 清理</h3>
<!-- `kubeadm reset` will not delete any etcd data if external etcd is used. This means that if you run `kubeadm init` again using the same etcd endpoints, you will see state from previous clusters. -->
<p>如果使用了外部 etcd，<code>kubeadm reset</code> 将不会删除任何 etcd 中的数据。这意味着，如果再次使用相同的 etcd 端点运行 <code>kubeadm init</code>，你将看到先前集群的状态。</p>
<!-- To wipe etcd data it is recommended you use a client like etcdctl, such as: -->
<p>要清理 etcd 中的数据，建议你使用 etcdctl 这样的客户端，例如：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">etcdctl del <span style="color:#b44">&#34;&#34;</span> --prefix
</code></pre></div><!-- See the [etcd documentation](https://github.com/coreos/etcd/tree/master/etcdctl) for more information. -->
<p>更多详情请参考 <a href="https://github.com/coreos/etcd/tree/master/etcdctl">etcd 文档</a>。</p>
<h2 id="接下来">接下来</h2>
<!-- * [kubeadm init](/docs/reference/setup-tools/kubeadm/kubeadm-init/) to bootstrap a Kubernetes control-plane node
* [kubeadm join](/docs/reference/setup-tools/kubeadm/kubeadm-join/) to bootstrap a Kubernetes worker node and join it to the cluster -->
<ul>
<li>参考 <a href="/zh/docs/reference/setup-tools/kubeadm/kubeadm-init/">kubeadm init</a> 来初始化 Kubernetes 主节点。</li>
<li>参考 <a href="/zh/docs/reference/setup-tools/kubeadm/kubeadm-join/">kubeadm join</a> 来初始化 Kubernetes 工作节点并加入集群。</li>
</ul>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-516f4705fb2f5f62c76c7742772726a3">7.1.7 - kubeadm token</h1>
    
	<!--
---
reviewers:
- mikedanese
- luxas
- jbeda
title: kubeadm token
content_type: concept
weight: 70
---
-->
<!-- overview -->
<!--
Bootstrap tokens are used for establishing bidirectional trust between a node joining
the cluster and a master node, as described in [authenticating with bootstrap tokens](/docs/reference/access-authn-authz/bootstrap-tokens/).
-->
<p>如<a href="/zh/docs/reference/access-authn-authz/bootstrap-tokens/">使用引导令牌进行身份验证</a>所描述的，引导令牌用于在即将加入集群的节点和主节点间建立双向认证。</p>
<!--
`kubeadm init` creates an initial token with a 24-hour TTL. The following commands allow you to manage
such a token and also to create and manage new ones.
-->
<p><code>kubeadm init</code> 创建了一个有效期为 24 小时的令牌，下面的命令允许你管理令牌，也可以创建和管理新的令牌。</p>
<!-- body -->
<h2 id="cmd-token-create">kubeadm token create</h2>

	<h3 id="概要">概要</h3>
<!--
This command will create a bootstrap token for you.
You can specify the usages for this token, the "time to live" and an optional human friendly description.

The [token] is the actual token to write.
This should be a securely generated random token of the form "[a-z0-9]{6}.[a-z0-9]{16}".
If no [token] is given, kubeadm will generate a random token instead.
-->
<p>这个命令将为你创建一个引导令牌。
您可以设置此令牌的用途，&quot;有效时间&quot; 和可选的人性化的描述。</p>
<p>这里的 [token] 是指将要生成的实际令牌。
该令牌应该是一个通过安全机制生成的随机令牌，形式为 &quot;[a-z0-9]{6}.[a-z0-9]{16}&quot;。
如果没有给出 [token]，kubeadm 将生成一个随机令牌。</p>
<pre tabindex="0"><code>kubeadm token create [token]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to a kubeadm configuration file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">--description string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
A human friendly description of how this token is used.
-->
针对令牌用途的人性化的描述。
</td>
</tr>
<tr>
<td colspan="2">
<!--
--groups stringSlice&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: [system:bootstrappers:kubeadm:default-node-token]
-->
--groups stringSlice&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：[system:bootstrappers:kubeadm:default-node-token]
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Extra groups that this token will authenticate as when used for authentication. Must match "\\Asystem:bootstrappers:[a-z0-9:-]{0,255}[a-z0-9]\\z"
-->
此令牌用于身份验证时将进行身份验证的其他组。必须匹配  "\\Asystem:bootstrappers:[a-z0-9:-]{0,255}[a-z0-9]\\z"
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for create
-->
create 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">--print-join-command</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Instead of printing only the token, print the full 'kubeadm join' flag needed to join the cluster using the token.
-->
不仅仅打印令牌，而是打印使用令牌加入集群所需的完整 'kubeadm join' 参数。
</td>
</tr>
<tr>
<td colspan="2">
<!--
--ttl duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: 24h0m0s
-->
--ttl duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：24h0m0s
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The duration before the token is automatically deleted (e.g. 1s, 2m, 3h). If set to '0', the token will never expire
-->
令牌有效时间，超过该时间令牌被自动删除。(例如： 1s, 2m, 3h)。如果设置为 '0'，令牌将永远不过期。
</td>
</tr>
<tr>
<td colspan="2">
<!--
--usages stringSlice&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: [signing,authentication]
-->
--usages stringSlice&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：[signing,authentication]
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Describes the ways in which this token can be used. You can pass --usages multiple times or provide a comma separated list of options. Valid options: [signing,authentication]
-->
描述可以使用此令牌的方式。你可以多次使用 `--usages` 或者提供一个以逗号分隔的选项列表。合法选项有: [signing,authentication]
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--dry-run</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Whether to enable dry-run mode or not
-->
是否启用 `dry-run` 运行模式
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"
-->
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.
-->
用于和集群通信的 KubeConfig 文件。如果它没有被设置，那么 kubeadm 将会搜索一个已经存在于标准路径的 KubeConfig 文件。
</td>
</tr>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

<h2 id="cmd-token-delete">kubeadm token delete</h2>

	<h3 id="概要">概要</h3>
<!--
This command will delete a list of bootstrap tokens for you.

The [token-value] is the full Token of the form "[a-z0-9]{6}.[a-z0-9]{16}" or the
Token ID of the form "[a-z0-9]{6}" to delete.
-->
<p>这个命令将为你删除指定的引导令牌列表。</p>
<p><code>[token-value]</code> 是要删除的 &quot;[a-z0-9]{6}.[a-z0-9]{16}&quot; 形式的完整令牌或者是 &quot;[a-z0-9]{6}&quot; 形式的的令牌 ID。</p>
<pre tabindex="0"><code>kubeadm token delete [token-value] ...
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for delete
-->
delete 操作的帮助命令
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--dry-run</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Whether to enable dry-run mode or not
-->
是否启用 `dry-run` 运行模式
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"
-->
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.
-->
用于和集群通信的 KubeConfig 文件。如果它没有被设置，那么 kubeadm 将会搜索一个已经存在于标准路径的 KubeConfig 文件。
</td>
</tr>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

<h2 id="cmd-token-generate">kubeadm token generate</h2>

	<h3 id="概要">概要</h3>
<!--
This command will print out a randomly-generated bootstrap token that can be used with
the "init" and "join" commands.

You don't have to use this command in order to generate a token. You can do so
yourself as long as it is in the format "[a-z0-9]{6}.[a-z0-9]{16}". This
command is provided for convenience to generate tokens in the given format.

You can also use "kubeadm init" without specifying a token and it will
generate and print one for you.
-->
<p>此命令将打印一个随机生成的可以被 &quot;init&quot; 和 &quot;join&quot; 命令使用的引导令牌。
您不必使用此命令来生成令牌。你可以自己设定，只要格式符合 &quot;[a-z0-9]{6}.[a-z0-9]{16}&quot;。这个命令提供是为了方便生成规定格式的令牌。
您也可以使用 &quot;kubeadm init&quot; 并且不指定令牌，该命令会生成一个令牌并打印出来。</p>
<pre tabindex="0"><code>kubeadm token generate [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for generate
-->
generate 操作的帮助命令
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--dry-run</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- Whether to enable dry-run mode or not -->
是否启用 `dry-run` 运行模式</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"
-->
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.
-->
用于和集群通信的 KubeConfig 文件。如果它没有被设置，那么 kubeadm 将会搜索一个已经存在于标准路径的 KubeConfig 文件。
</td>
</tr>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- [EXPERIMENTAL] The path to the 'real' host root filesystem.  -->
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

<h2 id="cmd-token-list">kubeadm token list</h2>

	<h3 id="概要">概要</h3>
<!--
This command will list all bootstrap tokens for you.
-->
<p>此命令将为您列出所有的引导令牌。</p>
<pre tabindex="0"><code>kubeadm token list [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">
<!-- --allow-missing-template-keys&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: true -->
--allow-missing-template-keys&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：true
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- 
If true, ignore any errors in templates when a field or map key is missing in the template. Only applies to golang and jsonpath output formats.
-->
如果设置为 true，则在模板中缺少字段或哈希表的键时忽略模板中的任何错误。
仅适用于 golang 和 jsonpath 输出格式。
</td>
</tr>
<tr>
<td colspan="2">
<!-- -o, --experimental-output string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "text" -->
-o, --experimental-output string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："text"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--  
Output format. One of: text|json|yaml|go-template|go-template-file|template|templatefile|jsonpath|jsonpath-as-json|jsonpath-file.
-->
输出格式：text|json|yaml|go-template|go-template-file|template|templatefile|jsonpath|jsonpath-as-json|jsonpath-file 其中之一
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- help for list -->
list 操作的帮助命令
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--dry-run</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- Whether to enable dry-run mode or not -->
是否启用 `dry-run` 模式
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"
-->
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.
-->
用于和集群通信的 kubeconfig 文件。如果它没有被设置，那么 kubeadm 将会搜索一个已经存在于标准路径的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- [EXPERIMENTAL] The path to the 'real' host root filesystem.  -->
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

<h2 id="接下来">接下来</h2>
<!--
* [kubeadm join](/docs/reference/setup-tools/kubeadm/kubeadm-join/) to bootstrap a Kubernetes worker node and join it to the cluster
-->
<ul>
<li><a href="/zh/docs/reference/setup-tools/kubeadm/kubeadm-join/">kubeadm join</a> 引导 Kubernetes 工作节点并将其加入集群</li>
</ul>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-34c4af6f36d969ed08ba840e7fb64c6d">7.1.8 - kubeadm version</h1>
    
	<!--
reviewers:
- luxas
- jbeda
title: kubeadm version
content_type: concept
weight: 80
-->
<!-- overview -->
<!--
This command prints the version of kubeadm.
-->
<p>此命令用来输出 kubeadm 的版本。</p>
<!-- body -->

	<h3 id="概要">概要</h3>
<!--
Print the version of kubeadm
-->
<p>打印 kubeadm 的版本</p>
<pre tabindex="0"><code>kubeadm version [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for version
-->
version 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">-o, --output string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Output format; available options are 'yaml', 'json' and 'short'
-->
输出格式；可用的选项有 'yaml', 'json' 和 'short'
</td>
</tr>
</tbody>
</table>
<!-- 
### Options inherited from parent commands 
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>


</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-92a39c69c3689119dd5fa12886cb73a3">7.1.9 - kubeadm alpha</h1>
    
	<!--
title: kubeadm alpha
content_type: concept
weight: 90
-->
<blockquote class="caution callout">
  <div><strong>注意：</strong> <!--
`kubeadm alpha` provides a preview of a set of features made available for gathering feedback
 from the community. Please try it out and give us feedback!
 -->
<p><code>kubeadm alpha</code> 提供了一组可用于收集社区反馈的预览性质功能。
请试用这些功能并给我们提供反馈！</div>
</blockquote>

<!--
Currently there are no experimental commands under `kubeadm alpha`.
-->
<p>目前在 <code>kubeadm alpha</code> 之下没有试验性质的命令。</p>
<h2 id="接下来">接下来</h2>
<!--
* [kubeadm init](/docs/reference/setup-tools/kubeadm/kubeadm-init/) to bootstrap a Kubernetes control-plane node
* [kubeadm join](/docs/reference/setup-tools/kubeadm/kubeadm-join/) to connect a node to the cluster
* [kubeadm reset](/docs/reference/setup-tools/kubeadm/kubeadm-reset/) to revert any changes made to this host by `kubeadm init` or `kubeadm join`
-->
<ul>
<li>用来启动引导 Kubernetes 控制平面节点的
<a href="/zh/docs/reference/setup-tools/kubeadm/kubeadm-init/">kubeadm init</a>
命令</li>
<li>用来将节点连接到集群的
<a href="/zh/docs/reference/setup-tools/kubeadm/kubeadm-join/">kubeadm join</a>
命令</li>
<li>用来还原 <code>kubeadm init</code> 或 <code>kubeadm join</code> 操作对主机所做的任何更改的
<a href="/zh/docs/reference/setup-tools/kubeadm/kubeadm-reset/">kubeadm reset</a>
命令</li>
</ul>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-6a1fed09235bbf3644c804339928f10e">7.1.10 - kubeadm certs</h1>
    
	<!--
`kubeadm certs` provides utilities for managing certificates.
For more details on how these commands can be used, see
[Certificate Management with kubeadm](/docs/tasks/administer-cluster/kubeadm/kubeadm-certs/).
-->
<p><code>kubeadm certs</code> 提供管理证书的工具。关于如何使用这些命令的细节，可参见
<a href="/zh/docs/tasks/administer-cluster/kubeadm/kubeadm-certs/">使用 kubeadm 管理证书</a>。</p>
<h2 id="cmd-certs">kubeadm certs</h2>
<!--
A collection of operations for operating Kubernetes certificates.
-->
<p>用来操作 Kubernetes 证书的一组命令。</p>
<ul class="nav nav-tabs" id="tab-certs" role="tablist"><li class="nav-item"><a data-toggle="tab" class="nav-link active" href="#tab-certs-0" role="tab" aria-controls="tab-certs-0" aria-selected="true">概览</a></li>
	  </ul>
<div class="tab-content" id="tab-certs"><div id="tab-certs-0" class="tab-pane show active" role="tabpanel" aria-labelledby="tab-certs-0">

<p><h3 id="概要">概要</h3>
<!--
Commands related to handling kubernetes certificates
-->
<p>与处理 kubernetes 证书相关的命令</p>
<!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<!-- td></td><td style="line-height: 130%; word-wrap: break-word;">help for certs</td -->
<td></td><td style="line-height: 130%; word-wrap: break-word;"><!-- help for certs-->certs 命令的帮助</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="继承于父命令的选项">继承于父命令的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<!-- td></td><td style="line-height: 130%; word-wrap: break-word;">[EXPERIMENTAL] The path to the 'real' host root filesystem.</td -->
<td></td><td style="line-height: 130%; word-wrap: break-word;">[实验] 到'真实'主机根文件系统的路径。</td>
</tr>
</tbody>
</table>
</div></div>

<h2 id="cmd-certs-renew">kubeadm certs renew</h2>
<!--
You can renew all Kubernetes certificates using the `all` subcommand or renew them selectively.
For more details see [Manual certificate renewal](/docs/tasks/administer-cluster/kubeadm/kubeadm-certs/#manual-certificate-renewal).
-->
<p>你可以使用 <code>all</code> 子命令来续订所有 Kubernetes 证书，也可以选择性地续订部分证书。
更多的相关细节，可参见
<a href="/zh/docs/tasks/administer-cluster/kubeadm/kubeadm-certs/#manual-certificate-renewal">手动续订证书</a>。</p>
<ul class="nav nav-tabs" id="tab-certs-renew" role="tablist"><li class="nav-item"><a data-toggle="tab" class="nav-link active" href="#tab-certs-renew-0" role="tab" aria-controls="tab-certs-renew-0" aria-selected="true">renew</a></li>
	  
		<li class="nav-item"><a data-toggle="tab" class="nav-link" href="#tab-certs-renew-1" role="tab" aria-controls="tab-certs-renew-1">all</a></li>
		<li class="nav-item"><a data-toggle="tab" class="nav-link" href="#tab-certs-renew-2" role="tab" aria-controls="tab-certs-renew-2">admin.conf</a></li>
		<li class="nav-item"><a data-toggle="tab" class="nav-link" href="#tab-certs-renew-3" role="tab" aria-controls="tab-certs-renew-3">apiserver-etcd-client</a></li>
		<li class="nav-item"><a data-toggle="tab" class="nav-link" href="#tab-certs-renew-4" role="tab" aria-controls="tab-certs-renew-4">apiserver-kubelet-client</a></li>
		<li class="nav-item"><a data-toggle="tab" class="nav-link" href="#tab-certs-renew-5" role="tab" aria-controls="tab-certs-renew-5">apiserver</a></li>
		<li class="nav-item"><a data-toggle="tab" class="nav-link" href="#tab-certs-renew-6" role="tab" aria-controls="tab-certs-renew-6">controller-manager.conf</a></li>
		<li class="nav-item"><a data-toggle="tab" class="nav-link" href="#tab-certs-renew-7" role="tab" aria-controls="tab-certs-renew-7">etcd-healthcheck-client</a></li>
		<li class="nav-item"><a data-toggle="tab" class="nav-link" href="#tab-certs-renew-8" role="tab" aria-controls="tab-certs-renew-8">etcd-peer</a></li>
		<li class="nav-item"><a data-toggle="tab" class="nav-link" href="#tab-certs-renew-9" role="tab" aria-controls="tab-certs-renew-9">etcd-server</a></li>
		<li class="nav-item"><a data-toggle="tab" class="nav-link" href="#tab-certs-renew-10" role="tab" aria-controls="tab-certs-renew-10">front-proxy-client</a></li>
		<li class="nav-item"><a data-toggle="tab" class="nav-link" href="#tab-certs-renew-11" role="tab" aria-controls="tab-certs-renew-11">scheduler.conf</a></li></ul>
<div class="tab-content" id="tab-certs-renew"><div id="tab-certs-renew-0" class="tab-pane show active" role="tabpanel" aria-labelledby="tab-certs-renew-0">

<p><h3 id="概要">概要</h3>
<!--
This command is not meant to be run on its own. See list of available subcommands.
-->
<p>此命令并非设计用来单独运行。请参阅可用子命令列表。</p>
<pre tabindex="0"><code>kubeadm certs renew [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for renew
-->
renew 操作的帮助命令
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
  <div id="tab-certs-renew-1" class="tab-pane" role="tabpanel" aria-labelledby="tab-certs-renew-1">

<p><h3 id="概要">概要</h3>
<!--
Renew all known certificates necessary to run the control plane. Renewals are run unconditionally, regardless of expiration date. Renewals can also be run individually for more control.
-->
<p>续订运行控制平面所需的所有已知证书。续订是无条件进行的，与到期日期无关。续订也可以单独运行以进行更多控制。</p>
<pre tabindex="0"><code>kubeadm certs renew all [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">
<!--
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"
-->
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The path where to save and store the certificates.
-->
存储证书的路径。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to a kubeadm configuration file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">--csr-dir string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The path to output the CSRs and private keys to
-->
输出 CSR 和私钥的路径
</td>
</tr>
<tr>
<td colspan="2">--csr-only</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Create CSRs instead of generating certificates
-->
创建 CSR 而不是生成证书
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for all
-->
all 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"
-->
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.
-->
与集群通信时使用的 kubeconfig 文件。
如果未设置该参数，则可以在一组标准位置中搜索现有的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan="2">--use-api</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Use the Kubernetes certificate API to renew certificates
-->
使用 Kubernetes 证书 API 续订证书
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
  <div id="tab-certs-renew-2" class="tab-pane" role="tabpanel" aria-labelledby="tab-certs-renew-2">

<p><h3 id="概要">概要</h3>
<!--
Renew the certificate embedded in the kubeconfig file for the admin to use and for kubeadm itself.
-->
<p>续订 kubeconfig 文件中嵌入的证书，供管理员 和 kubeadm 自身使用。</p>
<!--
Renewals run unconditionally, regardless of certificate expiration date; extra attributes such as SANs will be based on the existing file/certificates, there is no need to resupply them.
-->
<p>无论证书的到期日期如何，续订都是无条件进行的；SAN 等额外属性将基于现有文件/证书，因此无需重新提供它们。</p>
<!--
Renewal by default tries to use the certificate authority in the local PKI managed by kubeadm; as alternative it is possible to use K8s certificate API for certificate renewal, or as a last option, to generate a CSR request.
-->
<p>默认情况下，续订会尝试使用由 kubeadm 管理的本地 PKI 中的证书机构；作为替代方案，
也可以使用 K8s 证书 API 进行证书续订，或者（作为最后一种选择）生成 CSR 请求。</p>
<!--
After renewal, in order to make changes effective, is is required to restart control-plane components and eventually re-distribute the renewed certificate in case the file is used elsewhere.
-->
<p>续订后，为了使更改生效，需要重新启动控制平面组件，并最终重新分发更新的证书，以防证书文件在其他地方使用。</p>
<pre tabindex="0"><code>kubeadm certs renew admin.conf [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">
<!-- --cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki" -->
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The path where to save the certificates.
-->
保存证书的路径。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- Path to a kubeadm configuration file.  -->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">--csr-dir string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- The path to output the CSRs and private keys to -->
CSR 和私钥的输出路径
</td>
</tr>
<tr>
<td colspan="2">--csr-only</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Create CSRs instead of generating certificates
-->
创建 CSR 而不是生成证书
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- help for admin.conf -->
admin.conf 子操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.  -->
与集群通信时使用的 kubeconfig 文件。
如果未设置该参数，则可以在一组标准位置中搜索现有的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan="2">--use-api</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Use the Kubernetes certificate API to renew certificates
-->
使用 Kubernetes 证书 API 续订证书
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
  <div id="tab-certs-renew-3" class="tab-pane" role="tabpanel" aria-labelledby="tab-certs-renew-3">

<p><h3 id="概要">概要</h3>
<!--
Renew the certificate the apiserver uses to access etcd.
-->
<p>续订 apiserver 用于访问 etcd 的证书。</p>
<!--
Renewals run unconditionally, regardless of certificate expiration date; extra attributes such as SANs will be based on the existing file/certificates, there is no need to resupply them.
-->
<p>无论证书的到期日期如何，续订都会无条件地进行；SAN 等额外属性将基于现有文件/证书，因此无需重新提供它们。</p>
<!--
Renewal by default tries to use the certificate authority in the local PKI managed by kubeadm; as alternative it is possible to use K8s certificate API for certificate renewal, or as a last option, to generate a CSR request.
-->
<p>默认情况下，续订尝试使用在 kubeadm 所管理的本地 PKI 中的证书颁发机构；作为替代方案，
可以使用 K8s 证书 API 进行证书更新，或者作为最后一个选择来生成 CSR 请求。</p>
<!--
After renewal, in order to make changes effective, is is required to restart control-plane components and eventually re-distribute the renewed certificate in case the file is used elsewhere.
-->
<p>续订后，为了使更改生效，需要重新启动控制平面组件，并最终重新分发更新的证书，以防文件在其他地方使用。</p>
<pre tabindex="0"><code>kubeadm certs renew apiserver-etcd-client [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">
<!-- cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki" -->
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- The path where to save and store the certificates.  -->
存储证书的路径。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- Path to a kubeadm configuration file.  -->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">--csr-dir string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- The path to output the CSRs and private keys to -->
输出 CSR 和私钥的路径
</td>
</tr>
<tr>
<td colspan="2">--csr-only</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- Create CSRs instead of generating certificates -->
创建 CSR 而不是生成证书
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- help for apiserver-etcd-client -->
apiserver-etcd-client 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"
-->
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.
-->
与集群通信时使用的 kubeconfig 文件。
如果未设置该参数，则可以在一组标准位置中搜索现有的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan="2">--use-api</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- Use the Kubernetes certificate API to renew certificates -->
使用 Kubernetes 证书 API 续订证书
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- [EXPERIMENTAL] The path to the 'real' host root filesystem.  -->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
  <div id="tab-certs-renew-4" class="tab-pane" role="tabpanel" aria-labelledby="tab-certs-renew-4">

<p><h3 id="概要">概要</h3>
<!--
Renew the certificate for the API server to connect to kubelet.
-->
<p>续订 apiserver 用于连接 kubelet 的证书。</p>
<!--
Renewals run unconditionally, regardless of certificate expiration date; extra attributes such as SANs will be based on the existing file/certificates, there is no need to resupply them.
-->
<p>无论证书的到期日期如何，续订都会无条件地进行；SAN 等额外属性将基于现有文件/证书，因此无需重新提供它们。</p>
<!--
Renewal by default tries to use the certificate authority in the local PKI managed by kubeadm; as alternative it is possible to use K8s certificate API for certificate renewal, or as a last option, to generate a CSR request.
-->
<p>默认情况下，续订尝试使用位于 kubeadm 所管理的本地 PKI 中的证书颁发机构；作为替代方案，
也可能调用 K8s 证书 API 进行证书更新；亦或者，作为最后一个选择，生成 CSR 请求。</p>
<!--
After renewal, in order to make changes effective, is is required to restart control-plane components and eventually re-distribute the renewed certificate in case the file is used elsewhere.
-->
<p>续订后，为了使更改生效，需要重新启动控制平面组件，并最终重新分发更新的证书，以防文件在其他地方使用。</p>
<pre tabindex="0"><code>kubeadm certs renew apiserver-kubelet-client [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">
<!--
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"
-->
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The path where to save and store the certificates.
-->
存储证书的路径。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to a kubeadm configuration file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">--csr-dir string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The path to output the CSRs and private keys to
-->
输出 CSR 和私钥的路径
</td>
</tr>
<tr>
<td colspan="2">--csr-only</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Create CSRs instead of generating certificates
-->
创建 CSR 而不是生成证书
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for apiserver-kubelet-client
-->
apiserver-kubelet-client 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"
-->
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.
-->
与集群通信时使用的 kubeconfig 文件。
如果未设置该参数，则可以在一组标准位置中搜索现有的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan="2">--use-api</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Use the Kubernetes certificate API to renew certificates
-->
使用 Kubernetes 证书 API 续订证书
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
  <div id="tab-certs-renew-5" class="tab-pane" role="tabpanel" aria-labelledby="tab-certs-renew-5">

<p><h3 id="概要">概要</h3>
<!--
Renew the certificate for serving the Kubernetes API.
-->
<p>续订用于提供 Kubernetes API 的证书。</p>
<!--
Renewals run unconditionally, regardless of certificate expiration date; extra attributes such as SANs will be based on the existing file/certificates, there is no need to resupply them.
-->
<p>无论证书的到期日期如何，续订都会无条件地进行；SAN 等额外属性将基于现有文件/证书，因此无需重新提供它们。</p>
<!--
Renewal by default tries to use the certificate authority in the local PKI managed by kubeadm; as alternative it is possible to use K8s certificate API for certificate renewal, or as a last option, to generate a CSR request.
-->
<p>默认情况下，续订尝试在 kubeadm 管理的本地 PKI 中使用证书颁发机构；作为替代方案，
可以使用 K8s 证书 API 进行证书更新，或者作为最后一个选择来生成 CSR 请求。</p>
<!--
After renewal, in order to make changes effective, is is required to restart control-plane components and eventually re-distribute the renewed certificate in case the file is used elsewhere.
-->
<p>续订后，为了使更改生效，需要重新启动控制平面组件，并最终重新分发更新的证书，以防文件在其他地方使用。</p>
<pre tabindex="0"><code>kubeadm certs renew apiserver [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">
<!--
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"
-->
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The path where to save the certificates.
-->
保存证书的路径。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to a kubeadm configuration file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">--csr-dir string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;"> 
<!--
The path to output the CSRs and private keys to
-->
CSR 和私钥的输出路径
</td>
</tr>
<tr>
<td colspan="2">--csr-only</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Create CSRs instead of generating certificates
-->
创建 CSR 而不是生成证书
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for apiserver
-->
apiserver 子操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"
-->
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.
-->
与集群通信时使用的 kubeconfig 文件。
如果未设置该参数，则可以在一组标准位置中搜索现有的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan="2">--use-api</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Use the Kubernetes certificate API to renew certificates
-->
使用 Kubernetes 证书 API 续订证书
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
  <div id="tab-certs-renew-6" class="tab-pane" role="tabpanel" aria-labelledby="tab-certs-renew-6">

<p><h3 id="概要">概要</h3>
<!--
Renew the certificate embedded in the kubeconfig file for the controller manager to use.
-->
<p>续订 kubeconfig 文件中嵌入的证书，以供控制器管理器（Controller Manager）使用。</p>
<!--
Renewals run unconditionally, regardless of certificate expiration date; extra attributes such as SANs will be based on the existing file/certificates, there is no need to resupply them.
-->
<p>续订无条件地进行，与证书的到期日期无关；SAN 等额外属性将基于现有的文件/证书，因此无需重新提供它们。</p>
<!--
Renewal by default tries to use the certificate authority in the local PKI managed by kubeadm; as alternative it is possible to use K8s certificate API for certificate renewal, or as a last option, to generate a CSR request.
-->
<p>默认情况下，续订会尝试使用 kubeadm 管理的本地 PKI 中的证书颁发机构；作为替代方案，
可以使用 K8s 证书 API 进行证书续订；亦或者，作为最后一种选择，生成 CSR 请求。</p>
<!--
After renewal, in order to make changes effective, is is required to restart control-plane components and eventually re-distribute the renewed certificate in case the file is used elsewhere.
-->
<p>续订后，为了使更改生效，需要重新启动控制平面组件，并最终重新分发更新的证书，以防文件在其他地方使用。</p>
<pre tabindex="0"><code>kubeadm alpha renew controller-manager.conf [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">
<!--
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"
-->
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The path where to save the certificates.
-->
保存证书的路径。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to a kubeadm configuration file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">--csr-dir string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The path to output the CSRs and private keys to
-->
CSR 和私钥的输出路径
</td>
</tr>
<tr>
<td colspan="2">--csr-only</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Create CSRs instead of generating certificates
-->
创建 CSR 而不是生成证书
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for controller-manager.conf
-->
controller-manager.conf 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"
-->
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.
-->
与集群通信时使用的 kubeconfig 文件。
如果未设置该参数，则可以在一组标准位置中搜索现有的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan="2">--use-api</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Use the Kubernetes certificate API to renew certificates
-->
使用 Kubernetes 证书 API 续订证书
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
  <div id="tab-certs-renew-7" class="tab-pane" role="tabpanel" aria-labelledby="tab-certs-renew-7">

<p><h3 id="概要">概要</h3>
<!--
Renew the certificate for liveness probes to healthcheck etcd.
-->
<p>续订存活态探针的证书，用于对 etcd 执行健康检查。</p>
<!--
Renewals run unconditionally, regardless of certificate expiration date; extra attributes such as SANs will be based on the existing file/certificates, there is no need to resupply them.
-->
<p>无论证书的到期日期如何，续订都是无条件进行的；SAN 等额外属性将基于现有文件/证书，因此无需重新提供它们。</p>
<!--
Renewal by default tries to use the certificate authority in the local PKI managed by kubeadm; as alternative it is possible to use K8s certificate API for certificate renewal, or as a last option, to generate a CSR request.
-->
<p>默认情况下，续订会尝试使用由 kubeadm 管理的本地 PKI 中的证书机构；作为替代方案，
也可以使用 K8s certificate API 进行证书续订，或者（作为最后一种选择）生成 CSR 请求。</p>
<!--
After renewal, in order to make changes effective, is is required to restart control-plane components and eventually re-distribute the renewed certificate in case the file is used elsewhere.
-->
<p>续订后，为了使更改生效，需要重新启动控制平面组件，并最终重新分发更新的证书，以防证书文件在其他地方使用。</p>
<pre tabindex="0"><code>kubeadm certs renew etcd-healthcheck-client [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">
<!--
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"
-->
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The path where to save the certificates.
-->
保存证书的路径。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to a kubeadm configuration file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">--csr-dir string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The path to output the CSRs and private keys to
-->
CSR 和私钥的输出路径
</td>
</tr>
<tr>
<td colspan="2">--csr-only</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Create CSRs instead of generating certificates
-->
创建 CSR 而不是生成证书
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for etcd-healthcheck-client
-->
etcd-healthcheck-client 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"
-->
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.
-->
与集群通信时使用的 kubeconfig 文件。
如果未设置该参数，则可以在一组标准位置中搜索现有的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan="2">--use-api</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Use the Kubernetes certificate API to renew certificates
-->
使用 Kubernetes 证书 API 续订证书
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
  <div id="tab-certs-renew-8" class="tab-pane" role="tabpanel" aria-labelledby="tab-certs-renew-8">

<p><h3 id="概要">概要</h3>
<!--
Renew the certificate for etcd nodes to communicate with each other.
-->
<p>续订 etcd 节点间用来相互通信的证书。</p>
<!--
Renewals run unconditionally, regardless of certificate expiration date; extra attributes such as SANs will be based on the existing file/certificates, there is no need to resupply them.
-->
<p>无论证书的到期日期如何，续订都是无条件进行的；SAN 等额外属性将基于现有文件/证书，因此无需重新提供它们。</p>
<!--
Renewal by default tries to use the certificate authority in the local PKI managed by kubeadm; as alternative it is possible to use K8s certificate API for certificate renewal, or as a last option, to generate a CSR request.
-->
<p>默认情况下，续订会尝试使用由 kubeadm 管理的本地 PKI 中的证书机构；
作为替代方案，也可以使用 K8s certificate API 进行证书续订，或者（作为最后一种选择）生成 CSR 请求。</p>
<!--
After renewal, in order to make changes effective, is is required to restart control-plane components and eventually re-distribute the renewed certificate in case the file is used elsewhere.
-->
<p>续订后，为了使更改生效，需要重新启动控制平面组件，并最终重新分发更新的证书，以防证书文件在其他地方使用。</p>
<pre tabindex="0"><code>kubeadm certs renew etcd-peer [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">
<!--
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"
-->
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The path where to save the certificates.
-->
保存证书的路径。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to a kubeadm configuration file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">--csr-dir string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The path to output the CSRs and private keys to
-->
CSR 和私钥的输出路径
</td>
</tr>
<tr>
<td colspan="2">--csr-only</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Create CSRs instead of generating certificates
-->
创建 CSR 而不是生成证书
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for etcd-peer
-->
etcd-peer 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"
-->
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.
-->
与集群通信时使用的 kubeconfig 文件。
如果未设置该参数，则可以在一组标准位置中搜索现有的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan="2">--use-api</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Use the Kubernetes certificate API to renew certificates
-->
使用 Kubernetes 证书 API 续订证书
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
  <div id="tab-certs-renew-9" class="tab-pane" role="tabpanel" aria-labelledby="tab-certs-renew-9">

<p><h3 id="概要">概要</h3>
<!--
Renew the certificate for serving etcd.
-->
<p>续订用于提供 etcd 服务的证书。</p>
<!--
Renewals run unconditionally, regardless of certificate expiration date; extra attributes such as SANs will be based on the existing file/certificates, there is no need to resupply them.
-->
<p>续订无条件地进行，与证书的到期日期无关；SAN 等额外属性将基于现有的文件/证书，因此无需重新提供它们。</p>
<!--
Renewal by default tries to use the certificate authority in the local PKI managed by kubeadm; as alternative it is possible to use K8s certificate API for certificate renewal, or as a last option, to generate a CSR request.
-->
<p>默认情况下，续订会尝试在 kubeadm 管理的本地 PKI 中使用证书颁发机构；作为替代方案，
可以使用 K8s 证书 API 进行证书续订，或者作为最后一种选择来生成 CSR 请求。</p>
<!--
After renewal, in order to make changes effective, is is required to restart control-plane components and eventually re-distribute the renewed certificate in case the file is used elsewhere.
-->
<p>续订后，为了使更改生效，需要重新启动控制平面组件，并最终重新分发更新的证书，以防文件在其他地方使用。</p>
<pre tabindex="0"><code>kubeadm certs renew etcd-server [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">
<!--
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"
-->
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The path where to save the certificates.
-->
保存证书的路径。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to a kubeadm configuration file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">--csr-dir string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The path to output the CSRs and private keys to
-->
CSR 和私钥的输出路径
</td>
</tr>
<tr>
<td colspan="2">--csr-only</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Create CSRs instead of generating certificates
-->
创建 CSR 而不是生成证书
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for etcd-server
-->
etcd-server 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"
-->
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.
-->
与集群通信时使用的 kubeconfig 文件。
如果未设置该参数，则可以在一组标准位置中搜索现有的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan="2">--use-api</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Use the Kubernetes certificate API to renew certificates
-->
使用 Kubernetes 证书 API 续订证书
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
  <div id="tab-certs-renew-10" class="tab-pane" role="tabpanel" aria-labelledby="tab-certs-renew-10">

<p><h3 id="概要">概要</h3>
<!--
Renew the certificate for the front proxy client.
-->
<p>为前端代理客户端续订证书。</p>
<!--
Renewals run unconditionally, regardless of certificate expiration date; extra attributes such as SANs will be based on the existing file/certificates, there is no need to resupply them.
-->
<p>无论证书的到期日期如何，续订都会无条件地进行；SAN 等额外属性将基于现有文件/证书，因此无需重新提供它们。</p>
<!--
Renewal by default tries to use the certificate authority in the local PKI managed by kubeadm; as alternative it is possible to use K8s certificate API for certificate renewal, or as a last option, to generate a CSR request.
-->
<p>默认情况下，续订尝试使用位于 kubeadm 所管理的本地 PKI 中的证书颁发机构；作为替代方案，
也可以使用 K8s 证书 API 进行证书续订；亦或者，作为最后一种方案，生成 CSR 请求。</p>
<!--
After renewal, in order to make changes effective, is is required to restart control-plane components and eventually re-distribute the renewed certificate in case the file is used elsewhere.
-->
<p>续订后，为了使更改生效，需要重新启动控制平面组件，并最终重新分发更新的证书，以防文件在其他地方使用。</p>
<pre tabindex="0"><code>kubeadm certs renew front-proxy-client [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<!-- td colspan="2">--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"</td -->
<td colspan="2">--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The path where to save the certificates
-->
存储证书的路径。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to a kubeadm configuration file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">--csr-dir string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The path to output the CSRs and private keys to
-->
输出 CSR 和私钥的路径
</td>
</tr>
<tr>
<td colspan="2">--csr-only</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Create CSRs instead of generating certificates
-->
创建 CSR 而不是生成证书
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for front-proxy-client
-->
front-proxy-client 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"
-->
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.
-->
与集群通信时使用的 kubeconfig 文件。
如果未设置该参数，则可以在一组标准位置中搜索现有的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan="2">--use-api</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Use the Kubernetes certificate API to renew certificates
-->
使用 Kubernetes 证书 API 续订证书
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
  <div id="tab-certs-renew-11" class="tab-pane" role="tabpanel" aria-labelledby="tab-certs-renew-11">

<p><h3 id="概要">概要</h3>
<!--
Renew the certificate embedded in the kubeconfig file for the scheduler manager to use.
-->
<p>续订 kubeconfig 文件中嵌入的证书，以供调度管理器使用。</p>
<!--
Renewals run unconditionally, regardless of certificate expiration date; extra attributes such as SANs will be based on the existing file/certificates, there is no need to resupply them.
-->
<p>续订无条件地进行，与证书的到期日期无关；SAN 等额外属性将基于现有的文件/证书，因此无需重新提供它们。</p>
<!--
Renewal by default tries to use the certificate authority in the local PKI managed by kubeadm; as alternative it is possible to use K8s certificate API for certificate renewal, or as a last option, to generate a CSR request.
-->
<p>默认情况下，续订会尝试使用在 kubeadm 所管理的本地 PKI 中的证书颁发机构；作为替代方案，
也可以使用 K8s 证书 API 进行证书续订；亦或者，作为最后一种选择，生成 CSR 请求。</p>
<!--
After renewal, in order to make changes effective, is is required to restart control-plane components and eventually re-distribute the renewed certificate in case the file is used elsewhere.
-->
<p>续订后，为了使更改生效，需要重新启动控制平面组件，并最终重新分发更新的证书，以防文件在其他地方使用。</p>
<pre tabindex="0"><code>kubeadm certs renew scheduler.conf [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">
<!--
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"
-->
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The path where to save the certificates.
-->
保存证书的路径。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to a kubeadm configuration file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">--csr-dir string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The path to output the CSRs and private keys to
-->
CSR 和私钥的输出路径
</td>
</tr>
<tr>
<td colspan="2">--csr-only</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Create CSRs instead of generating certificates
-->
创建 CSR 而不是生成证书
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for scheduler.conf
-->
scheduler.conf 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"
-->
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.
-->
与集群通信时使用的 kubeconfig 文件。
如果未设置该参数，则可以在一组标准位置中搜索现有的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan="2">--use-api</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Use the Kubernetes certificate API to renew certificates
-->
使用 Kubernetes 证书 API 续订证书
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div></div>

<h2 id="cmd-certs-certificate-key">kubeadm certs certificate-key</h2>
<!--
This command can be used to generate a new control-plane certificate key.
The key can be passed as `--certificate-key` to [`kubeadm init`](/docs/reference/setup-tools/kubeadm/kubeadm-init)
and [`kubeadm join`](/docs/reference/setup-tools/kubeadm/kubeadm-join)
to enable the automatic copy of certificates when joining additional control-plane nodes.
-->
<p>此命令可用来生成一个新的控制面证书密钥。密钥可以作为 <code>--certificate-key</code>
标志的取值传递给 <a href="/zh/docs/reference/setup-tools/kubeadm/kubeadm-init"><code>kubeadm init</code></a>
和 <a href="/zh/docs/reference/setup-tools/kubeadm/kubeadm-join"><code>kubeadm join</code></a>
命令，从而在添加新的控制面节点时能够自动完成证书复制。</p>
<ul class="nav nav-tabs" id="tab-certs-certificate-key" role="tablist"><li class="nav-item"><a data-toggle="tab" class="nav-link active" href="#tab-certs-certificate-key-0" role="tab" aria-controls="tab-certs-certificate-key-0" aria-selected="true">certificate-key</a></li>
	  </ul>
<div class="tab-content" id="tab-certs-certificate-key"><div id="tab-certs-certificate-key-0" class="tab-pane show active" role="tabpanel" aria-labelledby="tab-certs-certificate-key-0">

<p><h3 id="概要">概要</h3>
<!--
This command will print out a secure randomly-generated certificate key that can be used with
the "init" command.
-->
<p>该命令将打印出可以与 &quot;init&quot; 命令一起使用的安全的随机生成的证书密钥。</p>
<!--
You can also use "kubeadm init -upload-certs" without specifying a certificate key and it will generate and print one for you.
-->
<p>你也可以使用 <code>kubeadm init --upload-certs</code> 而无需指定证书密钥；
命令将为你生成并打印一个证书密钥。</p>
<pre tabindex="0"><code>kubeadm certs certificate-key [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for certificate-key
-->
certificate-key 操作的帮助命令
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div></div>

<h2 id="cmd-certs-check-expiration">kubeadm certs check-expiration</h2>
<!--
This command checks expiration for the certificates in the local PKI managed by kubeadm.
For more details see
[Check certificate expiration](/docs/tasks/administer-cluster/kubeadm/kubeadm-certs/#check-certificate-expiration).
-->
<p>此命令检查 kubeadm 所管理的本地 PKI 中的证书是否以及何时过期。
更多的相关细节，可参见
<a href="/zh/docs/tasks/administer-cluster/kubeadm/kubeadm-certs/#check-certificate-expiration">检查证书过期</a>。</p>
<ul class="nav nav-tabs" id="tab-certs-check-expiration" role="tablist"><li class="nav-item"><a data-toggle="tab" class="nav-link active" href="#tab-certs-check-expiration-0" role="tab" aria-controls="tab-certs-check-expiration-0" aria-selected="true">check-expiration</a></li>
	  </ul>
<div class="tab-content" id="tab-certs-check-expiration"><div id="tab-certs-check-expiration-0" class="tab-pane show active" role="tabpanel" aria-labelledby="tab-certs-check-expiration-0">

<p><h3 id="概要">概要</h3>
<!-- 
Checks expiration for the certificates in the local PKI managed by kubeadm.
-->
<p>检查 kubeadm 管理的本地 PKI 中证书的到期时间。</p>
<pre tabindex="0"><code>kubeadm certs check-expiration [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<!--
<td colspan="2">--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"</td> 
-->
<td colspan="2">--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值: "/etc/kubernetes/pki"</td>
</tr>
<tr>
<!--
<td></td><td style="line-height: 130%; word-wrap: break-word;">The path where to save the certificates</td>
-->
<td></td><td style="line-height: 130%; word-wrap: break-word;">保存证书的路径</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<!-- td></td><td style="line-height: 130%; word-wrap: break-word;">Path to a kubeadm configuration file.</td -->
<td></td><td style="line-height: 130%; word-wrap: break-word;">kubeadm 配置文件的路径</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<!-- td></td><td style="line-height: 130%; word-wrap: break-word;">help for check-expiration</td -->
<td></td><td style="line-height: 130%; word-wrap: break-word;">check-expiration 的帮助命令</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="继承于父命令的选项">继承于父命令的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<!-- td></td><td style="line-height: 130%; word-wrap: break-word;">[EXPERIMENTAL] The path to the 'real' host root filesystem.</td -->
<td></td><td style="line-height: 130%; word-wrap: break-word;">[实验] 到'真实'主机根文件系统的路径。</td>
</tr>
</tbody>
</table>
</div></div>

<h2 id="cmd-certs-generate-csr">kubeadm certs generate-csr</h2>
<!--
This command can be used to generate keys and CSRs for all control-plane certificates and kubeconfig files.
The user can then sign the CSRs with a CA of their choice.
-->
<p>此命令可用来为所有控制面证书和 kubeconfig 文件生成密钥和 CSR（签名请求）。
用户可以根据自身需要选择 CA 为 CSR 签名。</p>
<ul class="nav nav-tabs" id="tab-certs-generate-csr" role="tablist"><li class="nav-item"><a data-toggle="tab" class="nav-link active" href="#tab-certs-generate-csr-0" role="tab" aria-controls="tab-certs-generate-csr-0" aria-selected="true">generate-csr</a></li>
	  </ul>
<div class="tab-content" id="tab-certs-generate-csr"><div id="tab-certs-generate-csr-0" class="tab-pane show active" role="tabpanel" aria-labelledby="tab-certs-generate-csr-0">

<p><p>为运行控制平面所需的所有证书生成密钥和证书签名请求（CSR）。该命令会生成部分 kubeconfig 文件，
其中 &quot;users &gt; user &gt; client-key-data&quot; 字段包含私钥数据，并为每个 kubeconfig
文件创建一个随附的 &quot;.csr&quot; 文件。</p>
<!--  
This command is designed for use in [Kubeadm External CA Mode](https://kubernetes.io/docs/tasks/administer-cluster/kubeadm/kubeadm-certs/#external-ca-mode). It generates CSRs which you can then submit to your external certificate authority for signing.
-->
<p>此命令设计用于
<a href="https://kubernetes.io/zh/docs/tasks/administer-cluster/kubeadm/kubeadm-certs/#external-ca-mode">Kubeadm 外部 CA 模式</a>。 
它生成你可以提交给外部证书颁发机构进行签名的 CSR。</p>
<!--  
The PEM encoded signed certificates should then be saved alongside the key files, using ".crt" as the file extension, or in the case of kubeconfig files, the PEM encoded signed certificate should be base64 encoded and added to the kubeconfig file in the "users &gt; user &gt; client-certificate-data" field.
-->
<p>应使用 &quot;.crt&quot; 作为文件扩展名将 PEM 编码的签名证书与密钥文件一起保存。
或者，对于 kubeconfig 文件，PEM 编码的签名证书应使用 base64 编码，
并添加到 &quot;users &gt; user &gt; client-certificate-data&quot; 字段。</p>
<pre tabindex="0"><code>kubeadm certs generate-csr [flags]
</code></pre><!--
### Examples
-->
<h3 id="示例">示例</h3>
<!-- 
```
  # The following command will generate keys and CSRs for all control-plane certificates and kubeconfig files:
  kubeadm certs generate-csr --kubeconfig-dir /tmp/etc-k8s --cert-dir /tmp/etc-k8s/pki
```
-->
<pre tabindex="0"><code># 以下命令将为所有控制平面证书和 kubeconfig 文件生成密钥和 CSR :
kubeadm certs generate-csr --kubeconfig-dir /tmp/etc-k8s --cert-dir /tmp/etc-k8s/pki
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--cert-dir string</td>
</tr>
<tr>
<!-- td></td><td style="line-height: 130%; word-wrap: break-word;">The path where to save the certificates</td-->
<td></td><td style="line-height: 130%; word-wrap: break-word;">保存证书的路径</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<!-- td></td><td style="line-height: 130%; word-wrap: break-word;">Path to a kubeadm configuration file.</td -->
<td></td><td style="line-height: 130%; word-wrap: break-word;">kubeadm 配置文件的路径。</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<!-- td></td><td style="line-height: 130%; word-wrap: break-word;">help for generate-csr</td -->
<td></td><td style="line-height: 130%; word-wrap: break-word;">generate-csr 命令的帮助</td>
</tr>
<tr>
<!-- td colspan="2">-kubeconfig-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes"</td -->
<td colspan="2">--kubeconfig-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes"</td>
</tr>
<tr>
<!-- td></td><td style="line-height: 130%; word-wrap: break-word;">The path where to save the kubeconfig file.</td-->
<td></td><td style="line-height: 130%; word-wrap: break-word;">保存 kubeconfig 文件的路径。</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="继承于父命令的选项">继承于父命令的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<!-- <td></td><td style="line-height: 130%; word-wrap: break-word;">[EXPERIMENTAL] The path to the 'real' host root filesystem.</td> -->
<td></td><td style="line-height: 130%; word-wrap: break-word;">[实验] 到'真实'主机根文件系统的路径。</td>
</tr>
</tbody>
</table>
</div></div>

<h2 id="接下来">接下来</h2>
<!--
* [kubeadm init](/docs/reference/setup-tools/kubeadm/kubeadm-init/) to bootstrap a Kubernetes control-plane node
* [kubeadm join](/docs/reference/setup-tools/kubeadm/kubeadm-join/) to connect a node to the cluster
* [kubeadm reset](/docs/reference/setup-tools/kubeadm/kubeadm-reset/) to revert any changes made to this host by `kubeadm init` or `kubeadm join`
-->
<ul>
<li>用来启动引导 Kubernetes 控制面节点的
<a href="/zh/docs/reference/setup-tools/kubeadm/kubeadm-init/">kubeadm init</a>
命令</li>
<li>用来将节点连接到集群的
<a href="/zh/docs/reference/setup-tools/kubeadm/kubeadm-join/">kubeadm join</a>
命令</li>
<li>用来回滚 <code>kubeadm init</code> 或 <code>kubeadm join</code> 对当前主机所做修改的
<a href="/zh/docs/reference/setup-tools/kubeadm/kubeadm-reset/">kubeadm reset</a>
命令</li>
</ul>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-fbe8dcd222ce5795a5c325670a26b067">7.1.11 - kubeadm init phase</h1>
    
	<!--
title: kubeadm init phase
weight: 90
content_type: concept
-->
<!--
`kubeadm init phase` enables you to invoke atomic steps of the bootstrap process.
Hence, you can let kubeadm do some of the work and you can fill in the gaps
if you wish to apply customization.
-->
<p><code>kubeadm init phase</code> 能确保调用引导过程的原子步骤。
因此，如果希望自定义应用，则可以让 kubeadm 做一些工作，然后填补空白。</p>
<!--
`kubeadm init phase` is consistent with the [kubeadm init workflow](/docs/reference/setup-tools/kubeadm/kubeadm-init/#init-workflow),
and behind the scene both use the same code.
-->
<p><code>kubeadm init phase</code> 与 <a href="/zh/docs/reference/setup-tools/kubeadm/kubeadm-init/#init-workflow">kubeadm init 工作流</a>
一致，后台都使用相同的代码。</p>
<!--
## kubeadm init phase preflight {#cmd-phase-preflight}
-->
<h2 id="cmd-phase-preflight">kubeadm init phase preflight</h2>
<!--
Using this command you can execute preflight checks on a control-plane node.
-->
<p>使用此命令可以在控制平面节点上执行启动前检查。</p>
<ul class="nav nav-tabs" id="tab-preflight" role="tablist"><li class="nav-item"><a data-toggle="tab" class="nav-link active" href="#tab-preflight-0" role="tab" aria-controls="tab-preflight-0" aria-selected="true">preflight</a></li>
	  </ul>
<div class="tab-content" id="tab-preflight"><div id="tab-preflight-0" class="tab-pane show active" role="tabpanel" aria-labelledby="tab-preflight-0">

<p><h3 id="概要">概要</h3>
<!--
Run pre-flight checks for kubeadm init.
-->
<p>运行 kubeadm init 前的启动检查。</p>
<pre tabindex="0"><code>kubeadm init phase preflight [flags]
</code></pre><!--
### Examples
-->
<h3 id="案例">案例</h3>
<!--
# Run pre-flight checks for kubeadm init using a config file.
-->
<pre tabindex="0"><code># 使用配置文件对 kubeadm init 进行启动检查。
kubeadm init phase preflight --config kubeadm-config.yml
</code></pre><!-- 
### Options 
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to a kubeadm configuration file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for preflight
-->
preflight 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">--ignore-preflight-errors stringSlice</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
A list of checks whose errors will be shown as warnings. Example: 'IsPrivilegedUser,Swap'. Value 'all' ignores errors from all checks.
-->
错误将显示为警告的检查列表：例如：'IsPrivilegedUser,Swap'。取值为 'all' 时将忽略检查中的所有错误。
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="继承于父命令的选项">继承于父命令的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div></div>

<!--
## kubeadm init phase kubelet-start {#cmd-phase-kubelet-start}
-->
<h2 id="cmd-phase-kubelet-start">kubeadm init phase kubelet-start</h2>
<!--
This phase will write the kubelet configuration file and environment file and then start the kubelet.
-->
<p>此阶段将检查 kubelet 配置文件和环境文件，然后启动 kubelet。</p>
<ul class="nav nav-tabs" id="tab-kubelet-start" role="tablist"><li class="nav-item"><a data-toggle="tab" class="nav-link active" href="#tab-kubelet-start-0" role="tab" aria-controls="tab-kubelet-start-0" aria-selected="true">kubelet-start</a></li>
	  </ul>
<div class="tab-content" id="tab-kubelet-start"><div id="tab-kubelet-start-0" class="tab-pane show active" role="tabpanel" aria-labelledby="tab-kubelet-start-0">

<p><h3 id="概要">概要</h3>
<!--
Write a file with KubeletConfiguration and an environment file with node specific kubelet settings, and then (re)start kubelet.
-->
<p>使用 kubelet 配置文件编写一个文件，并使用特定节点的 kubelet 设置编写一个环境文件，然后（重新）启动 kubelet。</p>
<pre tabindex="0"><code>kubeadm init phase kubelet-start [flags]
</code></pre><!--
### Examples
-->
<h3 id="示例">示例</h3>
<!--
# Writes a dynamic environment file with kubelet flags from a InitConfiguration file.
-->
<pre tabindex="0"><code># 从 InitConfiguration 文件中写入带有 kubelet 参数的动态环境文件。
kubeadm init phase kubelet-start --config config.yaml
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to a kubeadm configuration file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">--cri-socket string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to the CRI socket to connect. If empty kubeadm will try to auto-detect this value; use this option only if you have more than one CRI installed or if you have non-standard CRI socket.
-->
连接到 CRI 套接字的路径。如果为空，则 kubeadm 将尝试自动检测该值；仅当安装了多个 CRI 或具有非标准 CRI 套接字时，才使用此选项。
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for kubelet-start
-->
kubelet-start 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">--node-name string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Specify the node name.
-->
指定节点名称。
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div></div>

<!--
## kubeadm init phase certs {#cmd-phase-certs}
-->
<h2 id="cmd-phase-certs">kubeadm init phase certs</h2>
<!--
Can be used to create all required certificates by kubeadm.
-->
<p>该阶段可用于创建 kubeadm 所需的所有证书。</p>
<ul class="nav nav-tabs" id="tab-certs" role="tablist"><li class="nav-item"><a data-toggle="tab" class="nav-link active" href="#tab-certs-0" role="tab" aria-controls="tab-certs-0" aria-selected="true">certs</a></li>
	  
		<li class="nav-item"><a data-toggle="tab" class="nav-link" href="#tab-certs-1" role="tab" aria-controls="tab-certs-1">all</a></li>
		<li class="nav-item"><a data-toggle="tab" class="nav-link" href="#tab-certs-2" role="tab" aria-controls="tab-certs-2">ca</a></li>
		<li class="nav-item"><a data-toggle="tab" class="nav-link" href="#tab-certs-3" role="tab" aria-controls="tab-certs-3">apiserver</a></li>
		<li class="nav-item"><a data-toggle="tab" class="nav-link" href="#tab-certs-4" role="tab" aria-controls="tab-certs-4">apiserver-kubelet-client</a></li>
		<li class="nav-item"><a data-toggle="tab" class="nav-link" href="#tab-certs-5" role="tab" aria-controls="tab-certs-5">front-proxy-ca</a></li>
		<li class="nav-item"><a data-toggle="tab" class="nav-link" href="#tab-certs-6" role="tab" aria-controls="tab-certs-6">front-proxy-client</a></li>
		<li class="nav-item"><a data-toggle="tab" class="nav-link" href="#tab-certs-7" role="tab" aria-controls="tab-certs-7">etcd-ca</a></li>
		<li class="nav-item"><a data-toggle="tab" class="nav-link" href="#tab-certs-8" role="tab" aria-controls="tab-certs-8">etcd-server</a></li>
		<li class="nav-item"><a data-toggle="tab" class="nav-link" href="#tab-certs-9" role="tab" aria-controls="tab-certs-9">etcd-peer</a></li>
		<li class="nav-item"><a data-toggle="tab" class="nav-link" href="#tab-certs-10" role="tab" aria-controls="tab-certs-10">healthcheck-client</a></li>
		<li class="nav-item"><a data-toggle="tab" class="nav-link" href="#tab-certs-11" role="tab" aria-controls="tab-certs-11">apiserver-etcd-client</a></li>
		<li class="nav-item"><a data-toggle="tab" class="nav-link" href="#tab-certs-12" role="tab" aria-controls="tab-certs-12">sa</a></li></ul>
<div class="tab-content" id="tab-certs"><div id="tab-certs-0" class="tab-pane show active" role="tabpanel" aria-labelledby="tab-certs-0">

<p><h3 id="概要">概要</h3>
<!--
This command is not meant to be run on its own. See list of available subcommands.
-->
<p>此命令并非设计用来单独运行。请参阅可用子命令列表。</p>
<pre tabindex="0"><code>kubeadm init phase certs [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for certs
-->
certs 操作的帮助命令
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父指令中继承的选项">从父指令中继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
  <div id="tab-certs-1" class="tab-pane" role="tabpanel" aria-labelledby="tab-certs-1">

<p><h3 id="概要">概要</h3>
<!--
Generate all certificates
-->
<p>生成所有证书</p>
<pre tabindex="0"><code>kubeadm init phase certs all [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--apiserver-advertise-address string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The IP address the API Server will advertise it's listening on. If not set the default network interface will be used.
-->
API 服务器所公布的其正在监听的 IP 地址。如果未设置，将使用默认网络接口。
</td>
</tr>
<tr>
<td colspan="2">--apiserver-cert-extra-sans stringSlice</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Optional extra Subject Alternative Names (SANs) to use for the API Server serving certificate. Can be both IP addresses and DNS names.
-->
用于 API 服务器服务证书的可选额外替代名称（SAN）。可以同时使用 IP 地址和 DNS 名称。
</td>
</tr>
<tr>
<td colspan="2">
<!--
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"
-->
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The path where to save and store the certificates.
-->
证书的存储路径。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to a kubeadm configuration file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">--control-plane-endpoint string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Specify a stable IP address or DNS name for the control plane.
-->
为控制平面指定一个稳定的 IP 地址或 DNS 名称。
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for all
-->
all 操作的帮助命令 
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "stable-1"
-->
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Choose a specific Kubernetes version for the control plane.
-->
为控制平面选择特定的 Kubernetes 版本。
</td>
</tr>
<tr>
<td colspan="2">
<!--
--service-cidr string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "10.96.0.0/12"
-->
--service-cidr string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："10.96.0.0/12"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Use alternative range of IP address for service VIPs.
-->
VIP 服务使用其它的 IP 地址范围。
</td>
</tr>
<tr>
<td colspan="2">
<!--
--service-dns-domain string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "cluster.local"
-->
--service-dns-domain string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："cluster.local"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Use alternative domain for services, e.g. "myorg.internal".
-->
服务使用其它的域名，例如："myorg.internal"。
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="继承于父命令的选项">继承于父命令的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
  <div id="tab-certs-2" class="tab-pane" role="tabpanel" aria-labelledby="tab-certs-2">

<p><h3 id="概要">概要</h3>
<!--
Generate the self-signed Kubernetes CA to provision identities for other Kubernetes components, and save them into ca.cert and ca.key files.
-->
<p>生成自签名的 Kubernetes CA 以提供其他 Kubernetes 组件的身份，并将其保存到 ca.cert 和 ca.key 文件中。</p>
<!--
If both files already exist, kubeadm skips the generation step and existing files will be used.
-->
<p>如果两个文件都已存在，则 kubeadm 将跳过生成步骤，使用现有文件。</p>
<!--
Alpha Disclaimer: this command is currently alpha.
-->
<p>Alpha 免责声明：此命令当前为 Alpha 功能。</p>
<pre tabindex="0"><code>kubeadm init phase certs ca [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">
<!--
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"
-->
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The path where to save and store the certificates.
-->
证书的存储路径。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to a kubeadm configuration file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for ca
-->
ca 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "stable-1"
-->
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Choose a specific Kubernetes version for the control plane.
-->
为控制平面选择特定的 Kubernetes 版本。
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="继承于父命令的选项">继承于父命令的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</td>
</tr>
</tbody>
</table>
</div>
  <div id="tab-certs-3" class="tab-pane" role="tabpanel" aria-labelledby="tab-certs-3">

<p><h3 id="概要">概要</h3>
<!--
Generate the certificate for serving the Kubernetes API, and save them into apiserver.cert and apiserver.key files.
-->
<p>生成用于服务 Kubernetes API 的证书，并将其保存到 apiserver.cert 和 apiserver.key 文件中。</p>
<!--
Default SANs are kubernetes, kubernetes.default, kubernetes.default.svc, kubernetes.default.svc.cluster.local, 10.96.0.1, 127.0.0.1
-->
<p>默认 SAN 是 kubernetes、kubernetes.default、kubernetes.default.svc、kubernetes.default.svc.cluster.local、10.96.0.1、127.0.0.1。</p>
<!--
If both files already exist, kubeadm skips the generation step and existing files will be used.
-->
<p>如果两个文件都已存在，则 kubeadm 将跳过生成步骤，使用现有文件。</p>
<!--
Alpha Disclaimer: this command is currently alpha.
-->
<p>Alpha 免责声明：此命令当前为 Alpha 功能。</p>
<pre tabindex="0"><code>kubeadm init phase certs apiserver [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--apiserver-advertise-address string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The IP address the API Server will advertise it's listening on. If not set the default network interface will be used.
-->
API 服务器所公布的其正在监听的 IP 地址。如果未设置，则使用默认的网络接口。
</td>
</tr>
<tr>
<td colspan="2">--apiserver-cert-extra-sans stringSlice</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Optional extra Subject Alternative Names (SANs) to use for the API Server serving certificate. Can be both IP addresses and DNS names.
-->
用于 API Server 服务证书的可选附加主体备用名称（SAN）。可以是 IP 地址和 DNS 名称。
</td>
</tr>
<tr>
<td colspan="2">
<!--
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"
-->
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The path where to save and store the certificates.
-->
证书的存储路径。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to a kubeadm configuration file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">--control-plane-endpoint string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Specify a stable IP address or DNS name for the control plane.
-->
为控制平面指定一个稳定的 IP 地址或 DNS 名称。
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for apiserver
-->
apiserver 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "stable-1"
-->
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Choose a specific Kubernetes version for the control plane.
-->
为控制平面指定特定的 Kubernetes 版本。
</td>
</tr>
<tr>
<td colspan="2">
<!--
--service-cidr string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "10.96.0.0/12"
-->
--service-cidr string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："10.96.0.0/12"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Use alternative range of IP address for service VIPs.
-->
指定服务 VIP 可使用的其他 IP 地址段。
</td>
</tr>
<tr>
<td colspan="2">
<!--
--service-dns-domain string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "cluster.local"
-->
--service-dns-domain string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："cluster.local"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Use alternative domain for services, e.g. "myorg.internal".
-->
为服务使用其他域名，例如 "myorg.internal"。
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="继承于父命令的选项">继承于父命令的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
  <div id="tab-certs-4" class="tab-pane" role="tabpanel" aria-labelledby="tab-certs-4">

<p><h3 id="概要">概要</h3>
<!--
Generate the certificate for the API server to connect to kubelet, and save them into apiserver-kubelet-client.cert and apiserver-kubelet-client.key files.
-->
<p>生成供 API 服务器连接 kubelet 的证书，并将其保存到 apiserver-kubelet-client.cert 和 apiserver-kubelet-client.key 文件中。</p>
<!--
If both files already exist, kubeadm skips the generation step and existing files will be used.
-->
<p>如果两个文件都已存在，则 kubeadm 将跳过生成步骤，使用现有文件。</p>
<!--
Alpha Disclaimer: this command is currently alpha.
-->
<p>Alpha 免责声明：此命令当前为 Alpha 功能。</p>
<pre tabindex="0"><code>kubeadm init phase certs apiserver-kubelet-client [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">
<!--
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"
-->
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The path where to save and store the certificates.
-->
存储证书的路径。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to a kubeadm configuration file.
-->
kubeadm 配置文件路径。
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for apiserver-kubelet-client
-->
apiserver-kubelet-client 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "stable-1"
-->
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Choose a specific Kubernetes version for the control plane.
-->
为控制平面指定特定的 Kubernetes 版本。
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="继承于父命令的选项">继承于父命令的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 指向宿主机上的 '实际' 根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
  <div id="tab-certs-5" class="tab-pane" role="tabpanel" aria-labelledby="tab-certs-5">

<p><h3 id="概要">概要</h3>
<!--
Generate the self-signed CA to provision identities for front proxy, and save them into front-proxy-ca.cert and front-proxy-ca.key files.
-->
<p>生成自签名 CA 来提供前端代理的身份，并将其保存到 front-proxy-ca.cert 和 front-proxy-ca.key 文件中。</p>
<!--
If both files already exist, kubeadm skips the generation step and existing files will be used.
-->
<p>如果两个文件都已存在，kubeadm 将跳过生成步骤并将使用现有文件。</p>
<!--
Alpha Disclaimer: this command is currently alpha.
-->
<p>Alpha 免责声明：此命令目前是 alpha 阶段。</p>
<pre tabindex="0"><code>kubeadm init phase certs front-proxy-ca [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">
<!--
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"
-->
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The path where to save and store the certificates.
-->
存储证书的路径。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to a kubeadm configuration file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for front-proxy-ca
-->
front-proxy-ca 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "stable-1"
-->
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Choose a specific Kubernetes version for the control plane.
-->
为控制平面选择特定的 Kubernetes 版本。
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
  <div id="tab-certs-6" class="tab-pane" role="tabpanel" aria-labelledby="tab-certs-6">

<p><h3 id="概要">概要</h3>
<!--
Generate the certificate for the front proxy client, and save them into front-proxy-client.cert and front-proxy-client.key files.
If both files already exist, kubeadm skips the generation step and existing files will be used.
Alpha Disclaimer: this command is currently alpha.
-->
<p>为前端代理客户端生成证书，并将其保存到 front-proxy-client.cert 和 front-proxy-client.key 文件中。
如果两个文件都已存在，kubeadm 将跳过生成步骤并将使用现有文件。
Alpha 免责声明：此命令目前是 alpha 阶段。</p>
<pre tabindex="0"><code>kubeadm init phase certs front-proxy-client [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">
<!--
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"
-->
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认："/etc/kubernetes/pki"</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The path where to save and store the certificates.
-->
存储证书的路径。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to a kubeadm configuration file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for front-proxy-client
-->
front-proxy-client 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "stable-1"
-->
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Choose a specific Kubernetes version for the control plane.
-->
为控制平面选择特定的 Kubernetes 版本。
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
  <div id="tab-certs-7" class="tab-pane" role="tabpanel" aria-labelledby="tab-certs-7">

<p><h3 id="概要">概要</h3>
<!--
Generate the self-signed CA to provision identities for etcd, and save them into etcd/ca.cert and etcd/ca.key files.
-->
<p>生成用于为 etcd 设置身份的自签名 CA，并将其保存到 etcd/ca.cert 和 etcd/ca.key 文件中。</p>
<!--
If both files already exist, kubeadm skips the generation step and existing files will be used.
-->
<p>如果两个文件都已存在，则 kubeadm 将跳过生成步骤，使用现有文件。</p>
<!--
Alpha Disclaimer: this command is currently alpha.
-->
<p>Alpha 免责声明：此命令当前为 Alpha 功能。</p>
<pre tabindex="0"><code>kubeadm init phase certs etcd-ca [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">
<!--
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"
-->
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The path where to save and store the certificates.
-->
证书的存储路径。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to a kubeadm configuration file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for etcd-ca
-->
etcd-ca 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "stable-1"
-->
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Choose a specific Kubernetes version for the control plane.
-->
为控制平面选择特定的 Kubernetes 版本。
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="继承于父命令的选项">继承于父命令的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
  <div id="tab-certs-8" class="tab-pane" role="tabpanel" aria-labelledby="tab-certs-8">

<p><h3 id="概要">概要</h3>
<!--
Generate the certificate for serving etcd, and save them into etcd/server.cert and etcd/server.key files.
-->
<p>生成用于提供 etcd 服务的证书，并将其保存到 etcd/server.cert 和 etcd/server.key 文件中。</p>
<!--
Default SANs are localhost, 127.0.0.1, 127.0.0.1, ::1
-->
<p>默认 SAN 为 localhost、127.0.0.1、127.0.0.1、:: 1</p>
<!--
If both files already exist, kubeadm skips the generation step and existing files will be used.
-->
<p>如果两个文件都已存在，则 kubeadm 将跳过生成步骤，使用现有文件。</p>
<!--
Alpha Disclaimer: this command is currently alpha.
-->
<p>Alpha 免责声明：此命令当前为 alpha 功能。</p>
<pre tabindex="0"><code>kubeadm init phase certs etcd-server [flags]
</code></pre><!-- 
### Options 
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">
<!--
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"
-->
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The path where to save and store the certificates.
-->
保存和存储证书的路径。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to kubeadm configuration file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for etcd-server
-->
etcd-server 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "stable-1"
-->
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Choose a specific Kubernetes version for the control plane.
-->
为控制平面指定特定的 Kubernetes 版本。
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="继承于父命令的选项">继承于父命令的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
  <div id="tab-certs-9" class="tab-pane" role="tabpanel" aria-labelledby="tab-certs-9">

<p><h3 id="概要">概要</h3>
<!--
Generate the certificate for etcd nodes to communicate with each other, and save them into etcd/peer.cert and etcd/peer.key files.
-->
<p>生成 etcd 节点相互通信的证书，并将其保存到 etcd/peer.cert 和 etcd/peer.key 文件中。</p>
<!--
Default SANs are localhost, 127.0.0.1, 127.0.0.1, ::1
-->
<p>默认 SAN 为 localhost、127.0.0.1、127.0.0.1、:: 1</p>
<!--
If both files already exist, kubeadm skips the generation step and existing files will be used.
-->
<p>如果两个文件都已存在，则 kubeadm 将跳过生成步骤，使用现有文件。</p>
<!--
Alpha Disclaimer: this command is currently alpha.
-->
<p>Alpha 免责声明：此命令当前为 alpha 功能。</p>
<pre tabindex="0"><code>kubeadm init phase certs etcd-peer [flags]
</code></pre><!-- 
### Options 
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">
<!--
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"
-->
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- The path where to save and store the certificates.  -->
保存和存储证书的路径。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- Path to kubeadm configuration file.  -->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- help for etcd-peer -->
etcd-peer 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "stable-1"
-->
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- Choose a specific Kubernetes version for the control plane.  -->
为控制平面指定特定的 Kubernetes 版本。
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="继承于父命令的选项">继承于父命令的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
  <div id="tab-certs-10" class="tab-pane" role="tabpanel" aria-labelledby="tab-certs-10">

<p><h3 id="概要">概要</h3>
<!--
Generate the certificate for liveness probes to healthcheck etcd, and save them into etcd/healthcheck-client.cert and etcd/healthcheck-client.key files.
-->
<p>生成用于 etcd 健康检查的活跃性探针的证书，并将其保存到 healthcheck-client.cert 和 etcd/healthcheck-client.key 文件中。</p>
<!--
If both files already exist, kubeadm skips the generation step and existing files will be used.
-->
<p>如果两个文件都已存在，则 kubeadm 将跳过生成步骤，使用现有文件。</p>
<!--
Alpha Disclaimer: this command is currently alpha.
-->
<p>Alpha 免责声明：此命令当前为 alpha 功能。</p>
<pre tabindex="0"><code>kubeadm init phase certs etcd-healthcheck-client [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">
<!--
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"
-->
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The path where to save and store the certificates.
-->
证书存储的路径。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to a kubeadm configuration file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for etcd-healthcheck-client
-->
etcd-healthcheck-client 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "stable-1"
-->
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Choose a specific Kubernetes version for the control plane.
-->
为控制平面选择特定的 Kubernetes 版本。
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="继承于父命令的选项">继承于父命令的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
  <div id="tab-certs-11" class="tab-pane" role="tabpanel" aria-labelledby="tab-certs-11">

<p><h3 id="概要">概要</h3>
<!--
Generate the certificate the apiserver uses to access etcd, and save them into apiserver-etcd-client.cert and apiserver-etcd-client.key files.
-->
<p>生成 apiserver 用于访问 etcd 的证书，并将其保存到 apiserver-etcd-client.cert 和 apiserver-etcd-client.key 文件中。</p>
<!--
If both files already exist, kubeadm skips the generation step and existing files will be used.
-->
<p>如果两个文件都已存在，则 kubeadm 将跳过生成步骤，使用现有文件。</p>
<!--
Alpha Disclaimer: this command is currently alpha.
-->
<p>Alpha 免责声明：此命令当前为 Alpha 功能。</p>
<pre tabindex="0"><code>kubeadm init phase certs apiserver-etcd-client [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">
<!--
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"
-->
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- The path where to save and store the certificates.  -->
证书的存储路径。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- Path to a kubeadm configuration file.  -->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- help for apiserver-etcd-client -->
apiserver-etcd-client 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">
<!-- kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "stable-1" -->
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Choose a specific Kubernetes version for the control plane.
-->
为控制平面指定特定的 Kubernetes 版本。
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="继承于父命令的选项">继承于父命令的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- [EXPERIMENTAL] The path to the 'real' host root filesystem. -->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
  <div id="tab-certs-12" class="tab-pane" role="tabpanel" aria-labelledby="tab-certs-12">

<p><h3 id="概要">概要</h3>
<!--
Generate the private key for signing service account tokens along with its public key, and save them into sa.key and sa.pub files. If both files already exist, kubeadm skips the generation step and existing files will be used.
-->
<p>生成用于签名 service account 令牌的私钥及其公钥，并将其保存到 sa.key 和 sa.pub 文件中。如果两个文件都已存在，则 kubeadm 会跳过生成步骤，而将使用现有文件。</p>
<!--
Alpha Disclaimer: this command is currently alpha.
-->
<p>Alpha 免责声明：此命令当前为 alpha 阶段。</p>
<pre tabindex="0"><code>kubeadm init phase certs sa [flags]
</code></pre><!-- ### Options -->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">
<!--
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"
-->
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The path where to save and store the certificates.
-->
保存和存储证书的路径。
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for sa
-->
sa 操作的帮助命令
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="继承于父命令的选项">继承于父命令的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div></div>

<!--
## kubeadm init phase kubeconfig {#cmd-phase-kubeconfig}
-->
<h2 id="cmd-phase-kubeconfig">kubeadm init phase kubeconfig</h2>
<!--
You can create all required kubeconfig files by calling the `all` subcommand or call them individually.
-->
<p>可以通过调用 <code>all</code> 子命令来创建所有必需的 kubeconfig 文件，或者分别调用它们。</p>
<ul class="nav nav-tabs" id="tab-kubeconfig" role="tablist"><li class="nav-item"><a data-toggle="tab" class="nav-link active" href="#tab-kubeconfig-0" role="tab" aria-controls="tab-kubeconfig-0" aria-selected="true">kubeconfig</a></li>
	  
		<li class="nav-item"><a data-toggle="tab" class="nav-link" href="#tab-kubeconfig-1" role="tab" aria-controls="tab-kubeconfig-1">all</a></li>
		<li class="nav-item"><a data-toggle="tab" class="nav-link" href="#tab-kubeconfig-2" role="tab" aria-controls="tab-kubeconfig-2">admin</a></li>
		<li class="nav-item"><a data-toggle="tab" class="nav-link" href="#tab-kubeconfig-3" role="tab" aria-controls="tab-kubeconfig-3">kubelet</a></li>
		<li class="nav-item"><a data-toggle="tab" class="nav-link" href="#tab-kubeconfig-4" role="tab" aria-controls="tab-kubeconfig-4">controller-manager</a></li>
		<li class="nav-item"><a data-toggle="tab" class="nav-link" href="#tab-kubeconfig-5" role="tab" aria-controls="tab-kubeconfig-5">scheduler</a></li></ul>
<div class="tab-content" id="tab-kubeconfig"><div id="tab-kubeconfig-0" class="tab-pane show active" role="tabpanel" aria-labelledby="tab-kubeconfig-0">

<p><h3 id="概要">概要</h3>
<!-- 
This command is not meant to be run on its own. See list of available subcommands. 
-->
<p>此命令并非设计用来单独运行。请阅读可用子命令列表。</p>
<pre tabindex="0"><code>kubeadm init phase kubeconfig [flags]
</code></pre><!-- 
### Options 
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for kubeconfig
-->
kubeconfig 操作的帮助命令
</td>
</tr>
</tbody>
</table>
<!-- 
### Options inherited from parent commands 
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
  <div id="tab-kubeconfig-1" class="tab-pane" role="tabpanel" aria-labelledby="tab-kubeconfig-1">

<p><h3 id="概要">概要</h3>
<!--
Generate all kubeconfig files
-->
<p>生成所有 kubeconfig 文件</p>
<pre tabindex="0"><code>kubeadm init phase kubeconfig all [flags]
</code></pre><!-- 
### Options 
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--apiserver-advertise-address string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The IP address the API Server will advertise it's listening on. If not set the default network interface will be used.
-->
API 服务器所公布的其正在监听的 IP 地址。如果没有设置，将使用默认的网络接口。
</td>
</tr>
<tr>
<td colspan="2">
<!--
--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;default: 6443
-->
--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：6443
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Port for the API Server to bind to.
-->
要绑定到 API 服务器的端口。
</td>
</tr>
<tr>
<td colspan="2">
<!--
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"
-->
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The path where to save and store the certificates.
-->
保存和存储证书的路径。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to kubeadm configuration file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">--control-plane-endpoint string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Specify a stable IP address or DNS name for the control plane.
-->
为控制平面指定一个稳定的 IP 地址或 DNS 名称。
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for all
-->
all 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubeconfig-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes"
-->
--kubeconfig-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The path where to save the kubeconfig file.
-->
kubeconfig 文件的保存路径。
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "stable-1"
-->
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Choose a specific Kubernetes version for the control plane.
-->
为控制平面指定特定的 Kubernetes 版本。
</td>
</tr>
<tr>
<td colspan="2">--node-name string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Specify the node name.
-->
指定节点名称。
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="继承于父命令的选项">继承于父命令的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
  <div id="tab-kubeconfig-2" class="tab-pane" role="tabpanel" aria-labelledby="tab-kubeconfig-2">

<p><h3 id="概要">概要</h3>
<!--
Generate the kubeconfig file for the admin and for kubeadm itself, and save it to admin.conf file.
-->
<p>为管理员和 kubeadm 本身生成 kubeconfig 文件，并将其保存到 admin.conf 文件中。</p>
<pre tabindex="0"><code>kubeadm init phase kubeconfig admin [flags]
</code></pre><!-- 
### Options 
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--apiserver-advertise-address string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The IP address the API Server will advertise it's listening on. If not set the default network interface will be used.
-->
API 服务器所公布的其正在监听的 IP 地址。如果未设置，则使用默认的网络接口。
</td>
</tr>
<tr>
<td colspan="2">
<!--
--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;default: 6443
-->
--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：6443
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Port for the API Server to bind to.
-->
要绑定到 API 服务器的端口。
</td>
</tr>
<tr>
<td colspan="2">
<!--
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"
-->
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The path where to save and store the certificates.
-->
保存和存储证书的路径。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to kubeadm configuration file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">--control-plane-endpoint string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Specify a stable IP address or DNS name for the control plane.
-->
为控制平面指定一个稳定的 IP 地址或 DNS 名称。
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for admin
-->
admin 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubeconfig-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes"
-->
--kubeconfig-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The path where to save the kubeconfig file.
-->
kubeconfig 文件的保存路径。
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "stable-1"
-->
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Choose a specific Kubernetes version for the control plane.
-->
为控制平面指定特定的 Kubernetes 版本。
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="继承于父命令的选项">继承于父命令的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
  <div id="tab-kubeconfig-3" class="tab-pane" role="tabpanel" aria-labelledby="tab-kubeconfig-3">

<p><h3 id="概要">概要</h3>
<!--
Generate the kubeconfig file for the kubelet to use and save it to kubelet.conf file.
-->
<p>生成 kubelet 要使用的 kubeconfig 文件，并将其保存到 kubelet.conf 文件。</p>
<!--
Please note that this should *only* be used for cluster bootstrapping purposes. After your control plane is up, you should request all kubelet credentials from the CSR API.
-->
<p>请注意，该操作目的是<em>仅</em>应用于引导集群。在控制平面启动之后，应该从 CSR API 请求所有 kubelet 凭据。</p>
<pre tabindex="0"><code>kubeadm init phase kubeconfig kubelet [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--apiserver-advertise-address string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The IP address the API Server will advertise it's listening on. If not set the default network interface will be used.
-->
API 服务器所公布的其正在监听的 IP 地址。如果未设置，则使用默认的网络接口。
</td>
</tr>
<tr>
<td colspan="2">
<!--
--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;default: 6443
-->
--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：6443
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Port for the API Server to bind to.
-->
要绑定到 API 服务器的端口。
</td>
</tr>
<tr>
<td colspan="2">
<!--
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"
-->
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The path where to save and store the certificates.
-->
保存和存储证书的路径。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to kubeadm configuration file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">--control-plane-endpoint string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Specify a stable IP address or DNS name for the control plane.
-->
为控制平面指定一个稳定的 IP 地址或 DNS 名称。
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for kubelet
-->
kubelet 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubeconfig-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes"
-->
--kubeconfig-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The path where to save the kubeconfig file.
-->
kubeconfig 文件的保存路径。
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "stable-1"
-->
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Choose a specific Kubernetes version for the control plane.
-->
为控制平面选择特定的 Kubernetes 版本。
</td>
</tr>
<tr>
<td colspan="2">--node-name string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Specify the node name.
-->
指定节点的名称。
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="继承于父命令的选项">继承于父命令的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
  <div id="tab-kubeconfig-4" class="tab-pane" role="tabpanel" aria-labelledby="tab-kubeconfig-4">

<p><h3 id="概要">概要</h3>
<!--
Generate the kubeconfig file for the controller manager to use and save it to controller-manager.conf file
-->
<p>生成控制器管理器要使用的 kubeconfig 文件，并保存到 controller-manager.conf 文件中。</p>
<pre tabindex="0"><code>kubeadm init phase kubeconfig controller-manager [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--apiserver-advertise-address string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The IP address the API Server will advertise it's listening on. If not set the default network interface will be used.
-->
API 服务器所公布的其正在监听的 IP 地址。如果未设置，则使用默认的网络接口。
</td>
</tr>
<tr>
<td colspan="2">
<!--
--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;default: 6443
-->
--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：6443
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Port for the API Server to bind to.
-->
要绑定到 API 服务器的端口。
</td>
</tr>
<tr>
<td colspan="2">
<!--
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"
-->
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The path where to save and store the certificates.
-->
保存和存储证书的路径。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to kubeadm configuration file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">--control-plane-endpoint string</td>
</tr>
</tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Specify a stable IP address or DNS name for the control plane.
-->
为控制平面指定一个稳定的 IP 地址或 DNS 名称。
</td>
</tr>    
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;"> 
<!--
help for controller-manager
-->
controller-manager 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubeconfig-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes"
-->
--kubeconfig-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The path where to save the kubeconfig file.
-->
kubeconfig 文件的保存路径。
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "stable-1"
-->
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Choose a specific Kubernetes version for the control plane.
-->
为控制平面指定特定的 Kubernetes 版本。
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="继承于父命令的选项">继承于父命令的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs 字符串</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
  <div id="tab-kubeconfig-5" class="tab-pane" role="tabpanel" aria-labelledby="tab-kubeconfig-5">

<p><h3 id="概要">概要</h3>
<!--
Generate the kubeconfig file for the scheduler to use and save it to scheduler.conf file.
-->
<p>生成调度器（scheduler）要使用的 kubeconfig 文件，并保存到 scheduler.conf 文件中。</p>
<pre tabindex="0"><code>kubeadm init phase kubeconfig scheduler [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--apiserver-advertise-address string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The IP address the API Server will advertise it's listening on. If not set the default network interface will be used.
-->
API 服务器所公布的其正在监听的 IP 地址。如果未设置，则使用默认的网络接口。
</td>
</tr>
<tr>
<td colspan="2">
<!--
--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;default: 6443
-->
--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：6443
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Port for the API Server to bind to.
-->
要绑定到 API 服务器的端口。
</td>
</tr>
<tr>
<td colspan="2">
<!--
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"
-->
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The path where to save and store the certificates.
-->
保存和存储证书的路径。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to kubeadm configuration file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">--control-plane-endpoint string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Specify a stable IP address or DNS name for the control plane.
-->
为控制平面指定一个稳定的 IP 地址或 DNS 名称。
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for scheduler
-->
scheduler 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubeconfig-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes"
-->
--kubeconfig-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The path where to save the kubeconfig file.
-->
kubeconfig 文件的保存路径。
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "stable-1"
-->
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Choose a specific Kubernetes version for the control plane.
-->
为控制平面指定特定的 Kubernetes 版本。
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="继承于父命令的选项">继承于父命令的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div></div>

<!--
## kubeadm init phase control-plane {#cmd-phase-control-plane}
-->
<h2 id="cmd-phase-control-plane">kubeadm init phase control-plane</h2>
<!--
Using this phase you can create all required static Pod files for the control plane components.
-->
<p>使用此阶段，可以为控制平面组件创建所有必需的静态 Pod 文件。</p>
<ul class="nav nav-tabs" id="tab-control-plane" role="tablist"><li class="nav-item"><a data-toggle="tab" class="nav-link active" href="#tab-control-plane-0" role="tab" aria-controls="tab-control-plane-0" aria-selected="true">control-plane</a></li>
	  
		<li class="nav-item"><a data-toggle="tab" class="nav-link" href="#tab-control-plane-1" role="tab" aria-controls="tab-control-plane-1">all</a></li>
		<li class="nav-item"><a data-toggle="tab" class="nav-link" href="#tab-control-plane-2" role="tab" aria-controls="tab-control-plane-2">apiserver</a></li>
		<li class="nav-item"><a data-toggle="tab" class="nav-link" href="#tab-control-plane-3" role="tab" aria-controls="tab-control-plane-3">controller-manager</a></li>
		<li class="nav-item"><a data-toggle="tab" class="nav-link" href="#tab-control-plane-4" role="tab" aria-controls="tab-control-plane-4">scheduler</a></li></ul>
<div class="tab-content" id="tab-control-plane"><div id="tab-control-plane-0" class="tab-pane show active" role="tabpanel" aria-labelledby="tab-control-plane-0">

<p><h3 id="概要">概要</h3>
<!--
This command is not meant to be run on its own. See list of available subcommands.
-->
<p>此命令并非设计用来单独运行。请参阅可用子命令列表。</p>
<pre tabindex="0"><code>kubeadm init phase control-plane [flags]
</code></pre><!-- 
### Options 
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- help for control-plane -->
control-plane 操作的帮助命令
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="继承于父命令的选项">继承于父命令的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- [EXPERIMENTAL] The path to the 'real' host root filesystem.  -->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</td>
</tr>
</tbody>
</table>
</div>
  <div id="tab-control-plane-1" class="tab-pane" role="tabpanel" aria-labelledby="tab-control-plane-1">

<p><h3 id="概要">概要</h3>
<!--
Generate all static Pod manifest files
-->
<p>生成所有的静态 Pod 清单文件</p>
<pre tabindex="0"><code>kubeadm init phase control-plane all [flags]
</code></pre><!--
### Examples


```
# Generates all static Pod manifest files for control plane components,
# functionally equivalent to what is generated by kubeadm init.
# Generates all static Pod manifest files using options read from a configuration file.
```
-->
<h3 id="示例">示例</h3>
<pre tabindex="0"><code># 为控制平面组件生成静态 Pod 清单文件，其功能等效于 kubeadm init 生成的文件。
kubeadm init phase control-plane all

# 使用从某配置文件中读取的选项为生成静态 Pod 清单文件。
kubeadm init phase control-plane all --config config.yaml
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--apiserver-advertise-address string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The IP address the API Server will advertise it's listening on. If not set the default network interface will be used.
-->
API 服务器所公布的其正在监听的 IP 地址。如果未设置，将使用默认的网络接口。
</td>
</tr>
<tr>
<!-- td colspan="2">--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: 6443</td -->
<td colspan="2">--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：6443</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Port for the API Server to bind to.
-->
API 服务器要绑定的端口。
</td>
</tr>
<tr>
<td colspan="2">--apiserver-extra-args mapStringString</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
A set of extra flags to pass to the API Server or override default ones in form of &lt;flagname&gt;=&lt;value&gt;
-->
形式为 &lt;flagname&gt;=&lt;value&gt; 的一组额外参数，用来传递给 API 服务器，
或者覆盖其默认配置值
</td>
</tr>
<tr>
<td colspan="2">
<!--
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"
-->
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The path where to save and store the certificates.
-->
存储证书的路径。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to a kubeadm configuration file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">--control-plane-endpoint string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Specify a stable IP address or DNS name for the control plane.
-->
为控制平面选择一个稳定的 IP 地址或者 DNS 名称。
</td>
</tr>
<tr>
<td colspan="2">--controller-manager-extra-args mapStringString</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
A set of extra flags to pass to the Controller Manager or override default ones in form of &lt;flagname&gt;=&lt;value&gt;
-->
一组形式为 &lt;flagname&gt;=&lt;value&gt; 的额外参数，用来传递给控制管理器（Controller Manager）
或覆盖其默认设置值
</td>
</tr>
<tr>
<td colspan="2">--experimental-patches string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to a directory that contains files named "target[suffix][+patchtype].extension". For example, "kube-apiserver0+merge.yaml" or just "etcd.json". "patchtype" can be one of "strategic", "merge" or "json" and they match the patch formats supported by kubectl. The default "patchtype" is "strategic". "extension" must be either "json" or "yaml". "suffix" is an optional string that can be used to determine which patches are applied first alpha-numerically.
-->
包含名为 "target[suffix][+patchtype].extension" 的文件的目录。
例如，"kube-apiserver0+merge.yaml" 或者 "etcd.json"。
"patchtype" 可以是 "strategic"、"merge" 或 "json" 之一，分别与 kubectl
所支持的 patch 格式相匹配。默认的 "patchtype" 是 "strategic"。
"extension" 必须是 "json" 或 "yaml"。
"suffix" 是一个可选的字符串，用来确定按字母顺序排序时首先应用哪些 patch。
</td>
</tr>
<tr>
<td colspan="2">--feature-gates string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
A set of key=value pairs that describe feature gates for various features. Options are:<br/>IPv6DualStack=true|false (ALPHA - default=false)<br/>PublicKeysECDSA=true|false (ALPHA - default=false)
-->
一组用来描述各种特性门控的键值（key=value）对。选项是：
<br/>IPv6DualStack=true|false (ALPHA - 默认=false)
<br/>PublicKeysECDSA=true|false (ALPHA - 默认=false)
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for all
-->
all 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">
<!--
--image-repository string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "k8s.gcr.io"
-->
--image-repository string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："k8s.gcr.io"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Choose a container registry to pull control plane images from
-->
选择用于拉取控制平面镜像的容器仓库
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "stable-1"
-->
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Choose a specific Kubernetes version for the control plane.
-->
为控制平面选择指定的 Kubernetes 版本。
</td>
</tr>
<tr>
<td colspan="2">--pod-network-cidr string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Specify range of IP addresses for the pod network. If set, the control plane will automatically allocate CIDRs for every node.
-->
指定 Pod 网络的 IP 地址范围。如果设置了此标志，控制平面将自动地为每个节点分配 CIDR。
</td>
</tr>
<tr>
<td colspan="2">--scheduler-extra-args mapStringString</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
A set of extra flags to pass to the Scheduler or override default ones in form of &lt;flagname&gt;=&lt;value&gt;
-->
一组形式为 &lt;flagname&gt;=&lt;value&gt; 的额外参数，用来传递给调度器（Scheduler）
或覆盖其默认设置值
<p>传递给调度器（scheduler）一组额外的参数或者以 &lt;flagname&gt;=&lt;value&gt; 形式覆盖其默认值。</p>
</td>
</tr>
<tr>
<td colspan="2">
<!--
--service-cidr string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "10.96.0.0/12"
-->
--service-cidr string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："10.96.0.0/12"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Use alternative range of IP address for service VIPs.
-->
为服务 VIP 选择 IP 地址范围。
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父指令继承的选项">从父指令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 指向 '真实' 宿主机的根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
  <div id="tab-control-plane-2" class="tab-pane" role="tabpanel" aria-labelledby="tab-control-plane-2">

<p><h3 id="概要">概要</h3>
<!-- 
Generates the kube-apiserver static Pod manifest 
-->
<p>生成 kube-apiserver 静态 Pod 清单</p>
<pre tabindex="0"><code>kubeadm init phase control-plane apiserver [flags]
</code></pre><!-- 
### Options 
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--apiserver-advertise-address string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The IP address the API Server will advertise it's listening on. If not set the default network interface will be used.
-->
API 服务器所公布的其正在监听的 IP 地址。如果未设置，将使用默认网络接口。
</td>
</tr>
<tr>
<td colspan="2">
<!--
--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: 6443
-->
--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值： 6443
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Port for the API Server to bind to.
-->
要绑定到 API 服务器的端口。
</td>
</tr>
<tr>
<td colspan="2">--apiserver-extra-args mapStringString</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
A set of extra flags to pass to the API Server or override default ones in form of &lt;flagname&gt;=&lt;value&gt;
-->
一组 &lt;flagname&gt;=&lt;value&gt; 形式的额外参数，用来传递给 API 服务器
或者覆盖其默认参数配置
</td>
</tr>
<tr>
<td colspan="2">
<!--
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"
-->
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The path where to save and store the certificates.
-->
保存和存储证书的路径。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to a kubeadm configuration file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">--control-plane-endpoint string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Specify a stable IP address or DNS name for the control plane.
-->
为控制平面指定一个稳定的 IP 地址或 DNS 名称。
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--Path to a directory that contains files named "target[suffix][+patchtype].extension". For example, "kube-apiserver0+merge.yaml" or just "etcd.json". "patchtype" can be one of "strategic", "merge" or "json" and they match the patch formats supported by kubectl. The default "patchtype" is "strategic". "extension" must be either "json" or "yaml". "suffix" is an optional string that can be used to determine which patches are applied first alpha-numerically.-->
包含名为 "target[suffix][+patchtype].extension" 的文件的目录。
例如，"kube-apiserver0+merge.yaml" 或者 "etcd.json"。
"patchtype" 可以是 "strategic"、"merge" 或 "json" 之一，分别与 kubectl
所支持的 patch 格式相匹配。默认的 "patchtype" 是 "strategic"。
"extension" 必须是 "json" 或 "yaml"。
"suffix" 是一个可选的字符串，用来确定按字母顺序排序时首先应用哪些 patch。
</td>
</tr>
<tr>
<td colspan="2">--feature-gates string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
A set of key=value pairs that describe feature gates for various features. Options are:<br/>IPv6DualStack=true|false (ALPHA - default=false)<br/>PublicKeysECDSA=true|false (ALPHA - default=false)
-->
一组键值对，用于描述各种功能特性的特性门控。选项是：
<br/>IPv6DualStack=true|false (ALPHA - 默认=false)
<br/>PublicKeysECDSA=true|false (ALPHA - 默认=false)
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for apiserver
-->
apiserver 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">
<!--
--image-repository string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "k8s.gcr.io"
-->
--image-repository string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："k8s.gcr.io"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Choose a container registry to pull control plane images from
-->
选择要从中拉取控制平面镜像的容器仓库
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "stable-1"
-->
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Choose a specific Kubernetes version for the control plane.
-->
为控制平面选择特定的 Kubernetes 版本
</td>
</tr>
<tr>
<td colspan="2">
<!--
--service-cidr string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "10.96.0.0/12"
-->
--service-cidr string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："10.96.0.0/12"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Use alternative range of IP address for service VIPs.
-->
指定服务 VIP 使用 IP 地址的其他范围。
</td>
</tr>
</tbody>
</table>
<!-- 
### Options inherited from parent commands 
-->
<h3 id="继承于父命令的选项">继承于父命令的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统路径。
</td>
</tr>
</tbody>
</table>
</div>
  <div id="tab-control-plane-3" class="tab-pane" role="tabpanel" aria-labelledby="tab-control-plane-3">

<p><h3 id="概要">概要</h3>
<!--
Generates the kube-controller-manager static Pod manifest
-->
<p>生成 kube-controller-manager 静态 Pod 清单</p>
<pre tabindex="0"><code>kubeadm init phase control-plane controller-manager [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<!-- td colspan="2">--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"</td -->
<td colspan="2">--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The path where to save and store the certificates.
-->
存储证书的路径。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to a kubeadm configuration file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">--controller-manager-extra-args mapStringString</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
A set of extra flags to pass to the Controller Manager or override default ones in form of &lt;flagname&gt;=&lt;value&gt;
-->
一组 &lt;flagname&gt;=&lt; 形式的额外参数，传递给控制器管理器（Controller Manager）
或者覆盖其默认配置值
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--Path to a directory that contains files named "target[suffix][+patchtype].extension". For example, "kube-apiserver0+merge.yaml" or just "etcd.json". "patchtype" can be one of "strategic", "merge" or "json" and they match the patch formats supported by kubectl. The default "patchtype" is "strategic". "extension" must be either "json" or "yaml". "suffix" is an optional string that can be used to determine which patches are applied first alpha-numerically.-->
包含名为 "target[suffix][+patchtype].extension" 的文件的目录。
例如，"kube-apiserver0+merge.yaml" 或者 "etcd.json"。
"patchtype" 可以是 "strategic"、"merge" 或 "json" 之一，分别与 kubectl
所支持的 patch 格式相匹配。默认的 "patchtype" 是 "strategic"。
"extension" 必须是 "json" 或 "yaml"。
"suffix" 是一个可选的字符串，用来确定按字母顺序排序时首先应用哪些 patch。
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for controller-manager
-->
controller-manager 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">
<!--
--image-repository string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "k8s.gcr.io"
-->
--image-repository string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："k8s.gcr.io"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Choose a container registry to pull control plane images from
-->
选择要从中拉取控制平面镜像的容器仓库
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "stable-1"
-->
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Choose a specific Kubernetes version for the control plane.
-->
为控制平面选择特定的 Kubernetes 版本。
</td>
</tr>
<tr>
<td colspan="2">--pod-network-cidr string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Specify range of IP addresses for the pod network. If set, the control plane will automatically allocate CIDRs for every node.
-->
指定 Pod 网络的 IP 地址范围。如果设置，控制平面将自动为每个节点分配 CIDR。
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
  <div id="tab-control-plane-4" class="tab-pane" role="tabpanel" aria-labelledby="tab-control-plane-4">

<p><h3 id="概要">概要</h3>
<!--
Generates the kube-scheduler static Pod manifest
-->
<p>生成 kube-scheduler 静态 Pod 清单</p>
<pre tabindex="0"><code>kubeadm init phase control-plane scheduler [flags]
</code></pre><!-- 
### Options 
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">
<!--
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"
-->
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The path where to save and store the certificates.
-->
存储证书的路径。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to a kubeadm configuration file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">--experimental-patches string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--Path to a directory that contains files named "target[suffix][+patchtype].extension". For example, "kube-apiserver0+merge.yaml" or just "etcd.json". "patchtype" can be one of "strategic", "merge" or "json" and they match the patch formats supported by kubectl. The default "patchtype" is "strategic". "extension" must be either "json" or "yaml". "suffix" is an optional string that can be used to determine which patches are applied first alpha-numerically.-->
包含名为 "target[suffix][+patchtype].extension" 的文件的目录。
例如，"kube-apiserver0+merge.yaml" 或者 "etcd.json"。
"patchtype" 可以是 "strategic"、"merge" 或 "json" 之一，分别与 kubectl
所支持的 patch 格式相匹配。默认的 "patchtype" 是 "strategic"。
"extension" 必须是 "json" 或 "yaml"。
"suffix" 是一个可选的字符串，用来确定按字母顺序排序时首先应用哪些 patch。
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for scheduler
-->
scheduler 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">
<!--
--image-repository string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "k8s.gcr.io"
-->
--image-repository string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值:"k8s.gcr.io"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Choose a container registry to pull control plane images from
-->
选择要从中拉取控制平面镜像的容器仓库
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "stable-1"
-->
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Choose a specific Kubernetes version for the control plane.
-->
为控制平面选择特定的 Kubernetes 版本。
</td>
</tr>
<tr>
<td colspan="2">--scheduler-extra-args mapStringString</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
A set of extra flags to pass to the Scheduler or override default ones in form of &lt;flagname&gt;=&lt;value&gt;
-->
一组 &lt;flagname&gt;=&lt;value&gt; 形式的额外参数，用来传递给调度器
或者覆盖其默认参数配置
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="继承于父命令的选项">继承于父命令的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div></div>

<!--
## kubeadm init phase etcd {#cmd-phase-etcd}
-->
<h2 id="cmd-phase-etcd">kubeadm init phase etcd</h2>
<!--
Use the following phase to create a local etcd instance based on a static Pod file.
-->
<p>根据静态 Pod 文件，使用以下阶段创建本地 etcd 实例。</p>
<ul class="nav nav-tabs" id="tab-etcd" role="tablist"><li class="nav-item"><a data-toggle="tab" class="nav-link active" href="#tab-etcd-0" role="tab" aria-controls="tab-etcd-0" aria-selected="true">etcd</a></li>
	  
		<li class="nav-item"><a data-toggle="tab" class="nav-link" href="#tab-etcd-1" role="tab" aria-controls="tab-etcd-1">local</a></li></ul>
<div class="tab-content" id="tab-etcd"><div id="tab-etcd-0" class="tab-pane show active" role="tabpanel" aria-labelledby="tab-etcd-0">

<p><h3 id="概要">概要</h3>
<!--
This command is not meant to be run on its own. See list of available subcommands.
-->
<p>此命令并非设计用来单独运行。请参阅可用子命令列表。</p>
<pre tabindex="0"><code>kubeadm init phase etcd [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- help for etcd -->
etcd 操作的帮助命令
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="继承于父命令的选项">继承于父命令的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
  <div id="tab-etcd-1" class="tab-pane" role="tabpanel" aria-labelledby="tab-etcd-1">

<p><h3 id="概要">概要</h3>
<!--
Generate the static Pod manifest file for a local, single-node local etcd instance
-->
<p>为本地单节点 etcd 实例生成静态 Pod 清单文件</p>
<pre tabindex="0"><code>kubeadm init phase etcd local [flags]
</code></pre><!--
### Examples
-->
<h3 id="示例">示例</h3>
<!--
# Generates the static Pod manifest file for etcd, functionally
# equivalent to what is generated by kubeadm init.
# Generates the static Pod manifest file for etcd using options
# read from a configuration file.
-->
<pre tabindex="0"><code># 为 etcd 生成静态 Pod 清单文件，其功能等效于 kubeadm init 生成的文件。
kubeadm init phase etcd local

# 使用从配置文件读取的选项为 etcd 生成静态 Pod 清单文件。
kubeadm init phase etcd local --config config.yaml
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">
<!--
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"
-->
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- The path where to save and store the certificates.  -->
存储证书的路径。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- Path to a kubeadm configuration file.  -->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">--experimental-patches string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--  
Path to a directory that contains files named "target[suffix][+patchtype].extension". For example, "kube-apiserver0+merge.yaml" or just "etcd.json". "patchtype" can be one of "strategic", "merge" or "json" and they match the patch formats supported by kubectl. The default "patchtype" is "strategic". "extension" must be either "json" or "yaml". "suffix" is an optional string that can be used to determine which patches are applied first alpha-numerically.
-->
包含名为 "target[suffix][+patchtype].extension" 的文件的目录的路径。
例如，"kube-apiserver0+merge.yaml" 或仅仅是 "etcd.json"。
"patchtype" 可以是 "strategic"、"merge" 或 "json" 之一，并且它们与 kubectl 支持的补丁格式匹配。
默认的 "patchtype" 为 "strategic"。 "extension" 必须为 "json" 或 "yaml"。 
"suffix" 是一个可选字符串，可用于确定首先按字母顺序应用哪些补丁。
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- help for local -->
local 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">
<!--
--image-repository string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "k8s.gcr.io"
-->
--image-repository string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："k8s.gcr.io"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- Choose a container registry to pull control plane images from -->
选择要从中拉取控制平面镜像的容器仓库
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="继承于父命令的选项">继承于父命令的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- [EXPERIMENTAL] The path to the 'real' host root filesystem.  -->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div></div>

<!--
## kubeadm init phase upload-config {#cmd-phase-upload-config}
-->
<h2 id="cmd-phase-upload-config">kubeadm init phase upload-config</h2>
<!--
You can use this command to upload the kubeadm configuration to your cluster.
Alternatively, you can use [kubeadm config](/docs/reference/setup-tools/kubeadm/kubeadm-config/).
-->
<p>可以使用此命令将 kubeadm 配置文件上传到集群。或者使用
<a href="/zh/docs/reference/setup-tools/kubeadm/kubeadm-config/">kubeadm config</a>。</p>
<ul class="nav nav-tabs" id="upload-config" role="tablist"><li class="nav-item"><a data-toggle="tab" class="nav-link active" href="#upload-config-0" role="tab" aria-controls="upload-config-0" aria-selected="true">upload-config</a></li>
	  
		<li class="nav-item"><a data-toggle="tab" class="nav-link" href="#upload-config-1" role="tab" aria-controls="upload-config-1">all</a></li>
		<li class="nav-item"><a data-toggle="tab" class="nav-link" href="#upload-config-2" role="tab" aria-controls="upload-config-2">kubeadm</a></li>
		<li class="nav-item"><a data-toggle="tab" class="nav-link" href="#upload-config-3" role="tab" aria-controls="upload-config-3">kubelet</a></li></ul>
<div class="tab-content" id="upload-config"><div id="upload-config-0" class="tab-pane show active" role="tabpanel" aria-labelledby="upload-config-0">

<p><h3 id="概要">概要</h3>
<!--
This command is not meant to be run on its own. See list of available subcommands.
-->
<p>此命令并非设计用来单独运行。请参阅可用的子命令列表。</p>
<pre tabindex="0"><code>kubeadm init phase upload-config [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for upload-config
-->
upload-config 操作的帮助命令
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令中继承的选项">从父命令中继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
  <div id="upload-config-1" class="tab-pane" role="tabpanel" aria-labelledby="upload-config-1">

<p><h3 id="概要">概要</h3>
<!--
Upload all configuration to a config map
-->
<p>将所有配置上传到 ConfigMap</p>
<pre tabindex="0"><code>kubeadm init phase upload-config all [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to a kubeadm configuration file.
-->
kubeadm 配置文件的路径。
</td>
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for all
-->
all 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"
-->
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.
-->
与集群通信时使用的 kubeconfig 文件。如果未设置该参数，则可以在一组标准位置中搜索现有的 kubeconfig 文件。
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
  <div id="upload-config-2" class="tab-pane" role="tabpanel" aria-labelledby="upload-config-2">

<p><h3 id="概要">概要</h3>
<!--
Upload the kubeadm ClusterConfiguration to a ConfigMap called kubeadm-config in the kube-system namespace. This enables correct configuration of system components and a seamless user experience when upgrading.
-->
<p>将 kubeadm ClusterConfiguration 上传到 kube-system 命名空间中名为 kubeadm-config 的 ConfigMap 中。
这样就可以正确配置系统组件，并在升级时提供无缝的用户体验。</p>
<!--
Alternatively, you can use kubeadm config.
-->
<p>另外，可以使用 kubeadm 配置。</p>
<pre tabindex="0"><code>kubeadm init phase upload-config kubeadm [flags]
</code></pre><!--
### Examples
-->
<h3 id="示例">示例</h3>
<!--
# upload the configuration of your cluster
-->
<pre tabindex="0"><code># 上传集群配置
kubeadm init phase upload-config --config=myConfig.yaml
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to a kubeadm configuration file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for kubeadm
-->
kubeadm 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"
-->
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.
-->
与集群通信时使用的 kubeconfig 文件。如果未设置该参数，则可以在一组标准位置中搜索现有的 kubeconfig 文件。
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
  <div id="upload-config-3" class="tab-pane" role="tabpanel" aria-labelledby="upload-config-3">

<p><h3 id="概要">概要</h3>
<!--
Upload kubelet configuration extracted from the kubeadm InitConfiguration object to a ConfigMap of the form kubelet-config-1.X in the cluster, where X is the minor version of the current (API Server) Kubernetes version.
-->
<p>将从 kubeadm InitConfiguration 对象提取的 kubelet 配置上传到集群中 kubelet-config-1.X 形式的
ConfigMap，其中 X 是当前（API 服务器）Kubernetes 版本的次要版本。</p>
<pre tabindex="0"><code>kubeadm init phase upload-config kubelet [flags]
</code></pre><!--
### Examples
-->
<h3 id="示例">示例</h3>
<!--
```
  # Upload the kubelet configuration from the kubeadm Config file to a ConfigMap in the cluster.
  kubeadm init phase upload-config kubelet --config kubeadm.yaml
```
-->
<pre tabindex="0"><code># 将 kubelet 配置从 kubeadm 配置文件上传到集群中的 ConfigMap。
kubeadm init phase upload-config kubelet --config kubeadm.yaml
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- Path to a kubeadm configuration file.  -->
到 kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- help for kubelet -->
kubelet 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">
<!-- kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf" -->
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.
-->
与集群通信时使用的 kubeconfig 文件。如果未设置该标签，则可以通过一组标准路径来寻找已有的 kubeconfig 文件。
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div></div>

<!--
## kubeadm init phase upload-certs {#cmd-phase-upload-certs}
-->
<h2 id="cmd-phase-upload-certs">kubeadm init phase upload-certs</h2>
<!--
Use the following phase to upload control-plane certificates to the cluster.
By default the certs and encryption key expire after two hours.
-->
<p>使用以下阶段将控制平面证书上传到集群。默认情况下，证书和加密密钥会在两个小时后过期。</p>
<ul class="nav nav-tabs" id="tab-upload-certs" role="tablist"><li class="nav-item"><a data-toggle="tab" class="nav-link active" href="#tab-upload-certs-0" role="tab" aria-controls="tab-upload-certs-0" aria-selected="true">upload-certs</a></li>
	  </ul>
<div class="tab-content" id="tab-upload-certs"><div id="tab-upload-certs-0" class="tab-pane show active" role="tabpanel" aria-labelledby="tab-upload-certs-0">

<p><h3 id="概要">概要</h3>
<!--
This command is not meant to be run on its own. See list of available subcommands.
-->
<p>此命令并非设计用来单独运行。请参阅可用子命令列表。</p>
<pre tabindex="0"><code>kubeadm init phase upload-certs [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--certificate-key string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Key used to encrypt the control-plane certificates in the kubeadm-certs Secret.
-->
用于加密 kubeadm-certs Secret 中的控制平面证书的密钥。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to a kubeadm configuration file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for upload-certs
-->
upload-certs 操作的帮助命令
</td>
</tr>
<tr>
<!-- td colspan="2">--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"</td -->
<td colspan="2">--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"</td>
</tr>
<tr>
<!-- td></td><td style="line-height: 130%; word-wrap: break-word;">The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.</td -->
<td></td><td style="line-height: 130%; word-wrap: break-word;">
用来与集群通信的 kubeconfig 文件。
如果此标志未设置，则可以在一组标准的位置搜索现有的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan="2">--skip-certificate-key-print</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Don't print the key used to encrypt the control-plane certificates.
-->
不要打印输出用于加密控制平面证书的密钥。
</td>
</tr>
<tr>
<td colspan="2">--upload-certs</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Upload control-plane certificates to the kubeadm-certs Secret.
-->
将控制平面证书上传到 kubeadm-certs Secret。
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div></div>

<!--
## kubeadm init phase mark-control-plane {#cmd-phase-mark-control-plane}
-->
<h2 id="cmd-phase-mark-control-plane">kubeadm init phase mark-control-plane</h2>
<!--
Use the following phase to label and taint the node with the `node-role.kubernetes.io/master=""` key-value pair.
-->
<p>使用以下阶段来给具有 <code>node-role.kubernetes.io/master=&quot;&quot;</code> 键值对的节点
打标签（label）和记录污点（taint）。</p>
<ul class="nav nav-tabs" id="tab-mark-control-plane" role="tablist"><li class="nav-item"><a data-toggle="tab" class="nav-link active" href="#tab-mark-control-plane-0" role="tab" aria-controls="tab-mark-control-plane-0" aria-selected="true">mark-control-plane</a></li>
	  </ul>
<div class="tab-content" id="tab-mark-control-plane"><div id="tab-mark-control-plane-0" class="tab-pane show active" role="tabpanel" aria-labelledby="tab-mark-control-plane-0">

<p><h3 id="概要">概要</h3>
<!--
Mark a node as a control-plane
-->
<p>标记 Node 节点为控制平面节点</p>
<pre tabindex="0"><code>kubeadm init phase mark-control-plane [flags]
</code></pre><!--
### Examples

# Applies control-plane label and taint to the current node, functionally equivalent to what executed by kubeadm init.
# Applies control-plane label and taint to a specific node
-->
<h3 id="示例">示例</h3>
<pre tabindex="0"><code># 将控制平面标签和污点应用于当前节点，其功能等效于 kubeadm init执行的操作。
kubeadm init phase mark-control-plane --config config.yml

# 将控制平面标签和污点应用于特定节点
kubeadm init phase mark-control-plane --node-name myNode
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to a kubeadm configuration file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for mark-control-plane
-->
mark-control-plane 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">--node-name string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Specify the node name.
-->
指定节点名称。
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs 字符串</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div></div>

<!--
## kubeadm init phase bootstrap-token {#cmd-phase-bootstrap-token}
-->
<h2 id="cmd-phase-bootstrap-token">kubeadm init phase bootstrap-token</h2>
<!--
Use the following phase to configure bootstrap tokens.
-->
<p>使用以下阶段来配置引导令牌。</p>
<ul class="nav nav-tabs" id="tab-bootstrap-token" role="tablist"><li class="nav-item"><a data-toggle="tab" class="nav-link active" href="#tab-bootstrap-token-0" role="tab" aria-controls="tab-bootstrap-token-0" aria-selected="true">bootstrap-token</a></li>
	  </ul>
<div class="tab-content" id="tab-bootstrap-token"><div id="tab-bootstrap-token-0" class="tab-pane show active" role="tabpanel" aria-labelledby="tab-bootstrap-token-0">

<p><h3 id="概要">概要</h3>
<!--
Bootstrap tokens are used for establishing bidirectional trust between a node joining the cluster and a control-plane node.
-->
<p>启动引导令牌（bootstrap token）用于在即将加入集群的节点和控制平面节点之间建立双向信任。</p>
<!--
This command makes all the configurations required to make bootstrap tokens works and then creates an initial token.
-->
<p>该命令使启动引导令牌（bootstrap token）所需的所有配置生效，然后创建初始令牌。</p>
<pre tabindex="0"><code>kubeadm init phase bootstrap-token [flags]
</code></pre><!--
### Examples
-->
<h3 id="示例">示例</h3>
<!--
# Make all the bootstrap token configurations and create an initial token, functionally equivalent to what generated by kubeadm init.
-->
<pre tabindex="0"><code># 进行所有引导令牌配置，并创建一个初始令牌，功能上与 kubeadm init 生成的令牌等效。
kubeadm init phase bootstrap-token
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to a kubeadm configuration file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for bootstrap-token
-->
bootstrap-token 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"
-->
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.
-->
用于和集群通信的 kubeconfig 文件。如果它没有被设置，那么 kubeadm 将会搜索一个已经存在于标准路径的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan="2">--skip-token-print</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Skip printing of the default bootstrap token generated by 'kubeadm init'.
-->
跳过打印 'kubeadm init' 生成的默认引导令牌。
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="继承于父命令的选项">继承于父命令的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div></div>

<h2 id="cmd-phase-kubelet-finalize-all">kubeadm init phase kubelet-finialize</h2>
<!-- 
Use the following phase to update settings relevant to the kubelet after TLS
bootstrap. You can use the `all` subcommand to run all `kubelet-finalize`
phases.
-->
<p>使用以下阶段在 TLS 引导后更新与 kubelet 相关的设置。
你可以使用 <code>all</code> 子命令来运行所有 <code>kubelet-finalize</code> 阶段。</p>
<ul class="nav nav-tabs" id="tab-kubelet-finalize" role="tablist"><li class="nav-item"><a data-toggle="tab" class="nav-link active" href="#tab-kubelet-finalize-0" role="tab" aria-controls="tab-kubelet-finalize-0" aria-selected="true">kublet-finalize</a></li>
	  
		<li class="nav-item"><a data-toggle="tab" class="nav-link" href="#tab-kubelet-finalize-1" role="tab" aria-controls="tab-kubelet-finalize-1">kublet-finalize-all</a></li>
		<li class="nav-item"><a data-toggle="tab" class="nav-link" href="#tab-kubelet-finalize-2" role="tab" aria-controls="tab-kubelet-finalize-2">kublet-finalize-cert-rotation</a></li></ul>
<div class="tab-content" id="tab-kubelet-finalize"><div id="tab-kubelet-finalize-0" class="tab-pane show active" role="tabpanel" aria-labelledby="tab-kubelet-finalize-0">

<p><p>TLS 引导后更新与 kubelet 相关的设置</p>
<pre tabindex="0"><code>kubeadm init phase kubelet-finalize [flags]
</code></pre><!-- ### Examples -->
<h3 id="示例">示例</h3>
<!--  
```
  # Updates settings relevant to the kubelet after TLS bootstrap
  kubeadm init phase kubelet-finalize all --config
```
-->
<pre tabindex="0"><code>  # 在 TLS 引导后更新与 kubelet 相关的设置
  kubeadm init phase kubelet-finalize all --config
</code></pre><!-- ### Options -->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<!-- <td></td><td style="line-height: 130%; word-wrap: break-word;">help for kubelet-finalize</td> -->
<td></td><td style="line-height: 130%; word-wrap: break-word;">kubelet-finalize 操作的帮助命令</td>
</tr>
</tbody>
</table>
<!-- ### Options inherited from parent commands -->
<h3 id="继承于父命令的选项">继承于父命令的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<!-- <td></td><td style="line-height: 130%; word-wrap: break-word;">[EXPERIMENTAL] The path to the 'real' host root filesystem.</td> -->
<td></td><td style="line-height: 130%; word-wrap: break-word;">[实验] 到'真实'主机根文件系统的路径。</td>
</tr>
</tbody>
</table>
</div>
  <div id="tab-kubelet-finalize-1" class="tab-pane" role="tabpanel" aria-labelledby="tab-kubelet-finalize-1">

<p><p>运行所有 kubelet-finalize 阶段</p>
<pre tabindex="0"><code>kubeadm init phase kubelet-finalize all [flags]
</code></pre><!-- ### Examples -->
<h3 id="示例">示例</h3>
<!--  
```
  # Updates settings relevant to the kubelet after TLS bootstrap
  kubeadm init phase kubelet-finalize all --config
```
-->
<pre tabindex="0"><code>  # 在 TLS 引导后更新与 kubelet 相关的设置
  kubeadm init phase kubelet-finalize all --config
</code></pre><!-- ### Options -->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<!-- <td colspan="2">--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"</td> -->
<td colspan="2">--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值: "/etc/kubernetes/pki"</td>
</tr>
<tr>
<!-- <td></td><td style="line-height: 130%; word-wrap: break-word;">The path where to save and store the certificates.</td> -->
<td></td><td style="line-height: 130%; word-wrap: break-word;">保存和存储证书的路径。</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<!-- <td></td><td style="line-height: 130%; word-wrap: break-word;">Path to a kubeadm configuration file.</td> -->
<td></td><td style="line-height: 130%; word-wrap: break-word;">kubeadm 配置文件的路径。</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<!-- <td></td><td style="line-height: 130%; word-wrap: break-word;">help for all</td> -->
<td></td><td style="line-height: 130%; word-wrap: break-word;">all 操作的帮助命令</td>
</tr>
</tbody>
</table>
<!-- ### Options inherited from parent commands -->
<h3 id="继承于父命令的选项">继承于父命令的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<!-- <td></td><td style="line-height: 130%; word-wrap: break-word;">[EXPERIMENTAL] The path to the 'real' host root filesystem.</td> -->
<td></td><td style="line-height: 130%; word-wrap: break-word;">[实验] 到'真实'主机根文件系统的路径。</td>
</tr>
</tbody>
</table>
</div>
  <div id="tab-kubelet-finalize-2" class="tab-pane" role="tabpanel" aria-labelledby="tab-kubelet-finalize-2">

<p><p>启用 kubelet 客户端证书轮换</p>
<pre tabindex="0"><code>kubeadm init phase kubelet-finalize experimental-cert-rotation [flags]
</code></pre><!-- ### Options -->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"</td>
</tr>
<tr>
<!-- <td></td><td style="line-height: 130%; word-wrap: break-word;">The path where to save and store the certificates.</td> -->
<td></td><td style="line-height: 130%; word-wrap: break-word;">保存和存储证书的路径。</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<!-- <td></td><td style="line-height: 130%; word-wrap: break-word;">Path to a kubeadm configuration file.</td> -->
<td></td><td style="line-height: 130%; word-wrap: break-word;">kubeadm 配置文件的路径。</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<!-- <td></td><td style="line-height: 130%; word-wrap: break-word;">help for experimental-cert-rotation</td> -->
<td></td><td style="line-height: 130%; word-wrap: break-word;">experimental-cert-rotation 操作的帮助命令</td>
</tr>
</tbody>
</table>
<!-- ### Options inherited from parent commands -->
<h3 id="继承于父命令的选项">继承于父命令的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<!-- <td></td><td style="line-height: 130%; word-wrap: break-word;">[EXPERIMENTAL] The path to the 'real' host root filesystem.</td> -->
<td></td><td style="line-height: 130%; word-wrap: break-word;">[实验] 到'真实'主机根文件系统的路径。</td>
</tr>
</tbody>
</table>
</div></div>

<!--
## kubeadm init phase addon {#cmd-phase-addon}
-->
<h2 id="cmd-phase-addon">kubeadm init phase addon</h2>
<!--
You can install all the available addons with the `all` subcommand, or
install them selectively.
-->
<p>可以使用 <code>all</code> 子命令安装所有可用的插件，或者有选择性地安装它们。</p>
<ul class="nav nav-tabs" id="tab-addon" role="tablist"><li class="nav-item"><a data-toggle="tab" class="nav-link active" href="#tab-addon-0" role="tab" aria-controls="tab-addon-0" aria-selected="true">addon</a></li>
	  
		<li class="nav-item"><a data-toggle="tab" class="nav-link" href="#tab-addon-1" role="tab" aria-controls="tab-addon-1">all</a></li>
		<li class="nav-item"><a data-toggle="tab" class="nav-link" href="#tab-addon-2" role="tab" aria-controls="tab-addon-2">coredns</a></li>
		<li class="nav-item"><a data-toggle="tab" class="nav-link" href="#tab-addon-3" role="tab" aria-controls="tab-addon-3">kube-proxy</a></li></ul>
<div class="tab-content" id="tab-addon"><div id="tab-addon-0" class="tab-pane show active" role="tabpanel" aria-labelledby="tab-addon-0">

<p><h3 id="概要">概要</h3>
<!--
This command is not meant to be run on its own. See list of available subcommands.
-->
<p>此命令并非设计用来单独运行。请参阅可用子命令列表。</p>
<pre tabindex="0"><code>kubeadm init phase addon [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for addon
-->
addon 操作的帮助命令
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="继承于父命令的选项">继承于父命令的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
  <div id="tab-addon-1" class="tab-pane" role="tabpanel" aria-labelledby="tab-addon-1">

<p><h3 id="概要">概要</h3>
<!--
Install all the addons
-->
<p>安装所有插件（addon）</p>
<pre tabindex="0"><code>kubeadm init phase addon all [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--apiserver-advertise-address string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The IP address the API Server will advertise it's listening on. If not set the default network interface will be used.
-->
API 服务器所公布的其正在监听的 IP 地址。如果未设置，则将使用默认网络接口。
</td>
</tr>
<tr>
<td colspan="2">
<!--
--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: 6443
-->
--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：6443
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Port for the API Server to bind to.
-->
API 服务器绑定的端口。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to a kubeadm configuration file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">--control-plane-endpoint string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Specify a stable IP address or DNS name for the control plane.
-->
为控制平面指定一个稳定的 IP 地址或 DNS 名称。
</td>
</tr>
<tr>
<td colspan="2">--feature-gates string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
A set of key=value pairs that describe feature gates for various features. Options are:<br/>IPv6DualStack=true|false (ALPHA - default=false)
-->
一组键值对（key=value），描述了各种特征。选项包括：<br/>IPv6DualStack=true|false (ALPHA - 默认值=false)
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for all
all 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">
<!--
--image-repository string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "k8s.gcr.io"
-->
--image-repository string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："k8s.gcr.io"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Choose a container registry to pull control plane images from
-->
选择用于拉取控制平面镜像的容器仓库
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"
-->
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.
-->
与集群通信时使用的 kubeconfig 文件。如果未设置该参数，则可以在一组标准位置中搜索现有的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "stable-1"
-->
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Choose a specific Kubernetes version for the control plane.
-->
为控制平面选择特定的 Kubernetes 版本。
</td>
</tr>
<tr>
<td colspan="2">--pod-network-cidr string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Specify range of IP addresses for the pod network. If set, the control plane will automatically allocate CIDRs for every node.
-->
指定 Pod 网络的 IP 地址范围。如果已设置，控制平面将自动为每个节点分配 CIDR。
</td>
</tr>
<tr>
<td colspan="2">
<!--
--service-cidr string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "10.96.0.0/12"
-->
--service-cidr string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："10.96.0.0/12"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Use alternative range of IP address for service VIPs.
-->
为服务 VIP 使用 IP 地址的其他范围。
</td>
</tr>
<tr>
<td colspan="2">
<!--
--service-dns-domain string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "cluster.local"
-->
--service-dns-domain string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："cluster.local"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Use alternative domain for services, e.g. "myorg.internal".
-->
为服务使用其他域名，例如 "myorg.internal"。
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="继承于父命令的选项">继承于父命令的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
  <div id="tab-addon-2" class="tab-pane" role="tabpanel" aria-labelledby="tab-addon-2">

<p><h3 id="概要">概要</h3>
<!--
Install the CoreDNS addon components via the API server. Please note that although the DNS server is deployed, it will not be scheduled until CNI is installed.
-->
<p>通过 API 服务器安装 CoreDNS 附加组件。请注意，即使 DNS 服务器已部署，在安装 CNI 之前 DNS 服务器不会被调度执行。</p>
<pre tabindex="0"><code>kubeadm init phase addon coredns [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to kubeadm config file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">--feature-gates string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
A set of key=value pairs that describe feature gates for various features. Options are:<br/>IPv6DualStack=true|false (ALPHA - default=false)
-->
一组用来描述各种功能特性的键值（key=value）对。选项是：<br/>IPv6DualStack=true|false (ALPHA - 默认值=false)
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- help for coredns -->
coredns 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">
<!--
--image-repository string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "k8s.gcr.io"
-->
--image-repository string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："k8s.gcr.io"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Choose a container registry to pull control plane images from
-->
选择用于拉取控制平面镜像的容器仓库
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"
-->
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.
-->
与集群通信时使用的 kubeconfig 文件。如果未设置该参数，则可以在一组标准位置中搜索现有的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "stable-1"
-->
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- Choose a specific Kubernetes version for the control plane.  -->
为控制平面选择特定的 Kubernetes 版本。
</td>
</tr>
<tr>
<td colspan="2">
<!--
--service-cidr string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "10.96.0.0/12"
-->
--service-cidr string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："10.96.0.0/12"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- Use alternative range of IP address for service VIPs.  -->
为服务 VIP 选择 IP 地址范围。
</td>
</tr>
<tr>
<td colspan="2">
<!--
--service-dns-domain string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "cluster.local"
-->
--service-dns-domain string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："cluster.local"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- Use alternative domain for services, e.g. "myorg.internal".  -->
服务使用其它的域名，例如："myorg.internal"。
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="继承于父命令的选项">继承于父命令的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
  <div id="tab-addon-3" class="tab-pane" role="tabpanel" aria-labelledby="tab-addon-3">

<p><h3 id="概要">概要</h3>
<!--
Install the kube-proxy addon components via the API server.
-->
<p>通过 API 服务器安装 kube-proxy 附加组件。</p>
<pre tabindex="0"><code>kubeadm init phase addon kube-proxy [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--apiserver-advertise-address string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The IP address the API Server will advertise it's listening on. If not set the default network interface will be used.
-->
API 服务器所公布的其正在监听的 IP 地址。如果未设置，则将使用默认网络接口。
</td>
</tr>
<tr>
<td colspan="2">
<!--
--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: 6443
-->
--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值: 6443
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Port for the API Server to bind to.
-->
API 服务器绑定的端口。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to kubeadm config file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">--control-plane-endpoint string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Specify a stable IP address or DNS name for the control plane.
-->
为控制平面指定一个稳定的 IP 地址或 DNS 名称。
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for kube-proxy
-->
kube-proxy 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">
<!--
--image-repository string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "k8s.gcr.io"
-->
--image-repository string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："k8s.gcr.io"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Choose a container registry to pull control plane images from
-->
选择用于拉取控制平面镜像的容器仓库
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"
-->
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.
-->
与集群通信时使用的 kubeconfig 文件。如果未设置该参数，则可以在一组标准位置中搜索现有的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "stable-1"
-->
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Choose a specific Kubernetes version for the control plane.
-->
为控制平面选择特定的 Kubernetes 版本。
</td>
</tr>
<tr>
<td colspan="2">--pod-network-cidr string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Specify range of IP addresses for the pod network. If set, the control plane will automatically allocate CIDRs for every node.
-->
指定 Pod 网络的 IP 地址范围。如果已设置，控制平面将自动为每个节点分配 CIDR。
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="继承于父命令的选项">继承于父命令的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div></div>

<!--
For more details on each field in the `v1beta2` configuration you can navigate to our
[API reference pages.] (https://godoc.org/k8s.io/kubernetes/cmd/kubeadm/app/apis/kubeadm/v1beta2)
-->
<p>有关 <code>v1beta2</code> 配置中每个字段的更多详细信息，可以访问
<a href="https://godoc.org/k8s.io/kubernetes/cmd/kubeadm/app/apis/kubeadm/v1beta2">API</a>。</p>
<h2 id="接下来">接下来</h2>
<!--
* [kubeadm init](/docs/reference/setup-tools/kubeadm/kubeadm-init/) to bootstrap a Kubernetes control-plane node
* [kubeadm join](/docs/reference/setup-tools/kubeadm/kubeadm-join/) to connect a node to the cluster
* [kubeadm reset](/docs/reference/setup-tools/kubeadm/kubeadm-reset/) to revert any changes made to this host by `kubeadm init` or `kubeadm join`
* [kubeadm alpha](/docs/reference/setup-tools/kubeadm/kubeadm-alpha/) to try experimental functionality
-->
<ul>
<li><a href="/zh/docs/reference/setup-tools/kubeadm/kubeadm-init/">kubeadm init</a>
引导 Kubernetes 控制平面节点</li>
<li><a href="/zh/docs/reference/setup-tools/kubeadm/kubeadm-join/">kubeadm join</a>
将节点加入到集群</li>
<li><a href="/zh/docs/reference/setup-tools/kubeadm/kubeadm-reset/">kubeadm reset</a>
恢复通过 <code>kubeadm init</code> 或 <code>kubeadm join</code> 操作对主机所做的任何更改</li>
<li><a href="/zh/docs/reference/setup-tools/kubeadm/kubeadm-alpha/">kubeadm alpha</a>
尝试实验性功能</li>
</ul>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-62a742c564b0b5b7ac12a95e67cc425a">7.1.12 - kubeadm join phase</h1>
    
	<!--
title: kubeadm join phase
weight: 90
-->
<!--
`kubeadm join phase` enables you to invoke atomic steps of the join process.
Hence, you can let kubeadm do some of the work and you can fill in the gaps
if you wish to apply customization.
-->
<p><code>kubeadm join phase</code> 使你能够调用 <code>join</code> 过程的基本原子步骤。
因此，如果希望执行自定义操作，可以让 kubeadm 做一些工作，然后由用户来补足剩余操作。</p>
<!--
`kubeadm join phase` is consistent with the [kubeadm join workflow](/docs/reference/setup-tools/kubeadm/kubeadm-join/#join-workflow),
and behind the scene both use the same code.
-->
<p><code>kubeadm join phase</code> 与
<a href="/zh/docs/reference/setup-tools/kubeadm/kubeadm-join/#join-workflow">kubeadm join 工作流程</a>
一致，后台都使用相同的代码。</p>
<h2 id="cmd-join-phase">kubeadm join phase</h2>
<ul class="nav nav-tabs" id="tab-phase" role="tablist"><li class="nav-item"><a data-toggle="tab" class="nav-link active" href="#tab-phase-0" role="tab" aria-controls="tab-phase-0" aria-selected="true">phase</a></li>
	  </ul>
<div class="tab-content" id="tab-phase"><div id="tab-phase-0" class="tab-pane show active" role="tabpanel" aria-labelledby="tab-phase-0">

<p><h3 id="概要">概要</h3>
<!--
Use this command to invoke single phase of the join workflow
-->
<p>使用此命令来调用 <code>join</code> 工作流程的某个阶段</p>
<!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- help for phase -->
phase 操作的帮助命令
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令中继承的选项">从父命令中继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- [EXPERIMENTAL] The path to the 'real' host root filesystem.  -->
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div></div>

<h2 id="cmd-join-phase-preflight">kubeadm join phase preflight</h2>
<!--
Using this phase you can execute preflight checks on a joining node.
-->
<p>使用此命令可以在即将加入集群的节点上执行启动前检查。</p>
<ul class="nav nav-tabs" id="tab-preflight" role="tablist"><li class="nav-item"><a data-toggle="tab" class="nav-link active" href="#tab-preflight-0" role="tab" aria-controls="tab-preflight-0" aria-selected="true">preflight</a></li>
	  </ul>
<div class="tab-content" id="tab-preflight"><div id="tab-preflight-0" class="tab-pane show active" role="tabpanel" aria-labelledby="tab-preflight-0">

<p><h3 id="概要">概要</h3>
<!--
Run pre-flight checks for kubeadm join.
-->
<p>运行 kubeadm join 命令添加节点前检查。</p>
<pre tabindex="0"><code>kubeadm join phase preflight [api-server-endpoint] [flags]
</code></pre><!--
### Examples
# Run join pre-flight checks using a config file.
-->
<h3 id="示例">示例</h3>
<pre tabindex="0"><code># 使用配置文件运行 kubeadm join 命令添加节点前检查。
kubeadm join phase preflight --config kubeadm-config.yml
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--apiserver-advertise-address string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
If the node should host a new control plane instance, the IP address the API Server will advertise it's listening on. If not set the default network interface will be used.
-->
对于将要托管新的控制平面实例的节点，指定 API 服务器将公布的其正在侦听的 IP 地址。如果未设置，则使用默认网络接口。
</td>
</tr>
<tr>
<td colspan="2">
<!--
--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: 6443
-->
--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：6443
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
If the node should host a new control plane instance, the port for the API Server to bind to.
-->
针对将要托管新的控制平面实例的节点，设置 API 服务器要绑定的端口。
</td>
</tr>
<tr>
<td colspan="2">--certificate-key string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Use this key to decrypt the certificate secrets uploaded by init.
-->
使用此密钥可以解密由 `init` 操作上传的证书 secret。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to kubeadm config file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">--control-plane</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Create a new control plane instance on this node
-->
在此节点上创建一个新的控制平面实例
</td>
</tr>
<tr>
<td colspan="2">--cri-socket string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to the CRI socket to connect. If empty kubeadm will try to auto-detect this value; use this option only if you have more than one CRI installed or if you have non-standard CRI socket.
-->
提供给 CRI 套接字建立连接的路径。如果为空，则 kubeadm 将尝试自动检测该值；仅当安装了多个 CRI 或具有非标准 CRI 套接字时，才使用此选项。
</td>
</tr>
<tr>
<td colspan="2">--discovery-file string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
For file-based discovery, a file or URL from which to load cluster information.
-->
对于基于文件的发现，给出用于加载集群信息的文件或者 URL。
</td>
</tr>
<tr>
<td colspan="2">--discovery-token string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
For token-based discovery, the token used to validate cluster information fetched from the API server.
-->
对于基于令牌的发现，该令牌用于验证从 API 服务器获取的集群信息。
</td>
</tr>
<tr>
<td colspan="2">--discovery-token-ca-cert-hash stringSlice</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
For token-based discovery, validate that the root CA public key matches this hash (format: "&lt;type&gt;:&lt;value&gt;").
-->
对于基于令牌的发现，验证根 CA 公钥是否匹配此哈希值（格式："&lt;type&gt;:&lt;value&gt;"）。
</td>
</tr>
<tr>
<td colspan="2">--discovery-token-unsafe-skip-ca-verification</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
For token-based discovery, allow joining without --discovery-token-ca-cert-hash pinning.
-->
对于基于令牌的发现，允许在未关联 --discovery-token-ca-cert-hash 参数的情况下添加节点。
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for preflight
-->
preflight 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">--ignore-preflight-errors stringSlice</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
A list of checks whose errors will be shown as warnings. Example: 'IsPrivilegedUser,Swap'. Value 'all' ignores errors from all checks.
-->
错误将显示为警告的检查列表；例如：'IsPrivilegedUser,Swap'。取值为 'all' 时将忽略检查中的所有错误。
</td>
</tr>
<tr>
<td colspan="2">--node-name string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Specify the node name.
-->
指定节点名称。
</td>
</tr>
<tr>
<td colspan="2">--tls-bootstrap-token string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Specify the token used to temporarily authenticate with the Kubernetes Control Plane while joining the node.
-->
指定在加入节点时用于临时通过 Kubernetes 控制平面进行身份验证的令牌。
</td>
</tr>
<tr>
<td colspan="2">--token string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Use this token for both discovery-token and tls-bootstrap-token when those values are not provided.
-->
如果未提供这些值，则将它们用于 discovery-token 令牌和 tls-bootstrap 令牌。
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div></div>

<h2 id="cmd-join-phase-control-plane-prepare">kubeadm join phase control-plane-prepare</h2>
<!--
Using this phase you can prepare a node for serving a control-plane.
-->
<p>使用此阶段，你可以准备一个作为控制平面的节点。</p>
<ul class="nav nav-tabs" id="tab-control-plane-prepare" role="tablist"><li class="nav-item"><a data-toggle="tab" class="nav-link active" href="#tab-control-plane-prepare-0" role="tab" aria-controls="tab-control-plane-prepare-0" aria-selected="true">control-plane-prepare</a></li>
	  
		<li class="nav-item"><a data-toggle="tab" class="nav-link" href="#tab-control-plane-prepare-1" role="tab" aria-controls="tab-control-plane-prepare-1">all</a></li>
		<li class="nav-item"><a data-toggle="tab" class="nav-link" href="#tab-control-plane-prepare-2" role="tab" aria-controls="tab-control-plane-prepare-2">download-certs</a></li>
		<li class="nav-item"><a data-toggle="tab" class="nav-link" href="#tab-control-plane-prepare-3" role="tab" aria-controls="tab-control-plane-prepare-3">certs</a></li>
		<li class="nav-item"><a data-toggle="tab" class="nav-link" href="#tab-control-plane-prepare-4" role="tab" aria-controls="tab-control-plane-prepare-4">kubeconfig</a></li>
		<li class="nav-item"><a data-toggle="tab" class="nav-link" href="#tab-control-plane-prepare-5" role="tab" aria-controls="tab-control-plane-prepare-5">control-plane</a></li></ul>
<div class="tab-content" id="tab-control-plane-prepare"><div id="tab-control-plane-prepare-0" class="tab-pane show active" role="tabpanel" aria-labelledby="tab-control-plane-prepare-0">

<p><h3 id="概要">概要</h3>
<!--
Prepare the machine for serving a control plane
-->
<p>准备为控制平面服务的机器</p>
<pre tabindex="0"><code>kubeadm join phase control-plane-prepare [flags]
</code></pre><!--
### Examples
-->
<!--
# Prepares the machine for serving a control plane
-->
<h3 id="示例">示例</h3>
<pre tabindex="0"><code># 准备为控制平面服务的机器
kubeadm join phase control-plane-prepare all
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for control-plane-prepare
-->
control-plane-prepare 操作的帮助命令
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令中继承的选项">从父命令中继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
  <div id="tab-control-plane-prepare-1" class="tab-pane" role="tabpanel" aria-labelledby="tab-control-plane-prepare-1">

<p><h3 id="概要">概要</h3>
<!--
Prepare the machine for serving a control plane
-->
<p>准备为控制平面服务的机器</p>
<pre tabindex="0"><code>kubeadm join phase control-plane-prepare all [api-server-endpoint] [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--apiserver-advertise-address string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
If the node should host a new control plane instance, the IP address the API Server will advertise it's listening on. If not set the default network interface will be used.
-->
如果该节点托管一个新的控制平面实例，则 API 服务器将公布其正在侦听的 IP 地址。如果未设置，则使用默认网络接口。
</td>
</tr>
<tr>
<td colspan="2">
<!--
--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: 6443
-->
--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：6443
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
If the node should host a new control plane instance, the port for the API Server to bind to.
-->
如果该节点托管一个新的控制平面实例，则为 API 服务器要绑定的端口。
</td>
</tr>
<tr>
<td colspan="2">--certificate-key string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Use this key to decrypt the certificate secrets uploaded by init.
-->
使用此密钥解密由 init 上传的证书 secrets。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to kubeadm config file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">--control-plane</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Create a new control plane instance on this node
-->
在此节点上创建一个新的控制平面实例
</td>
</tr>
<tr>
<td colspan="2">--discovery-file string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
For file-based discovery, a file or URL from which to load cluster information.
-->
对于基于文件的发现，给出用于加载集群信息的文件或者 URL。
</td>
</tr>
<tr>
<td colspan="2">--discovery-token string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
For token-based discovery, the token used to validate cluster information fetched from the API server.
-->
对于基于令牌的发现，该令牌用于验证从 API 服务器获取的集群信息。
</td>
</tr>
<tr>
<td colspan="2">--discovery-token-ca-cert-hash stringSlice</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
For token-based discovery, validate that the root CA public key matches this hash (format: "&lt;type&gt;:&lt;value&gt;").
-->
对于基于令牌的发现，请验证根 CA 公钥是否匹配此哈希值（格式："&lt;type&gt;:&lt;value&gt;"）。
</td>
</tr>
<tr>
<td colspan="2">--discovery-token-unsafe-skip-ca-verification</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
For token-based discovery, allow joining without --discovery-token-ca-cert-hash pinning.
-->
对于基于令牌的发现，允许在未关联 --discovery-token-ca-cert-hash 参数的情况下添加节点。
</td>
</tr>
<tr>
<td colspan="2">--experimental-patches string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--  
Path to a directory that contains files named "target[suffix][+patchtype].extension". For example, "kube-apiserver0+merge.yaml" or just "etcd.json". "patchtype" can be one of "strategic", "merge" or "json" and they match the patch formats supported by kubectl. The default "patchtype" is "strategic". "extension" must be either "json" or "yaml". "suffix" is an optional string that can be used to determine which patches are applied first alpha-numerically.
-->
包含名为 "target[suffix][+patchtype].extension" 的文件的目录的路径。
例如，"kube-apiserver0+merge.yaml" 或仅仅是 "etcd.json"。
"patchtype" 可以是 "strategic"、"merge" 或 "json" 之一，并且它们与 kubectl 支持的补丁格式匹配。
默认的 "patchtype" 为 "strategic"。 "extension" 必须为 "json" 或 "yaml"。 
"suffix" 是一个可选字符串，可用于确定首先按字母顺序应用哪些补丁。
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for all
-->
all 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">--node-name string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Specify the node name.
-->
指定节点名称。
</td>
</tr>
<tr>
<td colspan="2">--tls-bootstrap-token string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Specify the token used to temporarily authenticate with the Kubernetes Control Plane while joining the node.
-->
指定在加入节点时用于临时通过 Kubernetes 控制平面进行身份验证的令牌。
</td>
</tr>
<tr>
<td colspan="2">--token string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Use this token for both discovery-token and tls-bootstrap-token when those values are not provided.
-->
如果未提供这些值，则将它们用于 discovery-token 令牌和 tls-bootstrap 令牌。
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
  <div id="tab-control-plane-prepare-2" class="tab-pane" role="tabpanel" aria-labelledby="tab-control-plane-prepare-2">

<p><h3 id="概要">概要</h3>
<!--
[EXPERIMENTAL] Download certificates shared among control-plane nodes from the kubeadm-certs Secret
-->
<p>[实验]从 kubeadm-certs Secret 下载控制平面节点之间共享的证书</p>
<pre tabindex="0"><code>kubeadm join phase control-plane-prepare download-certs [api-server-endpoint] [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--certificate-key string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Use this key to decrypt the certificate secrets uploaded by init.
-->
使用此密钥可以解密由 init 上传的证书 secret。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to kubeadm config file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">--control-plane</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Create a new control plane instance on this node
-->
在此节点上创建一个新的控制平面实例
</td>
</tr>
<tr>
<td colspan="2">--discovery-file string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
For file-based discovery, a file or URL from which to load cluster information.
-->
对于基于文件的发现，给出用于加载集群信息的文件或者 URL。
</td>
</tr>
<tr>
<td colspan="2">--discovery-token string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
For token-based discovery, the token used to validate cluster information fetched from the API server.
-->
对于基于令牌的发现，该令牌用于验证从 API 服务器获取的集群信息。
</td>
</tr>
<tr>
<td colspan="2">--discovery-token-ca-cert-hash stringSlice</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
For token-based discovery, validate that the root CA public key matches this hash (format: "&lt;type&gt;:&lt;value&gt;").
-->
对于基于令牌的发现，请验证根 CA 公钥是否匹配此哈希值（格式："&lt;type&gt;:&lt;value&gt;"）。
</td>
</tr>
<tr>
<td colspan="2">--discovery-token-unsafe-skip-ca-verification</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
For token-based discovery, allow joining without --discovery-token-ca-cert-hash pinning.
-->
对于基于令牌的发现，允许在未关联 --discovery-token-ca-cert-hash 参数的情况下添加节点。
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for kubeconfig
-->
kubeconfig 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">--tls-bootstrap-token string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Specify the token used to temporarily authenticate with the Kubernetes Control Plane while joining the node.
-->
指定在加入节点时用于临时通过 Kubernetes 控制平面进行身份验证的令牌。
</td>
</tr>
<tr>
<td colspan="2">--token string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Use this token for both discovery-token and tls-bootstrap-token when those values are not provided.
-->
如果未提供这些值，则将它们用于 discovery-token 令牌和 tls-bootstrap 令牌。
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令中继承的选项">从父命令中继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
  <div id="tab-control-plane-prepare-3" class="tab-pane" role="tabpanel" aria-labelledby="tab-control-plane-prepare-3">

<p><h3 id="概要">概要</h3>
<!--
Generate the certificates for the new control plane components
-->
<p>为新的控制平面组件生成证书</p>
<pre tabindex="0"><code>kubeadm join phase control-plane-prepare certs [api-server-endpoint] [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--apiserver-advertise-address string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
If the node should host a new control plane instance, the IP address the API Server will advertise it's listening on. If not set the default network interface will be used.
-->
如果该节点托管一个新的控制平面实例，则 API 服务器将公布其正在侦听的 IP 地址。如果未设置，则使用默认网络接口。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to kubeadm config file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">--control-plane</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Create a new control plane instance on this node
-->
在此节点上创建一个新的控制平面实例
</td>
</tr>
<tr>
<td colspan="2">--discovery-file string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
For file-based discovery, a file or URL from which to load cluster information.
-->
对于基于文件的发现，给出用于加载集群信息的文件或者 URL。
</td>
</tr>
<tr>
<td colspan="2">--discovery-token string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
For token-based discovery, the token used to validate cluster information fetched from the API server.
-->
对于基于令牌的发现，该令牌用于验证从 API 服务器获取的集群信息。
</td>
</tr>
<tr>
<td colspan="2">--discovery-token-ca-cert-hash stringSlice</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
For token-based discovery, validate that the root CA public key matches this hash (format: "&lt;type&gt;:&lt;value&gt;").
-->
对于基于令牌的发现，请验证根 CA 公钥是否匹配此哈希值（格式："&lt;type&gt;:&lt;value&gt;"）。
</td>
</tr>
<tr>
<td colspan="2">--discovery-token-unsafe-skip-ca-verification</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
For token-based discovery, allow joining without --discovery-token-ca-cert-hash pinning.
-->
对于基于令牌的发现，允许在未关联 --discovery-token-ca-cert-hash 参数的情况下添加节点。
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for certs
-->
certs 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">--node-name string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Specify the node name.
-->
指定节点名称。
</td>
</tr>
<tr>
<td colspan="2">--tls-bootstrap-token string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Specify the token used to temporarily authenticate with the Kubernetes Control Plane while joining the node.
-->
指定在加入节点时用于临时通过 Kubernetes 控制平面进行身份验证的令牌。
</td>
</tr>
<tr>
<td colspan="2">--token string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Use this token for both discovery-token and tls-bootstrap-token when those values are not provided.
-->
如果未提供这些值，则将它们用于 discovery-token 令牌和 tls-bootstrap 令牌。
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
  <div id="tab-control-plane-prepare-4" class="tab-pane" role="tabpanel" aria-labelledby="tab-control-plane-prepare-4">

<p><h3 id="概要">概要</h3>
<!--
Generate the kubeconfig for the new control plane components
-->
<p>为新的控制平面组件生成 kubeconfig</p>
<pre tabindex="0"><code>kubeadm join phase control-plane-prepare kubeconfig [api-server-endpoint] [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--certificate-key string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Use this key to decrypt the certificate secrets uploaded by init.
-->
使用此密钥可以解密由 init 上传的证书 secret。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to kubeadm config file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">--control-plane</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Create a new control plane instance on this node
-->
在此节点上创建一个新的控制平面实例
</td>
</tr>
<tr>
<td colspan="2">--discovery-file string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
For file-based discovery, a file or URL from which to load cluster information.
-->
对于基于文件的发现，给出用于加载集群信息的文件或者 URL。
</td>
</tr>
<tr>
<td colspan="2">--discovery-token string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
For token-based discovery, the token used to validate cluster information fetched from the API server.
-->
对于基于令牌的发现，该令牌用于验证从 API 服务器获取的集群信息。
</td>
</tr>
<tr>
<td colspan="2">--discovery-token-ca-cert-hash stringSlice</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
For token-based discovery, validate that the root CA public key matches this hash (format: "&lt;type&gt;:&lt;value&gt;").
-->
对于基于令牌的发现，请验证根 CA 公钥是否匹配此哈希值（格式："&lt;type&gt;:&lt;value&gt;"）。
</td>
</tr>
<tr>
<td colspan="2">--discovery-token-unsafe-skip-ca-verification</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
For token-based discovery, allow joining without --discovery-token-ca-cert-hash pinning.
-->
对于基于令牌的发现，允许在未关联 --discovery-token-ca-cert-hash 参数的情况下添加节点。
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for kubeconfig
-->
kubeconfig 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">--tls-bootstrap-token string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Specify the token used to temporarily authenticate with the Kubernetes Control Plane while joining the node.
-->
指定在加入节点时用于临时通过 Kubernetes 控制平面进行身份验证的令牌。
</td>
</tr>
<tr>
<td colspan="2">--token string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Use this token for both discovery-token and tls-bootstrap-token when those values are not provided.
-->
如果未提供这些值，则将它们用于 discovery-token 令牌和 tls-bootstrap 令牌。
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令中继承的选项">从父命令中继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
  <div id="tab-control-plane-prepare-5" class="tab-pane" role="tabpanel" aria-labelledby="tab-control-plane-prepare-5">

<p><h3 id="概要">概要</h3>
<!--
Generate the manifests for the new control plane components
-->
<p>为新的控制平面组件生成清单（manifest）</p>
<pre tabindex="0"><code>kubeadm join phase control-plane-prepare control-plane [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--apiserver-advertise-address string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
If the node should host a new control plane instance, the IP address the API Server will advertise it's listening on. If not set the default network interface will be used.
-->
对于将要托管新的控制平面实例的节点，指定 API 服务器将公布的其正在侦听的 IP 地址。如果未设置，则使用默认网络接口。
</td>
</tr>
<tr>
<td colspan="2">
<!--
--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: 6443
-->
--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：6443
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
If the node should host a new control plane instance, the port for the API Server to bind to.
-->
针对将要托管新的控制平面实例的节点，设置 API 服务器要绑定的端口。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to kubeadm config file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">--control-plane</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Create a new control plane instance on this node
-->
在此节点上创建一个新的控制平面实例
</td>
</tr>
<tr>
<td colspan="2">--experimental-patches string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--  
Path to a directory that contains files named "target[suffix][+patchtype].extension". For example, "kube-apiserver0+merge.yaml" or just "etcd.json". "patchtype" can be one of "strategic", "merge" or "json" and they match the patch formats supported by kubectl. The default "patchtype" is "strategic". "extension" must be either "json" or "yaml". "suffix" is an optional string that can be used to determine which patches are applied first alpha-numerically.
-->
包含名为 "target[suffix][+patchtype].extension" 的文件的目录的路径。
例如，"kube-apiserver0+merge.yaml" 或仅仅是 "etcd.json"。
"patchtype" 可以是 "strategic"、"merge" 或 "json" 之一，并且它们与 kubectl 支持的补丁格式匹配。
默认的 "patchtype" 为 "strategic"。 "extension" 必须为 "json" 或 "yaml"。 
"suffix" 是一个可选字符串，可用于确定首先按字母顺序应用哪些补丁。
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for control-plane
-->
control-plane 操作的帮助命令
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令中继承的选项">从父命令中继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div></div>

<h2 id="cmd-join-phase-kubelet-start">kubeadm join phase kubelet-start</h2>
<!--
Using this phase you can write the kubelet settings, certificates and (re)start the kubelet.
-->
<p>使用此阶段，你可以配置 kubelet 设置、证书和（重新）启动 kubelet。</p>
<ul class="nav nav-tabs" id="tab-kubelet-start" role="tablist"><li class="nav-item"><a data-toggle="tab" class="nav-link active" href="#tab-kubelet-start-0" role="tab" aria-controls="tab-kubelet-start-0" aria-selected="true">kubelet-start</a></li>
	  </ul>
<div class="tab-content" id="tab-kubelet-start"><div id="tab-kubelet-start-0" class="tab-pane show active" role="tabpanel" aria-labelledby="tab-kubelet-start-0">

<p><h3 id="概要">概要</h3>
<!--
Write a file with KubeletConfiguration and an environment file with node specific kubelet settings, and then (re)start kubelet.
-->
<p>生成一个包含 KubeletConfiguration 的文件和一个包含特定于节点的 kubelet 配置的环境文件，然后（重新）启动 kubelet。</p>
<pre tabindex="0"><code>kubeadm join phase kubelet-start [api-server-endpoint] [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to kubeadm config file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">--cri-socket string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to the CRI socket to connect. If empty kubeadm will try to auto-detect this value; use this option only if you have more than one CRI installed or if you have non-standard CRI socket.
-->
提供给 CRI 套接字建立连接的路径。如果为空，则 kubeadm 将尝试自动检测该值；仅当安装了多个 CRI 或具有非标准 CRI 套接字时，才使用此选项。
</td>
</tr>
<tr>
<td colspan="2">--discovery-file string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
For file-based discovery, a file or URL from which to load cluster information.
<!--
For file-based discovery, a file or URL from which to load cluster information.
-->
对于基于文件的发现，给出用于加载集群信息的文件或者 URL。
</td>
</tr>
<tr>
<td colspan="2">--discovery-token string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
For token-based discovery, the token used to validate cluster information fetched from the API server.
-->
对于基于令牌的发现，该令牌用于验证从 API 服务器获取的集群信息。
</td>
</tr>
<tr>
<td colspan="2">--discovery-token-ca-cert-hash stringSlice</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
For token-based discovery, validate that the root CA public key matches this hash (format: "&lt;type&gt;:&lt;value&gt;").
-->
对于基于令牌的发现，验证根 CA 公钥是否匹配此哈希值（格式："&lt;type&gt;:&lt;value&gt;"）。
</td>
</tr>
<tr>
<td colspan="2">--discovery-token-unsafe-skip-ca-verification</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
For token-based discovery, allow joining without --discovery-token-ca-cert-hash pinning.
-->
对于基于令牌的发现，允许在未关联 --discovery-token-ca-cert-hash 参数的情况下添加节点。
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for kubelet-start
-->
kubelet-start 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">--node-name string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Specify the node name.
-->
指定节点名称。
</td>
</tr>
<tr>
<td colspan="2">--tls-bootstrap-token string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Specify the token used to temporarily authenticate with the Kubernetes Control Plane while joining the node.
-->
指定在加入节点时用于临时通过 Kubernetes 控制平面进行身份验证的令牌。
</td>
</tr>
<tr>
<td colspan="2">--token string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Use this token for both discovery-token and tls-bootstrap-token when those values are not provided.
-->
如果未提供这些值，则将它们用于 discovery-token 令牌和 tls-bootstrap 令牌。
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div></div>

<h2 id="cmd-join-phase-control-plane-join">kubeadm join phase control-plane-join</h2>
<!--
Using this phase you can join a node as a control-plane instance.
-->
<p>使用此阶段，你可以将节点作为控制平面实例加入。</p>
<ul class="nav nav-tabs" id="tab-control-plane-join" role="tablist"><li class="nav-item"><a data-toggle="tab" class="nav-link active" href="#tab-control-plane-join-0" role="tab" aria-controls="tab-control-plane-join-0" aria-selected="true">control-plane-join</a></li>
	  
		<li class="nav-item"><a data-toggle="tab" class="nav-link" href="#tab-control-plane-join-1" role="tab" aria-controls="tab-control-plane-join-1">all</a></li>
		<li class="nav-item"><a data-toggle="tab" class="nav-link" href="#tab-control-plane-join-2" role="tab" aria-controls="tab-control-plane-join-2">etcd</a></li>
		<li class="nav-item"><a data-toggle="tab" class="nav-link" href="#tab-control-plane-join-3" role="tab" aria-controls="tab-control-plane-join-3">update-status</a></li>
		<li class="nav-item"><a data-toggle="tab" class="nav-link" href="#tab-control-plane-join-4" role="tab" aria-controls="tab-control-plane-join-4">mark-control-plane</a></li></ul>
<div class="tab-content" id="tab-control-plane-join"><div id="tab-control-plane-join-0" class="tab-pane show active" role="tabpanel" aria-labelledby="tab-control-plane-join-0">

<p><h3 id="概要">概要</h3>
<!--
Join a machine as a control plane instance
-->
<p>添加作为控制平面实例的机器</p>
<pre tabindex="0"><code>kubeadm join phase control-plane-join [flags]
</code></pre><!--
### Examples
-->
<h3 id="示例">示例</h3>
<!--
```
# Joins a machine as a control plane instance
kubeadm join phase control-plane-join all
```
-->
<pre tabindex="0"><code># 将机器作为控制平面实例加入
kubeadm join phase control-plane-join all
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for control-plane-join
-->
control-plane-join 操作的帮助命令
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令中继承的选项">从父命令中继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
  <div id="tab-control-plane-join-1" class="tab-pane" role="tabpanel" aria-labelledby="tab-control-plane-join-1">

<p><h3 id="概要">概要</h3>
<!--
Joins a machine as a control plane instance
-->
<p>添加作为控制平面实例的机器</p>
<pre tabindex="0"><code>kubeadm join phase control-plane-join all [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--apiserver-advertise-address string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
If the node should host a new control plane instance, the IP address the API Server will advertise it's listening on. If not set the default network interface will be used.
-->
如果该节点托管一个新的控制平面实例，则 API 服务器将公布其正在侦听的 IP 地址。如果未设置，则使用默认网络接口。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to kubeadm config file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">--experimental-control-plane</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Create a new control plane instance on this node
-->
在此节点上创建一个新的控制平面实例
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for all
-->
all 操作的帮助命令      
</td>
</tr>
<tr>
<td colspan="2">--node-name string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Specify the node name.
-->
指定节点名称。
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
  <div id="tab-control-plane-join-2" class="tab-pane" role="tabpanel" aria-labelledby="tab-control-plane-join-2">

<p><h3 id="概要">概要</h3>
<!--
Add a new local etcd member
-->
<p>添加新的本地 etcd 成员</p>
<pre tabindex="0"><code>kubeadm join phase control-plane-join etcd [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--apiserver-advertise-address string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
If the node should host a new control plane instance, the IP address the API Server will advertise it's listening on. If not set the default network interface will be used.
-->
如果该节点托管一个新的控制平面实例，则 API 服务器将公布其正在侦听的 IP 地址。如果未设置，则使用默认网络接口。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to kubeadm configuration file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">--control-plane</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Create a new control plane instance on this node
-->
在此节点上创建一个新的控制平面实例
</td>
</tr>
<tr>
<td colspan="2">--experimental-patches string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--  
Path to a directory that contains files named "target[suffix][+patchtype].extension". For example, "kube-apiserver0+merge.yaml" or just "etcd.json". "patchtype" can be one of "strategic", "merge" or "json" and they match the patch formats supported by kubectl. The default "patchtype" is "strategic". "extension" must be either "json" or "yaml". "suffix" is an optional string that can be used to determine which patches are applied first alpha-numerically.
-->
包含名为 "target[suffix][+patchtype].extension" 的文件的目录的路径。
例如，"kube-apiserver0+merge.yaml" 或仅仅是 "etcd.json"。
"patchtype" 可以是"strategic"、"merge" 或 "json" 之一，并且它们与 kubectl 支持的补丁格式匹配。
默认的 "patchtype" 为 "strategic"。 "extension" 必须为 "json" 或 "yaml"。 
"suffix" 是一个可选字符串，可用于确定首先按字母顺序应用哪些补丁。
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for etcd
-->
etcd 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">--node-name string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Specify the node name.
-->
指定节点的名称
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令中继承的选项">从父命令中继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
  <div id="tab-control-plane-join-3" class="tab-pane" role="tabpanel" aria-labelledby="tab-control-plane-join-3">

<p><h2 id="概要">概要</h2>
<!-- 
Register the new control-plane node into the ClusterStatus maintained in the kubeadm-config ConfigMap 
-->
<p>将新的控制平面节点注册到 kubeadm-config ConfigMap 维护的 ClusterStatus 中</p>
<pre tabindex="0"><code>kubeadm join phase control-plane-join update-status [flags]
</code></pre><!-- 
### Options 
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--apiserver-advertise-address string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
If the node should host a new control plane instance, the IP address the API Server will advertise it's listening on. If not set the default network interface will be used.
-->
如果该节点托管一个新的控制平面实例，则 API 服务器将公布其正在侦听的 IP 地址。如果未设置，则使用默认网络接口。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- Path to kubeadm config file.  -->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">--control-plane</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- Create a new control plane instance on this node -->
在此节点上创建一个新的控制平面实例
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- help for update-status -->
update-status 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">--node-name string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- Specify the node name.  -->
指定节点名称。
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令中继承的选项">从父命令中继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- [EXPERIMENTAL] The path to the 'real' host root filesystem.  -->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
  <div id="tab-control-plane-join-4" class="tab-pane" role="tabpanel" aria-labelledby="tab-control-plane-join-4">

<p><h3 id="概要">概要</h3>
<!--
Mark a node as a control-plane
-->
<p>将 Node 节点标记为控制平面节点</p>
<pre tabindex="0"><code>kubeadm join phase control-plane-join mark-control-plane [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to kubeadm configuration file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">--control-plane</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Create a new control plane instance on this node
-->
在此节点上创建一个新的控制平面实例
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for mark-control-plane
-->
mark-control-plane 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">--node-name string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Specify the node name.
-->
指定节点的名称
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令中继承的选项">从父命令中继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div></div>

<h2 id="接下来">接下来</h2>
<!--
* [kubeadm init](/docs/reference/setup-tools/kubeadm/kubeadm-init/) to bootstrap a Kubernetes control-plane node
* [kubeadm join](/docs/reference/setup-tools/kubeadm/kubeadm-join/) to connect a node to the cluster
* [kubeadm reset](/docs/reference/setup-tools/kubeadm/kubeadm-reset/) to revert any changes made to this host by `kubeadm init` or `kubeadm join`
* [kubeadm alpha](/docs/reference/setup-tools/kubeadm/kubeadm-alpha/) to try experimental functionality
-->
<ul>
<li><a href="/zh/docs/reference/setup-tools/kubeadm/kubeadm-init/">kubeadm init</a>
引导 Kubernetes 控制平面节点</li>
<li><a href="/zh/docs/reference/setup-tools/kubeadm/kubeadm-join/">kubeadm join</a>
将节点添加到集群</li>
<li><a href="/zh/docs/reference/setup-tools/kubeadm/kubeadm-reset/">kubeadm reset</a>
恢复通过 <code>kubeadm init</code> 或 <code>kubeadm join</code> 操作对主机所做的任何更改</li>
<li><a href="/zh/docs/reference/setup-tools/kubeadm/kubeadm-alpha/">kubeadm alpha</a>
尝试实验性功能</li>
</ul>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-b969d0033ce5d9036463521fb1f150b3">7.1.13 - kubeadm reset phase</h1>
    
	<!--
title: kubeadm reset phase
content_type: concept
weight: 90
-->
<!--
`kubeadm reset phase` enables you to invoke atomic steps of the node reset process.
Hence, you can let kubeadm do some of the work and you can fill in the gaps
if you wish to apply customization.
-->
<p><code>kubeadm reset phase</code> 使你能够调用 <code>reset</code> 过程的基本原子步骤。
因此，如果希望执行自定义操作，可以让 kubeadm 做一些工作，然后由用户来补足剩余操作。</p>
<!--
`kubeadm reset phase` is consistent with the [kubeadm reset workflow](/docs/reference/setup-tools/kubeadm/kubeadm-reset/#reset-workflow),
and behind the scene both use the same code.
-->
<p><code>kubeadm reset phase</code> 与
<a href="/zh/docs/reference/setup-tools/kubeadm/kubeadm-reset/#reset-workflow">kubeadm reset 工作流程</a>
一致，后台都使用相同的代码。</p>
<h2 id="cmd-reset-phase">kubeadm reset phase</h2>
<ul class="nav nav-tabs" id="tab-phase" role="tablist"><li class="nav-item"><a data-toggle="tab" class="nav-link active" href="#tab-phase-0" role="tab" aria-controls="tab-phase-0" aria-selected="true">phase</a></li>
	  </ul>
<div class="tab-content" id="tab-phase"><div id="tab-phase-0" class="tab-pane show active" role="tabpanel" aria-labelledby="tab-phase-0">

<p><h3 id="概要">概要</h3>
<!--
Use this command to invoke single phase of the reset workflow
-->
<p>使用此命令来调用 <code>reset</code> 工作流程的某个阶段</p>
<!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for phase
-->
phase 操作的帮助命令
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div></div>

<h2 id="cmd-reset-phase-preflight">kubeadm reset phase preflight</h2>
<!--
Using this phase you can execute preflight checks on a node that is being reset.
-->
<p>使用此阶段，你可以在要重置的节点上执行启动前检查阶段。</p>
<ul class="nav nav-tabs" id="tab-preflight" role="tablist"><li class="nav-item"><a data-toggle="tab" class="nav-link active" href="#tab-preflight-0" role="tab" aria-controls="tab-preflight-0" aria-selected="true">preflight</a></li>
	  </ul>
<div class="tab-content" id="tab-preflight"><div id="tab-preflight-0" class="tab-pane show active" role="tabpanel" aria-labelledby="tab-preflight-0">

<p><h3 id="概要">概要</h3>
<!--
Run pre-flight checks for kubeadm reset.
-->
<p>kubeadm reset（重置）前运行启动前检查。</p>
<pre tabindex="0"><code>kubeadm reset phase preflight [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">-f, --force</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Reset the node without prompting for confirmation.
-->
在不提示确认的情况下重置节点。
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for preflight
-->
preflight 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">--ignore-preflight-errors stringSlice</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
A list of checks whose errors will be shown as warnings. Example: 'IsPrivilegedUser,Swap'. Value 'all' ignores errors from all checks.
-->
错误将显示为警告的检查列表；例如：'IsPrivilegedUser,Swap'。取值为 'all' 时将忽略检查中的所有错误。
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div></div>

<!--
## kubeadm reset phase update-cluster-status
-->
<h2 id="cmd-reset-phase-update-cluster-status">kubeadm reset phase update-cluster-status</h2>
<!--
Using this phase you can remove this control-plane node from the ClusterStatus object.
-->
<p>使用此阶段，你可以从 ClusterStatus 对象中删除此控制平面节点。</p>
<ul class="nav nav-tabs" id="tab-update-cluster-status" role="tablist"><li class="nav-item"><a data-toggle="tab" class="nav-link active" href="#tab-update-cluster-status-0" role="tab" aria-controls="tab-update-cluster-status-0" aria-selected="true">update-cluster-status</a></li>
	  </ul>
<div class="tab-content" id="tab-update-cluster-status"><div id="tab-update-cluster-status-0" class="tab-pane show active" role="tabpanel" aria-labelledby="tab-update-cluster-status-0">

<p><h3 id="概要">概要</h3>
<!--
Remove this node from the ClusterStatus object if the node is a control plane node.
-->
<p>如果该节点是控制平面节点，从 ClusterStatus 对象中删除该节点。</p>
<pre tabindex="0"><code>kubeadm reset phase update-cluster-status [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- help for update-cluster-status -->
update-cluster-status 操作的帮助命令
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- [EXPERIMENTAL] The path to the 'real' host root filesystem.  -->
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div></div>

<!--
## kubeadm reset phase remove-etcd-member
-->
<h2 id="cmd-reset-phase-remove-etcd-member">kubeadm reset phase remove-etcd-member</h2>
<!--
Using this phase you can remove this control-plane node's etcd member from the etcd cluster.
-->
<p>使用此阶段，你可以从 etcd 集群中删除此控制平面节点的 etcd 成员。</p>
<ul class="nav nav-tabs" id="tab-remove-etcd-member" role="tablist"><li class="nav-item"><a data-toggle="tab" class="nav-link active" href="#tab-remove-etcd-member-0" role="tab" aria-controls="tab-remove-etcd-member-0" aria-selected="true">remove-etcd-member</a></li>
	  </ul>
<div class="tab-content" id="tab-remove-etcd-member"><div id="tab-remove-etcd-member-0" class="tab-pane show active" role="tabpanel" aria-labelledby="tab-remove-etcd-member-0">

<p><h3 id="概要">概要</h3>
<!--
Upload configuration about the current state, so that 'kubeadm upgrade' can later know how to configure the upgraded cluster.
-->
<p>上传关于当前状态的配置，以便 'kubeadm upgrade' 以后可以知道如何配置升级后的集群。</p>
<pre tabindex="0"><code>kubeadm config upload [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">upload 操作的帮助信息</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<!-- td colspan="2">kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"</td -->
<td colspan="2">--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值： "/etc/kubernetes/admin.conf"</td>
</tr>
<tr>
<!-- td></td><td style="line-height: 130%; word-wrap: break-word;">The KubeConfig file to use when talking to the cluster. If the flag is not set, a set of standard locations are searched for an existing KubeConfig file.</td -->
<td></td><td style="line-height: 130%; word-wrap: break-word;">用于和集群通信的 KubeConfig 文件。如果它没有被设置，那么 kubeadm 将会搜索一个已经存在于标准路径的 KubeConfig 文件。</td>
</tr>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<!-- td></td><td style="line-height: 130%; word-wrap: break-word;">[EXPERIMENTAL] The path to the 'real' host root filesystem.</td -->
<td></td><td style="line-height: 130%; word-wrap: break-word;">[实验] 到'真实'主机根文件系统的路径。</td>
</tr>
</tbody>
</table>
</div></div>

<!--
## kubeadm reset phase cleanup-node
-->
<h2 id="cmd-reset-phase-cleanup-node">kubeadm reset phase cleanup-node</h2>
<!--
Using this phase you can perform cleanup on this node.
-->
<p>使用此阶段，你可以在此节点上执行清理工作。</p>
<ul class="nav nav-tabs" id="tab-cleanup-node" role="tablist"><li class="nav-item"><a data-toggle="tab" class="nav-link active" href="#tab-cleanup-node-0" role="tab" aria-controls="tab-cleanup-node-0" aria-selected="true">cleanup-node</a></li>
	  </ul>
<div class="tab-content" id="tab-cleanup-node"><div id="tab-cleanup-node-0" class="tab-pane show active" role="tabpanel" aria-labelledby="tab-cleanup-node-0">

<p><h3 id="概要">概要</h3>
<!--
Run cleanup node.
-->
<p>执行 cleanup node（清理节点）操作。</p>
<pre tabindex="0"><code>kubeadm reset phase cleanup-node [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">
<!--
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"
-->
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The path to the directory where the certificates are stored. If specified, clean this directory.
-->
存储证书的目录路径。如果已指定，则需要清空此目录。
</td>
</tr>
<tr>
<td colspan="2">--cri-socket string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to the CRI socket to connect. If empty kubeadm will try to auto-detect this value; use this option only if you have more than one CRI installed or if you have non-standard CRI socket.
-->
要连接的 CRI 套接字的路径。如果为空，则 kubeadm 将尝试自动检测此值；仅当安装了多个CRI 或具有非标准 CRI 插槽时，才使用此选项。
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for cleanup-node
-->
cleanup-node 操作的帮助命令
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div></div>

<h2 id="接下来">接下来</h2>
<!--
* [kubeadm init](/docs/reference/setup-tools/kubeadm/kubeadm-init/) to bootstrap a Kubernetes control-plane node
* [kubeadm join](/docs/reference/setup-tools/kubeadm/kubeadm-join/) to connect a node to the cluster
* [kubeadm reset](/docs/reference/setup-tools/kubeadm/kubeadm-reset/) to revert any changes made to this host by `kubeadm init` or `kubeadm join`
* [kubeadm alpha](/docs/reference/setup-tools/kubeadm/kubeadm-alpha/) to try experimental functionality
-->
<ul>
<li><a href="/zh/docs/reference/setup-tools/kubeadm/kubeadm-init/">kubeadm init</a>
引导 Kubernetes 控制平面节点</li>
<li><a href="/zh/docs/reference/setup-tools/kubeadm/kubeadm-join/">kubeadm join</a>
将节点添加到集群</li>
<li><a href="/zh/docs/reference/setup-tools/kubeadm/kubeadm-reset/">kubeadm reset</a>
恢复通过 <code>kubeadm init</code> 或 <code>kubeadm join</code> 操作对主机所做的任何更改</li>
<li><a href="/zh/docs/reference/setup-tools/kubeadm/kubeadm-alpha/">kubeadm alpha</a>
尝试实验性功能</li>
</ul>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-dfd085b5ab706bd84dda15847dd27f1b">7.1.14 - kubeadm upgrade phase</h1>
    
	<!--
In v1.15.0, kubeadm introduced preliminary support for `kubeadm upgrade node` phases.
Phases for other `kubeadm upgrade` sub-commands such as `apply`, could be added in the
following releases.
-->
<p>在 Kubernetes v1.15.0 版本中，kubeadm 引入了对 <code>kubeadm upgrade node</code> 阶段的初步支持。其他 <code>kubeadm upgrade</code> 子命令如 <code>apply</code> 等阶段将在未来发行版中添加。</p>
<!--
## kubeadm upgrade node phase {#cmd-node-phase}
-->
<h2 id="cmd-node-phase">kubeadm upgrade node phase</h2>
<!--
Using this phase you can choose to execute the separate steps of the upgrade of
secondary control-plane or worker nodes. Please note that `kubeadm upgrade apply` still has to
be called on a primary control-plane node.
-->
<p>使用此阶段，可以选择执行辅助控制平面或工作节点升级的单独步骤。请注意，<code>kubeadm upgrade apply</code> 命令仍然必须在主控制平面节点上调用。</p>
<ul class="nav nav-tabs" id="tab-phase" role="tablist"><li class="nav-item"><a data-toggle="tab" class="nav-link active" href="#tab-phase-0" role="tab" aria-controls="tab-phase-0" aria-selected="true">phase</a></li>
	  
		<li class="nav-item"><a data-toggle="tab" class="nav-link" href="#tab-phase-1" role="tab" aria-controls="tab-phase-1">preflight</a></li>
		<li class="nav-item"><a data-toggle="tab" class="nav-link" href="#tab-phase-2" role="tab" aria-controls="tab-phase-2">control-plane</a></li>
		<li class="nav-item"><a data-toggle="tab" class="nav-link" href="#tab-phase-3" role="tab" aria-controls="tab-phase-3">kubelet-config</a></li></ul>
<div class="tab-content" id="tab-phase"><div id="tab-phase-0" class="tab-pane show active" role="tabpanel" aria-labelledby="tab-phase-0">

<p><h3 id="概要">概要</h3>
<!--
Use this command to invoke single phase of the node workflow
-->
<p>使用此命令调用 node 工作流的某个阶段</p>
<!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for phase
-->
phase 操作的帮助命令
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
  <div id="tab-phase-1" class="tab-pane" role="tabpanel" aria-labelledby="tab-phase-1">

<p><p>执行 kubeadm 升级节点的预检。</p>
<pre tabindex="0"><code>kubeadm upgrade node phase preflight [flags]
</code></pre><!-- ### Options -->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<!-- <td></td><td style="line-height: 130%; word-wrap: break-word;">help for preflight</td> -->
<td></td><td style="line-height: 130%; word-wrap: break-word;">preflight 操作的帮助命令</td>
</tr>
<tr>
<td colspan="2">--ignore-preflight-errors stringSlice</td>
</tr>
<tr>
<!-- 
<td></td><td style="line-height: 130%; word-wrap: break-word;">A list of checks whose errors will be shown as warnings. Example: 'IsPrivilegedUser,Swap'. Value 'all' ignores errors from all checks.</td> 
-->
<td></td><td style="line-height: 130%; word-wrap: break-word;">错误将显示为警告的检查清单。示例：'IsPrivilegedUser,Swap'。值为'all'表示忽略所有检查的错误。</td>
</tr>
</tbody>
</table>
<!-- ### Options inherited from parent commands -->
<h3 id="继承于父命令的选项">继承于父命令的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<!-- <td></td><td style="line-height: 130%; word-wrap: break-word;">[EXPERIMENTAL] The path to the 'real' host root filesystem.</td> -->
<td></td><td style="line-height: 130%; word-wrap: break-word;">[实验] 到'真实'主机根文件系统的路径。</td>
</tr>
</tbody>
</table>
</div>
  <div id="tab-phase-2" class="tab-pane" role="tabpanel" aria-labelledby="tab-phase-2">

<p><h3 id="概要">概要</h3>
<!--
Upgrade the control plane instance deployed on this node, if any
-->
<p>升级部署在此节点上的控制平面实例，如果有的话</p>
<pre tabindex="0"><code>kubeadm upgrade node phase control-plane [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--certificate-renewal</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">更新在升级期间变更的组件使用的证书。</td>
</tr>
<!-- 
<td></td><td style="line-height: 130%; word-wrap: break-word;">Perform the renewal of certificates used by component changed during upgrades.</td>
-->
<tr>
<td colspan="2">--dry-run</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">不改变任何状态，只输出将要执行的动作。</td>
</tr>
<!--
<td></td><td style="line-height: 130%; word-wrap: break-word;">Do not change any state, just output the actions that would be performed.</td>
-->
<tr>
<td colspan="2">--etcd-upgrade&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值: true</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">执行 etcd 的升级。</td>
</tr>
<!--
<td colspan="2">--etcd-upgrade&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: true</td> 
-->
<!--
<td></td><td style="line-height: 130%; word-wrap: break-word;">Perform the upgrade of etcd.</td>
-->
<tr>
<td colspan="2">--experimental-patches string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--  
Path to a directory that contains files named "target[suffix][+patchtype].extension". For example, "kube-apiserver0+merge.yaml" or just "etcd.json". "patchtype" can be one of "strategic", "merge" or "json" and they match the patch formats supported by kubectl. The default "patchtype" is "strategic". "extension" must be either "json" or "yaml". "suffix" is an optional string that can be used to determine which patches are applied first alpha-numerically.
-->
包含名为 "target[suffix][+patchtype].extension" 的文件的目录的路径。
例如，"kube-apiserver0+merge.yaml" 或仅仅是 "etcd.json"。
"patchtype" 可以是 "strategic"、"merge" 或 "json" 之一，并且它们与 kubectl 支持的补丁格式匹配。
默认的 "patchtype" 为 "strategic"。 "extension" 必须为 "json" 或 "yaml"。 
"suffix" 是一个可选字符串，可用于确定首先按字母顺序应用哪些补丁。
</td>
</tr>
<!--
<td></td><td style="line-height: 130%; word-wrap: break-word;">The path where kustomize patches for static pod manifests are stored.</td>
-->
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">control-plane 的帮助信息</td>
</tr>
<!--
<td></td><td style="line-height: 130%; word-wrap: break-word;">help for control-plane</td>
-->
<tr>
<td colspan="2">--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值: "/etc/kubernetes/admin.conf"</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">用于和集群通信的 KubeConfig 文件。如果它没有被设置，那么 kubeadm 将会搜索一个已经存在于标准路径的 KubeConfig 文件。</td>
</tr>
<!--
<td colspan="2">--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"</td>
-->
<!--
<td></td><td style="line-height: 130%; word-wrap: break-word;">The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.</td>
-->
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">[实验] 到'真实'主机根文件系统的路径。</td>
</tr>
<!--
<td></td><td style="line-height: 130%; word-wrap: break-word;">[EXPERIMENTAL] The path to the 'real' host root filesystem.</td>
-->
</tbody>
</table>
</div>
  <div id="tab-phase-3" class="tab-pane" role="tabpanel" aria-labelledby="tab-phase-3">

<p><p>从群集中 &quot;kubelet-config-1.X&quot; 的 ConfigMap 下载 kubelet 配置，其中 X 是kubelet 的次要版本。
kubeadm 使用 --kubelet-version 参数来确定所需的 kubelet 版本。</p>
<pre tabindex="0"><code>kubeadm upgrade node phase kubelet-config [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--dry-run</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">不改变任何状态，只输出将要执行的操作</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">配置操作的帮助信息</td>
</tr>
<tr>
<td colspan="2">--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值： "/etc/kubernetes/kubelet.conf"</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">用于和集群通信的 KubeConfig 文件。如果它没有被设置，那么 kubeadm 将会搜索一个已经存在于标准路径的 KubeConfig 文件。</td>
</tr>
<tr>
<td colspan="2">--kubelet-version string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">升级后的 kubelet 的*期望*版本。</td>
</tr>
</tbody>
</table>
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
<!--
### Options inherited from parent commands
-->
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">[实验] 到'真实'主机根文件系统的路径。</td>
</tr>
</tbody>
</table>
</div></div>

<h2 id="接下来">接下来</h2>
<!--
* [kubeadm init](/docs/reference/setup-tools/kubeadm/kubeadm-init/) to bootstrap a Kubernetes control-plane node
* [kubeadm join](/docs/reference/setup-tools/kubeadm/kubeadm-join/) to connect a node to the cluster
* [kubeadm reset](/docs/reference/setup-tools/kubeadm/kubeadm-reset/) to revert any changes made to this host by `kubeadm init` or `kubeadm join`
* [kubeadm upgrade](/docs/reference/setup-tools/kubeadm/kubeadm-upgrade/) to upgrade a kubeadm node
* [kubeadm alpha](/docs/reference/setup-tools/kubeadm/kubeadm-alpha/) to try experimental functionality
-->
<ul>
<li><a href="/zh/docs/reference/setup-tools/kubeadm/kubeadm-init/">kubeadm init</a> 引导一个 Kubernetes 控制平面节点</li>
<li><a href="/zh/docs/reference/setup-tools/kubeadm/kubeadm-join/">kubeadm join</a> 将节点加入到集群</li>
<li><a href="/zh/docs/reference/setup-tools/kubeadm/kubeadm-reset/">kubeadm reset</a> 还原 <code>kubeadm init</code> 或 <code>kubeadm join</code> 命令对主机所做的任何更改</li>
<li><a href="/zh/docs/reference/setup-tools/kubeadm/kubeadm-upgrade/">kubeadm upgrade</a> 升级 kubeadm 节点</li>
<li><a href="/zh/docs/reference/setup-tools/kubeadm/kubeadm-alpha/">kubeadm alpha</a> 尝试实验性功能</li>
</ul>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-455b6412a275b743ee8ad90f35808393">7.1.15 - 实现细节</h1>
    
	<!--  
reviewers:
- luxas
- jbeda
title: Implementation details
content_type: concept
weight: 100
-->
<!-- overview -->





<div style="margin-top: 10px; margin-bottom: 10px;">
<b>FEATURE STATE:</b> <code>Kubernetes v1.10 [stable]</code>
</div>

<!--  
`kubeadm init` and `kubeadm join` together provides a nice user experience for creating a best-practice but bare Kubernetes cluster from scratch.
However, it might not be obvious _how_ kubeadm does that.
-->
<p><code>kubeadm init</code> 和 <code>kubeadm join</code> 结合在一起提供了良好的用户体验，因为从头开始创建实践最佳而配置最基本的 Kubernetes 集群。
但是，kubeadm <em>如何</em> 做到这一点可能并不明显。</p>
<!-- 
This document provides additional details on what happen under the hood, 
with the aim of sharing knowledge on Kubernetes cluster best practices. 
-->
<p>本文档提供了更多幕后的详细信息，旨在分享有关 Kubernetes 集群最佳实践的知识。</p>
<!-- body -->
<!--
## Core design principles
-->
<h2 id="core-design-principles">核心设计原则   </h2>
<!-- The cluster that `kubeadm init` and `kubeadm join` set up should be: -->
<p><code>kubeadm init</code> 和 <code>kubeadm join</code> 设置的集群该是：</p>
<!-- 
 - **Secure**: It should adopt latest best-practices like:
   - enforcing RBAC
   - using the Node Authorizer
   - using secure communication between the control plane components
   - using secure communication between the API server and the kubelets
   - lock-down the kubelet API
   - locking down access to the API for system components like the kube-proxy and CoreDNS
   - locking down what a Bootstrap Token can access
 - **User-friendly**: The user should not have to run anything more than a couple of commands:
   - `kubeadm init`
   - `export KUBECONFIG=/etc/kubernetes/admin.conf`
   - `kubectl apply -f <network-of-choice.yaml>`
   - `kubeadm join --token <token> <endpoint>:<port>`
 - **Extendable**:
   - It should _not_ favor any particular network provider. Configuring the cluster network is out-of-scope
   - It should provide the possibility to use a config file for customizing various parameters
-->
<ul>
<li><strong>安全的</strong>：它应采用最新的最佳实践，例如：
<ul>
<li>实施 RBAC 访问控制</li>
<li>使用节点鉴权机制（Node Authorizer）</li>
<li>在控制平面组件之间使用安全通信</li>
<li>在 API 服务器和 kubelet 之间使用安全通信</li>
<li>锁定 kubelet API</li>
<li>锁定对系统组件（例如 kube-proxy 和 CoreDNS）的 API 的访问</li>
<li>锁定启动引导令牌（Bootstrap Token）可以访问的内容</li>
</ul>
</li>
<li><strong>用户友好</strong>：用户只需要运行几个命令即可：
<ul>
<li><code>kubeadm init</code></li>
<li><code>export KUBECONFIG=/etc/kubernetes/admin.conf</code></li>
<li><code>kubectl apply -f &lt;所选网络.yaml&gt;</code></li>
<li><code>kubeadm join --token &lt;令牌&gt; &lt;端点&gt;:&lt;端口&gt;</code></li>
</ul>
</li>
<li><strong>可扩展的</strong>：
<ul>
<li><em>不</em> 应偏向任何特定的网络提供商。不涉及配置集群网络</li>
<li>应该可以使用配置文件来自定义各种参数</li>
</ul>
</li>
</ul>
<!--
## Constants and well-known values and paths
-->
<h2 id="constants-and-well-known-values-and-paths">常量以及众所周知的值和路径 </h2>
<!-- 
In order to reduce complexity and to simplify development of higher level tools that build on top of kubeadm, it uses a
limited set of constant values for well-known paths and file names.
-->
<p>为了降低复杂性并简化基于 kubeadm 的高级工具的开发，对于众所周知的路径和文件名，
kubeadm 使用了一组有限的常量值。</p>
<!--  
The Kubernetes directory `/etc/kubernetes` is a constant in the application, since it is clearly the given path
in a majority of cases, and the most intuitive location; other constants paths and file names are:
-->
<p>Kubernetes 目录 <code>/etc/kubernetes</code> 在应用程序中是一个常量，因为在大多数情况下
它显然是给定的路径，并且是最直观的位置；其他路径常量和文件名有：</p>
<!--  
- `/etc/kubernetes/manifests` as the path where kubelet should look for static Pod manifests. Names of static Pod manifests are:
    - `etcd.yaml`
    - `kube-apiserver.yaml`
    - `kube-controller-manager.yaml`
    - `kube-scheduler.yaml`
- `/etc/kubernetes/` as the path where kubeconfig files with identities for control plane components are stored. Names of kubeconfig files are:
    - `kubelet.conf` (`bootstrap-kubelet.conf` during TLS bootstrap)
    - `controller-manager.conf`
    - `scheduler.conf`
    - `admin.conf` for the cluster admin and kubeadm itself
- Names of certificates and key files :
    - `ca.crt`, `ca.key` for the Kubernetes certificate authority
    - `apiserver.crt`, `apiserver.key` for the API server certificate
    - `apiserver-kubelet-client.crt`, `apiserver-kubelet-client.key` for the client certificate used by the API server to connect to the kubelets securely
    - `sa.pub`, `sa.key` for the key used by the controller manager when signing ServiceAccount
    - `front-proxy-ca.crt`, `front-proxy-ca.key` for the front proxy certificate authority
    - `front-proxy-client.crt`, `front-proxy-client.key` for the front proxy client
-->
<ul>
<li><code>/etc/kubernetes/manifests</code> 作为 kubelet 查找静态 Pod 清单的路径。静态 Pod 清单的名称为：
<ul>
<li><code>etcd.yaml</code></li>
<li><code>kube-apiserver.yaml</code></li>
<li><code>kube-controller-manager.yaml</code></li>
<li><code>kube-scheduler.yaml</code></li>
</ul>
</li>
<li><code>/etc/kubernetes/</code> 作为带有控制平面组件身份标识的 kubeconfig 文件的路径。kubeconfig 文件的名称为：
<ul>
<li><code>kubelet.conf</code> (在 TLS 引导时名称为 <code>bootstrap-kubelet.conf</code> )</li>
<li><code>controller-manager.conf</code></li>
<li><code>scheduler.conf</code></li>
<li><code>admin.conf</code> 用于集群管理员和 kubeadm 本身</li>
</ul>
</li>
<li>证书和密钥文件的名称：
<ul>
<li><code>ca.crt</code>, <code>ca.key</code> 用于 Kubernetes 证书颁发机构</li>
<li><code>apiserver.crt</code>, <code>apiserver.key</code> 用于 API 服务器证书</li>
<li><code>apiserver-kubelet-client.crt</code>, <code>apiserver-kubelet-client.key</code>
用于 API 服务器安全地连接到 kubelet 的客户端证书</li>
<li><code>sa.pub</code>, <code>sa.key</code> 用于控制器管理器签署 ServiceAccount 时使用的密钥</li>
<li><code>front-proxy-ca.crt</code>, <code>front-proxy-ca.key</code> 用于前端代理证书颁发机构</li>
<li><code>front-proxy-client.crt</code>, <code>front-proxy-client.key</code> 用于前端代理客户端</li>
</ul>
</li>
</ul>
<!--
## kubeadm init workflow internal design
-->
<h2 id="kubeadm-init-workflow-internal-design">kubeadm init 工作流程内部设计 </h2>
<!--  
The `kubeadm init` [internal workflow](/docs/reference/setup-tools/kubeadm/kubeadm-init/#init-workflow) consists of a sequence of atomic work tasks to perform,
as described in `kubeadm init`.
-->
<p><code>kubeadm init</code> <a href="/zh/docs/reference/setup-tools/kubeadm/kubeadm-init/#init-workflow">内部工作流程</a>
包含一系列要执行的原子性工作任务，如 <code>kubeadm init</code> 中所述。</p>
<!--  
The [`kubeadm init phase`](/docs/reference/setup-tools/kubeadm/kubeadm-init-phase/) command allows users to invoke each task individually, and ultimately offers a reusable and composable API/toolbox that can be used by other Kubernetes bootstrap tools, by any IT automation tool or by an advanced user for creating custom clusters.
-->
<p><a href="/zh/docs/reference/setup-tools/kubeadm/kubeadm-init-phase/"><code>kubeadm init phase</code></a>
命令允许用户分别调用每个任务，并最终提供可重用且可组合的 API 或工具箱，
其他 Kubernetes 引导工具、任何 IT 自动化工具和高级用户都可以使用它来
创建自定义集群。</p>
<!--
### Preflight checks
-->
<h3 id="preflight-checks">预检 </h3>
<!-- 
Kubeadm executes a set of preflight checks before starting the init, with the aim to verify preconditions and avoid common cluster startup problems.
The user can skip specific preflight checks or all of them with the `--ignore-preflight-errors` option. 
-->
<p>Kubeadm 在启动 init 之前执行一组预检，目的是验证先决条件并避免常见的集群启动问题。
用户可以使用 <code>--ignore-preflight-errors</code> 选项跳过特定的预检查或全部检查。</p>
<!--  
- [warning] If the Kubernetes version to use (specified with the `--kubernetes-version` flag) is at least one minor version higher than the kubeadm CLI version.
- Kubernetes system requirements:
  - if running on linux:
    - [error] if Kernel is older than the minimum required version
    - [error] if required cgroups subsystem aren't in set up
  - if using docker:
    - [warning/error] if Docker service does not exist, if it is disabled, if it is not active.
    - [error] if Docker endpoint does not exist or does not work
    - [warning] if docker version is not in the list of validated docker versions
  - If using other cri engine:
    - [error] if crictl socket does not answer
-->
<ul>
<li>[警告] 如果要使用的 Kubernetes 版本（由 <code>--kubernetes-version</code> 标志指定）比 kubeadm CLI
版本至少高一个小版本。</li>
<li>Kubernetes 系统要求：
<ul>
<li>如果在 linux上运行：
<ul>
<li>[错误] 如果内核早于最低要求的版本</li>
<li>[错误] 如果未设置所需的 cgroups 子系统</li>
</ul>
</li>
<li>如果使用 docker：
<ul>
<li>[警告/错误] 如果 Docker 服务不存在、被禁用或未激活。</li>
<li>[错误] 如果 Docker 端点不存在或不起作用</li>
<li>[警告] 如果 docker 版本不在经过验证的 docker 版本列表中</li>
</ul>
</li>
<li>如果使用其他 cri 引擎：
<ul>
<li>[错误] 如果 crictl 套接字未应答</li>
</ul>
</li>
</ul>
</li>
</ul>
<!--  
- [error] if user is not root
- [error] if the machine hostname is not a valid DNS subdomain
- [warning] if the host name cannot be reached via network lookup
- [error] if kubelet version is lower that the minimum kubelet version supported by kubeadm (current minor -1)
- [error] if kubelet version is at least one minor higher than the required controlplane version (unsupported version skew)
- [warning] if kubelet service does not exist or if it is disabled
- [warning] if firewalld is active
- [error] if API server bindPort or ports 10250/10251/10252 are used
- [Error] if `/etc/kubernetes/manifest` folder already exists and it is not empty
- [Error] if `/proc/sys/net/bridge/bridge-nf-call-iptables` file does not exist/does not contain 1
- [Error] if advertise address is ipv6 and `/proc/sys/net/bridge/bridge-nf-call-ip6tables` does not exist/does not contain 1.
- [Error] if swap is on
- [Error] if `conntrack`, `ip`, `iptables`,  `mount`, `nsenter` commands are not present in the command path
- [warning] if `ebtables`, `ethtool`, `socat`, `tc`, `touch`, `crictl` commands are not present in the command path
- [warning] if extra arg flags for API server, controller manager,  scheduler contains some invalid options
- [warning] if connection to https://API.AdvertiseAddress:API.BindPort goes through proxy
- [warning] if connection to services subnet goes through proxy (only first address checked)
- [warning] if connection to Pods subnet goes through proxy (only first address checked)
-->
<ul>
<li>[错误] 如果用户不是 root 用户</li>
<li>[错误] 如果机器主机名不是有效的 DNS 子域</li>
<li>[警告] 如果通过网络查找无法访问主机名</li>
<li>[错误] 如果 kubelet 版本低于 kubeadm 支持的最低 kubelet 版本（当前小版本 -1）</li>
<li>[错误] 如果 kubelet 版本比所需的控制平面板版本至少高一个小（不支持的版本偏斜）</li>
<li>[警告] 如果 kubelet 服务不存在或已被禁用</li>
<li>[警告] 如果 firewalld 处于活动状态</li>
<li>[错误] 如果 API ​​服务器绑定的端口或 10250/10251/10252 端口已被占用</li>
<li>[错误] 如果 <code>/etc/kubernetes/manifest</code> 文件夹已经存在并且不为空</li>
<li>[错误] 如果 <code>/proc/sys/net/bridge/bridge-nf-call-iptables</code> 文件不存在或不包含 1</li>
<li>[错误] 如果建议地址是 ipv6，并且 <code>/proc/sys/net/bridge/bridge-nf-call-ip6tables</code> 不存在或不包含 1</li>
<li>[错误] 如果启用了交换分区</li>
<li>[错误] 如果命令路径中没有 <code>conntrack</code>、<code>ip</code>、<code>iptables</code>、<code>mount</code>、<code>nsenter</code> 命令</li>
<li>[警告] 如果命令路径中没有 <code>ebtables</code>、<code>ethtool</code>、<code>socat</code>、<code>tc</code>、<code>touch</code>、<code>crictl</code> 命令</li>
<li>[警告] 如果 API 服务器、控制器管理器、调度程序的其他参数标志包含一些无效选项</li>
<li>[警告] 如果与 https://API.AdvertiseAddress:API.BindPort 的连接通过代理</li>
<li>[警告] 如果服务子网的连接通过代理（仅检查第一个地址）</li>
<li>[警告] 如果 Pod 子网的连接通过代理（仅检查第一个地址）</li>
</ul>
<!-- 
- If external etcd is provided:
  - [Error] if etcd version is older than the minimum required version
  - [Error] if etcd certificates or keys are specified, but not provided
- If external etcd is NOT provided (and thus local etcd will be installed):
  - [Error] if ports 2379 is used
  - [Error] if Etcd.DataDir folder already exists and it is not empty
- If authorization mode is ABAC:
  - [Error] if abac_policy.json does not exist
- If authorization mode is WebHook
  - [Error] if webhook_authz.conf does not exist
-->
<ul>
<li>如果提供了外部 etcd：
<ul>
<li>[错误] 如果 etcd 版本低于最低要求版本</li>
<li>[错误] 如果指定了 etcd 证书或密钥，但无法找到</li>
</ul>
</li>
<li>如果未提供外部 etcd（因此将安装本地 etcd）：
<ul>
<li>[错误] 如果端口 2379 已被占用</li>
<li>[错误] 如果 Etcd.DataDir 文件夹已经存在并且不为空</li>
</ul>
</li>
<li>如果授权模式为 ABAC：
<ul>
<li>[错误] 如果 abac_policy.json 不存在</li>
</ul>
</li>
<li>如果授权方式为 Webhook
<ul>
<li>[错误] 如果 webhook_authz.conf 不存在</li>
</ul>
</li>
</ul>
<!-- Please note that: -->
<p>请注意：</p>
<!--  
1. Preflight checks can be invoked individually with the [`kubeadm init phase preflight`](/docs/reference/setup-tools/kubeadm/kubeadm-init-phase/#cmd-phase-preflight) command
-->
<ol>
<li>可以使用 <a href="/zh/docs/reference/setup-tools/kubeadm/kubeadm-init-phase/#cmd-phase-preflight"><code>kubeadm init phase preflight</code></a>
命令单独触发预检。</li>
</ol>
<!--
### Generate the necessary certificates
-->
<h3 id="generate-the-necessary-certificate">生成必要的证书 </h3>
<!-- Kubeadm generates certificate and private key pairs for different purposes: -->
<p>Kubeadm 生成用于不同目的的证书和私钥对：</p>
<!-- 
 - A self signed certificate authority for the Kubernetes cluster saved into `ca.crt` file and `ca.key` private key file 
 - A serving certificate for the API server, generated using `ca.crt` as the CA, and saved into `apiserver.crt` file with
   its private key `apiserver.key`. This certificate should contain following alternative names:
     - The Kubernetes service's internal clusterIP (the first address in the services CIDR, e.g. `10.96.0.1` if service subnet is `10.96.0.0/12`)
     - Kubernetes DNS names, e.g.  `kubernetes.default.svc.cluster.local` if `--service-dns-domain` flag value is `cluster.local`, plus default DNS names `kubernetes.default.svc`, `kubernetes.default`, `kubernetes`
     - The node-name
     - The `--apiserver-advertise-address`
     - Additional alternative names specified by the user
 - A client certificate for the API server to connect to the kubelets securely, generated using `ca.crt` as the CA and saved into
   `apiserver-kubelet-client.crt` file with its private key `apiserver-kubelet-client.key`.
   This certificate should be in the `system:masters` organization
 - A private key for signing ServiceAccount Tokens saved into `sa.key` file along with its public key `sa.pub`
 - A certificate authority for the front proxy saved into `front-proxy-ca.crt` file with its key `front-proxy-ca.key`
 - A client cert for the front proxy client, generated using `front-proxy-ca.crt` as the CA and saved into `front-proxy-client.crt` file
   with its private key`front-proxy-client.key`
-->
<ul>
<li>
<p>Kubernetes 集群的自签名证书颁发机构会保存到 <code>ca.crt</code> 文件和 <code>ca.key</code> 私钥文件中</p>
</li>
<li>
<p>用于 API 服务器的服务证书，使用 <code>ca.crt</code> 作为 CA 生成，并将证书保存到 <code>apiserver.crt</code>
文件中，私钥保存到 <code>apiserver.key</code> 文件中
该证书应包含以下备用名称：</p>
<ul>
<li>Kubernetes 服务的内部 clusterIP（服务 CIDR 的第一个地址。
例如：如果服务的子网是 <code>10.96.0.0/12</code>，则为 <code>10.96.0.1</code>）</li>
<li>Kubernetes DNS 名称，例如：如果 <code>--service-dns-domain</code> 标志值是 <code>cluster.local</code>，
则为 <code>kubernetes.default.svc.cluster.local</code>；
加上默认的 DNS 名称 <code>kubernetes.default.svc</code>、<code>kubernetes.default</code> 和 <code>kubernetes</code>，</li>
<li>节点名称</li>
<li><code>--apiserver-advertise-address</code></li>
<li>用户指定的其他备用名称</li>
</ul>
</li>
<li>
<p>用于 API 服务器安全连接到 kubelet 的客户端证书，使用 <code>ca.crt</code> 作为 CA 生成，
并保存到 <code>apiserver-kubelet-client.crt</code>，私钥保存到 <code>apiserver-kubelet-client.key</code>
文件中。该证书应该在 <code>system:masters</code> 组织中。</p>
</li>
<li>
<p>用于签名 ServiceAccount 令牌的私钥保存到 <code>sa.key</code> 文件中，公钥保存到 <code>sa.pub</code> 文件中</p>
</li>
<li>
<p>用于前端代理的证书颁发机构保存到 <code>front-proxy-ca.crt</code> 文件中，私钥保存到
<code>front-proxy-ca.key</code> 文件中</p>
</li>
<li>
<p>前端代理客户端的客户端证书，使用 <code>front-proxy-ca.crt</code> 作为 CA 生成，并保存到
<code>front-proxy-client.crt</code> 文件中，私钥保存到 <code>front-proxy-client.key</code> 文件中</p>
</li>
</ul>
<!-- 
Certificates are stored by default in `/etc/kubernetes/pki`, but this directory is configurable using the `--cert-dir` flag. 
-->
<p>证书默认情况下存储在 <code>/etc/kubernetes/pki</code> 中，但是该目录可以使用 <code>--cert-dir</code> 标志进行配置。</p>
<!--
Please note that:
-->
<p>请注意：</p>
<!-- 
1. If a given certificate and private key pair both exist, and its content is evaluated compliant with the above specs, the existing files will
   be used and the generation phase for the given certificate skipped. This means the user can, for example, copy an existing CA to
   `/etc/kubernetes/pki/ca.{crt,key}`, and then kubeadm will use those files for signing the rest of the certs.
   See also [using custom certificates](/docs/tasks/administer-cluster/kubeadm/kubeadm-certs#custom-certificates)
2. Only for the CA, it is possible to provide the `ca.crt` file but not the `ca.key` file, if all other certificates and kubeconfig files
   already are in place kubeadm recognize this condition and activates the ExternalCA , which also implies the `csrsigner`controller in
   controller-manager won't be started
3. If kubeadm is running in [external CA mode](/docs/tasks/administer-cluster/kubeadm/kubeadm-certs#external-ca-mode);
   all the certificates must be provided by the user, because kubeadm cannot generate them by itself
4. In case of kubeadm is executed in the `--dry-run` mode, certificates files are written in a temporary folder
5. Certificate generation can be invoked individually with the [`kubeadm init phase certs all`](/docs/reference/setup-tools/kubeadm/kubeadm-init-phase/#cmd-phase-certs) command
-->
<ol>
<li>如果证书和私钥对都存在，并且其内容经过评估符合上述规范，将使用现有文件，
并且跳过给定证书的生成阶段。
这意味着用户可以将现有的 CA 复制到 <code>/etc/kubernetes/pki/ca.{crt,key}</code>，
kubeadm 将使用这些文件对其余证书进行签名。
请参阅<a href="/zh/docs/tasks/administer-cluster/kubeadm/kubeadm-certs#custom-certificates">使用自定义证书</a>。</li>
<li>仅对 CA 来说，如果所有其他证书和 kubeconfig 文件都已就位，则可以只提供 <code>ca.crt</code> 文件，
而不提供 <code>ca.key</code> 文件。
kubeadm 能够识别出这种情况并启用 ExternalCA，这也意味着了控制器管理器中的
<code>csrsigner</code> 控制器将不会启动</li>
<li>如果 kubeadm 在
<a href="/zh/docs/tasks/administer-cluster/kubeadm/kubeadm-certs#external-ca-mode">外部 CA 模式</a>
下运行，所有证书必须由用户提供，因为 kubeadm 无法自行生成它们。</li>
<li>如果在 <code>--dry-run</code> 模式下执行 kubeadm，证书文件将写入一个临时文件夹中</li>
<li>可以使用 <a href="/zh/docs/reference/setup-tools/kubeadm/kubeadm-init-phase/#cmd-phase-certs"><code>kubeadm init phase certs all</code></a> 
命令单独生成证书。</li>
</ol>
<!--
### Generate kubeconfig files for control plane components
-->
<h3 id="generate-kubeconfig-files-for-control-plane-components">为控制平面组件生成 kubeconfig 文件 </h3>
<!-- 
Kubeadm generates kubeconfig files with identities for control plane components:
-->
<p>Kubeadm 生成具有用于控制平面组件身份标识的 kubeconfig 文件：</p>
<!--  
- A kubeconfig file for the kubelet to use during TLS bootstrap - /etc/kubernetes/bootstrap-kubelet.conf. Inside this file there is a bootstrap-token or embedded client certificates for authenticating this node with the cluster.
  This client cert should:
    - Be in the `system:nodes` organization, as required by the [Node Authorization](/docs/reference/access-authn-authz/node/) module
    - Have the Common Name (CN) `system:node:<hostname-lowercased>`
- A kubeconfig file for controller-manager, `/etc/kubernetes/controller-manager.conf`; inside this file is embedded a client
  certificate with controller-manager identity. This client cert should have the CN `system:kube-controller-manager`, as defined
by default [RBAC core components roles](/docs/reference/access-authn-authz/rbac/#core-component-roles)
- A kubeconfig file for scheduler, `/etc/kubernetes/scheduler.conf`; inside this file is embedded a client certificate with scheduler identity.
  This client cert should have the CN `system:kube-scheduler`, as defined by default [RBAC core components roles](/docs/reference/access-authn-authz/rbac/#core-component-roles)
-->
<ul>
<li>
<p>供 kubelet 在 TLS 引导期间使用的 kubeconfig 文件 —— <code>/etc/kubernetes/bootstrap-kubelet.conf</code>。
在此文件中，有一个引导令牌或内嵌的客户端证书，向集群表明此节点身份。
此客户端证书应：</p>
<ul>
<li>根据<a href="/zh/docs/reference/access-authn-authz/node/">节点鉴权</a>模块的要求，属于 <code>system:nodes</code> 组织</li>
<li>具有通用名称（CN）：<code>system:node:&lt;小写主机名&gt;</code></li>
</ul>
</li>
<li>
<p>控制器管理器的 kubeconfig 文件 —— <code>/etc/kubernetes/controller-manager.conf</code>；
在此文件中嵌入了一个具有控制器管理器身份标识的客户端证书。
此客户端证书应具有 CN：<code>system:kube-controller-manager</code>，
该 CN 由 <a href="/zh/docs/reference/access-authn-authz/rbac/#core-component-roles">RBAC 核心组件角色</a>
默认定义的。</p>
</li>
<li>
<p>调度器的 kubeconfig 文件 —— <code>/etc/kubernetes/scheduler.conf</code>；
此文件中嵌入了具有调度器身份标识的客户端证书。此客户端证书应具有 CN：<code>system:kube-scheduler</code>，
该 CN 由 <a href="/zh/docs/reference/access-authn-authz/rbac/#core-component-roles">RBAC 核心组件角色</a>
默认定义的。</p>
</li>
</ul>
<!-- 
Additionally, a kubeconfig file for kubeadm itself and the admin is generated and saved into the `/etc/kubernetes/admin.conf` file.
The "admin" here is defined as the actual person(s) that is administering the cluster and wants to have full control (**root**) over the cluster.
The embedded client certificate for admin should be in the `system:masters` organization, as defined by default
[RBAC user facing role bindings](/docs/reference/access-authn-authz/rbac/#user-facing-roles). It should also include a
CN. Kubeadm uses the `kubernetes-admin` CN.
-->
<p>另外，用于 kubeadm 本身和 admin 的 kubeconfig 文件也被生成并保存到
<code>/etc/kubernetes/admin.conf</code> 文件中。
此处的 admin 定义为正在管理集群并希望完全控制集群（<strong>root</strong>）的实际人员。
内嵌的 admin 客户端证书应是  <code>system:masters</code> 组织的成员，
这一组织名由默认的 <a href="/zh/docs/reference/access-authn-authz/rbac/#user-facing-roles">RBAC 面向用户的角色绑定</a>
定义。它还应包括一个 CN。kubeadm 使用 <code>kubernetes-admin</code> CN。</p>
<!-- Please note that: -->
<p>请注意：</p>
<!--  
1. `ca.crt` certificate is embedded in all the kubeconfig files.
2. If a given kubeconfig file exists, and its content is evaluated compliant with the above specs, the existing file will be used and the generation phase for the given kubeconfig skipped
3. If kubeadm is running in [ExternalCA mode](/docs/reference/setup-tools/kubeadm/kubeadm-init/#external-ca-mode), all the required kubeconfig must be provided by the user as well, because kubeadm cannot generate any of them by itself
4. In case of kubeadm is executed in the `--dry-run` mode, kubeconfig files are written in a temporary folder
5. Kubeconfig files generation can be invoked individually with the [`kubeadm init phase kubeconfig all`](/docs/reference/setup-tools/kubeadm/kubeadm-init-phase/#cmd-phase-kubeconfig) command
-->
<ol>
<li><code>ca.crt</code> 证书内嵌在所有 kubeconfig 文件中。</li>
<li>如果给定的 kubeconfig 文件存在且其内容经过评估符合上述规范，则 kubeadm 将使用现有文件，
并跳过给定 kubeconfig 的生成阶段</li>
<li>如果 kubeadm 以 <a href="/zh/docs/reference/setup-tools/kubeadm/kubeadm-init/#external-ca-mode">ExternalCA 模式</a>
运行，则所有必需的 kubeconfig 也必须由用户提供，因为 kubeadm 不能自己生成</li>
<li>如果在 <code>--dry-run</code> 模式下执行 kubeadm，则 kubeconfig 文件将写入一个临时文件夹中</li>
<li>可以使用
<a href="/zh/docs/reference/setup-tools/kubeadm/kubeadm-init-phase/#cmd-phase-kubeconfig"><code>kubeadm init phase kubeconfig all</code></a>
命令分别生成 kubeconfig 文件。</li>
</ol>
<!--
### Generate static Pod manifests for control plane components
-->
<h3 id="generate-static-pod-manifests-for-control-plane-components">为控制平面组件生成静态 Pod 清单 </h3>
<!--  
Kubeadm writes static Pod manifest files for control plane components to `/etc/kubernetes/manifests`. The kubelet watches this directory for Pods to create on startup.
-->
<p>Kubeadm 将用于控制平面组件的静态 Pod 清单文件写入 <code>/etc/kubernetes/manifests</code> 目录。
Kubelet 启动后会监视这个目录以便创建 Pod。</p>
<!-- Static Pod manifest share a set of common properties: -->
<p>静态 Pod 清单有一些共同的属性：</p>
<!--  
- All static Pods are deployed on `kube-system` namespace
- All static Pods get `tier:control-plane` and `component:{component-name}` labels
- All static Pods use the `system-node-critical` priority class
- `hostNetwork: true` is set on all static Pods to allow control plane startup before a network is configured; as a consequence:
  * The `address` that the controller-manager and the scheduler use to refer the API server is `127.0.0.1`
  * If using a local etcd server, `etcd-servers` address will be set to `127.0.0.1:2379`
- Leader election is enabled for both the controller-manager and the scheduler
- Controller-manager and the scheduler will reference kubeconfig files with their respective, unique identities
- All static Pods get any extra flags specified by the user as described in [passing custom arguments to control plane components](/docs/setup/production-environment/tools/kubeadm/control-plane-flags/)
- All static Pods get any extra Volumes specified by the user (Host path)
-->
<ul>
<li>
<p>所有静态 Pod 都部署在 <code>kube-system</code> 名字空间</p>
</li>
<li>
<p>所有静态 Pod 都打上 <code>tier:ontrol-plane</code> 和 <code>component:{组件名称}</code> 标签</p>
</li>
<li>
<p>所有静态 Pod 均使用 <code>system-node-critical</code> 优先级</p>
</li>
<li>
<p>所有静态 Pod 都设置了 <code>hostNetwork:true</code>，使得控制平面在配置网络之前启动；结果导致：</p>
<ul>
<li>控制器管理器和调度器用来调用 API 服务器的地址为 127.0.0.1。</li>
<li>如果使用本地 etcd 服务器，则 <code>etcd-servers</code> 地址将设置为 <code>127.0.0.1:2379</code></li>
</ul>
</li>
<li>
<p>同时为控制器管理器和调度器启用了领导者选举</p>
</li>
<li>
<p>控制器管理器和调度器将引用 kubeconfig 文件及其各自的唯一标识</p>
</li>
<li>
<p>如<a href="/zh/docs/setup/production-environment/tools/kubeadm/control-plane-flags/">将自定义参数传递给控制平面组件</a>
中所述，所有静态 Pod 都会获得用户指定的额外标志</p>
</li>
<li>
<p>所有静态 Pod 都会获得用户指定的额外卷（主机路径）</p>
</li>
</ul>
<!-- Please note that: -->
<p>请注意：</p>
<!--  
1. All images will be pulled from k8s.gcr.io by default. See [using custom images](/docs/reference/setup-tools/kubeadm/kubeadm-init/#custom-images) for customizing the image repository
2. In case of kubeadm is executed in the `-dry-run` mode, static Pods files are written in a temporary folder
3. Static Pod manifest generation for control plane components can be invoked individually with the [`kubeadm init phase control-plane all`](/docs/reference/setup-tools/kubeadm/kubeadm-init-phase/#cmd-phase-control-plane) command
-->
<ol>
<li>所有镜像默认从 k8s.gcr.io 拉取。 
关于自定义镜像仓库，请参阅
<a href="/zh/docs/reference/setup-tools/kubeadm/kubeadm-init/#custom-images">使用自定义镜像</a>。</li>
<li>如果在 <code>--dry-run</code> 模式下执行 kubeadm，则静态 Pod 文件写入一个临时文件夹中。</li>
<li>可以使用 <a href="/zh/docs/reference/setup-tools/kubeadm/kubeadm-init-phase/#cmd-phase-control-plane"><code>kubeadm init phase control-plane all</code></a> 
命令分别生成主控组件的静态 Pod 清单。</li>
</ol>
<!--
#### API server

The static Pod manifest for the API server is affected by following parameters provided by the users: 
-->
<h4 id="api-server">API 服务器 </h4>
<p>API 服务器的静态 Pod 清单会受到用户提供的以下参数的影响:</p>
<!--  
 - The `apiserver-advertise-address` and `apiserver-bind-port` to bind to; if not provided, those value defaults to the IP address of
   the default network interface on the machine and port 6443
 - The `service-cluster-ip-range` to use for services
 - If an external etcd server is specified, the `etcd-servers` address and related TLS settings (`etcd-cafile`, `etcd-certfile`, `etcd-keyfile`);
   if an external etcd server is not be provided, a local etcd will be used (via host network)
 - If a cloud provider is specified, the corresponding `--cloud-provider` is configured, together with the  `--cloud-config` path
   if such file exists (this is experimental, alpha and will be removed in a future version)
-->
<ul>
<li>要绑定的 <code>apiserver-advertise-address</code> 和 <code>apiserver-bind-port</code>；
如果未提供，则这些值默认为机器上默认网络接口的 IP 地址和 6443 端口。</li>
<li><code>service-cluster-ip-range</code> 给 service 使用</li>
<li>如果指定了外部 etcd 服务器，则应指定 <code>etcd-servers</code> 地址和相关的 TLS 设置
（<code>etcd-cafile</code>，<code>etcd-certfile</code>，<code>etcd-keyfile</code>）；
如果未提供外部 etcd 服务器，则将使用本地 etcd（通过主机网络）</li>
<li>如果指定了云提供商，则配置相应的 <code>--cloud-provider</code>，如果该路径存在，则配置 <code>--cloud-config</code>
（这是实验性的，是 Alpha 版本，将在以后的版本中删除）</li>
</ul>
<!-- Other API server flags that are set unconditionally are: -->
<p>无条件设置的其他 API 服务器标志有：</p>
<!--  
 - `--insecure-port=0` to avoid insecure connections to the api server
 - `--enable-bootstrap-token-auth=true` to enable the `BootstrapTokenAuthenticator` authentication module.
   See [TLS Bootstrapping](/docs/reference/command-line-tools-reference/kubelet-tls-bootstrapping/) for more details
 - `--allow-privileged` to `true` (required e.g. by kube proxy)
 - `--requestheader-client-ca-file` to `front-proxy-ca.crt`
-->
<ul>
<li><code>--insecure-port=0</code> 禁止到 API 服务器不安全的连接</li>
<li><code>--enable-bootstrap-token-auth=true</code> 启用 <code>BootstrapTokenAuthenticator</code> 身份验证模块。
更多细节请参见 <a href="/zh/docs/reference/command-line-tools-reference/kubelet-tls-bootstrapping/">TLS 引导</a>。</li>
<li><code>--allow-privileged</code> 设为 <code>true</code>（诸如 kube-proxy 这些组件有此要求）</li>
<li><code>--requestheader-client-ca-file</code> 设为 <code>front-proxy-ca.crt</code></li>
</ul>
<!--
 - `--enable-admission-plugins` to:
    - [`NamespaceLifecycle`](/docs/reference/access-authn-authz/admission-controllers/#namespacelifecycle) e.g. to avoid deletion of
      system reserved namespaces
    - [`LimitRanger`](/docs/reference/access-authn-authz/admission-controllers/#limitranger) and [`ResourceQuota`](/docs/reference/access-authn-authz/admission-controllers/#resourcequota) to enforce limits on namespaces
    - [`ServiceAccount`](/docs/reference/access-authn-authz/admission-controllers/#serviceaccount) to enforce service account automation
    - [`PersistentVolumeLabel`](/docs/reference/access-authn-authz/admission-controllers/#persistentvolumelabel) attaches region or zone labels to
      PersistentVolumes as defined by the cloud provider (This admission controller is deprecated and will be removed in a future version.
      It is not deployed by kubeadm by default with v1.9 onwards when not explicitly opting into using `gce` or `aws` as cloud providers)
    - [`DefaultStorageClass`](/docs/reference/access-authn-authz/admission-controllers/#defaultstorageclass) to enforce default storage class on `PersistentVolumeClaim` objects
    - [`DefaultTolerationSeconds`](/docs/reference/access-authn-authz/admission-controllers/#defaulttolerationseconds)
    - [`NodeRestriction`](/docs/reference/access-authn-authz/admission-controllers/#noderestriction) to limit what a kubelet can modify
      (e.g. only pods on this node)
-->
<ul>
<li><code>--enable-admission-plugins</code> 设为：
<ul>
<li><a href="/zh/docs/reference/access-authn-authz/admission-controllers/#namespacelifecycle"><code>NamespaceLifecycle</code></a> 
例如，避免删除系统保留的名字空间</li>
<li><a href="/zh/docs/reference/access-authn-authz/admission-controllers/#limitranger"><code>LimitRanger</code></a> 和
<a href="/zh/docs/reference/access-authn-authz/admission-controllers/#resourcequota"><code>ResourceQuota</code></a>
对名字空间实施限制</li>
<li><a href="/zh/docs/reference/access-authn-authz/admission-controllers/#serviceaccount"><code>ServiceAccount</code></a>
实施服务账户自动化</li>
<li><a href="/zh/docs/reference/access-authn-authz/admission-controllers/#persistentvolumelabel"><code>PersistentVolumeLabel</code></a> 
将区域（Region）或区（Zone）标签附加到由云提供商定义的 PersistentVolumes
（此准入控制器已被弃用并将在以后的版本中删除）。
如果未明确选择使用 <code>gce</code> 或 <code>aws</code> 作为云提供商，则默认情况下，v1.9 以后的版本 kubeadm 都不会部署。</li>
<li><a href="/zh/docs/reference/access-authn-authz/admission-controllers/#defaultstorageclass"><code>DefaultStorageClass</code></a> 
在 <code>PersistentVolumeClaim</code> 对象上强制使用默认存储类型</li>
<li><a href="/zh/docs/reference/access-authn-authz/admission-controllers/#defaulttolerationseconds"><code>DefaultTolerationSeconds</code></a></li>
<li><a href="/zh/docs/reference/access-authn-authz/admission-controllers/#noderestriction"><code>NodeRestriction</code></a> 
限制 kubelet 可以修改的内容（例如，仅此节点上的 pod）</li>
</ul>
</li>
</ul>
<!--
 - `--kubelet-preferred-address-types` to `InternalIP,ExternalIP,Hostname;` this makes `kubectl logs` and other API server-kubelet
   communication work in environments where the hostnames of the nodes aren't resolvable
 - Flags for using certificates generated in previous steps:
    - `--client-ca-file` to `ca.crt`
    - `--tls-cert-file` to `apiserver.crt`
    - `--tls-private-key-file` to `apiserver.key`
    - `--kubelet-client-certificate` to `apiserver-kubelet-client.crt`
    - `--kubelet-client-key` to `apiserver-kubelet-client.key`
    - `--service-account-key-file` to `sa.pub`
    - `--requestheader-client-ca-file` to`front-proxy-ca.crt`
    - `--proxy-client-cert-file` to `front-proxy-client.crt`
    - `--proxy-client-key-file` to `front-proxy-client.key`
 - Other flags for securing the front proxy ([API Aggregation](/docs/concepts/extend-kubernetes/api-extension/apiserver-aggregation/)) communications:
    - `--requestheader-username-headers=X-Remote-User`
    - `--requestheader-group-headers=X-Remote-Group`
    - `--requestheader-extra-headers-prefix=X-Remote-Extra-`
    - `--requestheader-allowed-names=front-proxy-client`
-->
<ul>
<li>
<p><code>--kubelet-preferred-address-types</code> 设为 <code>InternalIP,ExternalIP,Hostname;</code> 
这使得在节点的主机名无法解析的环境中，<code>kubectl log</code> 和 API 服务器与 kubelet
的其他通信可以工作</p>
</li>
<li>
<p>使用在前面步骤中生成的证书的标志：</p>
<ul>
<li><code>--client-ca-file</code> 设为 <code>ca.crt</code></li>
<li><code>--tls-cert-file</code> 设为 <code>apiserver.crt</code></li>
<li><code>--tls-private-key-file</code> 设为 <code>apiserver.key</code></li>
<li><code>--kubelet-client-certificate</code> 设为 <code>apiserver-kubelet-client.crt</code></li>
<li><code>--kubelet-client-key</code> 设为 <code>apiserver-kubelet-client.key</code></li>
<li><code>--service-account-key-file</code> 设为 <code>sa.pub</code></li>
<li><code>--requestheader-client-ca-file</code> 设为 <code>front-proxy-ca.crt</code></li>
<li><code>--proxy-client-cert-file</code> 设为 <code>front-proxy-client.crt</code></li>
<li><code>--proxy-client-key-file</code> 设为 <code>front-proxy-client.key</code></li>
</ul>
</li>
<li>
<p>其他用于保护前端代理（
<a href="/zh/docs/concepts/extend-kubernetes/api-extension/apiserver-aggregation/">API 聚合层</a>）
通信的标志:</p>
<ul>
<li><code>--requestheader-username-headers=X-Remote-User</code></li>
<li><code>--requestheader-group-headers=X-Remote-Group</code></li>
<li><code>--requestheader-extra-headers-prefix=X-Remote-Extra-</code></li>
<li><code>--requestheader-allowed-names=front-proxy-client</code></li>
</ul>
</li>
</ul>
<!--
#### Controller manager
-->
<h4 id="controller-manager">控制器管理器 </h4>
<!-- 
The static Pod manifest for the controller-manager is affected by following parameters provided by the users: 
-->
<p>控制器管理器的静态 Pod 清单受用户提供的以下参数的影响:</p>
<!-- 
- If kubeadm is invoked specifying a `--pod-network-cidr`, the subnet manager feature required for some CNI network plugins is enabled by
   setting:
   - `--allocate-node-cidrs=true`
   - `--cluster-cidr` and `--node-cidr-mask-size` flags according to the given CIDR
 - If a cloud provider is specified, the corresponding `--cloud-provider` is specified, together with the  `--cloud-config` path
   if such configuration file exists (this is experimental, alpha and will be removed in a future version)
-->
<ul>
<li>如果调用 kubeadm 时指定了 <code>--pod-network-cidr</code> 参数，则可以通过以下方式启用
某些 CNI 网络插件所需的子网管理器功能：
<ul>
<li>设置 <code>--allocate-node-cidrs=true</code></li>
<li>根据给定 CIDR 设置 <code>--cluster-cidr</code> 和 <code>--node-cidr-mask-size</code> 标志</li>
</ul>
</li>
<li>如果指定了云提供商，则指定相应的 <code>--cloud-provider</code>，如果存在这样的配置文件，
则指定 <code>--cloud-config</code> 路径（此为试验性功能，是 Alpha 版本，将在以后的版本中删除）。</li>
</ul>
<!-- Other flags that are set unconditionally are: -->
<p>其他无条件设置的标志包括：</p>
<!--  
 - `--controllers` enabling all the default controllers plus `BootstrapSigner` and `TokenCleaner` controllers for TLS bootstrap.
   See [TLS Bootstrapping](/docs/reference/command-line-tools-reference/kubelet-tls-bootstrapping/) for more details
 - `--use-service-account-credentials` to `true`
 - Flags for using certificates generated in previous steps:
    - `--root-ca-file` to `ca.crt`
    - `--cluster-signing-cert-file` to `ca.crt`, if External CA mode is disabled, otherwise to `""`
    - `--cluster-signing-key-file` to `ca.key`, if External CA mode is disabled, otherwise to `""`
    - `--service-account-private-key-file` to `sa.key`
-->
<ul>
<li>
<p><code>--controllers</code> 为 TLS 引导程序启用所有默认控制器以及 <code>BootstrapSigner</code> 和
<code>TokenCleaner</code> 控制器。详细信息请参阅
<a href="/zh/docs/reference/command-line-tools-reference/kubelet-tls-bootstrapping/">TLS 引导</a></p>
</li>
<li>
<p><code>--use-service-account-credentials</code> 设为 <code>true</code></p>
</li>
<li>
<p>使用先前步骤中生成的证书的标志：</p>
<p>-<code>--root-ca-file</code> 设为 <code>ca.crt</code></p>
<ul>
<li>如果禁用了 External CA 模式，则 <code>--cluster-signing-cert-file</code> 设为 <code>ca.crt</code>，否则设为 <code>&quot;&quot;</code></li>
<li>如果禁用了 External CA 模式，则 <code>--cluster-signing-key-file</code> 设为 <code>ca.key</code>，否则设为 <code>&quot;&quot;</code></li>
<li><code>--service-account-private-key-file</code> 设为 <code>sa.key</code></li>
</ul>
</li>
</ul>
<!--
#### Scheduler

The static Pod manifest for the scheduler is not affected by parameters provided by the users. 
-->
<h4 id="scheduler">调度器 </h4>
<p>调度器的静态 Pod 清单不受用户提供的参数的影响。</p>
<!--
### Generate static Pod manifest for local etcd
-->
<h3 id="generate-static-pod-manifest-for-local-etcd">为本地 etcd 生成静态 Pod 清单 </h3>
<!--  
If the user specified an external etcd this step will be skipped, otherwise kubeadm generates a static Pod manifest file for creating
a local etcd instance running in a Pod with following attributes:
-->
<p>如果用户指定了外部 etcd，则将跳过此步骤，否则 kubeadm 会生成静态 Pod 清单文件，
以创建在 Pod 中运行的具有以下属性的本地 etcd 实例：</p>
<!--  
- listen on `localhost:2379` and use `HostNetwork=true`
- make a `hostPath` mount out from the `dataDir` to the host's filesystem
- Any extra flags specified by the user
-->
<ul>
<li>在 <code>localhost:2379</code> 上监听并使用 <code>HostNetwork=true</code></li>
<li>将 <code>hostPath</code> 从 <code>dataDir</code> 挂载到主机的文件系统</li>
<li>用户指定的任何其他标志</li>
</ul>
<!-- Please note that: -->
<p>请注意：</p>
<!--  
1. The etcd image will be pulled from `k8s.gcr.io` by default. See [using custom images](/docs/reference/setup-tools/kubeadm/kubeadm-init/#custom-images) for customizing the image repository
2. in case of kubeadm is executed in the `--dry-run` mode, the etcd static Pod manifest is written in a temporary folder
3. Static Pod manifest generation for local etcd can be invoked individually with the [`kubeadm init phase etcd local`](/docs/reference/setup-tools/kubeadm/kubeadm-init-phase/#cmd-phase-etcd) command
-->
<ol>
<li>etcd 镜像默认从 <code>k8s.gcr.io</code> 拉取。有关自定义镜像仓库，请参阅
<a href="/zh/docs/reference/setup-tools/kubeadm/kubeadm-init/#custom-images">使用自定义镜像</a>。</li>
<li>如果 kubeadm 以 <code>--dry-run</code> 模式执行，etcd 静态 Pod 清单将写入一个临时文件夹。</li>
<li>可以使用
<a href="/zh/docs/reference/setup-tools/kubeadm/kubeadm-init-phase/#cmd-phase-etcd">'kubeadm init phase etcd local'</a>
命令单独为本地 etcd 生成静态 Pod 清单</li>
</ol>
<!--
### Optional Dynamic Kubelet Configuration
-->
<h3 id="optional-dynamic-kubelet-configuration">可选的动态 Kubelet 配置 </h3>
<!--  
To use this functionality call `kubeadm alpha kubelet config enable-dynamic`. It writes the kubelet init configuration
into `/var/lib/kubelet/config/init/kubelet` file.
-->
<p>要使用这个功能，请执行 <code>kubeadm alpha kubelet config enable-dynamic</code>。
它将 kubelet 的初始化配置写入 <code>/var/lib/kubelet/config/init/kubelet</code> 文件。</p>
<!--  
The init configuration is used for starting the kubelet on this specific node, providing an alternative for the kubelet drop-in file;
such configuration will be replaced by the kubelet base configuration as described in following steps.
See [set Kubelet parameters via a config file](/docs/tasks/administer-cluster/kubelet-config-file) for additional information.
-->
<p>初始化配置用于在这个特定节点上启动 kubelet，从而为 kubelet 插件文件提供了
一种替代方法。如以下步骤中所述，这种配置将由 kubelet 基本配置所替代。
请参阅<a href="/zh/docs/tasks/administer-cluster/kubelet-config-file">通过配置文件设置 Kubelet 参数</a>
了解更多信息。</p>
<!-- Please note that: -->
<p>请注意：</p>
<!--  
1. To make dynamic kubelet configuration work, flag `--dynamic-config-dir=/var/lib/kubelet/config/dynamic` should be specified
   in `/etc/systemd/system/kubelet.service.d/10-kubeadm.conf`
1. The kubelet configuration can be changed by passing a `KubeletConfiguration` object to `kubeadm init` or `kubeadm join` by using
   a configuration file `--config some-file.yaml`. The `KubeletConfiguration` object can be separated from other objects such
   as `InitConfiguration` using the `---` separator. For more details have a look at the `kubeadm config print-default` command.
-->
<ol>
<li>要使动态 kubelet 配置生效，应在 <code>/etc/systemd/system/kubelet.service.d/10-kubeadm.conf</code>
中指定 <code>--dynamic-config-dir=/var/lib/kubelet/config/dynamic</code> 标志。</li>
<li>通过使用配置文件 <code>--config some-file.yaml</code> 将 <code>KubeletConfiguration</code> 对象传递给
<code>kubeadm init</code> 或 <code>kubeadm join</code> 来更改 kubelet 配置。
可以使用 <code>---</code> 分隔符将 <code>KubeletConfiguration</code> 对象与其他对象（例如 <code>InitConfiguration</code>）
分开。更多的详细信息，请查看 <code>kubeadm config print-default</code> 命令。</li>
</ol>
<!--
For more details about the `KubeletConfiguration` struct, take a look at the
[`KubeletConfiguration` reference](/docs/reference/config-api/kubelet-config.v1beta1/).
-->
<p>有关 <code>KubeletConfiguration</code> 结构的详细信息，可参阅
<a href="/docs/reference/config-api/kubelet-config.v1beta1/"><code>KubeletConfiguration</code> 参考文档</a>。</p>
<!--
### Wait for the control plane to come up
-->
<h3 id="wait-for-the-control-plane-to-come-up">等待控制平面启动 </h3>
<!--  
kubeadm waits (upto 4m0s) until `localhost:6443/healthz` (kube-apiserver liveness) returns `ok`. However in order to detect
deadlock conditions, kubeadm fails fast if `localhost:10255/healthz` (kubelet liveness) or
`localhost:10255/healthz/syncloop` (kubelet readiness) don't return `ok` within 40s and 60s respectively.
-->
<p>kubeadm 等待（最多 4m0s），直到 <code>localhost:6443/healthz</code>（kube-apiserver 存活）返回 <code>ok</code>。 
但是为了检测死锁条件，如果 <code>localhost:10255/healthz</code>（kubelet 存活）或
<code>localhost:10255/healthz/syncloop</code>（kubelet 就绪）未能在 40s 和 60s 内未返回 <code>ok</code>，
则 kubeadm 会快速失败。</p>
<!--  
kubeadm relies on the kubelet to pull the control plane images and run them properly as static Pods.
After the control plane is up, kubeadm completes the tasks described in following paragraphs.
-->
<p>kubeadm 依靠 kubelet 拉取控制平面镜像并将其作为静态 Pod 正确运行。
控制平面启动后，kubeadm 将完成以下段落中描述的任务。</p>
<!--
### (optional) Write base kubelet configuration
-->
<h3 id="write-base-kubelet-configuration">（可选）编写基本 kubelet 配置 </h3>





<div style="margin-top: 10px; margin-bottom: 10px;">
<b>FEATURE STATE:</b> <code>Kubernetes v1.11 [beta]</code>
</div>

<!--
If kubeadm is invoked with `--feature-gates=DynamicKubeletConfig`:
-->
<p>如果带 <code>--feature-gates=DynamicKubeletConfig</code> 参数调用 kubeadm，则 kubeadm：</p>
<!--  
1. Write the kubelet base configuration into the `kubelet-base-config-v1.9` ConfigMap in the `kube-system` namespace
2. Creates RBAC rules for granting read access to that ConfigMap to all bootstrap tokens and all kubelet instances
   (that is `system:bootstrappers:kubeadm:default-node-token` and `system:nodes` groups)
3. Enable the dynamic kubelet configuration feature for the initial control-plane node by pointing `Node.spec.configSource` to the newly-created ConfigMap
-->
<ol>
<li>将 kubelet 基本配置写入 <code>kube-system</code> 名字空间的 <code>kubelet-base-config-v1.9</code> ConfigMap 中。</li>
<li>创建 RBAC 规则，以授予对所有引导令牌和所有 kubelet 实例对该 ConfigMap 的读取访问权限
（即 <code>system:bootstrappers:kubeadm:default-node-token</code> 组和 <code>system:nodes</code> 组）</li>
<li>通过将 <code>Node.spec.configSource</code> 指向新创建的 ConfigMap，为初始控制平面节点启用动态
kubelet 配置功能。</li>
</ol>
<!--
### Save the kubeadm ClusterConfiguration in a ConfigMap for later reference
-->
<h3 id="save-the-kubeadm-clusterConfiguration-in-a-configMap-for-later-reference">将 kubeadm ClusterConfiguration 保存在 ConfigMap 中以供以后参考 </h3>
<!-- 
kubeadm saves the configuration passed to `kubeadm init` in a ConfigMap named `kubeadm-config` under `kube-system` namespace. 
-->
<p>kubeadm 将传递给 <code>kubeadm init</code> 的配置保存在 <code>kube-system</code> 名字空间下名为
<code>kubeadm-config</code> 的 ConfigMap 中。</p>
<!--  
This will ensure that kubeadm actions executed in future (e.g `kubeadm upgrade`) will be able to determine the actual/current cluster
state and make new decisions based on that data.
-->
<p>这将确保将来执行的 kubeadm 操作（例如 <code>kubeadm upgrade</code>）将能够确定实际/当前集群状态，
并根据该数据做出新的决策。</p>
<!-- Please note that: -->
<p>请注意：</p>
<!-- 
1. Before saving the ClusterConfiguration, sensitive information like the token is stripped from the configuration
2. Upload of control plane ndoe configuration can be invoked individually with the [`kubeadm init phase upload-config`](/docs/reference/setup-tools/kubeadm/kubeadm-init-phase/#cmd-phase-upload-config) command
-->
<ol>
<li>在保存 ClusterConfiguration 之前，从配置中删除令牌等敏感信息。</li>
<li>可以使用
<a href="/zh/docs/reference/setup-tools/kubeadm/kubeadm-init-phase/#cmd-phase-upload-config"><code>kubeadm init phase upload-config</code></a> 
命令单独上传主控节点配置。</li>
</ol>
<!--
### Mark the node as control-plane
-->
<h3 id="mark-the-node-as-control-plane">将节点标记为控制平面 </h3>
<!--
As soon as the control plane is available, kubeadm executes following actions:
-->
<p>一旦控制平面可用，kubeadm 将执行以下操作：</p>
<!-- 
- Labels the node as control-plane with `node-role.kubernetes.io/master=""`
- Taints the node with `node-role.kubernetes.io/master:NoSchedule`
-->
<ul>
<li>给节点打上 <code>node-role.kubernetes.io/master=&quot;&quot;</code> 标签，标记其为控制平面</li>
<li>给节点打上 <code>node-role.kubernetes.io/master:NoSchedule</code> 污点</li>
</ul>
<!-- Please note that: -->
<p>请注意：</p>
<!-- 
1. Mark control-plane phase can be invoked individually with the [`kubeadm init phase mark-control-plane`](/docs/reference/setup-tools/kubeadm/kubeadm-init-phase/#cmd-phase-mark-control-plane) command
-->
<ol>
<li>可以使用 <a href="/zh/docs/reference/setup-tools/kubeadm/kubeadm-init-phase/#cmd-phase-mark-control-plane"><code>kubeadm init phase mark-control-plane</code></a> 
命令单独触发控制平面标记</li>
</ol>
<!--
### Configure TLS-Bootstrapping for node joining
-->
<h3 id="configure-tls-bootstrapping-for-node-joining">为即将加入的节点加入 TLS 启动引导 </h3>
<!--
Kubeadm uses [Authenticating with Bootstrap Tokens](/docs/reference/access-authn-authz/bootstrap-tokens/) for joining new nodes to an
existing cluster; for more details see also [design proposal](https://github.com/kubernetes/community/blob/master/contributors/design-proposals/cluster-lifecycle/bootstrap-discovery.md).
-->
<p>Kubeadm 使用<a href="/zh/docs/reference/access-authn-authz/bootstrap-tokens/">引导令牌认证</a>
将新节点连接到现有集群；
更多的详细信息，请参见
<a href="https://github.com/kubernetes/community/blob/master/contributors/design-proposals/cluster-lifecycle/bootstrap-discovery.md">设计提案</a>。</p>
<!-- 
`kubeadm init` ensures that everything is properly configured for this process, and this includes following steps as well as
setting API server and controller flags as already described in previous paragraphs.
-->
<p><code>kubeadm init</code> 确保为该过程正确配置了所有内容，这包括以下步骤以及设置 API 服务器
和控制器标志，如前几段所述。</p>
<!-- Please note that: -->
<p>请注意：</p>
<!-- 
1. TLS bootstrapping for nodes can be configured with the [`kubeadm init phase bootstrap-token`](/docs/reference/setup-tools/kubeadm/kubeadm-init-phase/#cmd-phase-bootstrap-token)
   command, executing all the configuration steps described in following paragraphs; alternatively, each step can be invoked individually
-->
<ol>
<li>可以使用
<a href="/zh/docs/reference/setup-tools/kubeadm/kubeadm-init-phase/#cmd-phase-bootstrap-token"><code>kubeadm init phase bootstrap-token</code></a> 
命令配置节点的 TLS 引导，执行以下段落中描述的所有配置步骤；
或者每个步骤都单独触发。</li>
</ol>
<!--
#### Create a bootstrap token
-->
<h4 id="create-a-bootstrap-token">创建引导令牌 </h4>
<!--  
`kubeadm init` create a first bootstrap token, either generated automatically or provided by the user with the `--token` flag; as documented
in bootstrap token specification, token should be saved as secrets with name `bootstrap-token-<token-id>` under `kube-system` namespace.
-->
<p><code>kubeadm init</code> 创建第一个引导令牌，该令牌是自动生成的或由用户提供的 <code>--token</code>
标志的值；如引导令牌规范中记录的那样，
令牌应保存在 <code>kube-system</code> 名字空间下名为 <code>bootstrap-token-&lt;令牌-id&gt;</code>
的 Secret 中。</p>
<!--
Please note that:
-->
<p>请注意：</p>
<!--  
1. The default token created by `kubeadm init` will be used to validate temporary user during TLS bootstrap process; those users will
   be member of  `system:bootstrappers:kubeadm:default-node-token` group
2. The token has a limited validity, default 24 hours (the interval may be changed with the `—token-ttl` flag)
3. Additional tokens can be created with the [`kubeadm token`](/docs/reference/setup-tools/kubeadm/kubeadm-token/) command, that provide as well other useful functions
   for token management
-->
<ol>
<li>由 <code>kubeadm init</code> 创建的默认令牌将用于在 TLS 引导过程中验证临时用户；
这些用户会成为 <code>system:bootstrappers:kubeadm:default-node-token</code> 组的成员。</li>
<li>令牌的有效期有限，默认为 24 小时（间隔可以通过 <code>-token-ttl</code> 标志进行更改）</li>
<li>可以使用 <a href="/zh/docs/reference/setup-tools/kubeadm/kubeadm-token/"><code>kubeadm token</code></a>
命令创建其他令牌，这些令牌还提供其他有用的令牌管理功能</li>
</ol>
<!--
#### Allow joining nodes to call CSR API
-->
<h4 id="allow-joining-nodes-to-call-csr-api">允许加入的节点调用 CSR API </h4>
<!--
Kubeadm ensures that users in  `system:bootstrappers:kubeadm:default-node-token` group are able to access the certificate signing API.
-->
<p>Kubeadm 确保 <code>system:bootstrappers:kubeadm:default-node-token</code> 组中的用户
能够访问证书签名 API。</p>
<!-- 
This is implemented by creating a ClusterRoleBinding named `kubeadm:kubelet-bootstrap` between the group above and the default
RBAC role `system:node-bootstrapper`.
-->
<p>这是通过在上述组与默认 RBAC 角色 <code>system:node-bootstrapper</code> 之间创建名为
<code>kubeadm:kubelet-bootstrap</code> 的 ClusterRoleBinding 来实现的。</p>
<!--
#### Setup auto approval for new bootstrap tokens
-->
<h4 id="setup-auto-approval-for-new-bootstrap-tokens">为新的引导令牌设置自动批准 </h4>
<!--
Kubeadm ensures that the Bootstrap Token will get its CSR request automatically approved by the csrapprover controller.
-->
<p>Kubeadm 确保 csrapprover 控制器自动批准引导令牌的 CSR 请求。</p>
<!-- 
This is implemented by creating ClusterRoleBinding named `kubeadm:node-autoapprove-bootstrap` between
the  `system:bootstrappers:kubeadm:default-node-token` group and the default role `system:certificates.k8s.io:certificatesigningrequests:nodeclient`.
-->
<p>这是通过在 <code>system:bootstrappers:kubeadm:default-node-token</code> 用户组和
<code>system:certificates.k8s.io:certificatesigningrequests:nodeclient</code> 默认角色之间
创建名为 <code>kubeadm:node-autoapprove-bootstrap</code> 的 ClusterRoleBinding 来实现的。</p>
<!-- 
The role `system:certificates.k8s.io:certificatesigningrequests:nodeclient` should be created as well, granting
POST permission to `/apis/certificates.k8s.io/certificatesigningrequests/nodeclient`.
-->
<p>还应创建 <code>system:certificates.k8s.io:certificatesigningrequests:nodeclient</code> 角色，
授予对 <code>/apis/certificates.k8s.io/certificatesigningrequests/nodeclient</code>
执行 POST 的权限。</p>
<!--
#### Setup nodes certificate rotation with auto approval
-->
<h4 id="setup-nodes-certificate-rotation-with-auto-approval">通过自动批准设置节点证书轮换</h4>
<!-- 
Kubeadm ensures that certificate rotation is enabled for nodes, and that new certificate request for nodes will get its CSR request
automatically approved by the csrapprover controller. 
-->
<p>Kubeadm 确保节点启用了证书轮换，csrapprover 控制器将自动批准节点的
新证书的 CSR 请求。</p>
<!-- 
This is implemented by creating ClusterRoleBinding named `kubeadm:node-autoapprove-certificate-rotation` between the  `system:nodes` group
and the default role `system:certificates.k8s.io:certificatesigningrequests:selfnodeclient`.
-->
<p>这是通过在 <code>system:nodes</code> 组和
<code>system:certificates.k8s.io:certificatesigningrequests:selfnodeclient</code>
默认角色之间创建名为 <code>kubeadm:node-autoapprove-certificate-rotation</code> 的
ClusterRoleBinding 来实现的。</p>
<!--
#### Create the public cluster-info ConfigMap
-->
<h4 id="创建公共-cluster-info-configmap">创建公共 cluster-info ConfigMap</h4>
<!--
This phase creates the `cluster-info` ConfigMap in the `kube-public` namespace.
-->
<p>本步骤在 <code>kube-public</code> 名字空间中创建名为 <code>cluster-info</code> 的 ConfigMap。</p>
<!--  
Additionally it creates a Role and a RoleBinding granting access to the ConfigMap for unauthenticated users
(i.e. users in RBAC group `system:unauthenticated`).
-->
<p>另外，它创建一个 Role 和一个 RoleBinding，为未经身份验证的用户授予对 ConfigMap
的访问权限（即 RBAC 组 <code>system:unauthenticated</code> 中的用户）。</p>
<!--
Please note that:
-->
<p>请注意：</p>
<!--  
1. The access to the `cluster-info` ConfigMap _is not_ rate-limited. This may or may not be a problem if you expose your cluster's API server
to the internet; worst-case scenario here is a DoS attack where an attacker uses all the in-flight requests the kube-apiserver
can handle to serving the `cluster-info` ConfigMap.
-->
<ol>
<li>对 <code>cluster-info</code> ConfigMap 的访问 <em>不受</em> 速率限制。
如果你把 API 服务器暴露到外网，这可能是一个问题，也可能不是；
这里最坏的情况是 DoS 攻击，攻击者使用 kube-apiserver 能够处理的所有动态请求
来为 <code>cluster-info</code> ConfigMap 提供服务。</li>
</ol>
<!--
### Install addons
-->
<h3 id="install-addons">安装插件 </h3>
<!--
Kubeadm installs the internal DNS server and the kube-proxy addon components via the API server.
-->
<p>Kubeadm 通过 API 服务器安装内部 DNS 服务器和 kube-proxy 插件。</p>
<!--
Please note that:
-->
<p>请注意：</p>
<!-- 
1. This phase can be invoked individually with the [`kubeadm init phase addon all`](/docs/reference/setup-tools/kubeadm/kubeadm-init-phase/#cmd-phase-addon) command. 
-->
<ol>
<li>此步骤可以调用
<a href="/zh/docs/reference/setup-tools/kubeadm/kubeadm-init-phase/#cmd-phase-addon">'kubeadm init phase addon all'</a>
命令单独执行。</li>
</ol>
<!--
#### proxy

A ServiceAccount for `kube-proxy` is created in the `kube-system` namespace; then kube-proxy is deployed as a DaemonSet: 
-->
<h4 id="proxy">代理 </h4>
<p>在 <code>kube-system</code> 名字空间中创建一个用于 <code>kube-proxy</code> 的 ServiceAccount；
然后以 DaemonSet 的方式部署 kube-proxy：</p>
<!--  
- The credentials (`ca.crt` and `token`) to the control plane come from the ServiceAccount
- The location (URL) of the API server comes from a ConfigMap
- The `kube-proxy` ServiceAccount is bound to the privileges in the `system:node-proxier` ClusterRole
-->
<ul>
<li>主控节点凭据（<code>ca.crt</code> 和 <code>token</code>）来自 ServiceAccount</li>
<li>API 服务器节点的位置（URL）来自 ConfigMap</li>
<li><code>kube-proxy</code> 的 ServiceAccount 绑定了 <code>system:node-proxier</code> ClusterRole
中的特权</li>
</ul>
<h4 id="dns">DNS</h4>
<!--  
- The CoreDNS service is named `kube-dns`. This is done to prevent any interruption
  in service when the user is switching the cluster DNS from kube-dns to CoreDNS,
  the `--config` method described [here](/docs/reference/setup-tools/kubeadm/kubeadm-init-phase/#cmd-phase-addon)
- A ServiceAccount for CoreDNS is created in the `kube-system` namespace.
- The `coredns` ServiceAccount is bound to the privileges in the `system:coredns` ClusterRole
-->
<ul>
<li>CoreDNS 服务的名称为 <code>kube-dns</code>。这样做是为了防止当用户将集群 DNS 从 kube-dns
切换到 CoreDNS 时出现服务中断。<code>--config</code> 方法在
<a href="/zh/docs/reference/setup-tools/kubeadm/kubeadm-init-phase/#cmd-phase-addon">这里</a>
有描述。</li>
<li>在 <code>kube-system</code> 名字空间中创建 CoreDNS 的 ServiceAccount</li>
<li><code>coredns</code> 的 ServiceAccount 绑定了 <code>system:coredns</code> ClusterRole 中的特权</li>
</ul>
<!--
In Kubernetes version 1.21, support for using `kube-dns` with kubeadm was removed.
You can use CoreDNS with kubeadm even when the related Service is named `kube-dns`.
-->
<p>在 Kubernetes 1.21 版本中，kubeadm 对 <code>kube-dns</code> 的支持被移除。
你可以在 kubeadm 使用 CoreDNS，即使相关的 Service 名字仍然是 <code>kube-dns</code>。</p>
<!--
## kubeadm join phases internal design
-->
<h2 id="kubeadm-join-phases-internal-design">kubeadm join 步骤内部设计 </h2>
<!-- 
Similarly to `kubeadm init`, also `kubeadm join` internal workflow consists of a sequence of atomic work tasks to perform. 
-->
<p>与 <code>kubeadm init</code> 类似，<code>kubeadm join</code> 内部工作流由一系列待执行的原子工作任务组成。</p>
<!-- 
This is split into discovery (having the Node trust the Kubernetes Master) and TLS bootstrap (having the Kubernetes Master trust the Node). 
-->
<p>这分为发现（让该节点信任 Kubernetes 的主控节点）和 TLS 引导
（让 Kubernetes 的主控节点信任该节点）。</p>
<!-- 
see [Authenticating with Bootstrap Tokens](/docs/reference/access-authn-authz/bootstrap-tokens/) or the corresponding [design proposal](https://github.com/kubernetes/community/blob/master/contributors/design-proposals/cluster-lifecycle/bootstrap-discovery.md). 
-->
<p>请参阅<a href="/zh/docs/reference/access-authn-authz/bootstrap-tokens/">使用引导令牌进行身份验证</a>
或相应的<a href="https://github.com/kubernetes/community/blob/master/contributors/design-proposals/cluster-lifecycle/bootstrap-discovery.md">设计提案</a>。</p>
<!--
### Preflight checks
-->
<h3 id="preflight-checks">预检 </h3>
<!-- 
`kubeadm` executes a set of preflight checks before starting the join, with the aim to verify preconditions and avoid common
cluster startup problems.
-->
<p><code>kubeadm</code> 在开始执行之前执行一组预检，目的是验证先决条件，避免常见的集群启动问题。</p>
<!-- Please note that: -->
<p>请注意：</p>
<!--  
1. `kubeadm join` preflight checks are basically a subset `kubeadm init` preflight checks
1. Starting from 1.9, kubeadm provides better support for CRI-generic functionality; in that case, docker specific controls
   are skipped or replaced by similar controls for crictl.
1. Starting from 1.9, kubeadm provides support for joining nodes running on Windows; in that case, linux specific controls are skipped.
1. In any case the user can skip specific preflight checks (or eventually all preflight checks) with the `--ignore-preflight-errors` option.
-->
<ol>
<li><code>kubeadm join</code> 预检基本上是 <code>kubeadm init</code> 预检的一个子集</li>
<li>从 1.9 开始，kubeadm 为 CRI 通用的功能提供了更好的支持；在这种情况下，
Docker 特定的控制参数将跳过或替换为 crictl 中与之相似的控制参数。</li>
<li>从 1.9 开始，kubeadm 支持加入在 Windows 上运行的节点；在这种情况下，
将跳过 Linux 特定的控制参数。</li>
<li>在任何情况下，用户都可以通过 <code>--ignore-preflight-errors</code> 选项跳过
特定的预检（或者进而跳过所有预检）。</li>
</ol>
<!--
### Discovery cluster-info
-->
<h3 id="discovery-cluster-info">发现 cluster-info </h3>
<!--  
There are 2 main schemes for discovery. The first is to use a shared token along with the IP address of the API server.
The second is to provide a file (that is a subset of the standard kubeconfig file).
-->
<p>主要有两种发现方案。第一种是使用一个共享令牌以及 API 服务器的 IP 地址。
第二种是提供一个文件（它是标准 kubeconfig 文件的子集）。</p>
<!--
#### Shared token discovery
-->
<h4 id="shared-token-discovery">共享令牌发现 </h4>
<!--  
If `kubeadm join` is invoked with `--discovery-token`, token discovery is used; in this case the node basically retrieves
the cluster CA certificates from the  `cluster-info` ConfigMap in the `kube-public` namespace.
-->
<p>如果带 <code>--discovery-token</code> 参数调用 <code>kubeadm join</code>，则使用了令牌发现功能；
在这种情况下，节点基本上从 <code>kube-public</code> 名字空间中的 <code>cluster-info</code> ConfigMap
中检索集群 CA 证书。</p>
<!-- In order to prevent "man in the middle" attacks, several steps are taken: -->
<p>为了防止“中间人”攻击，采取了以下步骤：</p>
<!--  
- First, the CA certificate is retrieved via insecure connection (this is possible because `kubeadm init` granted access to  `cluster-info` users for `system:unauthenticated` )
- Then the CA certificate goes trough following validation steps:
  - Basic validation: using the token ID against a JWT signature
  - Pub key validation: using provided `--discovery-token-ca-cert-hash`. This value is available in the output of `kubeadm init` or can
    be calculated using standard tools (the hash is calculated over the bytes of the Subject Public Key Info (SPKI) object as in RFC7469).
    The `--discovery-token-ca-cert-hash flag` may be repeated multiple times to allow more than one public key.
  - As a additional validation, the CA certificate is retrieved via secure connection and then compared with the CA retrieved initially
-->
<ul>
<li>首先，通过不安全连接检索 CA 证书（这是可能的，因为 <code>kubeadm init</code> 授予
<code>system:unauthenticated</code> 的用户对 <code>cluster-info</code> 访问权限）</li>
<li>然后 CA 证书通过以下验证步骤：
<ul>
<li>基本验证：使用令牌 ID 而不是 JWT 签名</li>
<li>公钥验证：使用提供的 <code>--discovery-token-ca-cert-hash</code>。这个值来自 <code>kubeadm init</code> 的输出，
或者可以使用标准工具计算（哈希值是按 RFC7469 中主体公钥信息（SPKI）对象的字节计算的）
<code>--discovery-token-ca-cert-hash</code> 标志可以重复多次，以允许多个公钥。</li>
<li>作为附加验证，通过安全连接检索 CA 证书，然后与初始检索的 CA 进行比较</li>
</ul>
</li>
</ul>
<!-- Please note that: -->
<p>请注意：</p>
<!--  
1.  Pub key validation can be skipped passing `--discovery-token-unsafe-skip-ca-verification` flag; This weakens the kubeadm security
    model since others can potentially impersonate the Kubernetes Master.
-->
<ol>
<li>通过 <code>--discovery-token-unsafe-skip-ca-verification</code> 标志可以跳过公钥验证；
这削弱了 kubeadm 安全模型，因为其他人可能冒充 Kubernetes 主控节点。</li>
</ol>
<!--
#### File/https discovery
-->
<h4 id="file-or-https-discovery">文件/HTTPS 发现 </h4>
<!-- 
If `kubeadm join` is invoked with `--discovery-file`, file discovery is used; this file can be a local file or downloaded via an HTTPS URL; in case of HTTPS, the host installed CA bundle is used to verify the connection. 
-->
<p>如果带 <code>--discovery-file</code> 参数调用 <code>kubeadm join</code>，则使用文件发现功能；
该文件可以是本地文件或通过 HTTPS URL 下载；对于 HTTPS，主机安装的 CA 包
用于验证连接。</p>
<!--  
With file discovery, the cluster CA certificates is provided into the file itself; in fact, the discovery file is a kubeconfig
file with only `server` and `certificate-authority-data` attributes set, as described in [`kubeadm join`](/docs/reference/setup-tools/kubeadm/kubeadm-join/#file-or-https-based-discovery) reference doc;
when the connection with the cluster is established, kubeadm try to access the `cluster-info` ConfigMap, and if available, uses it.
-->
<p>通过文件发现，集群 CA 证书是文件本身提供；事实上，这个发现文件是一个 kubeconfig 文件，
只设置了 <code>server</code> 和 <code>certificate-authority-data</code> 属性，
如 <a href="/zh/docs/reference/setup-tools/kubeadm/kubeadm-join/#file-or-https-based-discovery"><code>kubeadm join</code></a>
参考文档中所述，当与集群建立连接时，kubeadm 尝试访问 <code>cluster-info</code> ConfigMap，
如果可用，就使用它。</p>
<!--
## TLS Bootstrap
-->
<h2 id="tls-boostrap">TLS 引导 </h2>
<!--  
Once the cluster info are known, the file `bootstrap-kubelet.conf` is written, thus allowing kubelet to do TLS Bootstrapping.
-->
<p>知道集群信息后，kubeadm 将写入文件 <code>bootstrap-kubelet.conf</code>，从而允许 kubelet 执行
TLS 引导。</p>
<!--  
The TLS bootstrap mechanism uses the shared token to temporarily authenticate with the Kubernetes API server to submit a certificate
signing request (CSR) for a locally created key pair.
-->
<p>TLS 引导机制使用共享令牌对 Kubernetes API 服务器进行临时身份验证，以便
为本地创建的密钥对提交证书签名请求（CSR）。</p>
<!--  
The request is then automatically approved and the operation completes saving `ca.crt` file and `kubelet.conf` file to be used
by kubelet for joining the cluster, while`bootstrap-kubelet.conf` is deleted.
-->
<p>该请求会被自动批准，并且该操作保存 <code>ca.crt</code> 文件和 <code>kubelet.conf</code> 文件，用于
kubelet 加入集群，同时删除 <code>bootstrap-kubelet.conf</code>。</p>
<!-- Please note that: -->
<p>请注意：</p>
<!--  
- The temporary authentication is validated against the token saved during the `kubeadm init` process (or with additional tokens
  created with `kubeadm token`)
- The temporary authentication resolve to a user member of `system:bootstrappers:kubeadm:default-node-token` group which was granted
  access to CSR api during the `kubeadm init` process
- The automatic CSR approval is managed by the csrapprover controller, according with configuration done the `kubeadm init` process
-->
<ul>
<li>临时身份验证根据 <code>kubeadm init</code> 过程中保存的令牌进行验证（或者使用 <code>kubeadm token</code>
创建的其他令牌）</li>
<li>临时身份验证解析到 <code>system:bootstrappers:kubeadm:default-node-token</code> 组的一个用户成员，
该成员在 <code>kubeadm init</code> 过程中被授予对 CSR API 的访问权</li>
<li>根据 <code>kubeadm init</code> 过程的配置，自动 CSR 审批由 csrapprover 控制器管理</li>
</ul>
<!--
### (optional) Write init kubelet configuration
-->
<h3 id="write-init-kubelet-configuration">（可选）写入初始的 kubelet 配置 </h3>





<div style="margin-top: 10px; margin-bottom: 10px;">
<b>FEATURE STATE:</b> <code>Kubernetes v1.11 [beta]</code>
</div>

<!--
If kubeadm is invoked with `--feature-gates=DynamicKubeletConfig`:
-->
<p>如果带 <code>--feature-gates=DynamicKubeletConfig</code> 参数调用 kubeadm，则 kubeadm：</p>
<!--  
1. Read the kubelet base configuration from the `kubelet-base-config-v1.x` ConfigMap in the `kube-system` namespace  using the
   Bootstrap Token credentials, and write it to disk as kubelet init configuration file  `/var/lib/kubelet/config/init/kubelet`
2. As soon as kubelet starts with the Node's own credential (`/etc/kubernetes/kubelet.conf`), update current node configuration
   specifying that the source for the node/kubelet configuration is the above ConfigMap.
-->
<ol>
<li>使用引导令牌凭证从 <code>kube-system</code> 名字空间中 ConfigMap <code>kubelet-base-config-v1.x</code>
中读取 kubelet 基本配置，
并将其作为 kubelet 初始配置文件 <code>/var/lib/kubelet/config/init/kubelet</code> 写入磁盘。</li>
<li>一旦 kubelet 开始使用节点自己的凭据（<code>/etc/kubernetes/kubelet.conf</code>），
就更新当前节点配置，指定该节点或 kubelet 配置来自上述 ConfigMap。</li>
</ol>
<!-- Please note that: -->
<p>请注意：</p>
<!-- 
1. To make dynamic kubelet configuration work, flag `--dynamic-config-dir=/var/lib/kubelet/config/dynamic` should be specified in `/etc/systemd/system/kubelet.service.d/10-kubeadm.conf` 
-->
<ol>
<li>要使动态 kubelet 配置生效，应在 <code>/etc/systemd/system/kubelet.service.d/10-kubeadm.conf</code>
中指定 <code>--dynamic-config-dir=/var/lib/kubelet/config/dynamic</code> 标志。</li>
</ol>

</div>



    
	
  

    
	
  

    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-03460a7254c6c73eb2a1bb3dd7d25910">8 - kubectl</h1>
    
	
</div>



    
      
  
  
  
  

  
  

  
    
    
	
    

<div class="td-content" style="">
    
	<h1 id="pg-f14fe15ecc2d41b5e901ef5e872ca657">8.1 - kubectl 概述</h1>
    
	<!--
reviewers:
- bgrant0607
- hw-qiaolei
title: Overview of kubectl
content_type: concept
weight: 20
card:
  name: reference
  weight: 20
-->
<!-- overview -->
<!--
The kubectl command line tool lets you control Kubernetes clusters.
For configuration, `kubectl` looks for a file named `config` in the `$HOME/.kube` directory.
You can specify other [kubeconfig](/docs/concepts/configuration/organize-cluster-access-kubeconfig/)
files by setting the KUBECONFIG environment variable or by setting the
[`--kubeconfig`](/docs/concepts/configuration/organize-cluster-access-kubeconfig/) flag.
-->
<p>你可以使用 Kubectl 命令行工具管理 Kubernetes 集群。
<code>kubectl</code> 在 <code>$HOME/.kube</code> 目录中查找一个名为 <code>config</code> 的配置文件。
你可以通过设置 KUBECONFIG 环境变量或设置
<a href="/zh/docs/concepts/configuration/organize-cluster-access-kubeconfig/"><code>--kubeconfig</code></a>
参数来指定其它 <a href="/zh/docs/concepts/configuration/organize-cluster-access-kubeconfig/">kubeconfig</a> 文件。</p>
<!--
This overview covers `kubectl` syntax, describes the command operations, and provides common examples.
For details about each command, including all the supported flags and subcommands, see the
[kubectl](/docs/reference/generated/kubectl/kubectl-commands/) reference documentation.
For installation instructions see [installing kubectl](/docs/tasks/tools/install-kubectl/).
-->
<p>本文概述了 <code>kubectl</code> 语法和命令操作描述，并提供了常见的示例。
有关每个命令的详细信息，包括所有受支持的参数和子命令，
请参阅 <a href="/docs/reference/generated/kubectl/kubectl-commands/">kubectl</a> 参考文档。
有关安装说明，请参见<a href="/zh/docs/tasks/tools/install-kubectl/">安装 kubectl</a> 。</p>
<!-- body -->
<!--
## Syntax
-->
<h2 id="语法">语法</h2>
<!--
Use the following syntax to run `kubectl` commands from your terminal window:
-->
<p>使用以下语法 <code>kubectl</code> 从终端窗口运行命令：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl <span style="color:#666">[</span>command<span style="color:#666">]</span> <span style="color:#666">[</span>TYPE<span style="color:#666">]</span> <span style="color:#666">[</span>NAME<span style="color:#666">]</span> <span style="color:#666">[</span>flags<span style="color:#666">]</span>
</code></pre></div><!--
where `command`, `TYPE`, `NAME`, and `flags` are:
-->
<p>其中 <code>command</code>、<code>TYPE</code>、<code>NAME</code> 和 <code>flags</code> 分别是：</p>
<!--
* `command`: Specifies the operation that you want to perform on one or more resources, for example `create`, `get`, `describe`, `delete`.

* `TYPE`: Specifies the [resource type](#resource-types). Resource types are case-insensitive and you can specify the singular, plural, or abbreviated forms. For example, the following commands produce the same output:
-->
<ul>
<li>
<p><code>command</code>：指定要对一个或多个资源执行的操作，例如 <code>create</code>、<code>get</code>、<code>describe</code>、<code>delete</code>。</p>
</li>
<li>
<p><code>TYPE</code>：指定<a href="#%E8%B5%84%E6%BA%90%E7%B1%BB%E5%9E%8B">资源类型</a>。资源类型不区分大小写，
可以指定单数、复数或缩写形式。例如，以下命令输出相同的结果:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl get pod pod1
kubectl get pods pod1
kubectl get po pod1
</code></pre></div></li>
</ul>
<!--
* `NAME`: Specifies the name of the resource. Names are case-sensitive. If the name is omitted, details for all resources are displayed, for example `kubectl get pods`.

   When performing an operation on multiple resources, you can specify each resource by type and name or specify one or more files:
-->
<ul>
<li>
<p><code>NAME</code>：指定资源的名称。名称区分大小写。
如果省略名称，则显示所有资源的详细信息 <code>kubectl get pods</code>。</p>
<p>在对多个资源执行操作时，你可以按类型和名称指定每个资源，或指定一个或多个文件：</p>
<!--
 * To specify resources by type and name:

    * To group resources if they are all the same type:  `TYPE1 name1 name2 name<#>`.<br/>
    Example: `kubectl get pod example-pod1 example-pod2`

    * To specify multiple resource types individually:  `TYPE1/name1 TYPE1/name2 TYPE2/name3 TYPE<#>/name<#>`.<br/>
    Example: `kubectl get pod/example-pod1 replicationcontroller/example-rc1`

 * To specify resources with one or more files:  `-f file1 -f file2 -f file<#>`

    * [Use YAML rather than JSON](/docs/concepts/configuration/overview/#general-configuration-tips)
      since YAML tends to be more user-friendly, especially for configuration files.<br/>
   Example: `kubectl get -f ./pod.yaml`
-->
<ul>
<li>
<p>要按类型和名称指定资源：</p>
<ul>
<li>
<p>要对所有类型相同的资源进行分组，请执行以下操作：<code>TYPE1 name1 name2 name&lt;#&gt;</code>。</p>
<p>例子：<code>kubectl get pod example-pod1 example-pod2</code></p>
</li>
<li>
<p>分别指定多个资源类型：<code>TYPE1/name1 TYPE1/name2 TYPE2/name3 TYPE&lt;#&gt;/name&lt;#&gt;</code>。</p>
<p>例子：<code>kubectl get pod/example-pod1 replicationcontroller/example-rc1</code></p>
</li>
</ul>
</li>
<li>
<p>用一个或多个文件指定资源：<code>-f file1 -f file2 -f file&lt;#&gt;</code></p>
<ul>
<li><a href="/zh/docs/concepts/configuration/overview/#general-configuration-tips">使用 YAML 而不是 JSON</a>
因为 YAML 更容易使用，特别是用于配置文件时。
例子：<code>kubectl get -f ./pod.yaml</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<!--
* `flags`: Specifies optional flags. For example, you can use the `-s` or `--server` flags to specify the address and port of the Kubernetes API server.
-->
<ul>
<li><code>flags</code>: 指定可选的参数。例如，可以使用 <code>-s</code> 或 <code>-server</code> 参数指定
Kubernetes API 服务器的地址和端口。</li>
</ul>
<blockquote class="caution callout">
  <div><strong>注意：</strong> <!--
Flags that you specify from the command line override default values and any corresponding environment variables.
-->
<p>从命令行指定的参数会覆盖默认值和任何相应的环境变量。</div>
</blockquote>

<!--
If you need help, run `kubectl help` from the terminal window.
-->
<p>如果你需要帮助，从终端窗口运行 <code>kubectl help</code> 。</p>
<!--
## Operations
-->
<h2 id="操作">操作</h2>
<!--
The following table includes short descriptions and the general syntax for all of the `kubectl` operations:
-->
<p>下表包含所有 kubectl 操作的简短描述和普通语法：</p>
<!--
Operation       | Syntax    |       Description
-------------------- | -------------------- | --------------------
`alpha`    | `kubectl alpha SUBCOMMAND [flags]` | List the available commands that correspond to alpha features, which are not enabled in Kubernetes clusters by default.
`annotate`    | <code>kubectl annotate (-f FILENAME &#124; TYPE NAME &#124; TYPE/NAME) KEY_1=VAL_1 ... KEY_N=VAL_N [--overwrite] [--all] [--resource-version=version] [flags]</code> | Add or update the annotations of one or more resources.
`api-resources`    | `kubectl api-resources [flags]` | List the API resources that are available.
`api-versions`    | `kubectl api-versions [flags]` | List the API versions that are available.
`apply`            | `kubectl apply -f FILENAME [flags]`| Apply a configuration change to a resource from a file or stdin.
`attach`        | `kubectl attach POD -c CONTAINER [-i] [-t] [flags]` | Attach to a running container either to view the output stream or interact with the container (stdin).
`auth`    | `kubectl auth [flags] [options]` | Inspect authorization.
`autoscale`    | <code>kubectl autoscale (-f FILENAME &#124; TYPE NAME &#124; TYPE/NAME) [--min=MINPODS] --max=MAXPODS [--cpu-percent=CPU] [flags]</code> | Automatically scale the set of pods that are managed by a replication controller.
`certificate`    | `kubectl certificate SUBCOMMAND [options]` | Modify certificate resources.
`cluster-info`    | `kubectl cluster-info [flags]` | Display endpoint information about the master and services in the cluster.
`completion`    | `kubectl completion SHELL [options]` | Output shell completion code for the specified shell (bash or zsh).
`config`        | `kubectl config SUBCOMMAND [flags]` | Modifies kubeconfig files. See the individual subcommands for details.
`convert`    | `kubectl convert -f FILENAME [options]` | Convert config files between different API versions. Both YAML and JSON formats are accepted.
`cordon`    | `kubectl cordon NODE [options]` | Mark node as unschedulable.
`cp`    | `kubectl cp <file-spec-src> <file-spec-dest> [options]` | Copy files and directories to and from containers.
`create`        | `kubectl create -f FILENAME [flags]` | Create one or more resources from a file or stdin.
`delete`        | <code>kubectl delete (-f FILENAME &#124; TYPE [NAME &#124; /NAME &#124; -l label &#124; --all]) [flags]</code> | Delete resources either from a file, stdin, or specifying label selectors, names, resource selectors, or resources.
`describe`    | <code>kubectl describe (-f FILENAME &#124; TYPE [NAME_PREFIX &#124; /NAME &#124; -l label]) [flags]</code> | Display the detailed state of one or more resources.
`diff`        | `kubectl diff -f FILENAME [flags]`| Diff file or stdin against live configuration.
`drain`    | `kubectl drain NODE [options]` | Drain node in preparation for maintenance.
`edit`        | <code>kubectl edit (-f FILENAME &#124; TYPE NAME &#124; TYPE/NAME) [flags]</code> | Edit and update the definition of one or more resources on the server by using the default editor.
`exec`        | `kubectl exec POD [-c CONTAINER] [-i] [-t] [flags] [-- COMMAND [args...]]` | Execute a command against a container in a pod.
`explain`    | `kubectl explain  [--recursive=false] [flags]` | Get documentation of various resources. For instance pods, nodes, services, etc.
`expose`        | <code>kubectl expose (-f FILENAME &#124; TYPE NAME &#124; TYPE/NAME) [--port=port] [--protocol=TCP&#124;UDP] [--target-port=number-or-name] [--name=name] [--external-ip=external-ip-of-service] [--type=type] [flags]</code> | Expose a replication controller, service, or pod as a new Kubernetes service.
`get`        | <code>kubectl get (-f FILENAME &#124; TYPE [NAME &#124; /NAME &#124; -l label]) [--watch] [--sort-by=FIELD] [[-o &#124; --output]=OUTPUT_FORMAT] [flags]</code> | List one or more resources.
`kustomize`    | `kubectl kustomize <dir> [flags] [options]` | List a set of API resources generated from instructions in a kustomization.yaml file. The argument must be the path to the directory containing the file, or a git repository URL with a path suffix specifying same with respect to the repository root.
`label`        | <code>kubectl label (-f FILENAME &#124; TYPE NAME &#124; TYPE/NAME) KEY_1=VAL_1 ... KEY_N=VAL_N [--overwrite] [--all] [--resource-version=version] [flags]</code> | Add or update the labels of one or more resources.
`logs`        | `kubectl logs POD [-c CONTAINER] [--follow] [flags]` | Print the logs for a container in a pod.
`options`    | `kubectl options` | List of global command-line options, which apply to all commands.
`patch`        | <code>kubectl patch (-f FILENAME &#124; TYPE NAME &#124; TYPE/NAME) --patch PATCH [flags]</code> | Update one or more fields of a resource by using the strategic merge patch process.
`plugin`    | `kubectl plugin [flags] [options]` | Provides utilities for interacting with plugins.
`port-forward`    | `kubectl port-forward POD [LOCAL_PORT:]REMOTE_PORT [...[LOCAL_PORT_N:]REMOTE_PORT_N] [flags]` | Forward one or more local ports to a pod.
`proxy`        | `kubectl proxy [--port=PORT] [--www=static-dir] [--www-prefix=prefix] [--api-prefix=prefix] [flags]` | Run a proxy to the Kubernetes API server.
`replace`        | `kubectl replace -f FILENAME` | Replace a resource from a file or stdin.
`rollout`    | `kubectl rollout SUBCOMMAND [options]` | Manage the rollout of a resource. Valid resource types include: deployments, daemonsets and statefulsets.
`run`        | <code>kubectl run NAME --image=image [--env="key=value"] [--port=port] [--dry-run=server&#124;client&#124;none] [--overrides=inline-json] [flags]</code> | Run a specified image on the cluster.
`scale`        | <code>kubectl scale (-f FILENAME &#124; TYPE NAME &#124; TYPE/NAME) --replicas=COUNT [--resource-version=version] [--current-replicas=count] [flags]</code> | Update the size of the specified replication controller.
`set`    | `kubectl set SUBCOMMAND [options]` | Configure application resources.
`taint`    | `kubectl taint NODE NAME KEY_1=VAL_1:TAINT_EFFECT_1 ... KEY_N=VAL_N:TAINT_EFFECT_N [options]` | Update the taints on one or more nodes.
`top`    | `kubectl top [flags] [options]` | Display Resource (CPU/Memory/Storage) usage.
`uncordon`    | `kubectl uncordon NODE [options]` | Mark node as schedulable.
`version`        | `kubectl version [--client] [flags]` | Display the Kubernetes version running on the client and server.
`wait`    | <code>kubectl wait ([-f FILENAME] &#124; resource.group/resource.name &#124; resource.group [(-l label &#124; --all)]) [--for=delete&#124;--for condition=available] [options]</code> | Experimental: Wait for a specific condition on one or many resources.
-->
<table>
<thead>
<tr>
<th>操作</th>
<th>语法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>alpha</code></td>
<td><code>kubectl alpha SUBCOMMAND [flags]</code></td>
<td>列出与 alpha 特性对应的可用命令，这些特性在 Kubernetes 集群中默认情况下是不启用的。</td>
</tr>
<tr>
<td><code>annotate</code></td>
<td><code>kubectl annotate (-f FILENAME | TYPE NAME | TYPE/NAME) KEY_1=VAL_1 ... KEY_N=VAL_N [--overwrite] [--all] [--resource-version=version] [flags]</code></td>
<td>添加或更新一个或多个资源的注解。</td>
</tr>
<tr>
<td><code>api-resources</code></td>
<td><code>kubectl api-resources [flags]</code></td>
<td>列出可用的 API 资源。</td>
</tr>
<tr>
<td><code>api-versions</code></td>
<td><code>kubectl api-versions [flags]</code></td>
<td>列出可用的 API 版本。</td>
</tr>
<tr>
<td><code>apply</code></td>
<td><code>kubectl apply -f FILENAME [flags]</code></td>
<td>从文件或 stdin 对资源应用配置更改。</td>
</tr>
<tr>
<td><code>attach</code></td>
<td><code>kubectl attach POD -c CONTAINER [-i] [-t] [flags]</code></td>
<td>附加到正在运行的容器，查看输出流或与容器（stdin）交互。</td>
</tr>
<tr>
<td><code>auth</code></td>
<td><code>kubectl auth [flags] [options]</code></td>
<td>检查授权。</td>
</tr>
<tr>
<td><code>autoscale</code></td>
<td><code>kubectl autoscale (-f FILENAME | TYPE NAME | TYPE/NAME) [--min=MINPODS] --max=MAXPODS [--cpu-percent=CPU] [flags]</code></td>
<td>自动伸缩由副本控制器管理的一组 pod。</td>
</tr>
<tr>
<td><code>certificate</code></td>
<td><code>kubectl certificate SUBCOMMAND [options]</code></td>
<td>修改证书资源。</td>
</tr>
<tr>
<td><code>cluster-info</code></td>
<td><code>kubectl cluster-info [flags]</code></td>
<td>显示有关集群中主服务器和服务的端口信息。</td>
</tr>
<tr>
<td><code>completion</code></td>
<td><code>kubectl completion SHELL [options]</code></td>
<td>为指定的 shell （bash 或 zsh）输出 shell 补齐代码。</td>
</tr>
<tr>
<td><code>config</code></td>
<td><code>kubectl config SUBCOMMAND [flags]</code></td>
<td>修改 kubeconfig 文件。有关详细信息，请参阅各个子命令。</td>
</tr>
<tr>
<td><code>convert</code></td>
<td><code>kubectl convert -f FILENAME [options]</code></td>
<td>在不同的 API 版本之间转换配置文件。配置文件可以是 YAML 或 JSON 格式。</td>
</tr>
<tr>
<td><code>cordon</code></td>
<td><code>kubectl cordon NODE [options]</code></td>
<td>将节点标记为不可调度。</td>
</tr>
<tr>
<td><code>cp</code></td>
<td><code>kubectl cp &lt;file-spec-src&gt; &lt;file-spec-dest&gt; [options]</code></td>
<td>在容器之间复制文件和目录。</td>
</tr>
<tr>
<td><code>create</code></td>
<td><code>kubectl create -f FILENAME [flags]</code></td>
<td>从文件或 stdin 创建一个或多个资源。</td>
</tr>
<tr>
<td><code>delete</code></td>
<td><code>kubectl delete (-f FILENAME | TYPE [NAME | /NAME | -l label | --all]) [flags]</code></td>
<td>从文件、标准输入或指定标签选择器、名称、资源选择器或资源中删除资源。</td>
</tr>
<tr>
<td><code>describe</code></td>
<td><code>kubectl describe (-f FILENAME | TYPE [NAME_PREFIX | /NAME | -l label]) [flags]</code></td>
<td>显示一个或多个资源的详细状态。</td>
</tr>
<tr>
<td><code>diff</code></td>
<td><code>kubectl diff -f FILENAME [flags]</code></td>
<td>将 live 配置和文件或标准输入做对比 (<strong>BETA</strong>)</td>
</tr>
<tr>
<td><code>drain</code></td>
<td><code>kubectl drain NODE [options]</code></td>
<td>腾空节点以准备维护。</td>
</tr>
<tr>
<td><code>edit</code></td>
<td><code>kubectl edit (-f FILENAME | TYPE NAME | TYPE/NAME) [flags]</code></td>
<td>使用默认编辑器编辑和更新服务器上一个或多个资源的定义。</td>
</tr>
<tr>
<td><code>exec</code></td>
<td><code>kubectl exec POD [-c CONTAINER] [-i] [-t] [flags] [-- COMMAND [args...]]</code></td>
<td>对 pod 中的容器执行命令。</td>
</tr>
<tr>
<td><code>explain</code></td>
<td><code>kubectl explain  [--recursive=false] [flags]</code></td>
<td>获取多种资源的文档。例如 pod, node, service 等。</td>
</tr>
<tr>
<td><code>expose</code></td>
<td><code>kubectl expose (-f FILENAME | TYPE NAME | TYPE/NAME) [--port=port] [--protocol=TCP|UDP] [--target-port=number-or-name] [--name=name] [--external-ip=external-ip-of-service] [--type=type] [flags]</code></td>
<td>将副本控制器、服务或 pod 作为新的 Kubernetes 服务暴露。</td>
</tr>
<tr>
<td><code>get</code></td>
<td><code>kubectl get (-f FILENAME | TYPE [NAME | /NAME | -l label]) [--watch] [--sort-by=FIELD] [[-o | --output]=OUTPUT_FORMAT] [flags]</code></td>
<td>列出一个或多个资源。</td>
</tr>
<tr>
<td><code>kustomize</code></td>
<td><code>kubectl kustomize &lt;dir&gt; [flags] [options]</code></td>
<td>列出从 kustomization.yaml 文件中的指令生成的一组 API 资源。参数必须是包含文件的目录的路径，或者是 git 存储库 URL，其路径后缀相对于存储库根目录指定了相同的路径。</td>
</tr>
<tr>
<td><code>label</code></td>
<td><code>kubectl label (-f FILENAME | TYPE NAME | TYPE/NAME) KEY_1=VAL_1 ... KEY_N=VAL_N [--overwrite] [--all] [--resource-version=version] [flags]</code></td>
<td>添加或更新一个或多个资源的标签。</td>
</tr>
<tr>
<td><code>logs</code></td>
<td><code>kubectl logs POD [-c CONTAINER] [--follow] [flags]</code></td>
<td>在 pod 中打印容器的日志。</td>
</tr>
<tr>
<td><code>options</code></td>
<td><code>kubectl options</code></td>
<td>全局命令行选项列表，适用于所有命令。</td>
</tr>
<tr>
<td><code>patch</code></td>
<td><code>kubectl patch (-f FILENAME | TYPE NAME | TYPE/NAME) --patch PATCH [flags]</code></td>
<td>使用策略合并 patch 程序更新资源的一个或多个字段。</td>
</tr>
<tr>
<td><code>plugin</code></td>
<td><code>kubectl plugin [flags] [options]</code></td>
<td>提供用于与插件交互的实用程序。</td>
</tr>
<tr>
<td><code>port-forward</code></td>
<td><code>kubectl port-forward POD [LOCAL_PORT:]REMOTE_PORT [...[LOCAL_PORT_N:]REMOTE_PORT_N] [flags]</code></td>
<td>将一个或多个本地端口转发到一个 pod。</td>
</tr>
<tr>
<td><code>proxy</code></td>
<td><code>kubectl proxy [--port=PORT] [--www=static-dir] [--www-prefix=prefix] [--api-prefix=prefix] [flags]</code></td>
<td>运行 Kubernetes API 服务器的代理。</td>
</tr>
<tr>
<td><code>replace</code></td>
<td><code>kubectl replace -f FILENAME</code></td>
<td>从文件或标准输入中替换资源。</td>
</tr>
<tr>
<td><code>rollout</code></td>
<td><code>kubectl rollout SUBCOMMAND [options]</code></td>
<td>管理资源的部署。有效的资源类型包括：Deployments, DaemonSets 和 StatefulSets。</td>
</tr>
<tr>
<td><code>run</code></td>
<td><code>kubectl run NAME --image=image [--env=&quot;key=value&quot;] [--port=port] [--dry-run=server | client | none] [--overrides=inline-json] [flags]</code></td>
<td>在集群上运行指定的镜像。</td>
</tr>
<tr>
<td><code>scale</code></td>
<td><code>kubectl scale (-f FILENAME | TYPE NAME | TYPE/NAME) --replicas=COUNT [--resource-version=version] [--current-replicas=count] [flags]</code></td>
<td>更新指定副本控制器的大小。</td>
</tr>
<tr>
<td><code>set</code></td>
<td><code>kubectl set SUBCOMMAND [options]</code></td>
<td>配置应用程序资源。</td>
</tr>
<tr>
<td><code>taint</code></td>
<td><code>kubectl taint NODE NAME KEY_1=VAL_1:TAINT_EFFECT_1 ... KEY_N=VAL_N:TAINT_EFFECT_N [options]</code></td>
<td>更新一个或多个节点上的污点。</td>
</tr>
<tr>
<td><code>top</code></td>
<td><code>kubectl top [flags] [options]</code></td>
<td>显示资源（CPU/内存/存储）的使用情况。</td>
</tr>
<tr>
<td><code>uncordon</code></td>
<td><code>kubectl uncordon NODE [options]</code></td>
<td>将节点标记为可调度。</td>
</tr>
<tr>
<td><code>version</code></td>
<td><code>kubectl version [--client] [flags]</code></td>
<td>显示运行在客户端和服务器上的 Kubernetes 版本。</td>
</tr>
<tr>
<td><code>wait</code></td>
<td><code>kubectl wait ([-f FILENAME] | resource.group/resource.name | resource.group [(-l label | --all)]) [--for=delete|--for condition=available] [options]</code></td>
<td>实验性：等待一种或多种资源的特定条件。</td>
</tr>
</tbody>
</table>
<!--
To learn more about command operations, see the [kubectl](/docs/reference/kubectl/kubectl/) reference documentation.
-->
<p>了解更多有关命令操作的信息，请参阅 <a href="/zh/docs/reference/kubectl/kubectl/">kubectl</a> 参考文档。</p>
<!--
## Resource types
-->
<h2 id="资源类型">资源类型</h2>
<!--
The following table includes a list of all the supported resource types and their abbreviated aliases:
-->
<p>下表列出所有受支持的资源类型及其缩写别名:</p>
<!--
(This output can be retrieved from `kubectl api-resources`, and was accurate as of Kubernetes 1.19.1.)
-->
<p>(以下输出可以通过 <code>kubectl api-resources</code> 获取，内容以 Kubernetes 1.19.1 版本为准。)</p>
<!--
| NAME | SHORTNAMES | APIGROUP | NAMESPACED | KIND |
|---|---|---|---|---|
| `bindings` | | | true | Binding |
| `componentstatuses` | `cs` | | false | ComponentStatus |
| `configmaps` | `cm` | | true | ConfigMap |
| `endpoints` | `ep` | | true | Endpoints |
| `events` | `ev` | | true | Event |
| `limitranges` | `limits` | | true | LimitRange |
| `namespaces` | `ns` | | false | Namespace |
| `nodes` | `no` | | false | Node |
| `persistentvolumeclaims` | `pvc` | | true | PersistentVolumeClaim |
| `persistentvolumes` | `pv` | | false | PersistentVolume |
| `pods` | `po` | | true | Pod |
| `podtemplates` | | | true | PodTemplate |
| `replicationcontrollers` | `rc` | | true | ReplicationController |
| `resourcequotas` | `quota` | | true | ResourceQuota |
| `secrets` | | | true | Secret |
| `serviceaccounts` | `sa` | | true | ServiceAccount |
| `services` | `svc` | | true | Service |
| `mutatingwebhookconfigurations` | | admissionregistration.k8s.io | false | MutatingWebhookConfiguration |
| `validatingwebhookconfigurations` | | admissionregistration.k8s.io | false | ValidatingWebhookConfiguration |
| `customresourcedefinitions` | `crd,crds` | apiextensions.k8s.io | false | CustomResourceDefinition |
| `apiservices` | | apiregistration.k8s.io | false | APIService |
| `controllerrevisions` | | apps | true | ControllerRevision |
| `daemonsets` | `ds` | apps | true | DaemonSet |
| `deployments` | `deploy` | apps | true | Deployment |
| `replicasets` | `rs` | apps | true | ReplicaSet |
| `statefulsets` | `sts` | apps | true | StatefulSet |
| `tokenreviews` | | authentication.k8s.io | false | TokenReview |
| `localsubjectaccessreviews` | | authorization.k8s.io | true | LocalSubjectAccessReview |
| `selfsubjectaccessreviews` | | authorization.k8s.io | false | SelfSubjectAccessReview |
| `selfsubjectrulesreviews` | | authorization.k8s.io | false | SelfSubjectRulesReview |
| `subjectaccessreviews` | | authorization.k8s.io | false | SubjectAccessReview |
| `horizontalpodautoscalers` | `hpa` | autoscaling | true | HorizontalPodAutoscaler |
| `cronjobs` | `cj` | batch | true | CronJob |
| `jobs` | | batch | true | Job |
| `certificatesigningrequests` | `csr` | certificates.k8s.io | false | CertificateSigningRequest |
| `leases` | | coordination.k8s.io | true | Lease |
| `endpointslices` |  | discovery.k8s.io | true | EndpointSlice |
| `events` | `ev` | events.k8s.io | true | Event |
| `ingresses` | `ing` | extensions | true | Ingress |
| `flowschemas` |  | flowcontrol.apiserver.k8s.io | false | FlowSchema |
| `prioritylevelconfigurations` |  | flowcontrol.apiserver.k8s.io | false | PriorityLevelConfiguration |
| `ingressclasses` |  | networking.k8s.io | false | IngressClass |
| `ingresses` | `ing` | networking.k8s.io | true | Ingress |
| `networkpolicies` | `netpol` | networking.k8s.io | true | NetworkPolicy |
| `runtimeclasses` |  | node.k8s.io | false | RuntimeClass |
| `poddisruptionbudgets` | `pdb` | policy | true | PodDisruptionBudget |
| `podsecuritypolicies` | `psp` | policy | false | PodSecurityPolicy |
| `clusterrolebindings` | | rbac.authorization.k8s.io | false | ClusterRoleBinding |
| `clusterroles` | | rbac.authorization.k8s.io | false | ClusterRole |
| `rolebindings` | | rbac.authorization.k8s.io | true | RoleBinding |
| `roles` | | rbac.authorization.k8s.io | true | Role |
| `priorityclasses` | `pc` | scheduling.k8s.io | false | PriorityClass |
| `csidrivers` | | storage.k8s.io | false | CSIDriver |
| `csinodes` | | storage.k8s.io | false | CSINode |
| `storageclasses` | `sc` | storage.k8s.io | false | StorageClass |
| `volumeattachments` | | storage.k8s.io | false | VolumeAttachment |
-->
<table>
<thead>
<tr>
<th>资源名</th>
<th>缩写名</th>
<th>API 分组</th>
<th>按命名空间</th>
<th>资源类型</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>bindings</code></td>
<td></td>
<td></td>
<td>true</td>
<td>Binding</td>
</tr>
<tr>
<td><code>componentstatuses</code></td>
<td><code>cs</code></td>
<td></td>
<td>false</td>
<td>ComponentStatus</td>
</tr>
<tr>
<td><code>configmaps</code></td>
<td><code>cm</code></td>
<td></td>
<td>true</td>
<td>ConfigMap</td>
</tr>
<tr>
<td><code>endpoints</code></td>
<td><code>ep</code></td>
<td></td>
<td>true</td>
<td>Endpoints</td>
</tr>
<tr>
<td><code>events</code></td>
<td><code>ev</code></td>
<td></td>
<td>true</td>
<td>Event</td>
</tr>
<tr>
<td><code>limitranges</code></td>
<td><code>limits</code></td>
<td></td>
<td>true</td>
<td>LimitRange</td>
</tr>
<tr>
<td><code>namespaces</code></td>
<td><code>ns</code></td>
<td></td>
<td>false</td>
<td>Namespace</td>
</tr>
<tr>
<td><code>nodes</code></td>
<td><code>no</code></td>
<td></td>
<td>false</td>
<td>Node</td>
</tr>
<tr>
<td><code>persistentvolumeclaims</code></td>
<td><code>pvc</code></td>
<td></td>
<td>true</td>
<td>PersistentVolumeClaim</td>
</tr>
<tr>
<td><code>persistentvolumes</code></td>
<td><code>pv</code></td>
<td></td>
<td>false</td>
<td>PersistentVolume</td>
</tr>
<tr>
<td><code>pods</code></td>
<td><code>po</code></td>
<td></td>
<td>true</td>
<td>Pod</td>
</tr>
<tr>
<td><code>podtemplates</code></td>
<td></td>
<td></td>
<td>true</td>
<td>PodTemplate</td>
</tr>
<tr>
<td><code>replicationcontrollers</code></td>
<td><code>rc</code></td>
<td></td>
<td>true</td>
<td>ReplicationController</td>
</tr>
<tr>
<td><code>resourcequotas</code></td>
<td><code>quota</code></td>
<td></td>
<td>true</td>
<td>ResourceQuota</td>
</tr>
<tr>
<td><code>secrets</code></td>
<td></td>
<td></td>
<td>true</td>
<td>Secret</td>
</tr>
<tr>
<td><code>serviceaccounts</code></td>
<td><code>sa</code></td>
<td></td>
<td>true</td>
<td>ServiceAccount</td>
</tr>
<tr>
<td><code>services</code></td>
<td><code>svc</code></td>
<td></td>
<td>true</td>
<td>Service</td>
</tr>
<tr>
<td><code>mutatingwebhookconfigurations</code></td>
<td></td>
<td>admissionregistration.k8s.io</td>
<td>false</td>
<td>MutatingWebhookConfiguration</td>
</tr>
<tr>
<td><code>validatingwebhookconfigurations</code></td>
<td></td>
<td>admissionregistration.k8s.io</td>
<td>false</td>
<td>ValidatingWebhookConfiguration</td>
</tr>
<tr>
<td><code>customresourcedefinitions</code></td>
<td><code>crd,crds</code></td>
<td>apiextensions.k8s.io</td>
<td>false</td>
<td>CustomResourceDefinition</td>
</tr>
<tr>
<td><code>apiservices</code></td>
<td></td>
<td>apiregistration.k8s.io</td>
<td>false</td>
<td>APIService</td>
</tr>
<tr>
<td><code>controllerrevisions</code></td>
<td></td>
<td>apps</td>
<td>true</td>
<td>ControllerRevision</td>
</tr>
<tr>
<td><code>daemonsets</code></td>
<td><code>ds</code></td>
<td>apps</td>
<td>true</td>
<td>DaemonSet</td>
</tr>
<tr>
<td><code>deployments</code></td>
<td><code>deploy</code></td>
<td>apps</td>
<td>true</td>
<td>Deployment</td>
</tr>
<tr>
<td><code>replicasets</code></td>
<td><code>rs</code></td>
<td>apps</td>
<td>true</td>
<td>ReplicaSet</td>
</tr>
<tr>
<td><code>statefulsets</code></td>
<td><code>sts</code></td>
<td>apps</td>
<td>true</td>
<td>StatefulSet</td>
</tr>
<tr>
<td><code>tokenreviews</code></td>
<td></td>
<td>authentication.k8s.io</td>
<td>false</td>
<td>TokenReview</td>
</tr>
<tr>
<td><code>localsubjectaccessreviews</code></td>
<td></td>
<td>authorization.k8s.io</td>
<td>true</td>
<td>LocalSubjectAccessReview</td>
</tr>
<tr>
<td><code>selfsubjectaccessreviews</code></td>
<td></td>
<td>authorization.k8s.io</td>
<td>false</td>
<td>SelfSubjectAccessReview</td>
</tr>
<tr>
<td><code>selfsubjectrulesreviews</code></td>
<td></td>
<td>authorization.k8s.io</td>
<td>false</td>
<td>SelfSubjectRulesReview</td>
</tr>
<tr>
<td><code>subjectaccessreviews</code></td>
<td></td>
<td>authorization.k8s.io</td>
<td>false</td>
<td>SubjectAccessReview</td>
</tr>
<tr>
<td><code>horizontalpodautoscalers</code></td>
<td><code>hpa</code></td>
<td>autoscaling</td>
<td>true</td>
<td>HorizontalPodAutoscaler</td>
</tr>
<tr>
<td><code>cronjobs</code></td>
<td><code>cj</code></td>
<td>batch</td>
<td>true</td>
<td>CronJob</td>
</tr>
<tr>
<td><code>jobs</code></td>
<td></td>
<td>batch</td>
<td>true</td>
<td>Job</td>
</tr>
<tr>
<td><code>certificatesigningrequests</code></td>
<td><code>csr</code></td>
<td>certificates.k8s.io</td>
<td>false</td>
<td>CertificateSigningRequest</td>
</tr>
<tr>
<td><code>leases</code></td>
<td></td>
<td>coordination.k8s.io</td>
<td>true</td>
<td>Lease</td>
</tr>
<tr>
<td><code>endpointslices</code></td>
<td></td>
<td>discovery.k8s.io</td>
<td>true</td>
<td>EndpointSlice</td>
</tr>
<tr>
<td><code>events</code></td>
<td><code>ev</code></td>
<td>events.k8s.io</td>
<td>true</td>
<td>Event</td>
</tr>
<tr>
<td><code>ingresses</code></td>
<td><code>ing</code></td>
<td>extensions</td>
<td>true</td>
<td>Ingress</td>
</tr>
<tr>
<td><code>flowschemas</code></td>
<td></td>
<td>flowcontrol.apiserver.k8s.io</td>
<td>false</td>
<td>FlowSchema</td>
</tr>
<tr>
<td><code>prioritylevelconfigurations</code></td>
<td></td>
<td>flowcontrol.apiserver.k8s.io</td>
<td>false</td>
<td>PriorityLevelConfiguration</td>
</tr>
<tr>
<td><code>ingressclasses</code></td>
<td></td>
<td>networking.k8s.io</td>
<td>false</td>
<td>IngressClass</td>
</tr>
<tr>
<td><code>ingresses</code></td>
<td><code>ing</code></td>
<td>networking.k8s.io</td>
<td>true</td>
<td>Ingress</td>
</tr>
<tr>
<td><code>networkpolicies</code></td>
<td><code>netpol</code></td>
<td>networking.k8s.io</td>
<td>true</td>
<td>NetworkPolicy</td>
</tr>
<tr>
<td><code>runtimeclasses</code></td>
<td></td>
<td>node.k8s.io</td>
<td>false</td>
<td>RuntimeClass</td>
</tr>
<tr>
<td><code>poddisruptionbudgets</code></td>
<td><code>pdb</code></td>
<td>policy</td>
<td>true</td>
<td>PodDisruptionBudget</td>
</tr>
<tr>
<td><code>podsecuritypolicies</code></td>
<td><code>psp</code></td>
<td>policy</td>
<td>false</td>
<td>PodSecurityPolicy</td>
</tr>
<tr>
<td><code>clusterrolebindings</code></td>
<td></td>
<td>rbac.authorization.k8s.io</td>
<td>false</td>
<td>ClusterRoleBinding</td>
</tr>
<tr>
<td><code>clusterroles</code></td>
<td></td>
<td>rbac.authorization.k8s.io</td>
<td>false</td>
<td>ClusterRole</td>
</tr>
<tr>
<td><code>rolebindings</code></td>
<td></td>
<td>rbac.authorization.k8s.io</td>
<td>true</td>
<td>RoleBinding</td>
</tr>
<tr>
<td><code>roles</code></td>
<td></td>
<td>rbac.authorization.k8s.io</td>
<td>true</td>
<td>Role</td>
</tr>
<tr>
<td><code>priorityclasses</code></td>
<td><code>pc</code></td>
<td>scheduling.k8s.io</td>
<td>false</td>
<td>PriorityClass</td>
</tr>
<tr>
<td><code>csidrivers</code></td>
<td></td>
<td>storage.k8s.io</td>
<td>false</td>
<td>CSIDriver</td>
</tr>
<tr>
<td><code>csinodes</code></td>
<td></td>
<td>storage.k8s.io</td>
<td>false</td>
<td>CSINode</td>
</tr>
<tr>
<td><code>storageclasses</code></td>
<td><code>sc</code></td>
<td>storage.k8s.io</td>
<td>false</td>
<td>StorageClass</td>
</tr>
<tr>
<td><code>volumeattachments</code></td>
<td></td>
<td>storage.k8s.io</td>
<td>false</td>
<td>VolumeAttachment</td>
</tr>
</tbody>
</table>
<!--
## Output options
-->
<h2 id="输出选项">输出选项</h2>
<!--
Use the following sections for information about how you can format or sort the output of certain commands. For details about which commands support the various output options, see the [kubectl](/docs/reference/kubectl/kubectl/) reference documentation.
-->
<p>有关如何格式化或排序某些命令的输出的信息，请使用以下部分。有关哪些命令支持各种输出选项的详细信息，请参阅<a href="/zh/docs/reference/kubectl/kubectl/">kubectl</a> 参考文档。</p>
<!--
### Formatting output
-->
<h3 id="格式化输出">格式化输出</h3>
<!--
The default output format for all `kubectl` commands is the human readable plain-text format. To output details to your terminal window in a specific format, you can add either the `-o` or `--output` flags to a supported `kubectl` command.
-->
<p>所有 <code>kubectl</code> 命令的默认输出格式都是人类可读的纯文本格式。要以特定格式向终端窗口输出详细信息，可以将 <code>-o</code> 或 <code>--output</code> 参数添加到受支持的 <code>kubectl</code> 命令中。</p>
<!--
#### Syntax
-->
<h4 id="语法-1">语法</h4>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl <span style="color:#666">[</span>command<span style="color:#666">]</span> <span style="color:#666">[</span>TYPE<span style="color:#666">]</span> <span style="color:#666">[</span>NAME<span style="color:#666">]</span> -o<span style="color:#666">=</span>&lt;output_format&gt;
</code></pre></div><!--
Depending on the `kubectl` operation, the following output formats are supported:
-->
<p>根据 <code>kubectl</code> 操作，支持以下输出格式：</p>
<!--
Output format | Description
--------------| -----------
`-o custom-columns=<spec>` | Print a table using a comma separated list of [custom columns](#custom-columns).
`-o custom-columns-file=<filename>` | Print a table using the [custom columns](#custom-columns) template in the `<filename>` file.
`-o json`     | Output a JSON formatted API object.
`-o jsonpath=<template>` | Print the fields defined in a [jsonpath](/docs/reference/kubectl/jsonpath/) expression.
`-o jsonpath-file=<filename>` | Print the fields defined by the [jsonpath](/docs/reference/kubectl/jsonpath/) expression in the `<filename>` file.
`-o name`     | Print only the resource name and nothing else.
`-o wide`     | Output in the plain-text format with any additional information. For pods, the node name is included.
`-o yaml`     | Output a YAML formatted API object.
-->
<table>
<thead>
<tr>
<th>Output format</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>-o custom-columns=&lt;spec&gt;</code></td>
<td>使用逗号分隔的<a href="#custom-columns">自定义列</a>列表打印表。</td>
</tr>
<tr>
<td><code>-o custom-columns-file=&lt;filename&gt;</code></td>
<td>使用 <code>&lt;filename&gt;</code> 文件中的<a href="#custom-columns">自定义列</a>模板打印表。</td>
</tr>
<tr>
<td><code>-o json</code></td>
<td>输出 JSON 格式的 API 对象</td>
</tr>
<tr>
<td><code>-o jsonpath=&lt;template&gt;</code></td>
<td>打印 <a href="/zh/docs/reference/kubectl/jsonpath/">jsonpath</a> 表达式定义的字段</td>
</tr>
<tr>
<td><code>-o jsonpath-file=&lt;filename&gt;</code></td>
<td>打印 <code>&lt;filename&gt;</code> 文件中 <a href="/zh/docs/reference/kubectl/jsonpath/">jsonpath</a> 表达式定义的字段。</td>
</tr>
<tr>
<td><code>-o name</code></td>
<td>仅打印资源名称而不打印任何其他内容。</td>
</tr>
<tr>
<td><code>-o wide</code></td>
<td>以纯文本格式输出，包含任何附加信息。对于 pod 包含节点名。</td>
</tr>
<tr>
<td><code>-o yaml</code></td>
<td>输出 YAML 格式的 API 对象。</td>
</tr>
</tbody>
</table>
<!--
##### Example
-->
<h5 id="示例">示例</h5>
<!--
In this example, the following command outputs the details for a single pod as a YAML formatted object:
-->
<p>在此示例中，以下命令将单个 pod 的详细信息输出为 YAML 格式的对象：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl get pod web-pod-13je7 -o yaml
</code></pre></div><!--
Remember: See the [kubectl](/docs/reference/kubectl/kubectl/) reference documentation
for details about which output format is supported by each command.
-->
<p>请记住：有关每个命令支持哪种输出格式的详细信息，请参阅 <a href="/zh/docs/reference/kubectl/kubectl/">kubectl</a> 参考文档。</p>
<!--
#### Custom columns
-->
<h4 id="自定义列">自定义列</h4>
<!--
To define custom columns and output only the details that you want into a table, you can use the `custom-columns` option. You can choose to define the custom columns inline or use a template file: `-o=custom-columns=<spec>` or `-o=custom-columns-file=<filename>`.
-->
<p>要定义自定义列并仅将所需的详细信息输出到表中，可以使用该 custom-columns 选项。你可以选择内联定义自定义列或使用模板文件：<code>-o=custom-columns=&lt;spec&gt;</code> 或 <code>-o=custom-columns-file=&lt;filename&gt;</code>。</p>
<!--
##### Examples
-->
<h5 id="示例-1">示例</h5>
<!--
Inline:
-->
<p>内联：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl get pods &lt;pod-name&gt; -o custom-columns<span style="color:#666">=</span>NAME:.metadata.name,RSRC:.metadata.resourceVersion
</code></pre></div><!--
Template file:
-->
<p>模板文件：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl get pods &lt;pod-name&gt; -o custom-columns-file<span style="color:#666">=</span>template.txt
</code></pre></div><!--
where the `template.txt` file contains:
-->
<p>其中，<code>template.txt</code> 文件包含：</p>
<pre tabindex="0"><code>NAME          RSRC
metadata.name metadata.resourceVersion
</code></pre><!--
The result of running either command is similar to:
-->
<p>运行任何一个命令的结果类似于:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">NAME           RSRC
submit-queue   <span style="color:#666">610995</span>
</code></pre></div><!--
#### Server-side columns
-->
<h4 id="server-side-列">Server-side 列</h4>
<!--
`kubectl` supports receiving specific column information from the server about objects.
This means that for any given resource, the server will return columns and rows relevant to that resource, for the client to print.
This allows for consistent human-readable output across clients used against the same cluster, by having the server encapsulate the details of printing.
-->
<p><code>kubectl</code> 支持从服务器接收关于对象的特定列信息。
这意味着对于任何给定的资源，服务器将返回与该资源相关的列和行，以便客户端打印。
通过让服务器封装打印的细节，这允许在针对同一集群使用的客户端之间提供一致的人类可读输出。</p>
<!--
This feature is enabled by default. To disable it, add the
`--server-print=false` flag to the `kubectl get` command.
-->
<p>此功能默认启用。要禁用它，请将该 <code>--server-print=false</code> 参数添加到 <code>kubectl get</code> 命令中。</p>
<!--
##### Examples
-->
<h5 id="例子">例子：</h5>
<!--
To print information about the status of a pod, use a command like the following:
-->
<p>要打印有关 pod 状态的信息，请使用如下命令：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl get pods &lt;pod-name&gt; --server-print<span style="color:#666">=</span><span style="color:#a2f">false</span>
</code></pre></div><!--
The output is similar to:
-->
<p>输出类似于：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">NAME       AGE
pod-name   1m
</code></pre></div><!--
### Sorting list objects
-->
<h3 id="排序列表对象">排序列表对象</h3>
<!--
To output objects to a sorted list in your terminal window, you can add the `--sort-by` flag to a supported `kubectl` command. Sort your objects by specifying any numeric or string field with the `--sort-by` flag. To specify a field, use a [jsonpath](/docs/reference/kubectl/jsonpath/) expression.
-->
<p>要将对象排序后输出到终端窗口，可以将 <code>--sort-by</code> 参数添加到支持的 <code>kubectl</code> 命令。通过使用 <code>--sort-by</code> 参数指定任何数字或字符串字段来对对象进行排序。要指定字段，请使用 <a href="/zh/docs/reference/kubectl/jsonpath/">jsonpath</a> 表达式。</p>
<!--
#### Syntax
-->
<h4 id="语法-2">语法</h4>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl <span style="color:#666">[</span>command<span style="color:#666">]</span> <span style="color:#666">[</span>TYPE<span style="color:#666">]</span> <span style="color:#666">[</span>NAME<span style="color:#666">]</span> --sort-by<span style="color:#666">=</span>&lt;jsonpath_exp&gt;
</code></pre></div><!--
##### Example
-->
<h5 id="示例-2">示例</h5>
<!--
To print a list of pods sorted by name, you run:
-->
<p>要打印按名称排序的 pod 列表，请运行：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl get pods --sort-by<span style="color:#666">=</span>.metadata.name
</code></pre></div><!--
## Examples: Common operations
-->
<h2 id="示例-常用操作">示例：常用操作</h2>
<!--
Use the following set of examples to help you familiarize yourself with running the commonly used `kubectl` operations:
-->
<p>使用以下示例集来帮助你熟悉运行常用 kubectl 操作：</p>
<!--
`kubectl apply` - Apply or Update a resource from a file or stdin.
-->
<p><code>kubectl apply</code> - 以文件或标准输入为准应用或更新资源。</p>
<!--
```shell
# Create a service using the definition in example-service.yaml.
kubectl apply -f example-service.yaml

# Create a replication controller using the definition in example-controller.yaml.
kubectl apply -f example-controller.yaml

# Create the objects that are defined in any .yaml, .yml, or .json file within the <directory> directory.
kubectl apply -f <directory>
```
-->
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="color:#080;font-style:italic"># 使用 example-service.yaml 中的定义创建服务。</span>
kubectl apply -f example-service.yaml

<span style="color:#080;font-style:italic"># 使用 example-controller.yaml 中的定义创建 replication controller。</span>
kubectl apply -f example-controller.yaml

<span style="color:#080;font-style:italic"># 使用 &lt;directory&gt; 路径下的任意 .yaml, .yml, 或 .json 文件 创建对象。</span>
kubectl apply -f &lt;directory&gt;
</code></pre></div><!--
`kubectl get` - List one or more resources.
-->
<p><code>kubectl get</code> - 列出一个或多个资源。</p>
<!--
# List all pods in plain-text output format.
# List all pods in plain-text output format and include additional information (such as node name).
# List the replication controller with the specified name in plain-text output format. Tip: You can shorten and replace the 'replicationcontroller' resource type with the alias 'rc'.
# List all replication controllers and services together in plain-text output format.
# List all daemon sets, including uninitialized ones, in plain-text output format.
# List all pods running on node server01
-->
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="color:#080;font-style:italic"># 以纯文本输出格式列出所有 pod。</span>
kubectl get pods

<span style="color:#080;font-style:italic"># 以纯文本输出格式列出所有 pod，并包含附加信息(如节点名)。</span>
kubectl get pods -o wide

<span style="color:#080;font-style:italic"># 以纯文本输出格式列出具有指定名称的副本控制器。提示：你可以使用别名 &#39;rc&#39; 缩短和替换 &#39;replicationcontroller&#39; 资源类型。</span>
kubectl get replicationcontroller &lt;rc-name&gt;

<span style="color:#080;font-style:italic"># 以纯文本输出格式列出所有副本控制器和服务。</span>
kubectl get rc,services

<span style="color:#080;font-style:italic"># 以纯文本输出格式列出所有守护程序集，包括未初始化的守护程序集。</span>
kubectl get ds --include-uninitialized

<span style="color:#080;font-style:italic"># 列出在节点 server01 上运行的所有 pod</span>
kubectl get pods --field-selector<span style="color:#666">=</span>spec.nodeName<span style="color:#666">=</span>server01
</code></pre></div><!--
`kubectl describe` - Display detailed state of one or more resources, including the uninitialized ones by default.
-->
<p><code>kubectl describe</code> - 显示一个或多个资源的详细状态，默认情况下包括未初始化的资源。</p>
<!--
# Display the details of the node with name <node-name>.
kubectl describe nodes <node-name>

# Display the details of the pod with name <pod-name>.
kubectl describe pods/<pod-name>

# Display the details of all the pods that are managed by the replication controller named <rc-name>.
# Remember: Any pods that are created by the replication controller get prefixed with the name of the replication controller.
kubectl describe pods <rc-name>

# Describe all pods, not including uninitialized ones
kubectl describe pods
-->
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="color:#080;font-style:italic"># 显示名称为 &lt;node-name&gt; 的节点的详细信息。</span>
kubectl describe nodes &lt;node-name&gt;

<span style="color:#080;font-style:italic"># 显示名为 &lt;pod-name&gt; 的 pod 的详细信息。</span>
kubectl describe pods/&lt;pod-name&gt;

<span style="color:#080;font-style:italic"># 显示由名为 &lt;rc-name&gt; 的副本控制器管理的所有 pod 的详细信息。</span>
<span style="color:#080;font-style:italic"># 记住：副本控制器创建的任何 pod 都以复制控制器的名称为前缀。</span>
kubectl describe pods &lt;rc-name&gt;

<span style="color:#080;font-style:italic"># 描述所有的 pod，不包括未初始化的 pod</span>
kubectl describe pods
</code></pre></div><blockquote class="note callout">
  <div><strong>说明：</strong> <!--
The `kubectl get` command is usually used for retrieving one or more
resources of the same resource type. It features a rich set of flags that allows
you to customize the output format using the `-o` or `--output` flag, for example.
You can specify the `-w` or `--watch` flag to start watching updates to a particular
object. The `kubectl describe` command is more focused on describing the many
related aspects of a specified resource. It may invoke several API calls to the
API server to build a view for the user. For example, the `kubectl describe node`
command retrieves not only the information about the node, but also a summary of
the pods running on it, the events generated for the node etc.
-->
<p><code>kubectl get</code> 命令通常用于检索同一资源类型的一个或多个资源。
它具有丰富的参数，允许你使用 <code>-o</code> 或 <code>--output</code> 参数自定义输出格式。你可以指定 <code>-w</code> 或 <code>--watch</code> 参数以开始观察特定对象的更新。
<code>kubectl describe</code> 命令更侧重于描述指定资源的许多相关方面。它可以调用对 <code>API 服务器</code> 的多个 API 调用来为用户构建视图。
例如，该 <code>kubectl describe node</code> 命令不仅检索有关节点的信息，还检索在其上运行的 pod 的摘要，为节点生成的事件等。</div>
</blockquote>
<!--
`kubectl delete` - Delete resources either from a file, stdin, or specifying label selectors, names, resource selectors, or resources.
-->
<p><code>kubectl delete</code> - 从文件、stdin 或指定标签选择器、名称、资源选择器或资源中删除资源。</p>
<!--
```shell
# Delete a pod using the type and name specified in the pod.yaml file.
kubectl delete -f pod.yaml

# Delete all the pods and services that have the label '<label-key>=<label-value>'.
kubectl delete pods,services -l <label-key>=<label-value>

# Delete all pods, including uninitialized ones.
kubectl delete pods --all
```

-->
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="color:#080;font-style:italic"># 使用 pod.yaml 文件中指定的类型和名称删除 pod。</span>
kubectl delete -f pod.yaml

<span style="color:#080;font-style:italic"># 删除所有带有 &#39;&lt;label-key&gt;=&lt;label-value&gt;&#39; 标签的 Pod 和服务。</span>
kubectl delete pods,services -l &lt;label-key&gt;<span style="color:#666">=</span>&lt;label-value&gt;

<span style="color:#080;font-style:italic"># 删除所有 pod，包括未初始化的 pod。</span>
kubectl delete pods --all
</code></pre></div><!--
`kubectl exec` - Execute a command against a container in a pod.
-->
<p><code>kubectl exec</code> - 对 pod 中的容器执行命令。</p>
<!--
# Get output from running 'date' from pod <pod-name>. By default, output is from the first container.
kubectl exec <pod-name> -- date

# Get output from running 'date' in container <container-name> of pod <pod-name>.
kubectl exec <pod-name> -c <container-name> -- date

# Get an interactive TTY and run /bin/bash from pod <pod-name>. By default, output is from the first container.
kubectl exec -ti <pod-name> -- /bin/bash
-->
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="color:#080;font-style:italic"># 从 pod &lt;pod-name&gt; 中获取运行 &#39;date&#39; 的输出。默认情况下，输出来自第一个容器。</span>
kubectl <span style="color:#a2f">exec</span> &lt;pod-name&gt; -- date

<span style="color:#080;font-style:italic"># 运行输出 &#39;date&#39; 获取在容器的 &lt;container-name&gt; 中 pod &lt;pod-name&gt; 的输出。</span>
kubectl <span style="color:#a2f">exec</span> &lt;pod-name&gt; -c &lt;container-name&gt; -- date

<span style="color:#080;font-style:italic"># 获取一个交互 TTY 并运行 /bin/bash &lt;pod-name &gt;。默认情况下，输出来自第一个容器。</span>
kubectl <span style="color:#a2f">exec</span> -ti &lt;pod-name&gt; -- /bin/bash
</code></pre></div><!--
`kubectl logs` - Print the logs for a container in a pod.
-->
<p><code>kubectl logs</code> - 打印 Pod 中容器的日志。</p>
<!--
# Return a snapshot of the logs from pod <pod-name>.
kubectl logs <pod-name>

# Start streaming the logs from pod <pod-name>. This is similar to the 'tail -f' Linux command.
kubectl logs -f <pod-name>
-->
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="color:#080;font-style:italic"># 从 pod 返回日志快照。</span>
kubectl logs &lt;pod-name&gt;

<span style="color:#080;font-style:italic"># 从 pod &lt;pod-name&gt; 开始流式传输日志。这类似于 &#39;tail -f&#39; Linux 命令。</span>
kubectl logs -f &lt;pod-name&gt;
</code></pre></div><!--
## Examples: Creating and using plugins
-->
<h2 id="示例-创建和使用插件">示例：创建和使用插件</h2>
<!--
Use the following set of examples to help you familiarize yourself with writing and using `kubectl` plugins:
-->
<p>使用以下示例来帮助你熟悉编写和使用 <code>kubectl</code> 插件：</p>
<!--
```shell
# create a simple plugin in any language and name the resulting executable file
# so that it begins with the prefix "kubectl-"
cat ./kubectl-hello
#!/bin/sh

# this plugin prints the words "hello world"
echo "hello world"
```
With a plugin written, let's make it executable:
```bash
chmod a+x ./kubectl-hello

# and move it to a location in our PATH
sudo mv ./kubectl-hello /usr/local/bin
sudo chown root:root /usr/local/bin

# You have now created and "installed" a kubectl plugin.
# You can begin using this plugin by invoking it from kubectl as if it were a regular command
kubectl hello
```
-->
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="color:#080;font-style:italic"># 用任何语言创建一个简单的插件，并为生成的可执行文件命名</span>
<span style="color:#080;font-style:italic"># 以前缀 &#34;kubectl-&#34; 开始</span>
cat ./kubectl-hello
</code></pre></div><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="color:#080">#!/bin/sh
</span><span style="color:#080"></span>
<span style="color:#080;font-style:italic"># 这个插件打印单词 &#34;hello world&#34;</span>
<span style="color:#a2f">echo</span> <span style="color:#b44">&#34;hello world&#34;</span>
</code></pre></div><p>这个插件写好了，把它变成可执行的：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">sudo chmod a+x ./kubectl-hello

<span style="color:#080;font-style:italic"># 并将其移动到路径中的某个位置</span>
sudo mv ./kubectl-hello /usr/local/bin
sudo chown root:root /usr/local/bin

<span style="color:#080;font-style:italic"># 你现在已经创建并&#34;安装了&#34;一个 kubectl 插件。</span>
<span style="color:#080;font-style:italic"># 你可以开始使用这个插件，从 kubectl 调用它，就像它是一个常规命令一样</span>
kubectl hello
</code></pre></div><pre tabindex="0"><code>hello world
</code></pre><!--
```shell
# You can "uninstall" a plugin, by removing it from the folder in your
# $PATH where you placed it
sudo rm /usr/local/bin/kubectl-hello
```
-->
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="color:#080;font-style:italic"># 你可以&#34;卸载&#34;一个插件，只需从你的路径中删除它</span>
sudo rm /usr/local/bin/kubectl-hello
</code></pre></div><!--
In order to view all of the plugins that are available to `kubectl`, use
the `kubectl plugin list` subcommand:
-->
<p>为了查看可用的所有 <code>kubectl</code> 插件，你可以使用 <code>kubectl plugin list</code> 子命令：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl plugin list
</code></pre></div><!--
The output is similar to:
```
The following kubectl-compatible plugins are available:

/usr/local/bin/kubectl-hello
/usr/local/bin/kubectl-foo
/usr/local/bin/kubectl-bar
```
-->
<p>输出类似于：</p>
<pre tabindex="0"><code>The following kubectl-compatible plugins are available:

/usr/local/bin/kubectl-hello
/usr/local/bin/kubectl-foo
/usr/local/bin/kubectl-bar
</code></pre><!--
`kubectl plugin list` also warns you about plugins that are not
executable, or that are shadowed by other plugins; for example:
```shell
sudo chmod -x /usr/local/bin/kubectl-foo # remove execute permission
kubectl plugin list
```
-->
<p><code>kubectl plugin list</code>指令也可以向你告警哪些插件被运行，或是被其它插件覆盖了,例如:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">sudo chmod -x /usr/local/bin/kubectl-foo <span style="color:#080;font-style:italic"># 删除执行权限</span>
kubectl plugin list
</code></pre></div><!--
```
The following kubectl-compatible plugins are available:

/usr/local/bin/kubectl-hello
/usr/local/bin/kubectl-foo
  - warning: /usr/local/bin/kubectl-foo identified as a plugin, but it is not executable
/usr/local/bin/kubectl-bar

error: one plugin warning was found
```
-->
<pre tabindex="0"><code>The following kubectl-compatible plugins are available:

/usr/local/bin/kubectl-hello
/usr/local/bin/kubectl-foo
  - warning: /usr/local/bin/kubectl-foo identified as a plugin, but it is not executable
/usr/local/bin/kubectl-bar

error: one plugin warning was found
</code></pre><!--
You can think of plugins as a means to build more complex functionality on top
of the existing kubectl commands:
-->
<p>你可以将插件视为在现有 kubectl 命令之上构建更复杂功能的一种方法：</p>
<!--
```shell
cat ./kubectl-whoami```
-->
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">cat ./kubectl-whoami
</code></pre></div><!--
The next few examples assume that you already made `kubectl-whoami` have
the following contents:
-->
<p>接下来的几个示例假设你已经将 <code>kubectl-whoami</code> 设置为以下内容:</p>
<!--
```shell
#!/bin/bash

# this plugin makes use of the `kubectl config` command in order to output
# information about the current user, based on the currently selected context
kubectl config view --template='{{ range .contexts }}{{ if eq .name "'$(kubectl config current-context)'" }}Current user: {{ printf "%s\n" .context.user }}{{ end }}{{ end }}'
```
-->
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="color:#080">#!/bin/bash
</span><span style="color:#080"></span>
<span style="color:#080;font-style:italic">#这个插件利用 `kubectl config` 命令基于当前所选上下文输出当前用户的信息</span>
kubectl config view --template<span style="color:#666">=</span><span style="color:#b44">&#39;{{ range .contexts }}{{ if eq .name &#34;&#39;</span><span style="color:#a2f;font-weight:bold">$(</span>kubectl config current-context<span style="color:#a2f;font-weight:bold">)</span><span style="color:#b44">&#39;&#34; }}Current user: {{ printf &#34;%s\n&#34; .context.user }}{{ end }}{{ end }}&#39;</span>
</code></pre></div><!--
Running the above command gives you an output containing the user for the
current context in your KUBECONFIG file:
-->
<p>运行以上命令将为你提供一个输出，其中包含 KUBECONFIG 文件中当前上下文的用户:</p>
<!--
```shell
# make the file executable
sudo chmod +x ./kubectl-whoami

# and move it into your PATH
sudo mv ./kubectl-whoami /usr/local/bin

kubectl whoami
Current user: plugins-user
```
-->
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="color:#080">#!/bin/bash
</span><span style="color:#080"></span><span style="color:#080;font-style:italic"># 使文件成为可执行的</span>
sudo chmod +x ./kubectl-whoami

<span style="color:#080;font-style:italic"># 然后移动到你的路径中</span>
sudo mv ./kubectl-whoami /usr/local/bin

kubectl whoami
Current user: plugins-user
</code></pre></div><!--
To find out more about plugins, take a look at the [example cli plugin](https://github.com/kubernetes/sample-cli-plugin).
-->
<p>要了解关于插件的更多信息，请查看<a href="https://github.com/kubernetes/sample-cli-plugin">示例 cli 插件</a>。</p>
<h2 id="接下来">接下来</h2>
<!--
* Start using the [kubectl](/docs/reference/generated/kubectl/kubectl-commands/) commands.

* To find out more about plugins, take a look at the [example cli plugin](https://github.com/kubernetes/sample-cli-plugin).
-->
<ul>
<li>
<p>开始使用 <a href="/docs/reference/generated/kubectl/kubectl-commands/">kubectl</a> 命令。</p>
</li>
<li>
<p>查看更多<a href="https://github.com/kubernetes/sample-cli-plugin">示例 cli 插件</a>。</p>
</li>
</ul>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-a938176c695852fe70362c29cf615f1c">8.2 - JSONPath 支持</h1>
    
	<!--
---
title: JSONPath Support
content_type: concept
weight: 25
---
-->
<!-- overview -->
<!--
Kubectl supports JSONPath template.
-->
<p>Kubectl 支持 JSONPath 模板。</p>
<!-- body -->
<!--
JSONPath template is composed of JSONPath expressions enclosed by curly braces {}.
Kubectl uses JSONPath expressions to filter on specific fields in the JSON object and format the output.
In addition to the original JSONPath template syntax, the following functions and syntax are valid:
-->
<p>JSONPath 模板由 {} 包起来的 JSONPath 表达式组成。Kubectl 使用 JSONPath 表达式来过滤 JSON 对象中的特定字段并格式化输出。除了原始的 JSONPath 模板语法，以下函数和语法也是有效的:</p>
<!--
1. Use double quotes to quote text inside JSONPath expressions.
2. Use the `range`, `end` operators to iterate lists.
3. Use negative slice indices to step backwards through a list. Negative indices do not "wrap around" a list and are valid as long as `-index + listLength >= 0`.
-->
<ol>
<li>使用双引号将 JSONPath 表达式内的文本引起来。</li>
<li>使用 <code>range</code>，<code>end</code> 运算符来迭代列表。</li>
<li>使用负片索引后退列表。负索引不会“环绕”列表，并且只要 <code>-index + listLength&gt; = 0</code> 就有效。</li>
</ol>
<blockquote class="note callout">
  <div><strong>说明：</strong> <!--
- The `$` operator is optional since the expression always starts from the root object by default.

- The result object is printed as its String() function.
-->
<ul>
<li>
<p><code>$</code> 运算符是可选的，因为默认情况下表达式总是从根对象开始。</p>
</li>
<li>
<p>结果对象将作为其 String() 函数输出。</p>
</li>
</ul>
</div>
</blockquote>
<!--
Given the JSON input:
-->
<p>给定 JSON 输入:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-json" data-lang="json">{
  <span style="color:#008000;font-weight:bold">&#34;kind&#34;</span>: <span style="color:#b44">&#34;List&#34;</span>,
  <span style="color:#008000;font-weight:bold">&#34;items&#34;</span>:[
    {
      <span style="color:#008000;font-weight:bold">&#34;kind&#34;</span>:<span style="color:#b44">&#34;None&#34;</span>,
      <span style="color:#008000;font-weight:bold">&#34;metadata&#34;</span>:{<span style="color:#008000;font-weight:bold">&#34;name&#34;</span>:<span style="color:#b44">&#34;127.0.0.1&#34;</span>},
      <span style="color:#008000;font-weight:bold">&#34;status&#34;</span>:{
        <span style="color:#008000;font-weight:bold">&#34;capacity&#34;</span>:{<span style="color:#008000;font-weight:bold">&#34;cpu&#34;</span>:<span style="color:#b44">&#34;4&#34;</span>},
        <span style="color:#008000;font-weight:bold">&#34;addresses&#34;</span>:[{<span style="color:#008000;font-weight:bold">&#34;type&#34;</span>: <span style="color:#b44">&#34;LegacyHostIP&#34;</span>, <span style="color:#008000;font-weight:bold">&#34;address&#34;</span>:<span style="color:#b44">&#34;127.0.0.1&#34;</span>}]
      }
    },
    {
      <span style="color:#008000;font-weight:bold">&#34;kind&#34;</span>:<span style="color:#b44">&#34;None&#34;</span>,
      <span style="color:#008000;font-weight:bold">&#34;metadata&#34;</span>:{<span style="color:#008000;font-weight:bold">&#34;name&#34;</span>:<span style="color:#b44">&#34;127.0.0.2&#34;</span>},
      <span style="color:#008000;font-weight:bold">&#34;status&#34;</span>:{
        <span style="color:#008000;font-weight:bold">&#34;capacity&#34;</span>:{<span style="color:#008000;font-weight:bold">&#34;cpu&#34;</span>:<span style="color:#b44">&#34;8&#34;</span>},
        <span style="color:#008000;font-weight:bold">&#34;addresses&#34;</span>:[
          {<span style="color:#008000;font-weight:bold">&#34;type&#34;</span>: <span style="color:#b44">&#34;LegacyHostIP&#34;</span>, <span style="color:#008000;font-weight:bold">&#34;address&#34;</span>:<span style="color:#b44">&#34;127.0.0.2&#34;</span>},
          {<span style="color:#008000;font-weight:bold">&#34;type&#34;</span>: <span style="color:#b44">&#34;another&#34;</span>, <span style="color:#008000;font-weight:bold">&#34;address&#34;</span>:<span style="color:#b44">&#34;127.0.0.3&#34;</span>}
        ]
      }
    }
  ],
  <span style="color:#008000;font-weight:bold">&#34;users&#34;</span>:[
    {
      <span style="color:#008000;font-weight:bold">&#34;name&#34;</span>: <span style="color:#b44">&#34;myself&#34;</span>,
      <span style="color:#008000;font-weight:bold">&#34;user&#34;</span>: {}
    },
    {
      <span style="color:#008000;font-weight:bold">&#34;name&#34;</span>: <span style="color:#b44">&#34;e2e&#34;</span>,
      <span style="color:#008000;font-weight:bold">&#34;user&#34;</span>: {<span style="color:#008000;font-weight:bold">&#34;username&#34;</span>: <span style="color:#b44">&#34;admin&#34;</span>, <span style="color:#008000;font-weight:bold">&#34;password&#34;</span>: <span style="color:#b44">&#34;secret&#34;</span>}
    }
  ]
}
</code></pre></div><!--
Function            | Description               | Example                                                         | Result
--------------------|---------------------------|-----------------------------------------------------------------|------------------
`text`              | the plain text            | `kind is {.kind}`                                               | `kind is List`
`@`                 | the current object        | `{@}`                                                           | the same as input
`.` or `[]`         | child operator            | `{.kind}`, `{['kind']}` or `{['name\.type']}`                   | `List`
`..`                | recursive descent         | `{..name}`                                                      | `127.0.0.1 127.0.0.2 myself e2e`
`*`                 | wildcard. Get all objects | `{.items[*].metadata.name}`                                     | `[127.0.0.1 127.0.0.2]`
`[start:end :step]` | subscript operator        | `{.users[0].name}`                                              | `myself`
`[,]`               | union operator            | `{.items[*]['metadata.name', 'status.capacity']}`               | `127.0.0.1 127.0.0.2 map[cpu:4] map[cpu:8]`
`?()`               | filter                    | `{.users[?(@.name=="e2e")].user.password}`                      | `secret`
`range`, `end`      | iterate list              | `{range .items[*]}[{.metadata.name}, {.status.capacity}] {end}` | `[127.0.0.1, map[cpu:4]] [127.0.0.2, map[cpu:8]]`
`''`                | quote interpreted string  | `{range .items[*]}{.metadata.name}{'\t'}{end}`                  | `127.0.0.1      127.0.0.2`
-->
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
<th>示例</th>
<th>结果</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>text</code></td>
<td>纯文本</td>
<td><code>kind is {.kind}</code></td>
<td><code>kind is List</code></td>
</tr>
<tr>
<td><code>@</code></td>
<td>当前对象</td>
<td><code>{@}</code></td>
<td>与输入相同</td>
</tr>
<tr>
<td><code>.</code> or <code>[]</code></td>
<td>子运算符</td>
<td><code>{.kind}</code>, <code>{['kind']}</code> or <code>{['name\.type']}</code></td>
<td><code>List</code></td>
</tr>
<tr>
<td><code>..</code></td>
<td>递归下降</td>
<td><code>{..name}</code></td>
<td><code>127.0.0.1 127.0.0.2 myself e2e</code></td>
</tr>
<tr>
<td><code>*</code></td>
<td>通配符。获取所有对象</td>
<td><code>{.items[*].metadata.name}</code></td>
<td><code>[127.0.0.1 127.0.0.2]</code></td>
</tr>
<tr>
<td><code>[start:end :step]</code></td>
<td>下标运算符</td>
<td><code>{.users[0].name}</code></td>
<td><code>myself</code></td>
</tr>
<tr>
<td><code>[,]</code></td>
<td>并集运算符</td>
<td><code>{.items[*]['metadata.name', 'status.capacity']}</code></td>
<td><code>127.0.0.1 127.0.0.2 map[cpu:4] map[cpu:8]</code></td>
</tr>
<tr>
<td><code>?()</code></td>
<td>过滤</td>
<td><code>{.users[?(@.name==&quot;e2e&quot;)].user.password}</code></td>
<td><code>secret</code></td>
</tr>
<tr>
<td><code>range</code>, <code>end</code></td>
<td>迭代列表</td>
<td><code>{range .items[*]}[{.metadata.name}, {.status.capacity}] {end}</code></td>
<td><code>[127.0.0.1, map[cpu:4]] [127.0.0.2, map[cpu:8]]</code></td>
</tr>
<tr>
<td><code>''</code></td>
<td>引用解释执行字符串</td>
<td><code>{range .items[*]}{.metadata.name}{'\t'}{end}</code></td>
<td><code>127.0.0.1      127.0.0.2</code></td>
</tr>
</tbody>
</table>
<!--
Examples using `kubectl` and JSONPath expressions:
-->
<p>使用 <code>kubectl</code> 和 JSONPath 表达式的示例:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl get pods -o json
kubectl get pods -o<span style="color:#666">=</span><span style="color:#b8860b">jsonpath</span><span style="color:#666">=</span><span style="color:#b44">&#39;{@}&#39;</span>
kubectl get pods -o<span style="color:#666">=</span><span style="color:#b8860b">jsonpath</span><span style="color:#666">=</span><span style="color:#b44">&#39;{.items[0]}&#39;</span>
kubectl get pods -o<span style="color:#666">=</span><span style="color:#b8860b">jsonpath</span><span style="color:#666">=</span><span style="color:#b44">&#39;{.items[0].metadata.name}&#39;</span>
kubectl get pods -o<span style="color:#666">=</span><span style="color:#b8860b">jsonpath</span><span style="color:#666">=</span><span style="color:#b44">&#34;{.items[*][&#39;metadata.name&#39;, &#39;status.capacity&#39;]}&#34;</span>
kubectl get pods -o<span style="color:#666">=</span><span style="color:#b8860b">jsonpath</span><span style="color:#666">=</span><span style="color:#b44">&#39;{range .items[*]}{.metadata.name}{&#34;\t&#34;}{.status.startTime}{&#34;\n&#34;}{end}&#39;</span>
</code></pre></div><!--
<blockquote class="note callout">
  <div><strong>说明：</strong> <p>On Windows, you must <em>double</em> quote any JSONPath template that contains spaces (not single quote as shown above for bash). This in turn means that you must use a single quote or escaped double quote around any literals in the template. For example:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cmd" data-lang="cmd">kubectl get pods -o=jsonpath=<span style="color:#b44">&#34;{range .items[*]}{.metadata.name}{&#39;\t&#39;}{.status.startTime}{&#39;\n&#39;}{end}&#34;</span>
kubectl get pods -o=jsonpath=<span style="color:#b44">&#34;{range .items[*]}{.metadata.name}{\&#34;</span>\t\<span style="color:#b44">&#34;}{.status.startTime}{\&#34;</span>\n\<span style="color:#b44">&#34;}{end}&#34;</span>
</code></pre></div></div>
</blockquote>
-->
<blockquote class="note callout">
  <div><strong>说明：</strong> <p>在 Windows 上，对于任何包含空格的 JSONPath 模板，您必须使用双引号（不是上面 bash 所示的单引号）。
反过来，这意味着您必须在模板中的所有文字周围使用单引号或转义的双引号。
例如:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cmd" data-lang="cmd">C:<span style="color:#a0a000">\</span><span style="color:#080;font-style:italic">&gt; kubectl get pods -o=jsonpath=&#34;{range .items[*]}{.metadata.name}{&#39;\t&#39;}{.status.startTime}{&#39;\n&#39;}{end}&#34;</span>
C:<span style="color:#a0a000">\</span><span style="color:#080;font-style:italic">&gt; kubectl get pods -o=jsonpath=&#34;{range .items[*]}{.metadata.name}{\&#34;\t\&#34;}{.status.startTime}{\&#34;\n\&#34;}{end}&#34;</span>
</code></pre></div></div>
</blockquote>
<!--
JSONPath regular expressions are not supported. If you want to match using regular expressions, you can use a tool such as `jq`.

```shell
# kubectl does not support regular expressions for JSONpath output
# The following command does not work
kubectl get pods -o jsonpath='{.items[?(@.metadata.name=~/^test$/)].metadata.name}'

# The following command achieves the desired result
kubectl get pods -o json | jq -r '.items[] | select(.metadata.name | test("test-")).spec.containers[].image'
```
-->
<blockquote class="note callout">
  <div><strong>说明：</strong> <p>不支持 JSONPath 正则表达式。如需使用正则表达式进行匹配操作，您可以使用如 <code>jq</code> 之类的工具。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="color:#080;font-style:italic"># kubectl 的 JSONpath 输出不支持正则表达式</span>
<span style="color:#080;font-style:italic"># 下面的命令不会生效</span>
kubectl get pods -o <span style="color:#b8860b">jsonpath</span><span style="color:#666">=</span><span style="color:#b44">&#39;{.items[?(@.metadata.name=~/^test$/)].metadata.name}&#39;</span>

<span style="color:#080;font-style:italic"># 下面的命令可以获得所需的结果</span>
kubectl get pods -o json | jq -r <span style="color:#b44">&#39;.items[] | select(.metadata.name | test(&#34;test-&#34;)).spec.containers[].image&#39;</span>
</code></pre></div></div>
</blockquote>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-4d3e62632c189fcc3c1357cd8fb8799c">8.3 - kubectl</h1>
    
	<!--
---
title: kubectl
content_type: tool-reference
weight: 28
---
-->
<h2 id="简介">简介</h2>
<!--
kubectl controls the Kubernetes cluster manager.
-->
<p>kubectl 管理控制 Kubernetes 集群。</p>
<!--
Find more information at: https://kubernetes.io/docs/reference/kubectl/overview/
-->
<p>获取更多信息，请访问 <a href="/zh/docs/reference/kubectl/overview/">kubectl 概述</a>。</p>
<pre tabindex="0"><code>kubectl [flags]
</code></pre><h2 id="选项">选项</h2>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
    <tr>
      <td colspan="2">--add-dir-header</td>
    </tr>
    <tr>
      <td></td><td style="line-height: 130%; word-wrap: break-word;">
      <!--
      If true, adds the file directory to the header of the log messages
      -->
      设置为 true 表示添加文件目录到日志信息头中
      </td>
    </tr>
    <tr>
      <td colspan="2">--alsologtostderr</td>
    </tr>
    <tr>
      <td></td><td style="line-height: 130%; word-wrap: break-word;">
      <!--
      log to standard error as well as files
      -->
      表示将日志输出到文件的同时输出到 stderr
      </td>
    </tr>
    <tr>
      <td colspan="2">--as string</td>
    </tr>
    <tr>
      <td></td><td style="line-height: 130%; word-wrap: break-word;">
      <!--
      Username to impersonate for the operation
      -->
      以指定用户的身份执行操作
      </td>
    </tr>
    <tr>
      <td colspan="2">--as-group stringArray</td>
    </tr>
    <tr>
      <td></td><td style="line-height: 130%; word-wrap: break-word;">
      <!--
      Group to impersonate for the operation, this flag can be repeated to specify multiple groups.
      -->
      模拟指定的组来执行操作，可以使用这个标志来指定多个组。
      </td>
    </tr>
    <tr>
      <td colspan="2">--azure-container-registry-config string</td>
    </tr>
    <tr>
      <td></td><td style="line-height: 130%; word-wrap: break-word;">
      <!--
      Path to the file containing Azure container registry configuration information.
      -->
      包含 Azure 容器仓库配置信息的文件的路径。
      </td>
    </tr>
    <tr>
      <td colspan="2">--cache-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值: "$HOME/.kube/cache"</td>
    </tr>
    <tr>
      <td></td><td style="line-height: 130%; word-wrap: break-word;">
      <!--
      Default cache directory
      -->
      默认缓存目录
      </td>
    </tr>
    <tr>
      <td colspan="2">--certificate-authority string</td>
    </tr>
    <tr>
      <td></td><td style="line-height: 130%; word-wrap: break-word;">
      <!--
      Path to a cert file for the certificate authority
      -->
      指向证书机构的 cert 文件路径
      </td>
    </tr>
    <tr>
      <td colspan="2">--client-certificate string</td>
    </tr>
    <tr>
      <td></td><td style="line-height: 130%; word-wrap: break-word;">
      <!--
      Path to a client certificate file for TLS
      -->
      TLS 使用的客户端证书路径
      </td>
    </tr>
    <tr>
      <td colspan="2">--client-key string</td>
    </tr>
    <tr>
      <td></td><td style="line-height: 130%; word-wrap: break-word;">
      <!--
      Path to a client key file for TLS
      -->
      TLS 使用的客户端密钥文件路径
      </td>
    </tr>
    <tr>
      <td colspan="2">--cloud-provider-gce-l7lb-src-cidrs cidrs&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值: 130.211.0.0/22,35.191.0.0/16</td>
    </tr>
    <tr>
      <td></td><td style="line-height: 130%; word-wrap: break-word;">
        <!--CIDRs opened in GCE firewall for L7 LB traffic proxy & health checks-->
        在 GCE 防火墙中开放的 CIDR，用来进行 L7 LB 流量代理和健康检查。
      </td>
    </tr>
    <tr>
      <td colspan="2">--cloud-provider-gce-lb-src-cidrs cidrs&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值: 130.211.0.0/22,209.85.152.0/22,209.85.204.0/22,35.191.0.0/16</td>
    </tr>
    <tr>
      <td></td><td style="line-height: 130%; word-wrap: break-word;">
      <!--
      CIDRs opened in GCE firewall for L4 LB traffic proxy & health checks
      -->
      在 GCE 防火墙中开放的 CIDR，用来进行 L4 LB 流量代理和健康检查。
      </td>
    </tr>
    <tr>
      <td colspan="2">--cluster string</td>
    </tr>
    <tr>
      <td></td><td style="line-height: 130%; word-wrap: break-word;">
      <!--
      The name of the kubeconfig cluster to use
      -->
      要使用的 kubeconfig 集群的名称
      </td>
    </tr>
    <tr>
      <td colspan="2">--context string</td>
    </tr>
    <tr>
      <td></td><td style="line-height: 130%; word-wrap: break-word;">
      <!--
      The name of the kubeconfig context to use
      -->
      要使用的 kubeconfig 上下文的名称
      </td>
    </tr>
    <tr>
      <td colspan="2">--default-not-ready-toleration-seconds int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值: 300</td>
    </tr>
    <tr>
      <td></td><td style="line-height: 130%; word-wrap: break-word;">
      <!--
      Indicates the tolerationSeconds of the toleration for notReady:NoExecute that is added by default to every pod that does not already have such a toleration.
      -->
      表示 `notReady` 状态的容忍度秒数：默认情况下，`NoExecute` 被添加到尚未具有此容忍度的每个 Pod 中。
      </td>
    </tr>
    <tr>
      <td colspan="2">--default-unreachable-toleration-seconds int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值: 300</td>
    </tr>
    <tr>
      <td></td><td style="line-height: 130%; word-wrap: break-word;">
      <!--
      Indicates the tolerationSeconds of the toleration for unreachable:NoExecute that is added by default to every pod that does not already have such a toleration.
      -->
      表示 `unreachable` 状态的容忍度秒数：默认情况下，`NoExecute` 被添加到尚未具有此容忍度的每个 Pod 中。
      </td>
    </tr>
    <tr>
      <td colspan="2">-h, --help</td>
    </tr>
    <tr>
      <td></td><td style="line-height: 130%; word-wrap: break-word;">
      <!--
      help for kubectl
      -->
      kubectl 操作的帮助命令
      </td>
    </tr>
    <tr>
      <td colspan="2">--insecure-skip-tls-verify</td>
    </tr>
    <tr>
      <td></td><td style="line-height: 130%; word-wrap: break-word;">
      <!--
      If true, the server's certificate will not be checked for validity. This will make your HTTPS connections insecure
      -->
      设置为 true，则表示不会检查服务器证书的有效性。这样会导致您的 HTTPS 连接不安全。
      </td>
    </tr>
    <tr>
      <td colspan="2">--kubeconfig string</td>
    </tr>
    <tr>
      <td></td><td style="line-height: 130%; word-wrap: break-word;">
      <!--
      Path to the kubeconfig file to use for CLI requests.
      -->
      CLI 请求使用的 kubeconfig 配置文件的路径。
      </td>
    </tr>
    <tr>
      <td colspan="2">--log-backtrace-at traceLocation&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值: 0</td>
    </tr>
    <tr>
      <td></td><td style="line-height: 130%; word-wrap: break-word;">
      <!--
      when logging hits line file:N, emit a stack trace
      -->
      当日志机制运行到指定文件的指定行（file:N）时，打印调用堆栈信息
      </td>
    </tr>
    <tr>
      <td colspan="2">--log-dir string</td>
    </tr>
    <tr>
      <td></td><td style="line-height: 130%; word-wrap: break-word;">
      <!--
      If non-empty, write log files in this directory
      -->
      如果不为空，则将日志文件写入此目录
      </td>
    </tr>
    <tr>
      <td colspan="2">--log-file string</td>
    </tr>
    <tr>
      <td></td><td style="line-height: 130%; word-wrap: break-word;">
      <!--
      If non-empty, use this log file
      -->
      如果不为空，则将使用此日志文件
      </td>
    </tr>
    <tr>
      <td colspan="2">--log-file-max-size uint&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值: 1800</td>
    </tr>
    <tr>
      <td></td><td style="line-height: 130%; word-wrap: break-word;">
      <!--
      Defines the maximum size a log file can grow to. Unit is megabytes. If the value is 0, the maximum file size is unlimited.
      -->
      定义日志文件的最大尺寸。单位为兆字节。如果值设置为 0，则表示日志文件大小不受限制。
      </td>
    </tr>
    <tr>
      <td colspan="2">--log-flush-frequency duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值: 5s</td>
    </tr>
    <tr>
      <td></td><td style="line-height: 130%; word-wrap: break-word;">
      <!--
      Maximum number of seconds between log flushes
      -->
      两次日志刷新操作之间的最长时间（秒）
      </td>
    </tr>
    <tr>
      <td colspan="2">--logtostderr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值: true</td>
    </tr>
    <tr>
      <td></td><td style="line-height: 130%; word-wrap: break-word;">
      <!--
      log to standard error instead of files
      -->
      日志输出到 stderr 而不是文件中
      </td>
    </tr>
    <tr>
      <td colspan="2">--match-server-version</td>
    </tr>
    <tr>
      <td></td><td style="line-height: 130%; word-wrap: break-word;">
      <!--
      Require server version to match client version
      -->
      要求客户端版本和服务端版本相匹配
      </td>
    </tr>
    <tr>
      <td colspan="2">-n, --namespace string</td>
    </tr>
    <tr>
      <td></td><td style="line-height: 130%; word-wrap: break-word;">
      <!--
      If present, the namespace scope for this CLI request
      -->
      如果存在，CLI 请求将使用此命名空间
      </td>
    <tr>
      <td colspan="2">--one-output</td>
    </tr>
    <tr>
      <td></td><td style="line-height: 130%; word-wrap: break-word;">
      <!--If true, only write logs to their native severity level (vs also writing to each lower severity level-->
      如果为 true，则只将日志写入初始严重级别（而不是同时写入所有较低的严重级别）。
      </td>
    </tr>
    </tr>
    <tr>
      <td colspan="2">--password string</td>
    </tr>
    <tr>
      <td></td><td style="line-height: 130%; word-wrap: break-word;">
      <!--
      Password for basic authentication to the API server
      -->
      API 服务器进行基本身份验证的密码
      </td>
    </tr>
    <tr>
      <td colspan="2">--profile string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值: "none"</td>
    </tr>
    <tr>
      <td></td><td style="line-height: 130%; word-wrap: break-word;">
      <!--
      Name of profile to capture. One of (none|cpu|heap|goroutine|threadcreate|block|mutex)
      -->
      要记录的性能指标的名称。可取 (none|cpu|heap|goroutine|threadcreate|block|mutex) 其中之一。
      </td>
    </tr>
    <tr>
      <td colspan="2">--profile-output string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值: "profile.pprof"</td>
    </tr>
    <tr>
      <td></td><td style="line-height: 130%; word-wrap: break-word;">
      <!--
      Name of the file to write the profile to
      -->
      用于转储所记录的性能信息的文件名
      </td>
    </tr>
    <tr>
      <td colspan="2">--request-timeout string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值: "0"</td>
    </tr>
    <tr>
      <td></td><td style="line-height: 130%; word-wrap: break-word;">
      <!--
      The length of time to wait before giving up on a single server request. Non-zero values should contain a corresponding time unit (e.g. 1s, 2m, 3h). A value of zero means don't timeout requests.
      -->
      放弃单个服务器请求之前的等待时间，非零值需要包含相应时间单位（例如：1s、2m、3h）。零值则表示不做超时要求。
      </td>
    </tr>
    <tr>
      <td colspan="2">-s, --server string</td>
    </tr>
    <tr>
      <td></td><td style="line-height: 130%; word-wrap: break-word;">
      <!--
      The address and port of the Kubernetes API server
      -->
      Kubernetes API 服务器的地址和端口
      </td>
    </tr>
    <tr>
      <td colspan="2">--skip-headers</td>
    </tr>
    <tr>
      <td></td><td style="line-height: 130%; word-wrap: break-word;">
      <!--
      If true, avoid header prefixes in the log messages
      -->
      设置为 true 则表示跳过在日志消息中出现 header 前缀信息
      </td>
    </tr>
    <tr>
      <td colspan="2">--skip-log-headers</td>
    </tr>
    <tr>
      <td></td><td style="line-height: 130%; word-wrap: break-word;">
      <!--
      If true, avoid headers when opening log files
      -->
      设置为 true 则表示在打开日志文件时跳过 header 信息
      </td>
    </tr>
    <tr>
      <td colspan="2">--stderrthreshold severity&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值: 2</td>
    </tr>
    <tr>
      <td></td><td style="line-height: 130%; word-wrap: break-word;">
      <!--
      logs at or above this threshold go to stderr
      -->
      等于或高于此阈值的日志将输出到标准错误输出（stderr）
      </td>
    </tr>
    <tr>
      <td colspan="2">--token string</td>
    </tr>
    <tr>
      <td></td><td style="line-height: 130%; word-wrap: break-word;">
      <!--
      Bearer token for authentication to the API server
      -->
      用于对 API 服务器进行身份认证的持有者令牌
      </td>
    </tr>
    <tr>
      <td colspan="2">--user string</td>
    </tr>
    <tr>
      <td></td><td style="line-height: 130%; word-wrap: break-word;">
      <!--
      The name of the kubeconfig user to use
      -->
      指定使用 kubeconfig 配置文件中的用户名
      </td>
    </tr>
    <tr>
      <td colspan="2">--username string</td>
    </tr>
    <tr>
      <td></td><td style="line-height: 130%; word-wrap: break-word;">
      <!--
      Username for basic authentication to the API server
      -->
      用于 API 服务器的基本身份验证的用户名
      </td>
    </tr>
    <tr>
      <td colspan="2">-v, --v Level</td>
    </tr>
    <tr>
      <td></td><td style="line-height: 130%; word-wrap: break-word;">
      <!--
      number for the log level verbosity
      -->
      指定输出日志的日志详细级别
      </td>
    </tr>
    <tr>
      <td colspan="2">--version version[=true]</td>
    </tr>
    <tr>
      <td></td><td style="line-height: 130%; word-wrap: break-word;">
      <!--
      Print version information and quit
      -->
      打印 kubectl 版本信息并退出
      </td>
    </tr>
    <tr>
      <td colspan="2">--vmodule moduleSpec</td>
    </tr>
    <tr>
      <td></td><td style="line-height: 130%; word-wrap: break-word;">
      <!--
      comma-separated list of pattern=N settings for file-filtered logging
      -->
      以逗号分隔的 pattern=N 设置列表，用于过滤文件的日志记录
      </td>
    </tr>
  </tbody>
</table>
<h2 id="另请参见">另请参见</h2>
<!--
* [kubectl annotate](/docs/reference/generated/kubectl/kubectl-commands#annotate)	 - Update the annotations on a resource
* [kubectl api-resources](/docs/reference/generated/kubectl/kubectl-commands#api-resources)	 - Print the supported API resources on the server
* [kubectl api-versions](/docs/reference/generated/kubectl/kubectl-commands#api-versions)	 - Print the supported API versions on the server, in the form of "group/version"
* [kubectl apply](/docs/reference/generated/kubectl/kubectl-commands#apply)	 - Apply a configuration to a resource by filename or stdin
* [kubectl attach](/docs/reference/generated/kubectl/kubectl-commands#attach)	 - Attach to a running container
-->
<ul>
<li><a href="/docs/reference/generated/kubectl/kubectl-commands#annotate">kubectl annotate</a>	 - 更新资源所关联的注解</li>
<li><a href="/docs/reference/generated/kubectl/kubectl-commands#api-resources">kubectl api-resources</a>	 - 打印服务器上所支持的 API 资源</li>
<li><a href="/docs/reference/generated/kubectl/kubectl-commands#api-versions">kubectl api-versions</a>	 - 以“组/版本”的格式输出服务端所支持的 API 版本</li>
<li><a href="/docs/reference/generated/kubectl/kubectl-commands#apply">kubectl apply</a>	 - 基于文件名或标准输入，将新的配置应用到资源上</li>
<li><a href="/docs/reference/generated/kubectl/kubectl-commands#attach">kubectl attach</a>	 - 连接到一个正在运行的容器</li>
</ul>
<!--
* [kubectl auth](/docs/reference/generated/kubectl/kubectl-commands#auth)	 - Inspect authorization
* [kubectl autoscale](/docs/reference/generated/kubectl/kubectl-commands#autoscale)	 - Auto-scale a Deployment, ReplicaSet, or ReplicationController
* [kubectl certificate](/docs/reference/generated/kubectl/kubectl-commands#certificate)	 - Modify certificate resources.
* [kubectl cluster-info](/docs/reference/generated/kubectl/kubectl-commands#cluster-info)	 - Display cluster info
* [kubectl completion](/docs/reference/generated/kubectl/kubectl-commands#completion)	 - Output shell completion code for the specified shell (bash or zsh)
* [kubectl config](/docs/reference/generated/kubectl/kubectl-commands#config)	 - Modify kubeconfig files
-->
<ul>
<li><a href="/docs/reference/generated/kubectl/kubectl-commands#auth">kubectl auth</a>	 - 检查授权信息</li>
<li><a href="/docs/reference/generated/kubectl/kubectl-commands#autoscale">kubectl autoscale</a>	 - 对一个资源对象（Deployment、ReplicaSet 或 ReplicationController ）进行扩缩</li>
<li><a href="/docs/reference/generated/kubectl/kubectl-commands#certificate">kubectl certificate</a>	 - 修改证书资源</li>
<li><a href="/docs/reference/generated/kubectl/kubectl-commands#cluster-info">kubectl cluster-info</a>	 - 显示集群信息</li>
<li><a href="/docs/reference/generated/kubectl/kubectl-commands#completion">kubectl completion</a>	 - 根据已经给出的 Shell（bash 或 zsh），输出 Shell 补全后的代码</li>
<li><a href="/docs/reference/generated/kubectl/kubectl-commands#config">kubectl config</a>	 - 修改 kubeconfig 配置文件</li>
</ul>
<!--
* [kubectl convert](/docs/reference/generated/kubectl/kubectl-commands#convert)	 - Convert config files between different API versions
* [kubectl cordon](/docs/reference/generated/kubectl/kubectl-commands#cordon)	 - Mark node as unschedulable
* [kubectl cp](/docs/reference/generated/kubectl/kubectl-commands#cp)	 - Copy files and directories to and from containers.
* [kubectl create](/docs/reference/generated/kubectl/kubectl-commands#create)	 - Create a resource from a file or from stdin.
* [kubectl debug](/docs/reference/generated/kubectl/kubectl-commands#debug)	 - Create debugging sessions for troubleshooting workloads and nodes
* [kubectl delete](/docs/reference/generated/kubectl/kubectl-commands#delete)	 - Delete resources by filenames, stdin, resources and names, or by resources and label selector
-->
<ul>
<li><a href="/docs/reference/generated/kubectl/kubectl-commands#convert">kubectl convert</a>	 - 在不同的 API 版本之间转换配置文件</li>
<li><a href="/docs/reference/generated/kubectl/kubectl-commands#cordon">kubectl cordon</a>	 - 标记节点为不可调度的</li>
<li><a href="/docs/reference/generated/kubectl/kubectl-commands#cp">kubectl cp</a>	 - 将文件和目录拷入/拷出容器</li>
<li><a href="/docs/reference/generated/kubectl/kubectl-commands#create">kubectl create</a>	 - 通过文件或标准输入来创建资源</li>
<li><a href="/docs/reference/generated/kubectl/kubectl-commands#debug">kubectl debug</a>	 - 创建用于排查工作负载和节点故障的调试会话</li>
<li><a href="/docs/reference/generated/kubectl/kubectl-commands#delete">kubectl delete</a>	 - 通过文件名、标准输入、资源和名字删除资源，或者通过资源和标签选择器来删除资源</li>
</ul>
<!--
* [kubectl describe](/docs/reference/generated/kubectl/kubectl-commands#describe)	 - Show details of a specific resource or group of resources
* [kubectl diff](/docs/reference/generated/kubectl/kubectl-commands#diff)	 - Diff live version against would-be applied version
* [kubectl drain](/docs/reference/generated/kubectl/kubectl-commands#drain)	 - Drain node in preparation for maintenance
* [kubectl edit](/docs/reference/generated/kubectl/kubectl-commands#edit)	 - Edit a resource on the server
* [kubectl exec](/docs/reference/generated/kubectl/kubectl-commands#exec)	 - Execute a command in a container
* [kubectl explain](/docs/reference/generated/kubectl/kubectl-commands#explain)	 - Documentation of resources
* [kubectl expose](/docs/reference/generated/kubectl/kubectl-commands#expose)	 - Take a replication controller, service, deployment or pod and expose it as a new Kubernetes Service
-->
<ul>
<li><a href="/docs/reference/generated/kubectl/kubectl-commands#describe">kubectl describe</a>	 - 显示某个资源或某组资源的详细信息</li>
<li><a href="/docs/reference/generated/kubectl/kubectl-commands#diff">kubectl diff</a>	 - 显示目前版本与将要应用的版本之间的差异</li>
<li><a href="/docs/reference/generated/kubectl/kubectl-commands#drain">kubectl drain</a>	 - 腾空节点，准备维护</li>
<li><a href="/docs/reference/generated/kubectl/kubectl-commands#edit">kubectl edit</a>	 - 修改服务器上的某资源</li>
<li><a href="/docs/reference/generated/kubectl/kubectl-commands#exec">kubectl exec</a>	 - 在容器中执行相关命令</li>
<li><a href="/docs/reference/generated/kubectl/kubectl-commands#explain">kubectl explain</a>	 - 显示资源文档说明</li>
<li><a href="/docs/reference/generated/kubectl/kubectl-commands#expose">kubectl expose</a>	 - 给定副本控制器、服务、Deployment 或 Pod，将其暴露为新的 kubernetes Service</li>
</ul>
<!--
* [kubectl get](/docs/reference/generated/kubectl/kubectl-commands#get)	 - Display one or many resources
* [kubectl kustomize](/docs/reference/generated/kubectl/kubectl-commands#kustomize)	 - Build a kustomization target from a directory or a remote url.
* [kubectl label](/docs/reference/generated/kubectl/kubectl-commands#label)	 - Update the labels on a resource
* [kubectl logs](/docs/reference/generated/kubectl/kubectl-commands#logs)	 - Print the logs for a container in a pod
* [kubectl options](/docs/reference/generated/kubectl/kubectl-commands#options)	 - Print the list of flags inherited by all commands
* [kubectl patch](/docs/reference/generated/kubectl/kubectl-commands#patch)	 - Update field(s) of a resource
-->
<ul>
<li><a href="/docs/reference/generated/kubectl/kubectl-commands#get">kubectl get</a>	 - 显示一个或者多个资源信息</li>
<li><a href="/docs/reference/generated/kubectl/kubectl-commands#kustomize">kubectl kustomize</a>	 - 从目录或远程 URL 中构建 kustomization</li>
<li><a href="/docs/reference/generated/kubectl/kubectl-commands#label">kubectl label</a>	 - 更新资源的标签</li>
<li><a href="/docs/reference/generated/kubectl/kubectl-commands#logs">kubectl logs</a>	 - 输出 pod 中某容器的日志</li>
<li><a href="/docs/reference/generated/kubectl/kubectl-commands#options">kubectl options</a>	 - 打印所有命令都支持的共有参数列表</li>
<li><a href="/docs/reference/generated/kubectl/kubectl-commands#patch">kubectl patch</a>	 - 基于策略性合并修补（Stategic Merge Patch）规则更新某资源中的字段</li>
</ul>
<!--
* [kubectl plugin](/docs/reference/generated/kubectl/kubectl-commands#plugin)	 - Provides utilities for interacting with plugins.
* [kubectl port-forward](/docs/reference/generated/kubectl/kubectl-commands#port-forward)	 - Forward one or more local ports to a pod
* [kubectl proxy](/docs/reference/generated/kubectl/kubectl-commands#proxy)	 - Run a proxy to the Kubernetes API server
* [kubectl replace](/docs/reference/generated/kubectl/kubectl-commands#replace)	 - Replace a resource by filename or stdin
* [kubectl rollout](/docs/reference/generated/kubectl/kubectl-commands#rollout)	 - Manage the rollout of a resource
* [kubectl run](/docs/reference/generated/kubectl/kubectl-commands#run)	 - Run a particular image on the cluster
-->
<ul>
<li><a href="/docs/reference/generated/kubectl/kubectl-commands#plugin">kubectl plugin</a>	 - 运行命令行插件</li>
<li><a href="/docs/reference/generated/kubectl/kubectl-commands#port-forward">kubectl port-forward</a>	 - 将一个或者多个本地端口转发到 pod</li>
<li><a href="/docs/reference/generated/kubectl/kubectl-commands#proxy">kubectl proxy</a>	 - 运行一个 kubernetes API 服务器代理</li>
<li><a href="/docs/reference/generated/kubectl/kubectl-commands#replace">kubectl replace</a>	 - 基于文件名或标准输入替换资源</li>
<li><a href="/docs/reference/generated/kubectl/kubectl-commands#rollout">kubectl rollout</a>	 - 管理资源的上线</li>
<li><a href="/docs/reference/generated/kubectl/kubectl-commands#run">kubectl run</a>	 - 在集群中使用指定镜像启动容器</li>
</ul>
<!--
* [kubectl scale](/docs/reference/generated/kubectl/kubectl-commands#scale)	 - Set a new size for a Deployment, ReplicaSet or Replication Controller
* [kubectl set](/docs/reference/generated/kubectl/kubectl-commands#set)	 - Set specific features on objects
* [kubectl taint](/docs/reference/generated/kubectl/kubectl-commands#taint)	 - Update the taints on one or more nodes
* [kubectl top](/docs/reference/generated/kubectl/kubectl-commands#top)	 - Display Resource (CPU/Memory/Storage) usage.
* [kubectl uncordon](/docs/reference/generated/kubectl/kubectl-commands#uncordon)	 - Mark node as schedulable
* [kubectl version](/docs/reference/generated/kubectl/kubectl-commands#version)	 - Print the client and server version information
* [kubectl wait](/docs/reference/generated/kubectl/kubectl-commands#wait)	 - Experimental: Wait for a specific condition on one or many resources.
-->
<ul>
<li><a href="/docs/reference/generated/kubectl/kubectl-commands#scale">kubectl scale</a>	 - 为一个 Deployment、ReplicaSet 或 ReplicationController 设置一个新的规模尺寸值</li>
<li><a href="/docs/reference/generated/kubectl/kubectl-commands#set">kubectl set</a>	 - 为对象设置功能特性</li>
<li><a href="/docs/reference/generated/kubectl/kubectl-commands#taint">kubectl taint</a>	 - 在一个或者多个节点上更新污点配置</li>
<li><a href="/docs/reference/generated/kubectl/kubectl-commands#top">kubectl top</a>	 - 显示资源（CPU /内存/存储）使用率</li>
<li><a href="/docs/reference/generated/kubectl/kubectl-commands#uncordon">kubectl uncordon</a>	 - 标记节点为可调度的</li>
<li><a href="/docs/reference/generated/kubectl/kubectl-commands#version">kubectl version</a>	 - 打印客户端和服务器的版本信息</li>
<li><a href="/docs/reference/generated/kubectl/kubectl-commands#wait">kubectl wait</a>	 - 实验性：等待一个或多个资源达到某种状态</li>
</ul>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-d7ffbf04ffbefb241fd0722423b80f5a">8.4 - kubectl 命令</h1>
    
	<!-- ---
title: kubectl Commands
--- -->
<!-- [kubectl Command Reference](/docs/reference/generated/kubectl/kubectl-commands/) -->
<p><a href="/docs/reference/generated/kubectl/kubectl-commands/">kubectl 命令参考</a></p>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-8aba901ac13f124e5782b90ddb166ee2">8.5 - kubectl 备忘单</h1>
    
	<!-- ---
title: kubectl Cheat Sheet
reviewers:
- erictune
- krousey
- clove
content_type: concept
card:
  name: reference
  weight: 30
--- -->
<!-- overview -->
<!--
This page contains a list of commonly used `kubectl` commands and flags.
-->
<p>本页列举了常用的 “kubectl” 命令和标志</p>
<!-- body -->
<!--
## Kubectl autocomplete

### BASH
-->
<h2 id="kubectl-自动补全">Kubectl 自动补全</h2>
<h3 id="bash">BASH</h3>
<!--
```bash
source <(kubectl completion bash) # setup autocomplete in bash into the current shell, bash-completion package should be installed first.
echo "source <(kubectl completion bash)" >> ~/.bashrc # add autocomplete permanently to your bash shell.
```

You can also use a shorthand alias for `kubectl` that also works with completion:
-->
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#a2f">source</span> &lt;<span style="color:#666">(</span>kubectl completion bash<span style="color:#666">)</span> <span style="color:#080;font-style:italic"># 在 bash 中设置当前 shell 的自动补全，要先安装 bash-completion 包。</span>
<span style="color:#a2f">echo</span> <span style="color:#b44">&#34;source &lt;(kubectl completion bash)&#34;</span> &gt;&gt; ~/.bashrc <span style="color:#080;font-style:italic"># 在您的 bash shell 中永久的添加自动补全</span>
</code></pre></div><p>您还可以为 <code>kubectl</code> 使用一个速记别名，该别名也可以与 completion 一起使用：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#a2f">alias</span> <span style="color:#b8860b">k</span><span style="color:#666">=</span>kubectl
<span style="color:#a2f">complete</span> -F __start_kubectl k
</code></pre></div><h3 id="zsh">ZSH</h3>
<!--
```bash
source <(kubectl completion zsh)  # setup autocomplete in zsh into the current shell
echo "[[ $commands[kubectl] ]] && source <(kubectl completion zsh)" >> ~/.zshrc # add autocomplete permanently to your zsh shell
```
-->
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#a2f">source</span> &lt;<span style="color:#666">(</span>kubectl completion zsh<span style="color:#666">)</span>  <span style="color:#080;font-style:italic"># 在 zsh 中设置当前 shell 的自动补全</span>
<span style="color:#a2f">echo</span> <span style="color:#b44">&#34;[[ </span><span style="color:#b8860b">$commands</span><span style="color:#b44">[kubectl] ]] &amp;&amp; source &lt;(kubectl completion zsh)&#34;</span> &gt;&gt; ~/.zshrc <span style="color:#080;font-style:italic"># 在您的 zsh shell 中永久的添加自动补全</span>
</code></pre></div><!--
## Kubectl Context and Configuration

Set which Kubernetes cluster `kubectl` communicates with and modifies configuration
information. See [Authenticating Across Clusters with kubeconfig](/docs/tasks/access-application-cluster/configure-access-multiple-clusters/) documentation for
detailed config file information.
-->
<h2 id="kubectl-上下文和配置">Kubectl 上下文和配置</h2>
<p>设置 <code>kubectl</code> 与哪个 Kubernetes 集群进行通信并修改配置信息。
查看<a href="/zh/docs/tasks/access-application-cluster/configure-access-multiple-clusters/">使用 kubeconfig 跨集群授权访问</a>
文档获取配置文件详细信息。</p>
<!--
```bash
kubectl config view # Show Merged kubeconfig settings.

# use multiple kubeconfig files at the same time and view merged config
KUBECONFIG=~/.kube/config:~/.kube/kubconfig2

kubectl config view

# get the password for the e2e user
kubectl config view -o jsonpath='{.users[?(@.name == "e2e")].user.password}'

kubectl config view -o jsonpath='{.users[].name}'    # display the first user
kubectl config view -o jsonpath='{.users[*].name}'   # get a list of users
kubectl config get-contexts                          # display list of contexts
kubectl config current-context           # display the current-context
kubectl config use-context my-cluster-name           # set the default context to my-cluster-name

# add a new user to your kubeconf that supports basic auth
kubectl config set-credentials kubeuser/foo.kubernetes.com --username=kubeuser --password=kubepassword

# permanently save the namespace for all subsequent kubectl commands in that context.
kubectl config set-context --current --namespace=ggckad-s2

# set a context utilizing a specific username and namespace.
kubectl config set-context gce --user=cluster-admin --namespace=foo \
  && kubectl config use-context gce

kubectl config unset users.foo                       # delete user foo
```
-->
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">kubectl config view <span style="color:#080;font-style:italic"># 显示合并的 kubeconfig 配置。</span>

<span style="color:#080;font-style:italic"># 同时使用多个 kubeconfig 文件并查看合并的配置</span>
<span style="color:#b8860b">KUBECONFIG</span><span style="color:#666">=</span>~/.kube/config:~/.kube/kubconfig2 kubectl config view

<span style="color:#080;font-style:italic"># 获取 e2e 用户的密码</span>
kubectl config view -o <span style="color:#b8860b">jsonpath</span><span style="color:#666">=</span><span style="color:#b44">&#39;{.users[?(@.name == &#34;e2e&#34;)].user.password}&#39;</span>

kubectl config view -o <span style="color:#b8860b">jsonpath</span><span style="color:#666">=</span><span style="color:#b44">&#39;{.users[].name}&#39;</span>    <span style="color:#080;font-style:italic"># 显示第一个用户</span>
kubectl config view -o <span style="color:#b8860b">jsonpath</span><span style="color:#666">=</span><span style="color:#b44">&#39;{.users[*].name}&#39;</span>   <span style="color:#080;font-style:italic"># 获取用户列表</span>
kubectl config get-contexts                          <span style="color:#080;font-style:italic"># 显示上下文列表</span>
kubectl config current-context                       <span style="color:#080;font-style:italic"># 展示当前所处的上下文</span>
kubectl config use-context my-cluster-name           <span style="color:#080;font-style:italic"># 设置默认的上下文为 my-cluster-name</span>

<span style="color:#080;font-style:italic"># 添加新的用户配置到 kubeconf 中，使用 basic auth 进行身份认证</span>
kubectl config set-credentials kubeuser/foo.kubernetes.com --username<span style="color:#666">=</span>kubeuser --password<span style="color:#666">=</span>kubepassword

<span style="color:#080;font-style:italic"># 在指定上下文中持久性地保存名字空间，供所有后续 kubectl 命令使用</span>
kubectl config set-context --current --namespace<span style="color:#666">=</span>ggckad-s2

<span style="color:#080;font-style:italic"># 使用特定的用户名和名字空间设置上下文</span>
kubectl config set-context gce --user<span style="color:#666">=</span>cluster-admin --namespace<span style="color:#666">=</span>foo <span style="color:#b62;font-weight:bold">\
</span><span style="color:#b62;font-weight:bold"></span>  <span style="color:#666">&amp;&amp;</span> kubectl config use-context gce

kubectl config <span style="color:#a2f">unset</span> users.foo                       <span style="color:#080;font-style:italic"># 删除用户 foo</span>
</code></pre></div><!--
## Kubectl apply
`apply` manages applications through files defining Kubernetes resources. It creates and updates resources in a cluster through running `kubectl apply`. This is the recommended way of managing Kubernetes applications on production. See [Kubectl Book](https://kubectl.docs.kubernetes.io).
-->
<h2 id="kubectl-apply">Kubectl apply</h2>
<p><code>apply</code> 通过定义 Kubernetes 资源的文件来管理应用。
它通过运行 <code>kubectl apply</code> 在集群中创建和更新资源。
这是在生产中管理 Kubernetes 应用的推荐方法。
参见 <a href="https://kubectl.docs.kubernetes.io">Kubectl 文档</a>。</p>
<!--
## Creating objects

Kubernetes manifests can be defined in YAML or JSON. The file extension `.yaml`,
`.yml`, and `.json` can be used.
-->
<h2 id="creating-objects">创建对象</h2>
<p>Kubernetes 配置可以用 YAML 或 JSON 定义。可以使用的文件扩展名有
<code>.yaml</code>、<code>.yml</code> 和 <code>.json</code>。</p>
<!--
```bash
kubectl apply -f ./my-manifest.yaml            # create resource(s)
kubectl apply -f ./my1.yaml -f ./my2.yaml      # create from multiple files
kubectl apply -f ./dir                         # create resource(s) in all manifest files in dir
kubectl apply -f https://git.io/vPieo          # create resource(s) from url
kubectl create deployment nginx --image=nginx  # start a single instance of nginx

# create a Job which prints "Hello World"
kubectl create job hello --image=busybox -- echo "Hello World" 

# create a CronJob that prints "Hello World" every minute
kubectl create cronjob hello --image=busybox   --schedule="*/1 * * * *" -- echo "Hello World"    

kubectl explain pods                           # get the documentation for pod manifests

# Create multiple YAML objects from stdin
cat <<EOF | kubectl apply -f -
apiVersion: v1
kind: Pod
metadata:
  name: busybox-sleep
spec:
  containers:
  - name: busybox
    image: busybox
    args:
    - sleep
    - "1000000"
---
apiVersion: v1
kind: Pod
metadata:
  name: busybox-sleep-less
spec:
  containers:
  - name: busybox
    image: busybox
    args:
    - sleep
    - "1000"
EOF

# Create a secret with several keys
cat <<EOF | kubectl apply -f -
apiVersion: v1
kind: Secret
metadata:
  name: mysecret
type: Opaque
data:
  password: $(echo -n "s33msi4" | base64 -w0)
  username: $(echo -n "jane" | base64 -w0)
EOF
```
-->
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">kubectl apply -f ./my-manifest.yaml           <span style="color:#080;font-style:italic"># 创建资源</span>
kubectl apply -f ./my1.yaml -f ./my2.yaml     <span style="color:#080;font-style:italic"># 使用多个文件创建</span>
kubectl apply -f ./dir                        <span style="color:#080;font-style:italic"># 基于目录下的所有清单文件创建资源</span>
kubectl apply -f https://git.io/vPieo         <span style="color:#080;font-style:italic"># 从 URL 中创建资源</span>
kubectl create deployment nginx --image<span style="color:#666">=</span>nginx <span style="color:#080;font-style:italic"># 启动单实例 nginx</span>

<span style="color:#080;font-style:italic"># 创建一个打印 “Hello World” 的 Job</span>
kubectl create job hello --image<span style="color:#666">=</span>busybox -- <span style="color:#a2f">echo</span> <span style="color:#b44">&#34;Hello World&#34;</span> 

<span style="color:#080;font-style:italic"># 创建一个打印 “Hello World” 间隔1分钟的 CronJob</span>
kubectl create cronjob hello --image<span style="color:#666">=</span>busybox   --schedule<span style="color:#666">=</span><span style="color:#b44">&#34;*/1 * * * *&#34;</span> -- <span style="color:#a2f">echo</span> <span style="color:#b44">&#34;Hello World&#34;</span>    

kubectl explain pods                          <span style="color:#080;font-style:italic"># 获取 pod 清单的文档说明</span>

<span style="color:#080;font-style:italic"># 从标准输入创建多个 YAML 对象</span>
cat <span style="color:#b44">&lt;&lt;EOF | kubectl apply -f -
</span><span style="color:#b44">apiVersion: v1
</span><span style="color:#b44">kind: Pod
</span><span style="color:#b44">metadata:
</span><span style="color:#b44">  name: busybox-sleep
</span><span style="color:#b44">spec:
</span><span style="color:#b44">  containers:
</span><span style="color:#b44">  - name: busybox
</span><span style="color:#b44">    image: busybox
</span><span style="color:#b44">    args:
</span><span style="color:#b44">    - sleep
</span><span style="color:#b44">    - &#34;1000000&#34;
</span><span style="color:#b44">---
</span><span style="color:#b44">apiVersion: v1
</span><span style="color:#b44">kind: Pod
</span><span style="color:#b44">metadata:
</span><span style="color:#b44">  name: busybox-sleep-less
</span><span style="color:#b44">spec:
</span><span style="color:#b44">  containers:
</span><span style="color:#b44">  - name: busybox
</span><span style="color:#b44">    image: busybox
</span><span style="color:#b44">    args:
</span><span style="color:#b44">    - sleep
</span><span style="color:#b44">    - &#34;1000&#34;
</span><span style="color:#b44">EOF</span>

<span style="color:#080;font-style:italic"># 创建有多个 key 的 Secret</span>
cat <span style="color:#b44">&lt;&lt;EOF | kubectl apply -f -
</span><span style="color:#b44">apiVersion: v1
</span><span style="color:#b44">kind: Secret
</span><span style="color:#b44">metadata:
</span><span style="color:#b44">  name: mysecret
</span><span style="color:#b44">type: Opaque
</span><span style="color:#b44">data:
</span><span style="color:#b44">  password: $(echo -n &#34;s33msi4&#34; | base64 -w0)
</span><span style="color:#b44">  username: $(echo -n &#34;jane&#34; | base64 -w0)
</span><span style="color:#b44">EOF</span>
</code></pre></div><!--
## Viewing, finding resources
-->
<h2 id="查看和查找资源">查看和查找资源</h2>
<!--
```bash
# Get commands with basic output
kubectl get services                          # List all services in the namespace
kubectl get pods --all-namespaces             # List all pods in all namespaces
kubectl get pods -o wide                      # List all pods in the current namespace, with more details
kubectl get deployment my-dep                 # List a particular deployment
kubectl get pods                              # List all pods in the namespace
kubectl get pod my-pod -o yaml                # Get a pod's YAML

# Describe commands with verbose output
kubectl describe nodes my-node
kubectl describe pods my-pod

# List Services Sorted by Name
kubectl get services --sort-by=.metadata.name

# List pods Sorted by Restart Count
kubectl get pods --sort-by='.status.containerStatuses[0].restartCount'

# List PersistentVolumes sorted by capacity
kubectl get pv --sort-by=.spec.capacity.storage

# Get the version label of all pods with label app=cassandra
kubectl get pods --selector=app=cassandra -o \
  jsonpath='{.items[*].metadata.labels.version}'

# Retrieve the value of a key with dots, e.g. 'ca.crt'
kubectl get configmap myconfig \
  -o jsonpath='{.data.ca\.crt}'

# Get all worker nodes (use a selector to exclude results that have a label
# named 'node-role.kubernetes.io/master')
kubectl get node --selector='!node-role.kubernetes.io/master'

# Get all running pods in the namespace
kubectl get pods --field-selector=status.phase=Running

# Get ExternalIPs of all nodes
kubectl get nodes -o jsonpath='{.items[*].status.addresses[?(@.type=="ExternalIP")].address}'

# List Names of Pods that belong to Particular RC
# "jq" command useful for transformations that are too complex for jsonpath, it can be found at https://stedolan.github.io/jq/
sel=${$(kubectl get rc my-rc --output=json | jq -j '.spec.selector | to_entries | .[] | "\(.key)=\(.value),"')%?}
echo $(kubectl get pods --selector=$sel --output=jsonpath={.items..metadata.name})

# Show labels for all pods (or any other Kubernetes object that supports labelling)
kubectl get pods --show-labels

# Check which nodes are ready
JSONPATH='{range .items[*]}{@.metadata.name}:{range @.status.conditions[*]}{@.type}={@.status};{end}{end}' \
 && kubectl get nodes -o jsonpath="$JSONPATH" | grep "Ready=True"

# Output decoded secrets without external tools
kubectl get secret my-secret -o go-template='{{range $k,$v := .data}}{{"### "}}{{$k}}{{"\n"}}{{$v|base64decode}}{{"\n\n"}}{{end}}'

# List all Secrets currently in use by a pod
kubectl get pods -o json | jq '.items[].spec.containers[].env[]?.valueFrom.secretKeyRef.name' | grep -v null | sort | uniq

# List all containerIDs of initContainer of all pods
# Helpful when cleaning up stopped containers, while avoiding removal of initContainers.
kubectl get pods --all-namespaces -o jsonpath='{range .items[*].status.initContainerStatuses[*]}{.containerID}{"\n"}{end}' | cut -d/ -f3

# List Events sorted by timestamp
kubectl get events --sort-by=.metadata.creationTimestamp

# Compares the current state of the cluster against the state that the cluster would be in if the manifest was applied.
kubectl diff -f ./my-manifest.yaml

# Produce a period-delimited tree of all keys returned for nodes
# Helpful when locating a key within a complex nested JSON structure
kubectl get nodes -o json | jq -c 'path(..)|[.[]|tostring]|join(".")'

# Produce a period-delimited tree of all keys returned for pods, etc
kubectl get pods -o json | jq -c 'path(..)|[.[]|tostring]|join(".")'

# Produce ENV for all pods, assuming you have a default container for the pods, default namespace and the `env` command is supported.
# Helpful when running any supported command across all pods, not just `env`
for pod in $(kubectl get po --output=jsonpath={.items..metadata.name}); do echo $pod && kubectl exec -it $pod env; done
```
-->
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#080;font-style:italic"># get 命令的基本输出</span>
kubectl get services                          <span style="color:#080;font-style:italic"># 列出当前命名空间下的所有 services</span>
kubectl get pods --all-namespaces             <span style="color:#080;font-style:italic"># 列出所有命名空间下的全部的 Pods</span>
kubectl get pods -o wide                      <span style="color:#080;font-style:italic"># 列出当前命名空间下的全部 Pods，并显示更详细的信息</span>
kubectl get deployment my-dep                 <span style="color:#080;font-style:italic"># 列出某个特定的 Deployment</span>
kubectl get pods                              <span style="color:#080;font-style:italic"># 列出当前命名空间下的全部 Pods</span>
kubectl get pod my-pod -o yaml                <span style="color:#080;font-style:italic"># 获取一个 pod 的 YAML</span>

<span style="color:#080;font-style:italic"># describe 命令的详细输出</span>
kubectl describe nodes my-node
kubectl describe pods my-pod

<span style="color:#080;font-style:italic"># 列出当前名字空间下所有 Services，按名称排序</span>
kubectl get services --sort-by<span style="color:#666">=</span>.metadata.name

<span style="color:#080;font-style:italic"># 列出 Pods，按重启次数排序</span>
kubectl get pods --sort-by<span style="color:#666">=</span><span style="color:#b44">&#39;.status.containerStatuses[0].restartCount&#39;</span>

<span style="color:#080;font-style:italic"># 列举所有 PV 持久卷，按容量排序</span>
kubectl get pv --sort-by<span style="color:#666">=</span>.spec.capacity.storage

<span style="color:#080;font-style:italic"># 获取包含 app=cassandra 标签的所有 Pods 的 version 标签</span>
kubectl get pods --selector<span style="color:#666">=</span><span style="color:#b8860b">app</span><span style="color:#666">=</span>cassandra -o <span style="color:#b62;font-weight:bold">\
</span><span style="color:#b62;font-weight:bold"></span>  <span style="color:#b8860b">jsonpath</span><span style="color:#666">=</span><span style="color:#b44">&#39;{.items[*].metadata.labels.version}&#39;</span>

<span style="color:#080;font-style:italic"># 检索带有 “.” 键值，例： &#39;ca.crt&#39;</span>
kubectl get configmap myconfig <span style="color:#b62;font-weight:bold">\
</span><span style="color:#b62;font-weight:bold"></span>  -o <span style="color:#b8860b">jsonpath</span><span style="color:#666">=</span><span style="color:#b44">&#39;{.data.ca\.crt}&#39;</span>

<span style="color:#080;font-style:italic"># 获取所有工作节点（使用选择器以排除标签名称为 &#39;node-role.kubernetes.io/master&#39; 的结果）</span>
kubectl get node --selector<span style="color:#666">=</span><span style="color:#b44">&#39;!node-role.kubernetes.io/master&#39;</span>

<span style="color:#080;font-style:italic"># 获取当前命名空间中正在运行的 Pods</span>
kubectl get pods --field-selector<span style="color:#666">=</span>status.phase<span style="color:#666">=</span>Running

<span style="color:#080;font-style:italic"># 获取全部节点的 ExternalIP 地址</span>
kubectl get nodes -o <span style="color:#b8860b">jsonpath</span><span style="color:#666">=</span><span style="color:#b44">&#39;{.items[*].status.addresses[?(@.type==&#34;ExternalIP&#34;)].address}&#39;</span>

<span style="color:#080;font-style:italic"># 列出属于某个特定 RC 的 Pods 的名称</span>
<span style="color:#080;font-style:italic"># 在转换对于 jsonpath 过于复杂的场合，&#34;jq&#34; 命令很有用；可以在 https://stedolan.github.io/jq/ 找到它。</span>
<span style="color:#b8860b">sel</span><span style="color:#666">=</span><span style="color:#b68;font-weight:bold">${</span><span style="color:#a2f;font-weight:bold">$(</span>kubectl get rc my-rc --output<span style="color:#666">=</span>json | jq -j <span style="color:#b44">&#39;.spec.selector | to_entries | .[] | &#34;\(.key)=\(.value),&#34;&#39;</span><span style="color:#a2f;font-weight:bold">)</span>%?<span style="color:#b68;font-weight:bold">}</span>
<span style="color:#a2f">echo</span> <span style="color:#a2f;font-weight:bold">$(</span>kubectl get pods --selector<span style="color:#666">=</span><span style="color:#b8860b">$sel</span> --output<span style="color:#666">=</span><span style="color:#b8860b">jsonpath</span><span style="color:#666">={</span>.items..metadata.name<span style="color:#666">}</span><span style="color:#a2f;font-weight:bold">)</span>

<span style="color:#080;font-style:italic"># 显示所有 Pods 的标签（或任何其他支持标签的 Kubernetes 对象）</span>
kubectl get pods --show-labels

<span style="color:#080;font-style:italic"># 检查哪些节点处于就绪状态</span>
<span style="color:#b8860b">JSONPATH</span><span style="color:#666">=</span><span style="color:#b44">&#39;{range .items[*]}{@.metadata.name}:{range @.status.conditions[*]}{@.type}={@.status};{end}{end}&#39;</span> <span style="color:#b62;font-weight:bold">\
</span><span style="color:#b62;font-weight:bold"></span> <span style="color:#666">&amp;&amp;</span> kubectl get nodes -o <span style="color:#b8860b">jsonpath</span><span style="color:#666">=</span><span style="color:#b44">&#34;</span><span style="color:#b8860b">$JSONPATH</span><span style="color:#b44">&#34;</span> | grep <span style="color:#b44">&#34;Ready=True&#34;</span>

<span style="color:#080;font-style:italic"># 不使用外部工具来输出解码后的 Secret</span>
kubectl get secret my-secret -o go-template<span style="color:#666">=</span><span style="color:#b44">&#39;{{range $k,$v := .data}}{{&#34;### &#34;}}{{$k}}{{&#34;\n&#34;}}{{$v|base64decode}}{{&#34;\n\n&#34;}}{{end}}&#39;</span>

<span style="color:#080;font-style:italic"># 列出被一个 Pod 使用的全部 Secret</span>
kubectl get pods -o json | jq <span style="color:#b44">&#39;.items[].spec.containers[].env[]?.valueFrom.secretKeyRef.name&#39;</span> | grep -v null | sort | uniq

<span style="color:#080;font-style:italic"># 列举所有 Pods 中初始化容器的容器 ID（containerID）</span>
<span style="color:#080;font-style:italic"># 可用于在清理已停止的容器时避免删除初始化容器</span>
kubectl get pods --all-namespaces -o <span style="color:#b8860b">jsonpath</span><span style="color:#666">=</span><span style="color:#b44">&#39;{range .items[*].status.initContainerStatuses[*]}{.containerID}{&#34;\n&#34;}{end}&#39;</span> | cut -d/ -f3

<span style="color:#080;font-style:italic"># 列出事件（Events），按时间戳排序</span>
kubectl get events --sort-by<span style="color:#666">=</span>.metadata.creationTimestamp

<span style="color:#080;font-style:italic"># 比较当前的集群状态和假定某清单被应用之后的集群状态</span>
kubectl diff -f ./my-manifest.yaml

<span style="color:#080;font-style:italic"># 生成一个句点分隔的树，其中包含为节点返回的所有键</span>
<span style="color:#080;font-style:italic"># 在复杂的嵌套JSON结构中定位键时非常有用</span>
kubectl get nodes -o json | jq -c <span style="color:#b44">&#39;path(..)|[.[]|tostring]|join(&#34;.&#34;)&#39;</span>

<span style="color:#080;font-style:italic"># 生成一个句点分隔的树，其中包含为pod等返回的所有键</span>
kubectl get pods -o json | jq -c <span style="color:#b44">&#39;path(..)|[.[]|tostring]|join(&#34;.&#34;)&#39;</span>

<span style="color:#080;font-style:italic"># 假设你的 Pods 有默认的容器和默认的名字空间，并且支持 &#39;env&#39; 命令，可以使用以下脚本为所有 Pods 生成 ENV 变量。</span>
<span style="color:#080;font-style:italic"># 该脚本也可用于在所有的 Pods 里运行任何受支持的命令，而不仅仅是 &#39;env&#39;。 </span>
<span style="color:#a2f;font-weight:bold">for</span> pod in <span style="color:#a2f;font-weight:bold">$(</span>kubectl get po --output<span style="color:#666">=</span><span style="color:#b8860b">jsonpath</span><span style="color:#666">={</span>.items..metadata.name<span style="color:#666">}</span><span style="color:#a2f;font-weight:bold">)</span>; <span style="color:#a2f;font-weight:bold">do</span> <span style="color:#a2f">echo</span> <span style="color:#b8860b">$pod</span> <span style="color:#666">&amp;&amp;</span> kubectl <span style="color:#a2f">exec</span> -it <span style="color:#b8860b">$pod</span> env; <span style="color:#a2f;font-weight:bold">done</span>
</code></pre></div><!--
## Updating resources
-->
<h2 id="更新资源">更新资源</h2>
<!--
```bash
kubectl set image deployment/frontend www=image:v2               # Rolling update "www" containers of "frontend" deployment, updating the image
kubectl rollout history deployment/frontend                      # Check the history of deployments including the revision
kubectl rollout undo deployment/frontend                         # Rollback to the previous deployment
kubectl rollout undo deployment/frontend --to-revision=2         # Rollback to a specific revision
kubectl rollout status -w deployment/frontend                    # Watch rolling update status of "frontend" deployment until completion
kubectl rollout restart deployment/frontend                      # Rolling restart of the "frontend" deployment

cat pod.json | kubectl replace -f -                              # Replace a pod based on the JSON passed into std

# Force replace, delete and then re-create the resource. Will cause a service outage.
kubectl replace --force -f ./pod.json

# Create a service for a replicated nginx, which serves on port 80 and connects to the containers on port 8000
kubectl expose rc nginx --port=80 --target-port=8000

# Update a single-container pod's image version (tag) to v4
kubectl get pod mypod -o yaml | sed 's/\(image: myimage\):.*$/\1:v4/' | kubectl replace -f -

kubectl label pods my-pod new-label=awesome                      # Add a Label
kubectl annotate pods my-pod icon-url=http://goo.gl/XXBTWq       # Add an annotation
kubectl autoscale deployment foo --min=2 --max=10                # Auto scale a deployment "foo"
```
-->
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">kubectl <span style="color:#a2f">set</span> image deployment/frontend <span style="color:#b8860b">www</span><span style="color:#666">=</span>image:v2               <span style="color:#080;font-style:italic"># 滚动更新 &#34;frontend&#34; Deployment 的 &#34;www&#34; 容器镜像</span>
kubectl rollout <span style="color:#a2f">history</span> deployment/frontend                      <span style="color:#080;font-style:italic"># 检查 Deployment 的历史记录，包括版本</span>
kubectl rollout undo deployment/frontend                         <span style="color:#080;font-style:italic"># 回滚到上次部署版本</span>
kubectl rollout undo deployment/frontend --to-revision<span style="color:#666">=</span><span style="color:#666">2</span>         <span style="color:#080;font-style:italic"># 回滚到特定部署版本</span>
kubectl rollout status -w deployment/frontend                    <span style="color:#080;font-style:italic"># 监视 &#34;frontend&#34; Deployment 的滚动升级状态直到完成</span>
kubectl rollout restart deployment/frontend                      <span style="color:#080;font-style:italic"># 轮替重启 &#34;frontend&#34; Deployment</span>

cat pod.json | kubectl replace -f -                              <span style="color:#080;font-style:italic"># 通过传入到标准输入的 JSON 来替换 Pod</span>

<span style="color:#080;font-style:italic"># 强制替换，删除后重建资源。会导致服务不可用。</span>
kubectl replace --force -f ./pod.json

<span style="color:#080;font-style:italic"># 为多副本的 nginx 创建服务，使用 80 端口提供服务，连接到容器的 8000 端口。</span>
kubectl expose rc nginx --port<span style="color:#666">=</span><span style="color:#666">80</span> --target-port<span style="color:#666">=</span><span style="color:#666">8000</span>

<span style="color:#080;font-style:italic"># 将某单容器 Pod 的镜像版本（标签）更新到 v4</span>
kubectl get pod mypod -o yaml | sed <span style="color:#b44">&#39;s/\(image: myimage\):.*$/\1:v4/&#39;</span> | kubectl replace -f -

kubectl label pods my-pod new-label<span style="color:#666">=</span>awesome                      <span style="color:#080;font-style:italic"># 添加标签</span>
kubectl annotate pods my-pod icon-url<span style="color:#666">=</span>http://goo.gl/XXBTWq       <span style="color:#080;font-style:italic"># 添加注解</span>
kubectl autoscale deployment foo --min<span style="color:#666">=</span><span style="color:#666">2</span> --max<span style="color:#666">=</span><span style="color:#666">10</span>                <span style="color:#080;font-style:italic"># 对 &#34;foo&#34; Deployment 自动伸缩容</span>
</code></pre></div><!-- ## Patching resources -->
<h2 id="部分更新资源">部分更新资源</h2>
<!--
```bash
# Partially update a node
kubectl patch node k8s-node-1 -p '{"spec":{"unschedulable":true}}'

# Update a container's image; spec.containers[*].name is required because it's a merge key
kubectl patch pod valid-pod -p '{"spec":{"containers":[{"name":"kubernetes-serve-hostname","image":"new image"}]}}'

# Update a container's image using a json patch with positional arrays
kubectl patch pod valid-pod --type='json' -p='[{"op": "replace", "path": "/spec/containers/0/image", "value":"new image"}]'

# Disable a deployment livenessProbe using a json patch with positional arrays
kubectl patch deployment valid-deployment  --type json   -p='[{"op": "remove", "path": "/spec/template/spec/containers/0/livenessProbe"}]'

# Add a new element to a positional array
kubectl patch sa default --type='json' -p='[{"op": "add", "path": "/secrets/1", "value": {"name": "whatever" } }]'
```
-->
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#080;font-style:italic"># 部分更新某节点</span>
kubectl patch node k8s-node-1 -p <span style="color:#b44">&#39;{&#34;spec&#34;:{&#34;unschedulable&#34;:true}}&#39;</span>

<span style="color:#080;font-style:italic"># 更新容器的镜像；spec.containers[*].name 是必须的。因为它是一个合并性质的主键。</span>
kubectl patch pod valid-pod -p <span style="color:#b44">&#39;{&#34;spec&#34;:{&#34;containers&#34;:[{&#34;name&#34;:&#34;kubernetes-serve-hostname&#34;,&#34;image&#34;:&#34;new image&#34;}]}}&#39;</span>

<span style="color:#080;font-style:italic"># 使用带位置数组的 JSON patch 更新容器的镜像</span>
kubectl patch pod valid-pod --type<span style="color:#666">=</span><span style="color:#b44">&#39;json&#39;</span> -p<span style="color:#666">=</span><span style="color:#b44">&#39;[{&#34;op&#34;: &#34;replace&#34;, &#34;path&#34;: &#34;/spec/containers/0/image&#34;, &#34;value&#34;:&#34;new image&#34;}]&#39;</span>

<span style="color:#080;font-style:italic"># 使用带位置数组的 JSON patch 禁用某 Deployment 的 livenessProbe</span>
kubectl patch deployment valid-deployment  --type json   -p<span style="color:#666">=</span><span style="color:#b44">&#39;[{&#34;op&#34;: &#34;remove&#34;, &#34;path&#34;: &#34;/spec/template/spec/containers/0/livenessProbe&#34;}]&#39;</span>

<span style="color:#080;font-style:italic"># 在带位置数组中添加元素</span>
kubectl patch sa default --type<span style="color:#666">=</span><span style="color:#b44">&#39;json&#39;</span> -p<span style="color:#666">=</span><span style="color:#b44">&#39;[{&#34;op&#34;: &#34;add&#34;, &#34;path&#34;: &#34;/secrets/1&#34;, &#34;value&#34;: {&#34;name&#34;: &#34;whatever&#34; } }]&#39;</span>
</code></pre></div><!--
## Editing resources

Edit any API resource in your preferred editor.
-->
<h2 id="编辑资源">编辑资源</h2>
<p>使用你偏爱的编辑器编辑 API 资源。</p>
<!--
```bash
kubectl edit svc/docker-registry                      # Edit the service named docker-registry
KUBE_EDITOR="nano" kubectl edit svc/docker-registry   # Use an alternative editor
```
-->
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">kubectl edit svc/docker-registry                      <span style="color:#080;font-style:italic"># 编辑名为 docker-registry 的服务</span>
<span style="color:#b8860b">KUBE_EDITOR</span><span style="color:#666">=</span><span style="color:#b44">&#34;nano&#34;</span> kubectl edit svc/docker-registry   <span style="color:#080;font-style:italic"># 使用其他编辑器</span>
</code></pre></div><!--
## Scaling resources
-->
<h2 id="对资源进行伸缩">对资源进行伸缩</h2>
<!-- ```bash
kubectl scale --replicas=3 rs/foo                                 # Scale a replicaset named 'foo' to 3
kubectl scale --replicas=3 -f foo.yaml                            # Scale a resource specified in "foo.yaml" to 3
kubectl scale --current-replicas=2 --replicas=3 deployment/mysql  # If the deployment named mysql's current size is 2, scale mysql to 3
kubectl scale --replicas=5 rc/foo rc/bar rc/baz                   # Scale multiple replication controllers
```
-->
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">kubectl scale --replicas<span style="color:#666">=</span><span style="color:#666">3</span> rs/foo                                 <span style="color:#080;font-style:italic"># 将名为 &#39;foo&#39; 的副本集伸缩到 3 副本</span>
kubectl scale --replicas<span style="color:#666">=</span><span style="color:#666">3</span> -f foo.yaml                            <span style="color:#080;font-style:italic"># 将在 &#34;foo.yaml&#34; 中的特定资源伸缩到 3 个副本</span>
kubectl scale --current-replicas<span style="color:#666">=</span><span style="color:#666">2</span> --replicas<span style="color:#666">=</span><span style="color:#666">3</span> deployment/mysql  <span style="color:#080;font-style:italic"># 如果名为 mysql 的 Deployment 的副本当前是 2，那么将它伸缩到 3</span>
kubectl scale --replicas<span style="color:#666">=</span><span style="color:#666">5</span> rc/foo rc/bar rc/baz                   <span style="color:#080;font-style:italic"># 伸缩多个副本控制器</span>
</code></pre></div><!--
## Deleting resources
-->
<h2 id="删除资源">删除资源</h2>
<!-- ```bash
kubectl delete -f ./pod.json                                              # Delete a pod using the type and name specified in pod.json
kubectl delete pod,service baz foo                                        # Delete pods and services with same names "baz" and "foo"
kubectl delete pods,services -l name=myLabel                              # Delete pods and services with label name=myLabel
kubectl -n my-ns delete pod,svc --all                                      # Delete all pods and services in namespace my-ns,
# Delete all pods matching the awk pattern1 or pattern2
kubectl get pods  -n mynamespace --no-headers=true | awk '/pattern1|pattern2/{print $1}' | xargs  kubectl delete -n mynamespace pod
```
-->
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">kubectl delete -f ./pod.json                                              <span style="color:#080;font-style:italic"># 删除在 pod.json 中指定的类型和名称的 Pod</span>
kubectl delete pod,service baz foo                                        <span style="color:#080;font-style:italic"># 删除名称为 &#34;baz&#34; 和 &#34;foo&#34; 的 Pod 和服务</span>
kubectl delete pods,services -l <span style="color:#b8860b">name</span><span style="color:#666">=</span>myLabel                              <span style="color:#080;font-style:italic"># 删除包含 name=myLabel 标签的 pods 和服务</span>
kubectl -n my-ns delete pod,svc --all                                     <span style="color:#080;font-style:italic"># 删除在 my-ns 名字空间中全部的 Pods 和服务</span>
<span style="color:#080;font-style:italic"># 删除所有与 pattern1 或 pattern2 awk 模式匹配的 Pods</span>
kubectl get pods  -n mynamespace --no-headers<span style="color:#666">=</span><span style="color:#a2f">true</span> | awk <span style="color:#b44">&#39;/pattern1|pattern2/{print $1}&#39;</span> | xargs  kubectl delete -n mynamespace pod
</code></pre></div><!--
## Interacting with running Pods
-->
<h2 id="与运行中的-pods-进行交互">与运行中的 Pods 进行交互</h2>
<!--
```bash
kubectl logs my-pod                                 # dump pod logs (stdout)
kubectl logs -l name=myLabel                        # dump pod logs, with label name=myLabel (stdout)
kubectl logs my-pod --previous                      # dump pod logs (stdout) for a previous instantiation of a container
kubectl logs my-pod -c my-container                 # dump pod container logs (stdout, multi-container case)
kubectl logs -l name=myLabel -c my-container        # dump pod logs, with label name=myLabel (stdout)
kubectl logs my-pod -c my-container --previous      # dump pod container logs (stdout, multi-container case) for a previous instantiation of a container
kubectl logs -f my-pod                              # stream pod logs (stdout)
kubectl logs -f my-pod -c my-container              # stream pod container logs (stdout, multi-container case)
kubectl logs -f -l name=myLabel --all-containers    # stream all pods logs with label name=myLabel (stdout)
kubectl run -i --tty busybox --image=busybox -- sh  # Run pod as interactive shell
kubectl run nginx --image=nginx -n 
mynamespace                                         # Run pod nginx in a specific namespace
kubectl run nginx --image=nginx                     # Run pod nginx and write its spec into a file called pod.yaml
--dry-run=client -o yaml > pod.yaml

kubectl attach my-pod -i                            # Attach to Running Container
kubectl port-forward my-pod 5000:6000               # Listen on port 5000 on the local machine and forward to port 6000 on my-pod
kubectl exec my-pod -- ls /                         # Run command in existing pod (1 container case)
kubectl exec --stdin --tty my-pod -- /bin/sh        # Interactive shell access to a running pod (1 container case) 
kubectl exec my-pod -c my-container -- ls /         # Run command in existing pod (multi-container case)
kubectl top pod POD_NAME --containers               # Show metrics for a given pod and its containers
kubectl top pod POD_NAME --sort-by=cpu              # Show metrics for a given pod and sort it by 'cpu' or 'memory'
```
-->
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">kubectl logs my-pod                                 <span style="color:#080;font-style:italic"># 获取 pod 日志（标准输出）</span>
kubectl logs -l <span style="color:#b8860b">name</span><span style="color:#666">=</span>myLabel                        <span style="color:#080;font-style:italic"># 获取含 name=myLabel 标签的 Pods 的日志（标准输出）</span>
kubectl logs my-pod --previous                      <span style="color:#080;font-style:italic"># 获取上个容器实例的 pod 日志（标准输出）</span>
kubectl logs my-pod -c my-container                 <span style="color:#080;font-style:italic"># 获取 Pod 容器的日志（标准输出, 多容器场景）</span>
kubectl logs -l <span style="color:#b8860b">name</span><span style="color:#666">=</span>myLabel -c my-container        <span style="color:#080;font-style:italic"># 获取含 name=myLabel 标签的 Pod 容器日志（标准输出, 多容器场景）</span>
kubectl logs my-pod -c my-container --previous      <span style="color:#080;font-style:italic"># 获取 Pod 中某容器的上个实例的日志（标准输出, 多容器场景）</span>
kubectl logs -f my-pod                              <span style="color:#080;font-style:italic"># 流式输出 Pod 的日志（标准输出）</span>
kubectl logs -f my-pod -c my-container              <span style="color:#080;font-style:italic"># 流式输出 Pod 容器的日志（标准输出, 多容器场景）</span>
kubectl logs -f -l <span style="color:#b8860b">name</span><span style="color:#666">=</span>myLabel --all-containers    <span style="color:#080;font-style:italic"># 流式输出含 name=myLabel 标签的 Pod 的所有日志（标准输出）</span>
kubectl run -i --tty busybox --image<span style="color:#666">=</span>busybox -- sh  <span style="color:#080;font-style:italic"># 以交互式 Shell 运行 Pod</span>
kubectl run nginx --image<span style="color:#666">=</span>nginx -n mynamespace      <span style="color:#080;font-style:italic"># 在指定名字空间中运行 nginx Pod</span>
kubectl run nginx --image<span style="color:#666">=</span>nginx                     <span style="color:#080;font-style:italic"># 运行 ngins Pod 并将其规约写入到名为 pod.yaml 的文件</span>
  --dry-run<span style="color:#666">=</span>client -o yaml &gt; pod.yaml

kubectl attach my-pod -i                            <span style="color:#080;font-style:italic"># 挂接到一个运行的容器中</span>
kubectl port-forward my-pod 5000:6000               <span style="color:#080;font-style:italic"># 在本地计算机上侦听端口 5000 并转发到 my-pod 上的端口 6000</span>
kubectl <span style="color:#a2f">exec</span> my-pod -- ls /                         <span style="color:#080;font-style:italic"># 在已有的 Pod 中运行命令（单容器场景）</span>
kubectl <span style="color:#a2f">exec</span> --stdin --tty my-pod -- /bin/sh        <span style="color:#080;font-style:italic"># 使用交互 shell 访问正在运行的 Pod (一个容器场景)</span>
kubectl <span style="color:#a2f">exec</span> my-pod -c my-container -- ls /         <span style="color:#080;font-style:italic"># 在已有的 Pod 中运行命令（多容器场景）</span>
kubectl top pod POD_NAME --containers               <span style="color:#080;font-style:italic"># 显示给定 Pod 和其中容器的监控数据</span>
kubectl top pod POD_NAME --sort-by<span style="color:#666">=</span>cpu              <span style="color:#080;font-style:italic"># 显示给定 Pod 的指标并且按照 &#39;cpu&#39; 或者 &#39;memory&#39; 排序</span>
</code></pre></div><!--
## Interacting with Deployments and Services
-->
<h2 id="与-deployments-和-services-进行交互">与 Deployments 和 Services 进行交互</h2>
<!--
```bash
kubectl logs deploy/my-deployment                         # dump Pod logs for a Deployment (single-container case)
kubectl logs deploy/my-deployment -c my-container         # dump Pod logs for a Deployment (multi-container case)

kubectl port-forward svc/my-service 5000                  # listen on local port 5000 and forward to port 5000 on Service backend
kubectl port-forward svc/my-service 5000:my-service-port  # listen on local port 5000 and forward to Service target port with name <my-service-port>

kubectl port-forward deploy/my-deployment 5000:6000       # listen on local port 5000 and forward to port 6000 on a Pod created by <my-deployment>
kubectl exec deploy/my-deployment -- ls                   # run command in first Pod and first container in Deployment (single- or multi-container cases)
```
-->
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">kubectl logs deploy/my-deployment                         <span style="color:#080;font-style:italic"># 获取一个 Deployment 的 Pod 的日志（单容器例子）</span>
kubectl logs deploy/my-deployment -c my-container         <span style="color:#080;font-style:italic"># 获取一个 Deployment 的 Pod 的日志（多容器例子）</span>

kubectl port-forward svc/my-service <span style="color:#666">5000</span>                  <span style="color:#080;font-style:italic"># 侦听本地端口 5000 并转发到 Service 后端端口 5000</span>
kubectl port-forward svc/my-service 5000:my-service-port  <span style="color:#080;font-style:italic"># 侦听本地端口 5000 并转发到名字为 &lt;my-service-port&gt; 的 Service 目标端口</span>

kubectl port-forward deploy/my-deployment 5000:6000       <span style="color:#080;font-style:italic"># 侦听本地端口 5000 并转发到 &lt;my-deployment&gt; 创建的 Pod 里的端口 6000</span>
kubectl <span style="color:#a2f">exec</span> deploy/my-deployment -- ls                   <span style="color:#080;font-style:italic"># 在 Deployment 里的第一个 Pod 的第一个容器里运行命令（单容器和多容器例子）</span>
</code></pre></div><!--
## Interacting with Nodes and Cluster
-->
<h2 id="与节点和集群进行交互">与节点和集群进行交互</h2>
<!--
```bash
kubectl cordon my-node                                                # Mark my-node as unschedulable
kubectl drain my-node                                                 # Drain my-node in preparation for maintenance
kubectl uncordon my-node                                              # Mark my-node as schedulable
kubectl top node my-node                                              # Show metrics for a given node
kubectl cluster-info                                                  # Display addresses of the master and services
kubectl cluster-info dump                                             # Dump current cluster state to stdout
kubectl cluster-info dump --output-directory=/path/to/cluster-state   # Dump current cluster state to /path/to/cluster-state

# If a taint with that key and effect already exists, its value is replaced as specified.
kubectl taint nodes foo dedicated=special-user:NoSchedule
```
-->
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">kubectl cordon my-node                                                <span style="color:#080;font-style:italic"># 标记 my-node 节点为不可调度</span>
kubectl drain my-node                                                 <span style="color:#080;font-style:italic"># 对 my-node 节点进行清空操作，为节点维护做准备</span>
kubectl uncordon my-node                                              <span style="color:#080;font-style:italic"># 标记 my-node 节点为可以调度</span>
kubectl top node my-node                                              <span style="color:#080;font-style:italic"># 显示给定节点的度量值</span>
kubectl cluster-info                                                  <span style="color:#080;font-style:italic"># 显示主控节点和服务的地址</span>
kubectl cluster-info dump                                             <span style="color:#080;font-style:italic"># 将当前集群状态转储到标准输出</span>
kubectl cluster-info dump --output-directory<span style="color:#666">=</span>/path/to/cluster-state   <span style="color:#080;font-style:italic"># 将当前集群状态输出到 /path/to/cluster-state</span>

<span style="color:#080;font-style:italic"># 如果已存在具有指定键和效果的污点，则替换其值为指定值。</span>
kubectl taint nodes foo <span style="color:#b8860b">dedicated</span><span style="color:#666">=</span>special-user:NoSchedule
</code></pre></div><!--
### Resource types
-->
<h3 id="资源类型">资源类型</h3>
<!--
List all supported resource types along with their shortnames, [API group](/docs/concepts/overview/kubernetes-api/#api-groups-and-versioning), whether they are [namespaced](/docs/concepts/overview/working-with-objects/namespaces), and [Kind](/docs/concepts/overview/working-with-objects/kubernetes-objects):
-->
<p>列出所支持的全部资源类型和它们的简称、<a href="/zh/docs/concepts/overview/kubernetes-api/#api-groups-and-versioning">API 组</a>, 是否是<a href="/zh/docs/concepts/overview/working-with-objects/namespaces">名字空间作用域</a> 和 <a href="/zh/docs/concepts/overview/working-with-objects/kubernetes-objects">Kind</a>。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">kubectl api-resources
</code></pre></div><!--
Other operations for exploring API resources:
-->
<p>用于探索 API 资源的其他操作：</p>
<!--
```bash
kubectl api-resources --namespaced=true      # All namespaced resources
kubectl api-resources --namespaced=false     # All non-namespaced resources
kubectl api-resources -o name                # All resources with simple output (only the resource name)
kubectl api-resources -o wide                # All resources with expanded (aka "wide") output
kubectl api-resources --verbs=list,get       # All resources that support the "list" and "get" request verbs
kubectl api-resources --api-group=extensions # All resources in the "extensions" API group
```
-->
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">kubectl api-resources --namespaced<span style="color:#666">=</span><span style="color:#a2f">true</span>      <span style="color:#080;font-style:italic"># 所有命名空间作用域的资源</span>
kubectl api-resources --namespaced<span style="color:#666">=</span><span style="color:#a2f">false</span>     <span style="color:#080;font-style:italic"># 所有非命名空间作用域的资源</span>
kubectl api-resources -o name                <span style="color:#080;font-style:italic"># 用简单格式列举所有资源（仅显示资源名称）</span>
kubectl api-resources -o wide                <span style="color:#080;font-style:italic"># 用扩展格式列举所有资源（又称 &#34;wide&#34; 格式）</span>
kubectl api-resources --verbs<span style="color:#666">=</span>list,get       <span style="color:#080;font-style:italic"># 支持 &#34;list&#34; 和 &#34;get&#34; 请求动词的所有资源</span>
kubectl api-resources --api-group<span style="color:#666">=</span>extensions <span style="color:#080;font-style:italic"># &#34;extensions&#34; API 组中的所有资源</span>
</code></pre></div><!--
### Formatting output

To output details to your terminal window in a specific format, add the `-o` (or `--output`) flag to a supported `kubectl` command.
-->
<h3 id="格式化输出">格式化输出</h3>
<p>要以特定格式将详细信息输出到终端窗口，将 <code>-o</code>（或者 <code>--output</code>）参数添加到支持的 <code>kubectl</code> 命令中。</p>
<!--O
Output format | Description
--------------| -----------
`-o=custom-columns=<spec>` | Print a table using a comma separated list of custom columns
`-o=custom-columns-file=<filename>` | Print a table using the custom columns template in the `<filename>` file
`-o=json`     | Output a JSON formatted API object
`-o=jsonpath=<template>` | Print the fields defined in a [jsonpath](/docs/reference/kubectl/jsonpath) expression
`-o=jsonpath-file=<filename>` | Print the fields defined by the [jsonpath](/docs/reference/kubectl/jsonpath) expression in the `<filename>` file
`-o=name`     | Print only the resource name and nothing else
`-o=wide`     | Output in the plain-text format with any additional information, and for pods, the node name is included
`-o=yaml`     | Output a YAML formatted API object
-->
<table>
<thead>
<tr>
<th>输出格式</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>-o=custom-columns=&lt;spec&gt;</code></td>
<td>使用逗号分隔的自定义列来打印表格</td>
</tr>
<tr>
<td><code>-o=custom-columns-file=&lt;filename&gt;</code></td>
<td>使用 <code>&lt;filename&gt;</code> 文件中的自定义列模板打印表格</td>
</tr>
<tr>
<td><code>-o=json</code></td>
<td>输出 JSON 格式的 API 对象</td>
</tr>
<tr>
<td><code>-o=jsonpath=&lt;template&gt;</code></td>
<td>打印 <a href="/zh/docs/reference/kubectl/jsonpath">jsonpath</a> 表达式中定义的字段</td>
</tr>
<tr>
<td><code>-o=jsonpath-file=&lt;filename&gt;</code></td>
<td>打印在 <code>&lt;filename&gt;</code> 文件中定义的 <a href="/zh/docs/reference/kubectl/jsonpath">jsonpath</a> 表达式所指定的字段。</td>
</tr>
<tr>
<td><code>-o=name</code></td>
<td>仅打印资源名称而不打印其他内容</td>
</tr>
<tr>
<td><code>-o=wide</code></td>
<td>以纯文本格式输出额外信息，对于 Pod 来说，输出中包含了节点名称</td>
</tr>
<tr>
<td><code>-o=yaml</code></td>
<td>输出 YAML 格式的 API 对象</td>
</tr>
</tbody>
</table>
<!--
Examples using `-o=custom-columns`:

```bash
# All images running in a cluster
kubectl get pods -A -o=custom-columns='DATA:spec.containers[*].image'

# All images running in namespace: default, grouped by Pod
kubectl get pods --namespace default --output=custom-columns="NAME:.metadata.name,IMAGE:.spec.containers[*].image"

# All images excluding "k8s.gcr.io/coredns:1.6.2"
kubectl get pods -A -o=custom-columns='DATA:spec.containers[?(@.image!="k8s.gcr.io/coredns:1.6.2")].image'

# All fields under metadata regardless of name
kubectl get pods -A -o=custom-columns='DATA:metadata.*'

More examples in the kubectl [reference documentation](/docs/reference/kubectl/overview/#custom-columns).
```
-->
<p>使用 <code>-o=custom-columns</code> 的示例：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#080;font-style:italic"># 集群中运行着的所有镜像</span>
kubectl get pods -A -o<span style="color:#666">=</span>custom-columns<span style="color:#666">=</span><span style="color:#b44">&#39;DATA:spec.containers[*].image&#39;</span>

<span style="color:#080;font-style:italic"># 列举 default 名字空间中运行的所有镜像，按 Pod 分组</span>
kubectl get pods --namespace default --output<span style="color:#666">=</span>custom-columns<span style="color:#666">=</span><span style="color:#b44">&#34;NAME:.metadata.name,IMAGE:.spec.containers[*].image&#34;</span>

<span style="color:#080;font-style:italic"># 除 &#34;k8s.gcr.io/coredns:1.6.2&#34; 之外的所有镜像</span>
kubectl get pods -A -o<span style="color:#666">=</span>custom-columns<span style="color:#666">=</span><span style="color:#b44">&#39;DATA:spec.containers[?(@.image!=&#34;k8s.gcr.io/coredns:1.6.2&#34;)].image&#39;</span>

<span style="color:#080;font-style:italic"># 输出 metadata 下面的所有字段，无论 Pod 名字为何</span>
kubectl get pods -A -o<span style="color:#666">=</span>custom-columns<span style="color:#666">=</span><span style="color:#b44">&#39;DATA:metadata.*&#39;</span>
</code></pre></div><p>有关更多示例，请参看 kubectl <a href="/zh/docs/reference/kubectl/overview/#custom-columns">参考文档</a>。</p>
<!--
### Kubectl output verbosity and debugging

Kubectl verbosity is controlled with the `-v` or `--v` flags followed by an integer representing the log level. General Kubernetes logging conventions and the associated log levels are described [here](https://github.com/kubernetes/community/blob/master/contributors/devel/sig-instrumentation/logging.md).
-->
<h3 id="kubectl-日志输出详细程度和调试">Kubectl 日志输出详细程度和调试</h3>
<p>Kubectl 日志输出详细程度是通过 <code>-v</code> 或者 <code>--v</code> 来控制的，参数后跟一个数字表示日志的级别。
Kubernetes 通用的日志习惯和相关的日志级别在
<a href="https://github.com/kubernetes/community/blob/master/contributors/devel/sig-instrumentation/logging.md">这里</a> 有相应的描述。</p>
<!--
Verbosity | Description
--------------| -----------
`--v=0` | Generally useful for this to *always* be visible to a cluster operator.
`--v=1` | A reasonable default log level if you don't want verbosity.
`--v=2` | Useful steady state information about the service and important log messages that may correlate to significant changes in the system. This is the recommended default log level for most systems.
`--v=3` | Extended information about changes.
`--v=4` | Debug level verbosity.
`--v=5` | Trace level verbosity.
`--v=6` | Display requested resources.
`--v=7` | Display HTTP request headers.
`--v=8` | Display HTTP request contents.
`--v=9` | Display HTTP request contents without truncation of contents.
-->
<table>
<thead>
<tr>
<th>详细程度</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>--v=0</code></td>
<td>用于那些应该 <em>始终</em> 对运维人员可见的信息，因为这些信息一般很有用。</td>
</tr>
<tr>
<td><code>--v=1</code></td>
<td>如果您不想要看到冗余信息，此值是一个合理的默认日志级别。</td>
</tr>
<tr>
<td><code>--v=2</code></td>
<td>输出有关服务的稳定状态的信息以及重要的日志消息，这些信息可能与系统中的重大变化有关。这是建议大多数系统设置的默认日志级别。</td>
</tr>
<tr>
<td><code>--v=3</code></td>
<td>包含有关系统状态变化的扩展信息。</td>
</tr>
<tr>
<td><code>--v=4</code></td>
<td>包含调试级别的冗余信息。</td>
</tr>
<tr>
<td><code>--v=5</code></td>
<td>跟踪级别的详细程度。</td>
</tr>
<tr>
<td><code>--v=6</code></td>
<td>显示所请求的资源。</td>
</tr>
<tr>
<td><code>--v=7</code></td>
<td>显示 HTTP 请求头。</td>
</tr>
<tr>
<td><code>--v=8</code></td>
<td>显示 HTTP 请求内容。</td>
</tr>
<tr>
<td><code>--v=9</code></td>
<td>显示 HTTP 请求内容而且不截断内容。</td>
</tr>
</tbody>
</table>
<h2 id="接下来">接下来</h2>
<!--

* Read the [kubectl overview](/docs/reference/kubectl/overview/) and learn about [JsonPath](/docs/reference/kubectl/jsonpath).

* See [kubectl](/docs/reference/kubectl/kubectl/) options.

* Also read [kubectl Usage Conventions](/docs/reference/kubectl/conventions/) to understand how to use kubectl in reusable scripts.

* See more community [kubectl cheatsheets](https://github.com/dennyzhang/cheatsheet-kubernetes-A4).
-->
<ul>
<li>参阅 <a href="/zh/docs/reference/kubectl/overview/">kubectl 概述</a>，进一步了解<a href="/zh/docs/reference/kubectl/jsonpath">JsonPath</a>。</li>
<li>参阅 <a href="/zh/docs/reference/kubectl/kubectl/">kubectl</a> 选项。</li>
<li>参阅 <a href="/zh/docs/reference/kubectl/conventions/">kubectl 使用约定</a>来理解如何在可复用的脚本中使用它。</li>
<li>查看社区中其他的 <a href="https://github.com/dennyzhang/cheatsheet-kubernetes-A4">kubectl 备忘单</a>。</li>
</ul>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-8de6aceb8bf692c06cced446bac5bc92">8.6 - kubectl 的用法约定</h1>
    
	<!--
---
title: kubectl Usage Conventions
reviewers:
- janetkuo
content_type: concept
---
-->
<!-- overview -->
<!--
Recommended usage conventions for `kubectl`.
-->
<p><code>kubectl</code> 的推荐用法约定。</p>
<!-- body -->
<!--
## Using `kubectl` in Reusable Scripts
-->
<h2 id="在可重用脚本中使用-kubectl">在可重用脚本中使用 <code>kubectl</code></h2>
<!--
For a stable output in a script:
-->
<p>对于脚本中的稳定输出：</p>
<!--
* Request one of the machine-oriented output forms, such as `-o name`, `-o json`, `-o yaml`, `-o go-template`, or `-o jsonpath`.
* Fully-qualify the version. For example, `jobs.v1.batch/myjob`. This will ensure that kubectl does not use its default version that can change over time.
* Don't rely on context, preferences, or other implicit states.
-->
<ul>
<li>请求一个面向机器的输出格式，例如 <code>-o name</code>、<code>-o json</code>、<code>-o yaml</code>、<code>-o go template</code> 或 <code>-o jsonpath</code>。</li>
<li>完全限定版本。例如 <code>jobs.v1.batch/myjob</code>。这将确保 kubectl 不会使用其默认版本，该版本会随着时间的推移而更改。</li>
<li>不要依赖上下文、首选项或其他隐式状态。</li>
</ul>
<!--
## Best Practices
-->
<h2 id="最佳实践">最佳实践</h2>
<h3 id="kubectl-run"><code>kubectl run</code></h3>
<!--
For `kubectl run` to satisfy infrastructure as code:
-->
<p>若希望 <code>kubectl run</code> 满足基础设施即代码的要求：</p>
<!--
* Tag the image with a version-specific tag and don't move that tag to a new version. For example, use `:v1234`, `v1.2.3`, `r03062016-1-4`, rather than `:latest` (For more information, see [Best Practices for Configuration](/docs/concepts/configuration/overview/#container-images)).
* Check in the script for an image that is heavily parameterized.
* Switch to configuration files checked into source control for features that are needed, but not expressible via `kubectl run` flags.
-->
<ul>
<li>使用特定版本的标签标记镜像，不要将该标签移动到新版本。例如，使用 <code>:v1234</code>、<code>v1.2.3</code>、<code>r03062016-1-4</code>，而不是 <code>:latest</code>（有关详细信息，请参阅<a href="/zh/docs/concepts/configuration/overview/#container-images">配置的最佳实践</a>)。</li>
<li>使用基于版本控制的脚本来运行包含大量参数的镜像。</li>
<li>对于无法通过 <code>kubectl run</code> 参数来表示的功能特性，使用基于源码控制的配置文件，以记录要使用的功能特性。</li>
</ul>
<!--
You can use the `--dry-run=client` flag to preview the object that would be sent to your cluster, without really submitting it.
-->
<p>你可以使用 <code>--dry-run=client</code> 参数来预览而不真正提交即将下发到集群的对象实例：</p>
<blockquote class="note callout">
  <div><strong>说明：</strong> <!--
All `kubectl run` generators are deprecated.
See the Kubernetes v1.17 documentation for a [list](https://v1-17.docs.kubernetes.io/docs/reference/kubectl/conventions/#generators) of generators and how they were used.
-->
<p>所有的 <code>kubectl run</code> 生成器已弃用。
查阅 Kubernetes v1.17 文档中的生成器<a href="https://v1-17.docs.kubernetes.io/docs/reference/kubectl/conventions/#generators">列表</a>以及它们的用法。</div>
</blockquote>
<!--
#### Generators
-->
<h4 id="生成器">生成器</h4>
<!--
You can generate the following resources with a kubectl command, `kubectl create --dry-run=client -o yaml`:

* `clusterrole`: Create a ClusterRole.
* `clusterrolebinding`: Create a ClusterRoleBinding for a particular ClusterRole.
* `configmap`: Create a ConfigMap from a local file, directory or literal value.
* `cronjob`: Create a CronJob with the specified name.
* `deployment`: Create a Deployment with the specified name.
* `job`: Create a Job with the specified name.
* `namespace`: Create a Namespace with the specified name.
* `poddisruptionbudget`: Create a PodDisruptionBudget with the specified name.
* `priorityclass`: Create a PriorityClass with the specified name.
* `quota`: Create a Quota with the specified name.
* `role`: Create a Role with single rule.
* `rolebinding`: Create a RoleBinding for a particular Role or ClusterRole.
* `secret`: Create a Secret using specified subcommand.
* `service`: Create a Service using specified subcommand.
* `serviceaccount`: Create a ServiceAccount with the specified name.

-->
<p>你可以使用 kubectl 命令生成以下资源， <code>kubectl create --dry-run=client -o yaml</code>：</p>
<ul>
<li><code>clusterrole</code>:         创建 ClusterRole。</li>
<li><code>clusterrolebinding</code>:  为特定的 ClusterRole 创建 ClusterRoleBinding。</li>
<li><code>configmap</code>:           使用本地文件、目录或文本值创建 Configmap。</li>
<li><code>cronjob</code>:             使用指定的名称创建 Cronjob。</li>
<li><code>deployment</code>:          使用指定的名称创建 Deployment。</li>
<li><code>job</code>:                 使用指定的名称创建 Job。</li>
<li><code>namespace</code>:           使用指定的名称创建名称空间。</li>
<li><code>poddisruptionbudget</code>: 使用指定名称创建 Pod 干扰预算。</li>
<li><code>priorityclass</code>:       使用指定的名称创建 Priorityclass。</li>
<li><code>quota</code>:               使用指定的名称创建配额。</li>
<li><code>role</code>:                使用单一规则创建角色。</li>
<li><code>rolebinding</code>:         为特定角色或 ClusterRole 创建 RoleBinding。</li>
<li><code>secret</code>:              使用指定的子命令创建 Secret。</li>
<li><code>service</code>:             使用指定的子命令创建服务。</li>
<li><code>serviceaccount</code>:      使用指定的名称创建服务帐户。</li>
</ul>
<h3 id="kubectl-apply"><code>kubectl apply</code></h3>
<!--
* You can use `kubectl apply` to create or update resources. For more information about using kubectl apply to update resources, see [Kubectl Book](https://kubectl.docs.kubernetes.io).
-->
<ul>
<li>您可以使用 <code>kubectl apply</code> 命令创建或更新资源。有关使用 kubectl apply 更新资源的详细信息，请参阅 <a href="https://kubectl.docs.kubernetes.io">Kubectl 文档</a>。</li>
</ul>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-a7abc09192597e614b58f8b552b682f5">8.7 - 适用于 Docker 用户的 kubectl</h1>
    
	<!--
---
title: kubectl for Docker Users
content_type: concept
reviewers:
- brendandburns
- thockin
---
-->
<!-- overview -->
<!--
You can use the Kubernetes command line tool `kubectl` to interact with the API Server. Using kubectl is straightforward if you are familiar with the Docker command line tool. However, there are a few differences between the docker commands and the kubectl commands. The following sections show a Docker sub-command and describe the equivalent `kubectl` command.
-->
<p>您可以使用 Kubernetes 命令行工具 <code>kubectl</code> 与 API 服务器进行交互。如果您熟悉 Docker 命令行工具，则使用 kubectl 非常简单。但是，Docker 命令和 kubectl 命令之间有一些区别。以下显示了 Docker 子命令，并描述了等效的 <code>kubectl</code> 命令。</p>
<!-- body -->
<h2 id="docker-run">docker run</h2>
<!--
To run an nginx Deployment and expose the Deployment, see [kubectl create deployment](/docs/reference/generated/kubectl/kubectl-commands#-em-deployment-em-).
-->
<p>要运行 nginx 部署并将其暴露，请参见<a href="/docs/reference/generated/kubectl/kubectl-commands#-em-deployment-em-">kubectl create deployment</a>
docker:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">docker run -d --restart<span style="color:#666">=</span>always -e <span style="color:#b8860b">DOMAIN</span><span style="color:#666">=</span>cluster --name nginx-app -p 80:80 nginx
</code></pre></div><pre tabindex="0"><code>55c103fa129692154a7652490236fee9be47d70a8dd562281ae7d2f9a339a6db
</code></pre><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">docker ps
</code></pre></div><pre tabindex="0"><code>CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                NAMES
55c103fa1296        nginx               &quot;nginx -g 'daemon of…&quot;   9 seconds ago       Up 9 seconds        0.0.0.0:80-&gt;80/tcp   nginx-app
</code></pre><p>kubectl:</p>
<!--
```shell
# start the pod running nginx
kubectl run --image=nginx nginx-app --port=80 --env="DOMAIN=cluster"
```
-->
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="color:#080;font-style:italic"># 启动运行 nginx 的 Pod</span>
kubectl create deployment --image<span style="color:#666">=</span>nginx nginx-app
</code></pre></div><pre tabindex="0"><code>deployment.apps/nginx-app created
</code></pre><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="color:#080;font-style:italic"># add env to nginx-app</span>
kubectl <span style="color:#a2f">set</span> env deployment/nginx-app  <span style="color:#b8860b">DOMAIN</span><span style="color:#666">=</span>cluster
</code></pre></div><pre tabindex="0"><code>deployment.apps/nginx-app env updated
</code></pre><blockquote class="note callout">
  <div><strong>说明：</strong> <!--
`kubectl` commands print the type and name of the resource created or mutated, which can then be used in subsequent commands. You can expose a new Service after a Deployment is created.
-->
<p><code>kubectl</code> 命令打印创建或突变资源的类型和名称，然后可以在后续命令中使用。部署后，您可以公开新服务。</div>
</blockquote>
<!--
```shell
# expose a port through with a service
kubectl expose deployment nginx-app --port=80 --name=nginx-http
```
-->
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="color:#080;font-style:italic"># 通过服务公开端口</span>
kubectl expose deployment nginx-app --port<span style="color:#666">=</span><span style="color:#666">80</span> --name<span style="color:#666">=</span>nginx-http
</code></pre></div><pre tabindex="0"><code>service &quot;nginx-http&quot; exposed
</code></pre><!--
By using kubectl, you can create a [Deployment](/docs/concepts/workloads/controllers/deployment/) to ensure that N pods are running nginx, where N is the number of replicas stated in the spec and defaults to 1. You can also create a [service](/docs/concepts/services-networking/service/) with a selector that matches the pod labels. For more information, see [Use a Service to Access an Application in a Cluster](/docs/tasks/access-application-cluster/service-access-application-cluster).
-->
<p>在 kubectl 命令中，我们创建了一个 <a href="/zh/docs/concepts/workloads/controllers/deployment/">Deployment</a>，这将保证有 N 个运行 nginx 的 pod(N 代表 spec 中声明的 replica 数，默认为 1)。我们还创建了一个 <a href="/zh/docs/concepts/services-networking/service/">service</a>，其选择器与容器标签匹配。查看<a href="/zh/docs/tasks/access-application-cluster/service-access-application-cluster">使用服务访问群集中的应用程序</a> 获取更多信息。</p>
<!--
By default images run in the background, similar to `docker run -d ...`. To run things in the foreground, use [`kubectl run`](/docs/reference/generated/kubectl/kubectl-commands/#run) to create pod:
-->
<p>默认情况下镜像会在后台运行，与 <code>docker run -d ...</code> 类似，如果您想在前台运行，使用 <a href="/docs/reference/generated/kubectl/kubectl-commands/#run"><code>kubectl run</code></a> 在前台运行 Pod:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl run <span style="color:#666">[</span>-i<span style="color:#666">]</span> <span style="color:#666">[</span>--tty<span style="color:#666">]</span> --attach &lt;name&gt; --image<span style="color:#666">=</span>&lt;image&gt;
</code></pre></div><!--
Unlike `docker run ...`, if you specify `--attach`, then you attach `stdin`, `stdout` and `stderr`. You cannot control which streams are attached (`docker -a ...`).
To detach from the container, you can type the escape sequence Ctrl+P followed by Ctrl+Q.
-->
<p>与 <code>docker run ...</code> 不同的是，如果指定了 <code>--attach</code> ，我们将连接到 <code>stdin</code>，<code>stdout</code> 和 <code>stderr</code>，而不能控制具体连接到哪个输出流（<code>docker -a ...</code>）。要从容器中退出，可以输入 Ctrl + P，然后按 Ctrl + Q。</p>
<!--
Because the kubectl run command starts a Deployment for the container, the Deployment restarts if you terminate the attached process by using Ctrl+C, unlike `docker run -it`.
To destroy the Deployment and its pods you need to run `kubectl delete deployment <name>`.
-->
<p>因为我们使用 Deployment 启动了容器，如果您终止连接到的进程（例如 <code>ctrl-c</code>），容器将会重启，这跟 <code>docker run -it</code> 不同。
如果想销毁该 Deployment（和它的 pod），您需要运行 <code>kubectl delete deployment &lt;name&gt;</code>。</p>
<h2 id="docker-ps">docker ps</h2>
<!--
To list what is currently running, see [kubectl get](/docs/reference/generated/kubectl/kubectl-commands/#get).
-->
<p>如何列出哪些正在运行？查看 <a href="/docs/reference/generated/kubectl/kubectl-commands/#get">kubectl get</a>。</p>
<!--
docker:
 -->
<p>使用 docker 命令：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">docker ps -a
</code></pre></div><pre tabindex="0"><code>CONTAINER ID        IMAGE               COMMAND                  CREATED              STATUS                     PORTS                NAMES
14636241935f        ubuntu:16.04        &quot;echo test&quot;              5 seconds ago        Exited (0) 5 seconds ago                        cocky_fermi
55c103fa1296        nginx               &quot;nginx -g 'daemon of…&quot;   About a minute ago   Up About a minute          0.0.0.0:80-&gt;80/tcp   nginx-app
</code></pre><!--
kubectl:
-->
<p>使用 kubectl 命令：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl get po
</code></pre></div><pre tabindex="0"><code>NAME                        READY     STATUS      RESTARTS   AGE
nginx-app-8df569cb7-4gd89   1/1       Running     0          3m
ubuntu                      0/1       Completed   0          20s
</code></pre><h2 id="docker-attach">docker attach</h2>
<!--
To attach a process that is already running in a container, see [kubectl attach](/docs/reference/generated/kubectl/kubectl-commands/#attach).
-->
<p>如何连接到已经运行在容器中的进程？查看 <a href="/docs/reference/generated/kubectl/kubectl-commands/#attach">kubectl attach</a>。</p>
<!--
docker:
-->
<p>使用 docker 命令：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">docker ps
</code></pre></div><pre tabindex="0"><code>CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                NAMES
55c103fa1296        nginx               &quot;nginx -g 'daemon of…&quot;   5 minutes ago       Up 5 minutes        0.0.0.0:80-&gt;80/tcp   nginx-app
</code></pre><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">docker attach 55c103fa1296
...
</code></pre></div><p>kubectl:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl get pods
</code></pre></div><pre tabindex="0"><code>NAME              READY     STATUS    RESTARTS   AGE
nginx-app-5jyvm   1/1       Running   0          10m
</code></pre><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl attach -it nginx-app-5jyvm
...
</code></pre></div><!--
To detach from the container, you can type the escape sequence Ctrl+P followed by Ctrl+Q.
-->
<p>要从容器中分离，可以输入 Ctrl + P，然后按 Ctrl + Q。</p>
<h2 id="docker-exec">docker exec</h2>
<!--
To execute a command in a container, see [kubectl exec](/docs/reference/generated/kubectl/kubectl-commands/#exec).
-->
<p>如何在容器中执行命令？查看 <a href="/docs/reference/generated/kubectl/kubectl-commands/#exec">kubectl exec</a>。</p>
<!--
docker:
-->
<p>使用 docker 命令：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">docker ps
</code></pre></div><pre tabindex="0"><code>CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                NAMES
55c103fa1296        nginx               &quot;nginx -g 'daemon of…&quot;   6 minutes ago       Up 6 minutes        0.0.0.0:80-&gt;80/tcp   nginx-app
</code></pre><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">docker <span style="color:#a2f">exec</span> 55c103fa1296 cat /etc/hostname
</code></pre></div><pre tabindex="0"><code>55c103fa1296
</code></pre><!--
kubectl:
-->
<p>使用 kubectl 命令：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl get po
</code></pre></div><pre tabindex="0"><code>NAME              READY     STATUS    RESTARTS   AGE
nginx-app-5jyvm   1/1       Running   0          10m
</code></pre><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl <span style="color:#a2f">exec</span> nginx-app-5jyvm -- cat /etc/hostname
</code></pre></div><pre tabindex="0"><code>nginx-app-5jyvm
</code></pre><!--
To use interactive commands.
-->
<p>执行交互式命令怎么办？</p>
<!--
docker:
-->
<p>使用 docker 命令：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">docker <span style="color:#a2f">exec</span> -ti 55c103fa1296 /bin/sh
<span style="color:#080;font-style:italic"># exit</span>
</code></pre></div><p>kubectl:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl <span style="color:#a2f">exec</span> -ti nginx-app-5jyvm -- /bin/sh      
<span style="color:#080;font-style:italic"># exit</span>
</code></pre></div><!--
For more information, see [Get a Shell to a Running Container](/docs/tasks/debug-application-cluster/get-shell-running-container/).
-->
<p>更多信息请查看<a href="/zh/docs/tasks/debug-application-cluster/get-shell-running-container/">获取运行中容器的 Shell 环境</a>。</p>
<h2 id="docker-logs">docker logs</h2>
<!--
To follow stdout/stderr of a process that is running, see [kubectl logs](/docs/reference/generated/kubectl/kubectl-commands/#logs).
-->
<p>如何查看运行中进程的 stdout/stderr？查看 <a href="/docs/reference/generated/kubectl/kubectl-commands/#logs">kubectl logs</a>。</p>
<!--
docker:
-->
<p>使用 docker 命令：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">docker logs -f a9e
</code></pre></div><pre tabindex="0"><code>192.168.9.1 - - [14/Jul/2015:01:04:02 +0000] &quot;GET / HTTP/1.1&quot; 200 612 &quot;-&quot; &quot;curl/7.35.0&quot; &quot;-&quot;
192.168.9.1 - - [14/Jul/2015:01:04:03 +0000] &quot;GET / HTTP/1.1&quot; 200 612 &quot;-&quot; &quot;curl/7.35.0&quot; &quot;-&quot;
</code></pre><!--
kubectl:
-->
<p>使用 kubectl 命令：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl logs -f nginx-app-zibvs
</code></pre></div><pre tabindex="0"><code>10.240.63.110 - - [14/Jul/2015:01:09:01 +0000] &quot;GET / HTTP/1.1&quot; 200 612 &quot;-&quot; &quot;curl/7.26.0&quot; &quot;-&quot;
10.240.63.110 - - [14/Jul/2015:01:09:02 +0000] &quot;GET / HTTP/1.1&quot; 200 612 &quot;-&quot; &quot;curl/7.26.0&quot; &quot;-&quot;
</code></pre><!--
There is a slight difference between pods and containers; by default pods do not terminate if their processes exit. Instead the pods restart the process. This is similar to the docker run option `--restart=always` with one major difference. In docker, the output for each invocation of the process is concatenated, but for Kubernetes, each invocation is separate. To see the output from a previous run in Kubernetes, do this:
-->
<p>现在是时候提一下 pod 和容器之间的细微差别了；默认情况下如果 pod 中的进程退出 pod 也不会终止，相反它将会重启该进程。这类似于 docker run 时的 <code>--restart=always</code> 选项， 这是主要差别。在 docker 中，进程的每个调用的输出都是被连接起来的，但是对于 kubernetes，每个调用都是分开的。要查看以前在 kubernetes 中执行的输出，请执行以下操作：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl logs --previous nginx-app-zibvs
</code></pre></div><pre tabindex="0"><code>10.240.63.110 - - [14/Jul/2015:01:09:01 +0000] &quot;GET / HTTP/1.1&quot; 200 612 &quot;-&quot; &quot;curl/7.26.0&quot; &quot;-&quot;
10.240.63.110 - - [14/Jul/2015:01:09:02 +0000] &quot;GET / HTTP/1.1&quot; 200 612 &quot;-&quot; &quot;curl/7.26.0&quot; &quot;-&quot;
</code></pre><!--
For more information, see [Logging Architecture](/docs/concepts/cluster-administration/logging/).
-->
<p>查看<a href="/zh/docs/concepts/cluster-administration/logging/">日志架构</a>获取更多信息。</p>
<h2 id="docker-stop-and-docker-rm">docker stop and docker rm</h2>
<!--
To stop and delete a running process, see [kubectl delete](/docs/reference/generated/kubectl/kubectl-commands/#delete).
-->
<p>如何停止和删除运行中的进程？查看 <a href="/docs/reference/generated/kubectl/kubectl-commands/#delete">kubectl delete</a>。</p>
<!--
docker:
-->
<p>使用 docker 命令：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">docker ps
</code></pre></div><pre tabindex="0"><code>CONTAINER ID        IMAGE               COMMAND                CREATED             STATUS              PORTS                         NAMES
a9ec34d98787        nginx               &quot;nginx -g 'daemon of&quot;  22 hours ago        Up 22 hours         0.0.0.0:80-&gt;80/tcp, 443/tcp   nginx-app
</code></pre><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">docker stop a9ec34d98787
</code></pre></div><pre tabindex="0"><code>a9ec34d98787
</code></pre><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">docker rm a9ec34d98787
</code></pre></div><pre tabindex="0"><code>a9ec34d98787
</code></pre><!--
kubectl:
-->
<p>使用 kubectl 命令：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl get deployment nginx-app
</code></pre></div><pre tabindex="0"><code>NAME        DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE
nginx-app   1         1         1            1           2m
</code></pre><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl get po -l <span style="color:#b8860b">app</span><span style="color:#666">=</span>nginx-app
</code></pre></div><pre tabindex="0"><code>NAME                         READY     STATUS    RESTARTS   AGE
nginx-app-2883164633-aklf7   1/1       Running   0          2m
</code></pre><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl delete deployment nginx-app
</code></pre></div><pre tabindex="0"><code>deployment &quot;nginx-app&quot; deleted
</code></pre><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl get po -l <span style="color:#b8860b">app</span><span style="color:#666">=</span>nginx-app
<span style="color:#080;font-style:italic"># Return nothing</span>
</code></pre></div><blockquote class="note callout">
  <div><strong>说明：</strong> <!--
When you use kubectl, you don't delete the pod directly.You have to first delete the Deployment that owns the pod. If you delete the pod directly, the Deployment recreates the pod.
-->
<p>请注意，我们不直接删除 pod。使用 kubectl 命令，我们要删除拥有该 pod 的 Deployment。如果我们直接删除 pod，Deployment 将会重新创建该 pod。</div>
</blockquote>
<h2 id="docker-login">docker login</h2>
<!--
There is no direct analog of `docker login` in kubectl. If you are interested in using Kubernetes with a private registry, see [Using a Private Registry](/docs/concepts/containers/images/#using-a-private-registry).
-->
<p>在 kubectl 中没有对 <code>docker login</code> 的直接模拟。如果您有兴趣在私有镜像仓库中使用 Kubernetes，请参阅<a href="/zh/docs/concepts/containers/images/#using-a-private-registry">使用私有镜像仓库</a>。</p>
<h2 id="docker-version">docker version</h2>
<!--
To get the version of client and server, see [kubectl version](/docs/reference/generated/kubectl/kubectl-commands/#version).
-->
<p>如何查看客户端和服务端的版本？查看 <a href="/docs/reference/generated/kubectl/kubectl-commands/#version">kubectl version</a>。</p>
<!--
docker:
-->
<p>使用 docker 命令：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">docker version
</code></pre></div><pre tabindex="0"><code>Client version: 1.7.0
Client API version: 1.19
Go version (client): go1.4.2
Git commit (client): 0baf609
OS/Arch (client): linux/amd64
Server version: 1.7.0
Server API version: 1.19
Go version (server): go1.4.2
Git commit (server): 0baf609
OS/Arch (server): linux/amd64
</code></pre><!--
kubectl:
-->
<p>使用 kubectl 命令：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl version
</code></pre></div><pre tabindex="0"><code>Client Version: version.Info{Major:&quot;1&quot;, Minor:&quot;6&quot;, GitVersion:&quot;v1.6.9+a3d1dfa6f4335&quot;, GitCommit:&quot;9b77fed11a9843ce3780f70dd251e92901c43072&quot;, GitTreeState:&quot;dirty&quot;, BuildDate:&quot;2017-08-29T20:32:58Z&quot;, OpenPaasKubernetesVersion:&quot;v1.03.02&quot;, GoVersion:&quot;go1.7.5&quot;, Compiler:&quot;gc&quot;, Platform:&quot;linux/amd64&quot;}
Server Version: version.Info{Major:&quot;1&quot;, Minor:&quot;6&quot;, GitVersion:&quot;v1.6.9+a3d1dfa6f4335&quot;, GitCommit:&quot;9b77fed11a9843ce3780f70dd251e92901c43072&quot;, GitTreeState:&quot;dirty&quot;, BuildDate:&quot;2017-08-29T20:32:58Z&quot;, OpenPaasKubernetesVersion:&quot;v1.03.02&quot;, GoVersion:&quot;go1.7.5&quot;, Compiler:&quot;gc&quot;, Platform:&quot;linux/amd64&quot;}
</code></pre><h2 id="docker-info">docker info</h2>
<!--
To get miscellaneous information about the environment and configuration, see [kubectl cluster-info](/docs/reference/generated/kubectl/kubectl-commands/#cluster-info).
-->
<p>如何获取有关环境和配置的各种信息？查看 <a href="/docs/reference/generated/kubectl/kubectl-commands/#cluster-info">kubectl cluster-info</a>。</p>
<!--
docker:
-->
<p>使用 docker 命令：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">docker info
</code></pre></div><pre tabindex="0"><code>Containers: 40
Images: 168
Storage Driver: aufs
 Root Dir: /usr/local/google/docker/aufs
 Backing Filesystem: extfs
 Dirs: 248
 Dirperm1 Supported: false
Execution Driver: native-0.2
Logging Driver: json-file
Kernel Version: 3.13.0-53-generic
Operating System: Ubuntu 14.04.2 LTS
CPUs: 12
Total Memory: 31.32 GiB
Name: k8s-is-fun.mtv.corp.google.com
ID: ADUV:GCYR:B3VJ:HMPO:LNPQ:KD5S:YKFQ:76VN:IANZ:7TFV:ZBF4:BYJO
WARNING: No swap limit support
</code></pre><!--
kubectl:
-->
<p>使用 kubectl 命令：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl cluster-info
</code></pre></div><pre tabindex="0"><code>Kubernetes master is running at https://108.59.85.141
KubeDNS is running at https://108.59.85.141/api/v1/namespaces/kube-system/services/kube-dns/proxy
kubernetes-dashboard is running at https://108.59.85.141/api/v1/namespaces/kube-system/services/kubernetes-dashboard/proxy
Grafana is running at https://108.59.85.141/api/v1/namespaces/kube-system/services/monitoring-grafana/proxy
Heapster is running at https://108.59.85.141/api/v1/namespaces/kube-system/services/monitoring-heapster/proxy
InfluxDB is running at https://108.59.85.141/api/v1/namespaces/kube-system/services/monitoring-influxdb/proxy
</code></pre>
</div>



    
	
  

    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-54e562dd1441d0195970a6526b0055cc">9 - 组件工具</h1>
    
	<!--
title: Component tools
weight: 60
-->

</div>



    
      
  
  
  
  

  
  

  
    
    
	
    

<div class="td-content" style="">
    
	<h1 id="pg-ca5d01a42c486d535539d3038aa67eb9">9.1 - 特性门控</h1>
    
	<!--
title: Feature Gates
weight: 10
content_type: concept
card:
  name: reference
  weight: 60
-->
<!-- overview -->
<!--
This page contains an overview of the various feature gates an administrator
can specify on different Kubernetes components.

See [feature stages](#feature-stages) for an explanation of the stages for a feature.
-->
<p>本页详述了管理员可以在不同的 Kubernetes 组件上指定的各种特性门控。</p>
<p>关于特性各个阶段的说明，请参见<a href="#feature-stages">特性阶段</a>。</p>
<!-- body -->
<!--
## Overview

Feature gates are a set of key=value pairs that describe Kubernetes features.
You can turn these features on or off using the `--feature-gates` command line flag
on each Kubernetes component.
-->
<h2 id="概述">概述</h2>
<p>特性门控是描述 Kubernetes 特性的一组键值对。你可以在 Kubernetes 的各个组件中使用
<code>--feature-gates</code> flag 来启用或禁用这些特性。</p>
<!--
Each Kubernetes component lets you enable or disable a set of feature gates that
are relevant to that component.
Use `-h` flag to see a full set of feature gates for all components.
To set feature gates for a component, such as kubelet, use the `--feature-gates` flag assigned to a list of feature pairs:
-->
<p>每个 Kubernetes 组件都支持启用或禁用与该组件相关的一组特性门控。
使用 <code>-h</code> 参数来查看所有组件支持的完整特性门控。
要为诸如 kubelet 之类的组件设置特性门控，请使用 <code>--feature-gates</code> 参数，并向其
传递一个特性设置键值对列表：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">--feature-gates<span style="color:#666">=</span><span style="color:#b44">&#34;...,GracefulNodeShutdown=true&#34;</span>
</code></pre></div><!--
The following tables are a summary of the feature gates that you can set on
different Kubernetes components.
-->
<p>下表总结了在不同的 Kubernetes 组件上可以设置的特性门控。</p>
<!--
- The "Since" column contains the Kubernetes release when a feature is introduced
  or its release stage is changed.
- The "Until" column, if not empty, contains the last Kubernetes release in which
  you can still use a feature gate.
- If a feature is in the Alpha or Beta state, you can find the feature listed
  in the [Alpha/Beta feature gate table](#feature-gates-for-alpha-or-beta-features).
- If a feature is stable you can find all stages for that feature listed in the
  [Graduated/Deprecated feature gate table](#feature-gates-for-graduated-or-deprecated-features).
- The [Graduated/Deprecated feature gate table](#feature-gates-for-graduated-or-deprecated-features)
  also lists deprecated and withdrawn features.
-->
<ul>
<li>引入特性或更改其发布阶段后，&quot;开始（Since）&quot; 列将包含 Kubernetes 版本。</li>
<li>&quot;结束（Until）&quot; 列（如果不为空）包含最后一个 Kubernetes 版本，你仍可以在其中使用特性门控。</li>
<li>如果某个特性处于 Alpha 或 Beta 状态，你可以在
<a href="#feature-gates-for-alpha-or-beta-features">Alpha 和 Beta 特性门控表</a>中找到该特性。</li>
<li>如果某个特性处于稳定状态，你可以在
<a href="#feature-gates-for-graduated-or-deprecated-features">已毕业和废弃特性门控表</a>
中找到该特性的所有阶段。</li>
<li><a href="#feature-gates-for-graduated-or-deprecated-features">已毕业和废弃特性门控表</a>
还列出了废弃的和已被移除的特性。</li>
</ul>
<!--
### Feature gates for Alpha or Beta features






| Feature | Default | Stage | Since | Until |
-->
<h3 id="feature-gates-for-alpha-or-beta-features">Alpha 和 Beta 状态的特性门控 </h3>





<table><caption style="display: none;">处于 Alpha 或 Beta 状态的特性门控</caption>
<thead>
<tr>
<th>特性</th>
<th>默认值</th>
<th>状态</th>
<th>开始（Since）</th>
<th>结束（Until）</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>APIListChunking</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.8</td>
<td>1.8</td>
</tr>
<tr>
<td><code>APIListChunking</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.9</td>
<td></td>
</tr>
<tr>
<td><code>APIPriorityAndFairness</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.17</td>
<td>1.19</td>
</tr>
<tr>
<td><code>APIPriorityAndFairness</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.20</td>
<td></td>
</tr>
<tr>
<td><code>APIResponseCompression</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.7</td>
<td>1.15</td>
</tr>
<tr>
<td><code>APIResponseCompression</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.16</td>
<td></td>
</tr>
<tr>
<td><code>APIServerIdentity</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.20</td>
<td></td>
</tr>
<tr>
<td><code>APIServerTracing</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.22</td>
<td></td>
</tr>
<tr>
<td><code>AllowInsecureBackendProxy</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.17</td>
<td></td>
</tr>
<tr>
<td><code>AnyVolumeDataSource</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.18</td>
<td></td>
</tr>
<tr>
<td><code>AppArmor</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.4</td>
<td></td>
</tr>
<tr>
<td><code>ControllerManagerLeaderMigration</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.21</td>
<td></td>
</tr>
<tr>
<td><code>CPUManager</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.8</td>
<td>1.9</td>
</tr>
<tr>
<td><code>CPUManager</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.10</td>
<td></td>
</tr>
<tr>
<td><code>CPUManagerPolicyOptions</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.22</td>
<td></td>
</tr>
<tr>
<td><code>CSIInlineVolume</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.15</td>
<td>1.15</td>
</tr>
<tr>
<td><code>CSIInlineVolume</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.16</td>
<td>-</td>
</tr>
<tr>
<td><code>CSIMigration</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.14</td>
<td>1.16</td>
</tr>
<tr>
<td><code>CSIMigration</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.17</td>
<td></td>
</tr>
<tr>
<td><code>CSIMigrationAWS</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.14</td>
<td></td>
</tr>
<tr>
<td><code>CSIMigrationAWS</code></td>
<td><code>false</code></td>
<td>Beta</td>
<td>1.17</td>
<td></td>
</tr>
<tr>
<td><code>CSIMigrationAzureDisk</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.15</td>
<td>1.18</td>
</tr>
<tr>
<td><code>CSIMigrationAzureDisk</code></td>
<td><code>false</code></td>
<td>Beta</td>
<td>1.19</td>
<td></td>
</tr>
<tr>
<td><code>CSIMigrationAzureFile</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.15</td>
<td>1.19</td>
</tr>
<tr>
<td><code>CSIMigrationAzureFile</code></td>
<td><code>false</code></td>
<td>Beta</td>
<td>1.21</td>
<td></td>
</tr>
<tr>
<td><code>CSIMigrationGCE</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.14</td>
<td>1.16</td>
</tr>
<tr>
<td><code>CSIMigrationGCE</code></td>
<td><code>false</code></td>
<td>Beta</td>
<td>1.17</td>
<td></td>
</tr>
<tr>
<td><code>CSIMigrationOpenStack</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.14</td>
<td>1.17</td>
</tr>
<tr>
<td><code>CSIMigrationOpenStack</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.18</td>
<td></td>
</tr>
<tr>
<td><code>CSIMigrationvSphere</code></td>
<td><code>false</code></td>
<td>Beta</td>
<td>1.19</td>
<td></td>
</tr>
<tr>
<td><code>CSIStorageCapacity</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.19</td>
<td>1.20</td>
</tr>
<tr>
<td><code>CSIStorageCapacity</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.21</td>
<td></td>
</tr>
<tr>
<td><code>CSIVolumeFSGroupPolicy</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.19</td>
<td>1.19</td>
</tr>
<tr>
<td><code>CSIVolumeFSGroupPolicy</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.20</td>
<td></td>
</tr>
<tr>
<td><code>CSIVolumeHealth</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.21</td>
<td></td>
</tr>
<tr>
<td><code>CSRDuration</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.22</td>
<td></td>
</tr>
<tr>
<td><code>ConfigurableFSGroupPolicy</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.18</td>
<td>1.19</td>
</tr>
<tr>
<td><code>ConfigurableFSGroupPolicy</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.20</td>
<td></td>
</tr>
<tr>
<td><code>ControllerManagerLeaderMigration</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.21</td>
<td>1.21</td>
</tr>
<tr>
<td><code>ControllerManagerLeaderMigration</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.22</td>
<td></td>
</tr>
<tr>
<td><code>CustomCPUCFSQuotaPeriod</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.12</td>
<td></td>
</tr>
<tr>
<td><code>DaemonSetUpdateSurge</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.21</td>
<td>1.21</td>
</tr>
<tr>
<td><code>DaemonSetUpdateSurge</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.22</td>
<td></td>
</tr>
<tr>
<td><code>DefaultPodTopologySpread</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.19</td>
<td>1.19</td>
</tr>
<tr>
<td><code>DefaultPodTopologySpread</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.20</td>
<td></td>
</tr>
<tr>
<td><code>DelegateFSGroupToCSIDriver</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.22</td>
<td></td>
</tr>
<tr>
<td><code>DevicePlugins</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.8</td>
<td>1.9</td>
</tr>
<tr>
<td><code>DevicePlugins</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.10</td>
<td></td>
</tr>
<tr>
<td><code>DisableAcceleratorUsageMetrics</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.19</td>
<td>1.19</td>
</tr>
<tr>
<td><code>DisableAcceleratorUsageMetrics</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.20</td>
<td></td>
</tr>
<tr>
<td><code>DisableCloudProviders</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.22</td>
<td></td>
</tr>
<tr>
<td><code>DownwardAPIHugePages</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.20</td>
<td>1.20</td>
</tr>
<tr>
<td><code>DownwardAPIHugePages</code></td>
<td><code>false</code></td>
<td>Beta</td>
<td>1.21</td>
<td></td>
</tr>
<tr>
<td><code>EfficientWatchResumption</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.20</td>
<td>1.20</td>
</tr>
<tr>
<td><code>EfficientWatchResumption</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.21</td>
<td></td>
</tr>
<tr>
<td><code>EndpointSliceTerminatingCondition</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.20</td>
<td>1.21</td>
</tr>
<tr>
<td><code>EndpointSliceTerminatingCondition</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.22</td>
<td></td>
</tr>
<tr>
<td><code>EphemeralContainers</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.16</td>
<td></td>
</tr>
<tr>
<td><code>ExpandCSIVolumes</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.14</td>
<td>1.15</td>
</tr>
<tr>
<td><code>ExpandCSIVolumes</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.16</td>
<td></td>
</tr>
<tr>
<td><code>ExpandedDNSConfig</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.22</td>
<td></td>
</tr>
<tr>
<td><code>ExpandInUsePersistentVolumes</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.11</td>
<td>1.14</td>
</tr>
<tr>
<td><code>ExpandInUsePersistentVolumes</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.15</td>
<td></td>
</tr>
<tr>
<td><code>ExpandPersistentVolumes</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.8</td>
<td>1.10</td>
</tr>
<tr>
<td><code>ExpandPersistentVolumes</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.11</td>
<td></td>
</tr>
<tr>
<td><code>ExperimentalHostUserNamespaceDefaulting</code></td>
<td><code>false</code></td>
<td>Beta</td>
<td>1.5</td>
<td></td>
</tr>
<tr>
<td><code>GenericEphemeralVolume</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.19</td>
<td>1.20</td>
</tr>
<tr>
<td><code>GenericEphemeralVolume</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.21</td>
<td></td>
</tr>
<tr>
<td><code>GracefulNodeShutdown</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.20</td>
<td>1.20</td>
</tr>
<tr>
<td><code>GracefulNodeShutdown</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.21</td>
<td></td>
</tr>
<tr>
<td><code>HPAContainerMetrics</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.20</td>
<td></td>
</tr>
<tr>
<td><code>HPAScaleToZero</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.16</td>
<td></td>
</tr>
<tr>
<td><code>IndexedJob</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.21</td>
<td>1.21</td>
</tr>
<tr>
<td><code>IndexedJob</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.22</td>
<td></td>
</tr>
<tr>
<td><code>JobTrackingWithFinalizers</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.22</td>
<td></td>
</tr>
<tr>
<td><code>IngressClassNamespacedParams</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.21</td>
<td>1.21</td>
</tr>
<tr>
<td><code>IngressClassNamespacedParams</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.22</td>
<td></td>
</tr>
<tr>
<td><code>InTreePluginAWSUnregister</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.21</td>
<td></td>
</tr>
<tr>
<td><code>InTreePluginAzureDiskUnregister</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.21</td>
<td></td>
</tr>
<tr>
<td><code>InTreePluginAzureFileUnregister</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.21</td>
<td></td>
</tr>
<tr>
<td><code>InTreePluginGCEUnregister</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.21</td>
<td></td>
</tr>
<tr>
<td><code>InTreePluginOpenStackUnregister</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.21</td>
<td></td>
</tr>
<tr>
<td><code>InTreePluginvSphereUnregister</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.21</td>
<td></td>
</tr>
<tr>
<td><code>IPv6DualStack</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.15</td>
<td>1.20</td>
</tr>
<tr>
<td><code>IPv6DualStack</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.21</td>
<td></td>
</tr>
<tr>
<td><code>JobTrackingWithFinalizers</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.22</td>
<td></td>
</tr>
<tr>
<td><code>KubeletCredentialProviders</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.20</td>
<td></td>
</tr>
<tr>
<td><code>LocalStorageCapacityIsolation</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.7</td>
<td>1.9</td>
</tr>
<tr>
<td><code>LocalStorageCapacityIsolation</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.10</td>
<td></td>
</tr>
<tr>
<td><code>LocalStorageCapacityIsolationFSQuotaMonitoring</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.15</td>
<td></td>
</tr>
<tr>
<td><code>LogarithmicScaleDown</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.21</td>
<td>1.21</td>
</tr>
<tr>
<td><code>LogarithmicScaleDown</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.22</td>
<td></td>
</tr>
<tr>
<td><code>KubeletInUserNamespace</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.22</td>
<td></td>
</tr>
<tr>
<td><code>KubeletPodResourcesGetAllocatable</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.21</td>
<td></td>
</tr>
<tr>
<td><code>MemoryManager</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.21</td>
<td>1.21</td>
</tr>
<tr>
<td><code>MemoryManager</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.22</td>
<td></td>
</tr>
<tr>
<td><code>MemoryQoS</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.22</td>
<td></td>
</tr>
<tr>
<td><code>MixedProtocolLBService</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.20</td>
<td></td>
</tr>
<tr>
<td><code>NetworkPolicyEndPort</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.21</td>
<td>1.21</td>
</tr>
<tr>
<td><code>NetworkPolicyEndPort</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.22</td>
<td></td>
</tr>
<tr>
<td><code>NodeSwap</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.22</td>
<td></td>
</tr>
<tr>
<td><code>NonPreemptingPriority</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.15</td>
<td>1.18</td>
</tr>
<tr>
<td><code>NonPreemptingPriority</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.19</td>
<td></td>
</tr>
<tr>
<td><code>PodDeletionCost</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.21</td>
<td>1.21</td>
</tr>
<tr>
<td><code>PodDeletionCost</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.22</td>
<td></td>
</tr>
<tr>
<td><code>PodAffinityNamespaceSelector</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.21</td>
<td>1.21</td>
</tr>
<tr>
<td><code>PodAffinityNamespaceSelector</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.22</td>
<td></td>
</tr>
<tr>
<td><code>PodOverhead</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.16</td>
<td>1.17</td>
</tr>
<tr>
<td><code>PodOverhead</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.18</td>
<td></td>
</tr>
<tr>
<td><code>PodSecurity</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.22</td>
<td></td>
</tr>
<tr>
<td><code>PreferNominatedNode</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.21</td>
<td>1.21</td>
</tr>
<tr>
<td><code>PreferNominatedNode</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.22</td>
<td></td>
</tr>
<tr>
<td><code>ProbeTerminationGracePeriod</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.21</td>
<td>1.21</td>
</tr>
<tr>
<td><code>ProbeTerminationGracePeriod</code></td>
<td><code>false</code></td>
<td>Beta</td>
<td>1.22</td>
<td></td>
</tr>
<tr>
<td><code>ProcMountType</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.12</td>
<td></td>
</tr>
<tr>
<td><code>ProxyTerminatingEndpoints</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.22</td>
<td></td>
</tr>
<tr>
<td><code>QOSReserved</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.11</td>
<td></td>
</tr>
<tr>
<td><code>ReadWriteOncePod</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.22</td>
<td></td>
</tr>
<tr>
<td><code>RemainingItemCount</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.15</td>
<td>1.15</td>
</tr>
<tr>
<td><code>RemainingItemCount</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.16</td>
<td></td>
</tr>
<tr>
<td><code>RemoveSelfLink</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.16</td>
<td>1.19</td>
</tr>
<tr>
<td><code>RemoveSelfLink</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.20</td>
<td></td>
</tr>
<tr>
<td><code>RotateKubeletServerCertificate</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.7</td>
<td>1.11</td>
</tr>
<tr>
<td><code>RotateKubeletServerCertificate</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.12</td>
<td></td>
</tr>
<tr>
<td><code>SeccompDefault</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.22</td>
<td></td>
</tr>
<tr>
<td><code>ServiceInternalTrafficPolicy</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.21</td>
<td>1.21</td>
</tr>
<tr>
<td><code>ServiceInternalTrafficPolicy</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.22</td>
<td></td>
</tr>
<tr>
<td><code>ServiceLBNodePortControl</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.20</td>
<td>1.21</td>
</tr>
<tr>
<td><code>ServiceLBNodePortControl</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.22</td>
<td></td>
</tr>
<tr>
<td><code>ServiceLoadBalancerClass</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.21</td>
<td>1.21</td>
</tr>
<tr>
<td><code>ServiceLoadBalancerClass</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.22</td>
<td></td>
</tr>
<tr>
<td><code>SizeMemoryBackedVolumes</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.20</td>
<td>1.21</td>
</tr>
<tr>
<td><code>SizeMemoryBackedVolumes</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.22</td>
<td></td>
</tr>
<tr>
<td><code>StatefulSetMinReadySeconds</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.22</td>
<td></td>
</tr>
<tr>
<td><code>StorageVersionAPI</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.20</td>
<td></td>
</tr>
<tr>
<td><code>StorageVersionHash</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.14</td>
<td>1.14</td>
</tr>
<tr>
<td><code>StorageVersionHash</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.15</td>
<td></td>
</tr>
<tr>
<td><code>SuspendJob</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.21</td>
<td>1.21</td>
</tr>
<tr>
<td><code>SuspendJob</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.22</td>
<td></td>
</tr>
<tr>
<td><code>TTLAfterFinished</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.12</td>
<td>1.20</td>
</tr>
<tr>
<td><code>TTLAfterFinished</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.21</td>
<td></td>
</tr>
<tr>
<td><code>TopologyAwareHints</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.21</td>
<td></td>
</tr>
<tr>
<td><code>TopologyManager</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.16</td>
<td>1.17</td>
</tr>
<tr>
<td><code>TopologyManager</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.18</td>
<td></td>
</tr>
<tr>
<td><code>VolumeCapacityPriority</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.21</td>
<td>-</td>
</tr>
<tr>
<td><code>WinDSR</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.14</td>
<td></td>
</tr>
<tr>
<td><code>WinOverlay</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.14</td>
<td>1.19</td>
</tr>
<tr>
<td><code>WinOverlay</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.20</td>
<td></td>
</tr>
<tr>
<td><code>WindowsHostProcessContainers</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.22</td>
<td></td>
</tr>
</tbody>
</table>

<!--
### Feature gates for graduated or deprecated features






| Feature | Default | Stage | Since | Until |
-->
<h3 id="feature-gates-for-graduated-or-deprecated-features">已毕业和已废弃的特性门控 </h3>





<table><caption style="display: none;">已毕业或不推荐使用的特性门控</caption>
<thead>
<tr>
<th>特性</th>
<th>默认值</th>
<th>状态</th>
<th>开始（Since）</th>
<th>结束（Until）</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Accelerators</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.6</td>
<td>1.10</td>
</tr>
<tr>
<td><code>Accelerators</code></td>
<td>-</td>
<td>Deprecated</td>
<td>1.11</td>
<td>-</td>
</tr>
<tr>
<td><code>AdvancedAuditing</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.7</td>
<td>1.7</td>
</tr>
<tr>
<td><code>AdvancedAuditing</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.8</td>
<td>1.11</td>
</tr>
<tr>
<td><code>AdvancedAuditing</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.12</td>
<td>-</td>
</tr>
<tr>
<td><code>AffinityInAnnotations</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.6</td>
<td>1.7</td>
</tr>
<tr>
<td><code>AffinityInAnnotations</code></td>
<td>-</td>
<td>Deprecated</td>
<td>1.8</td>
<td>-</td>
</tr>
<tr>
<td><code>AllowExtTrafficLocalEndpoints</code></td>
<td><code>false</code></td>
<td>Beta</td>
<td>1.4</td>
<td>1.6</td>
</tr>
<tr>
<td><code>AllowExtTrafficLocalEndpoints</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.7</td>
<td>-</td>
</tr>
<tr>
<td><code>AttachVolumeLimit</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.11</td>
<td>1.11</td>
</tr>
<tr>
<td><code>AttachVolumeLimit</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.12</td>
<td>1.16</td>
</tr>
<tr>
<td><code>AttachVolumeLimit</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.17</td>
<td>-</td>
</tr>
<tr>
<td><code>BalanceAttachedNodeVolumes</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.11</td>
<td>1.21</td>
</tr>
<tr>
<td><code>BalanceAttachedNodeVolumes</code></td>
<td><code>false</code></td>
<td>Deprecated</td>
<td>1.22</td>
<td></td>
</tr>
<tr>
<td><code>BlockVolume</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.9</td>
<td>1.12</td>
</tr>
<tr>
<td><code>BlockVolume</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.13</td>
<td>1.17</td>
</tr>
<tr>
<td><code>BlockVolume</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.18</td>
<td>-</td>
</tr>
<tr>
<td><code>BoundServiceAccountTokenVolume</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.13</td>
<td>1.20</td>
</tr>
<tr>
<td><code>BoundServiceAccountTokenVolume</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.21</td>
<td>1.21</td>
</tr>
<tr>
<td><code>BoundServiceAccountTokenVolume</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.22</td>
<td>-</td>
</tr>
<tr>
<td><code>CRIContainerLogRotation</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.10</td>
<td>1.10</td>
</tr>
<tr>
<td><code>CRIContainerLogRotation</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.11</td>
<td>1.20</td>
</tr>
<tr>
<td><code>CRIContainerLogRotation</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.21</td>
<td>-</td>
</tr>
<tr>
<td><code>CSIBlockVolume</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.11</td>
<td>1.13</td>
</tr>
<tr>
<td><code>CSIBlockVolume</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.14</td>
<td>1.17</td>
</tr>
<tr>
<td><code>CSIBlockVolume</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.18</td>
<td>-</td>
</tr>
<tr>
<td><code>CSIDriverRegistry</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.12</td>
<td>1.13</td>
</tr>
<tr>
<td><code>CSIDriverRegistry</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.14</td>
<td>1.17</td>
</tr>
<tr>
<td><code>CSIDriverRegistry</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.18</td>
<td></td>
</tr>
<tr>
<td><code>CSIMigrationAWSComplete</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.17</td>
<td>1.20</td>
</tr>
<tr>
<td><code>CSIMigrationAWSComplete</code></td>
<td>-</td>
<td>Deprecated</td>
<td>1.21</td>
<td>-</td>
</tr>
<tr>
<td><code>CSIMigrationAzureDiskComplete</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.17</td>
<td>1.20</td>
</tr>
<tr>
<td><code>CSIMigrationAzureDiskComplete</code></td>
<td>-</td>
<td>Deprecated</td>
<td>1.21</td>
<td>-</td>
</tr>
<tr>
<td><code>CSIMigrationAzureFileComplete</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.17</td>
<td>1.20</td>
</tr>
<tr>
<td><code>CSIMigrationAzureFileComplete</code></td>
<td>-</td>
<td>Deprecated</td>
<td>1.21</td>
<td>-</td>
</tr>
<tr>
<td><code>CSIMigrationGCEComplete</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.17</td>
<td>1.20</td>
</tr>
<tr>
<td><code>CSIMigrationGCEComplete</code></td>
<td>-</td>
<td>Deprecated</td>
<td>1.21</td>
<td>-</td>
</tr>
<tr>
<td><code>CSIMigrationOpenStackComplete</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.17</td>
<td>1.20</td>
</tr>
<tr>
<td><code>CSIMigrationOpenStackComplete</code></td>
<td>-</td>
<td>Deprecated</td>
<td>1.21</td>
<td>-</td>
</tr>
<tr>
<td><code>CSIMigrationvSphereComplete</code></td>
<td><code>false</code></td>
<td>Beta</td>
<td>1.19</td>
<td>1.21</td>
</tr>
<tr>
<td><code>CSIMigrationvSphereComplete</code></td>
<td>-</td>
<td>Deprecated</td>
<td>1.22</td>
<td>-</td>
</tr>
<tr>
<td><code>CSINodeInfo</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.12</td>
<td>1.13</td>
</tr>
<tr>
<td><code>CSINodeInfo</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.14</td>
<td>1.16</td>
</tr>
<tr>
<td><code>CSINodeInfo</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.17</td>
<td></td>
</tr>
<tr>
<td><code>CSIPersistentVolume</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.9</td>
<td>1.9</td>
</tr>
<tr>
<td><code>CSIPersistentVolume</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.10</td>
<td>1.12</td>
</tr>
<tr>
<td><code>CSIPersistentVolume</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.13</td>
<td>-</td>
</tr>
<tr>
<td><code>CSIServiceAccountToken</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.20</td>
<td>1.20</td>
</tr>
<tr>
<td><code>CSIServiceAccountToken</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.21</td>
<td>1.21</td>
</tr>
<tr>
<td><code>CSIServiceAccountToken</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.22</td>
<td></td>
</tr>
<tr>
<td><code>CronJobControllerV2</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.20</td>
<td>1.20</td>
</tr>
<tr>
<td><code>CronJobControllerV2</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.21</td>
<td>1.21</td>
</tr>
<tr>
<td><code>CronJobControllerV2</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.22</td>
<td>-</td>
</tr>
<tr>
<td><code>CustomPodDNS</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.9</td>
<td>1.9</td>
</tr>
<tr>
<td><code>CustomPodDNS</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.10</td>
<td>1.13</td>
</tr>
<tr>
<td><code>CustomPodDNS</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.14</td>
<td>-</td>
</tr>
<tr>
<td><code>CustomResourceDefaulting</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.15</td>
<td>1.15</td>
</tr>
<tr>
<td><code>CustomResourceDefaulting</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.16</td>
<td>1.16</td>
</tr>
<tr>
<td><code>CustomResourceDefaulting</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.17</td>
<td>-</td>
</tr>
<tr>
<td><code>CustomResourcePublishOpenAPI</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.14</td>
<td>1.14</td>
</tr>
<tr>
<td><code>CustomResourcePublishOpenAPI</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.15</td>
<td>1.15</td>
</tr>
<tr>
<td><code>CustomResourcePublishOpenAPI</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.16</td>
<td>-</td>
</tr>
<tr>
<td><code>CustomResourceSubresources</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.10</td>
<td>1.10</td>
</tr>
<tr>
<td><code>CustomResourceSubresources</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.11</td>
<td>1.15</td>
</tr>
<tr>
<td><code>CustomResourceSubresources</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.16</td>
<td>-</td>
</tr>
<tr>
<td><code>CustomResourceValidation</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.8</td>
<td>1.8</td>
</tr>
<tr>
<td><code>CustomResourceValidation</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.9</td>
<td>1.15</td>
</tr>
<tr>
<td><code>CustomResourceValidation</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.16</td>
<td>-</td>
</tr>
<tr>
<td><code>CustomResourceWebhookConversion</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.13</td>
<td>1.14</td>
</tr>
<tr>
<td><code>CustomResourceWebhookConversion</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.15</td>
<td>1.15</td>
</tr>
<tr>
<td><code>CustomResourceWebhookConversion</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.16</td>
<td>-</td>
</tr>
<tr>
<td><code>DryRun</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.12</td>
<td>1.12</td>
</tr>
<tr>
<td><code>DryRun</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.13</td>
<td>1.18</td>
</tr>
<tr>
<td><code>DryRun</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.19</td>
<td>-</td>
</tr>
<tr>
<td><code>DynamicAuditing</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.13</td>
<td>1.18</td>
</tr>
<tr>
<td><code>DynamicAuditing</code></td>
<td>-</td>
<td>Deprecated</td>
<td>1.19</td>
<td>-</td>
</tr>
<tr>
<td><code>DynamicKubeletConfig</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.4</td>
<td>1.10</td>
</tr>
<tr>
<td><code>DynamicKubeletConfig</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.11</td>
<td>1.21</td>
</tr>
<tr>
<td><code>DynamicKubeletConfig</code></td>
<td><code>false</code></td>
<td>Deprecated</td>
<td>1.22</td>
<td>-</td>
</tr>
<tr>
<td><code>DynamicProvisioningScheduling</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.11</td>
<td>1.11</td>
</tr>
<tr>
<td><code>DynamicProvisioningScheduling</code></td>
<td>-</td>
<td>Deprecated</td>
<td>1.12</td>
<td>-</td>
</tr>
<tr>
<td><code>DynamicKubeletConfig</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.4</td>
<td>1.10</td>
</tr>
<tr>
<td><code>DynamicKubeletConfig</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.11</td>
<td>1.21</td>
</tr>
<tr>
<td><code>DynamicKubeletConfig</code></td>
<td><code>false</code></td>
<td>Deprecated</td>
<td>1.22</td>
<td>-</td>
</tr>
<tr>
<td><code>DynamicVolumeProvisioning</code></td>
<td><code>true</code></td>
<td>Alpha</td>
<td>1.3</td>
<td>1.7</td>
</tr>
<tr>
<td><code>DynamicVolumeProvisioning</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.8</td>
<td>-</td>
</tr>
<tr>
<td><code>EnableAggregatedDiscoveryTimeout</code></td>
<td><code>true</code></td>
<td>Deprecated</td>
<td>1.16</td>
<td>-</td>
</tr>
<tr>
<td><code>EnableEquivalenceClassCache</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.8</td>
<td>1.14</td>
</tr>
<tr>
<td><code>EnableEquivalenceClassCache</code></td>
<td>-</td>
<td>Deprecated</td>
<td>1.15</td>
<td>-</td>
</tr>
<tr>
<td><code>EndpointSlice</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.16</td>
<td>1.16</td>
</tr>
<tr>
<td><code>EndpointSlice</code></td>
<td><code>false</code></td>
<td>Beta</td>
<td>1.17</td>
<td>1.17</td>
</tr>
<tr>
<td><code>EndpointSlice</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.18</td>
<td>1.20</td>
</tr>
<tr>
<td><code>EndpointSlice</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.21</td>
<td>-</td>
</tr>
<tr>
<td><code>EndpointSliceNodeName</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.20</td>
<td>1.20</td>
</tr>
<tr>
<td><code>EndpointSliceNodeName</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.21</td>
<td>-</td>
</tr>
<tr>
<td><code>EndpointSliceProxying</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.18</td>
<td>1.18</td>
</tr>
<tr>
<td><code>EndpointSliceProxying</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.19</td>
<td>1.21</td>
</tr>
<tr>
<td><code>EndpointSliceProxying</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.22</td>
<td>-</td>
</tr>
<tr>
<td><code>ExperimentalCriticalPodAnnotation</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.5</td>
<td>1.12</td>
</tr>
<tr>
<td><code>ExperimentalCriticalPodAnnotation</code></td>
<td><code>false</code></td>
<td>Deprecated</td>
<td>1.13</td>
<td>-</td>
</tr>
<tr>
<td><code>EvenPodsSpread</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.16</td>
<td>1.17</td>
</tr>
<tr>
<td><code>EvenPodsSpread</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.18</td>
<td>1.18</td>
</tr>
<tr>
<td><code>EvenPodsSpread</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.19</td>
<td>-</td>
</tr>
<tr>
<td><code>ExecProbeTimeout</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.20</td>
<td>-</td>
</tr>
<tr>
<td><code>ExternalPolicyForExternalIP</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.18</td>
<td>-</td>
</tr>
<tr>
<td><code>GCERegionalPersistentDisk</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.10</td>
<td>1.12</td>
</tr>
<tr>
<td><code>GCERegionalPersistentDisk</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.13</td>
<td>-</td>
</tr>
<tr>
<td><code>HugePageStorageMediumSize</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.18</td>
<td>1.18</td>
</tr>
<tr>
<td><code>HugePageStorageMediumSize</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.19</td>
<td>1.21</td>
</tr>
<tr>
<td><code>HugePageStorageMediumSize</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.22</td>
<td>-</td>
</tr>
<tr>
<td><code>HugePages</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.8</td>
<td>1.9</td>
</tr>
<tr>
<td><code>HugePages</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.10</td>
<td>1.13</td>
</tr>
<tr>
<td><code>HugePages</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.14</td>
<td>-</td>
</tr>
<tr>
<td><code>HugePageStorageMediumSize</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.18</td>
<td>1.18</td>
</tr>
<tr>
<td><code>HugePageStorageMediumSize</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.19</td>
<td>1.21</td>
</tr>
<tr>
<td><code>HugePageStorageMediumSize</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.22</td>
<td>-</td>
</tr>
<tr>
<td><code>HyperVContainer</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.10</td>
<td>1.19</td>
</tr>
<tr>
<td><code>HyperVContainer</code></td>
<td><code>false</code></td>
<td>Deprecated</td>
<td>1.20</td>
<td>-</td>
</tr>
<tr>
<td><code>ImmutableEphemeralVolumes</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.18</td>
<td>1.18</td>
</tr>
<tr>
<td><code>ImmutableEphemeralVolumes</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.19</td>
<td>1.20</td>
</tr>
<tr>
<td><code>ImmutableEphemeralVolumes</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.21</td>
<td></td>
</tr>
<tr>
<td><code>Initializers</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.7</td>
<td>1.13</td>
</tr>
<tr>
<td><code>Initializers</code></td>
<td>-</td>
<td>Deprecated</td>
<td>1.14</td>
<td>-</td>
</tr>
<tr>
<td><code>KubeletConfigFile</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.8</td>
<td>1.9</td>
</tr>
<tr>
<td><code>KubeletConfigFile</code></td>
<td>-</td>
<td>Deprecated</td>
<td>1.10</td>
<td>-</td>
</tr>
<tr>
<td><code>KubeletPluginsWatcher</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.11</td>
<td>1.11</td>
</tr>
<tr>
<td><code>KubeletPluginsWatcher</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.12</td>
<td>1.12</td>
</tr>
<tr>
<td><code>KubeletPluginsWatcher</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.13</td>
<td>-</td>
</tr>
<tr>
<td><code>KubeletPodResources</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.13</td>
<td>1.14</td>
</tr>
<tr>
<td><code>KubeletPodResources</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.15</td>
<td></td>
</tr>
<tr>
<td><code>KubeletPodResources</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.20</td>
<td></td>
</tr>
<tr>
<td><code>LegacyNodeRoleBehavior</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.16</td>
<td>1.18</td>
</tr>
<tr>
<td><code>LegacyNodeRoleBehavior</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.19</td>
<td>1.20</td>
</tr>
<tr>
<td><code>LegacyNodeRoleBehavior</code></td>
<td><code>false</code></td>
<td>GA</td>
<td>1.21</td>
<td>-</td>
</tr>
<tr>
<td><code>MountContainers</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.9</td>
<td>1.16</td>
</tr>
<tr>
<td><code>MountContainers</code></td>
<td><code>false</code></td>
<td>Deprecated</td>
<td>1.17</td>
<td>-</td>
</tr>
<tr>
<td><code>MountPropagation</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.8</td>
<td>1.9</td>
</tr>
<tr>
<td><code>MountPropagation</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.10</td>
<td>1.11</td>
</tr>
<tr>
<td><code>MountPropagation</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.12</td>
<td>-</td>
</tr>
<tr>
<td><code>NodeDisruptionExclusion</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.16</td>
<td>1.18</td>
</tr>
<tr>
<td><code>NodeDisruptionExclusion</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.19</td>
<td>1.20</td>
</tr>
<tr>
<td><code>NodeDisruptionExclusion</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.21</td>
<td>-</td>
</tr>
<tr>
<td><code>NodeLease</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.12</td>
<td>1.13</td>
</tr>
<tr>
<td><code>NodeLease</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.14</td>
<td>1.16</td>
</tr>
<tr>
<td><code>NodeLease</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.17</td>
<td>-</td>
</tr>
<tr>
<td><code>NamespaceDefaultLabelName</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.21</td>
<td>1.21</td>
</tr>
<tr>
<td><code>NamespaceDefaultLabelName</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.22</td>
<td>-</td>
</tr>
<tr>
<td><code>PVCProtection</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.9</td>
<td>1.9</td>
</tr>
<tr>
<td><code>PVCProtection</code></td>
<td>-</td>
<td>Deprecated</td>
<td>1.10</td>
<td>-</td>
</tr>
<tr>
<td><code>PersistentLocalVolumes</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.7</td>
<td>1.9</td>
</tr>
<tr>
<td><code>PersistentLocalVolumes</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.10</td>
<td>1.13</td>
</tr>
<tr>
<td><code>PersistentLocalVolumes</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.14</td>
<td>-</td>
</tr>
<tr>
<td><code>PodDisruptionBudget</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.3</td>
<td>1.4</td>
</tr>
<tr>
<td><code>PodDisruptionBudget</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.5</td>
<td>1.20</td>
</tr>
<tr>
<td><code>PodDisruptionBudget</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.21</td>
<td>-</td>
</tr>
<tr>
<td><code>PodPriority</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.8</td>
<td>1.10</td>
</tr>
<tr>
<td><code>PodPriority</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.11</td>
<td>1.13</td>
</tr>
<tr>
<td><code>PodPriority</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.14</td>
<td>-</td>
</tr>
<tr>
<td><code>PodReadinessGates</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.11</td>
<td>1.11</td>
</tr>
<tr>
<td><code>PodReadinessGates</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.12</td>
<td>1.13</td>
</tr>
<tr>
<td><code>PodReadinessGates</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.14</td>
<td>-</td>
</tr>
<tr>
<td><code>PodShareProcessNamespace</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.10</td>
<td>1.11</td>
</tr>
<tr>
<td><code>PodShareProcessNamespace</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.12</td>
<td>1.16</td>
</tr>
<tr>
<td><code>PodShareProcessNamespace</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.17</td>
<td>-</td>
</tr>
<tr>
<td><code>RequestManagement</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.15</td>
<td>1.16</td>
</tr>
<tr>
<td><code>RequestManagement</code></td>
<td>-</td>
<td>Derecated</td>
<td>1.17</td>
<td>-</td>
</tr>
<tr>
<td><code>ResourceLimitsPriorityFunction</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.9</td>
<td>1.18</td>
</tr>
<tr>
<td><code>ResourceLimitsPriorityFunction</code></td>
<td>-</td>
<td>Deprecated</td>
<td>1.19</td>
<td>-</td>
</tr>
<tr>
<td><code>ResourceQuotaScopeSelectors</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.11</td>
<td>1.11</td>
</tr>
<tr>
<td><code>ResourceQuotaScopeSelectors</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.12</td>
<td>1.16</td>
</tr>
<tr>
<td><code>ResourceQuotaScopeSelectors</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.17</td>
<td>-</td>
</tr>
<tr>
<td><code>RootCAConfigMap</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.13</td>
<td>1.19</td>
</tr>
<tr>
<td><code>RootCAConfigMap</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.20</td>
<td>1.20</td>
</tr>
<tr>
<td><code>RootCAConfigMap</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.21</td>
<td>-</td>
</tr>
<tr>
<td><code>RotateKubeletClientCertificate</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.8</td>
<td>1.18</td>
</tr>
<tr>
<td><code>RotateKubeletClientCertificate</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.19</td>
<td>-</td>
</tr>
<tr>
<td><code>RunAsGroup</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.14</td>
<td>1.20</td>
</tr>
<tr>
<td><code>RunAsGroup</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.21</td>
<td>-</td>
</tr>
<tr>
<td><code>RuntimeClass</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.12</td>
<td>1.13</td>
</tr>
<tr>
<td><code>RuntimeClass</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.14</td>
<td>1.19</td>
</tr>
<tr>
<td><code>RuntimeClass</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.20</td>
<td>-</td>
</tr>
<tr>
<td><code>SCTPSupport</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.12</td>
<td>1.18</td>
</tr>
<tr>
<td><code>SCTPSupport</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.19</td>
<td>1.19</td>
</tr>
<tr>
<td><code>SCTPSupport</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.20</td>
<td>-</td>
</tr>
<tr>
<td><code>ScheduleDaemonSetPods</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.11</td>
<td>1.11</td>
</tr>
<tr>
<td><code>ScheduleDaemonSetPods</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.12</td>
<td>1.16</td>
</tr>
<tr>
<td><code>ScheduleDaemonSetPods</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.17</td>
<td>-</td>
</tr>
<tr>
<td><code>SelectorIndex</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.18</td>
<td>1.18</td>
</tr>
<tr>
<td><code>SelectorIndex</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.19</td>
<td>1.19</td>
</tr>
<tr>
<td><code>SelectorIndex</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.20</td>
<td>-</td>
</tr>
<tr>
<td><code>ServerSideApply</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.14</td>
<td>1.15</td>
</tr>
<tr>
<td><code>ServerSideApply</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.16</td>
<td>1.21</td>
</tr>
<tr>
<td><code>ServerSideApply</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.22</td>
<td>-</td>
</tr>
<tr>
<td><code>ServiceAccountIssuerDiscovery</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.18</td>
<td>1.19</td>
</tr>
<tr>
<td><code>ServiceAccountIssuerDiscovery</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.20</td>
<td>1.20</td>
</tr>
<tr>
<td><code>ServiceAccountIssuerDiscovery</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.21</td>
<td>-</td>
</tr>
<tr>
<td><code>ServiceAppProtocol</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.18</td>
<td>1.18</td>
</tr>
<tr>
<td><code>ServiceAppProtocol</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.19</td>
<td>1.19</td>
</tr>
<tr>
<td><code>ServiceAppProtocol</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.20</td>
<td>-</td>
</tr>
<tr>
<td><code>ServiceLoadBalancerFinalizer</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.15</td>
<td>1.15</td>
</tr>
<tr>
<td><code>ServiceLoadBalancerFinalizer</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.16</td>
<td>1.16</td>
</tr>
<tr>
<td><code>ServiceLoadBalancerFinalizer</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.17</td>
<td>-</td>
</tr>
<tr>
<td><code>ServiceNodeExclusion</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.8</td>
<td>1.18</td>
</tr>
<tr>
<td><code>ServiceNodeExclusion</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.19</td>
<td>1.20</td>
</tr>
<tr>
<td><code>ServiceNodeExclusion</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.21</td>
<td>-</td>
</tr>
<tr>
<td><code>ServiceTopology</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.17</td>
<td>1.19</td>
</tr>
<tr>
<td><code>ServiceTopology</code></td>
<td><code>false</code></td>
<td>Deprecated</td>
<td>1.20</td>
<td>-</td>
</tr>
<tr>
<td><code>SetHostnameAsFQDN</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.19</td>
<td>1.19</td>
</tr>
<tr>
<td><code>SetHostnameAsFQDN</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.20</td>
<td>1.21</td>
</tr>
<tr>
<td><code>SetHostnameAsFQDN</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.22</td>
<td>-</td>
</tr>
<tr>
<td><code>StartupProbe</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.16</td>
<td>1.17</td>
</tr>
<tr>
<td><code>StartupProbe</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.18</td>
<td>1.19</td>
</tr>
<tr>
<td><code>StartupProbe</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.20</td>
<td>-</td>
</tr>
<tr>
<td><code>StorageObjectInUseProtection</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.10</td>
<td>1.10</td>
</tr>
<tr>
<td><code>StorageObjectInUseProtection</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.11</td>
<td>-</td>
</tr>
<tr>
<td><code>StreamingProxyRedirects</code></td>
<td><code>false</code></td>
<td>Beta</td>
<td>1.5</td>
<td>1.5</td>
</tr>
<tr>
<td><code>StreamingProxyRedirects</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.6</td>
<td>1.17</td>
</tr>
<tr>
<td><code>StreamingProxyRedirects</code></td>
<td><code>true</code></td>
<td>Deprecated</td>
<td>1.18</td>
<td>1.21</td>
</tr>
<tr>
<td><code>StreamingProxyRedirects</code></td>
<td><code>false</code></td>
<td>Deprecated</td>
<td>1.22</td>
<td>-</td>
</tr>
<tr>
<td><code>SupportIPVSProxyMode</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.8</td>
<td>1.8</td>
</tr>
<tr>
<td><code>SupportIPVSProxyMode</code></td>
<td><code>false</code></td>
<td>Beta</td>
<td>1.9</td>
<td>1.9</td>
</tr>
<tr>
<td><code>SupportIPVSProxyMode</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.10</td>
<td>1.10</td>
</tr>
<tr>
<td><code>SupportIPVSProxyMode</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.11</td>
<td>-</td>
</tr>
<tr>
<td><code>SupportNodePidsLimit</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.14</td>
<td>1.14</td>
</tr>
<tr>
<td><code>SupportNodePidsLimit</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.15</td>
<td>1.19</td>
</tr>
<tr>
<td><code>SupportNodePidsLimit</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.20</td>
<td>-</td>
</tr>
<tr>
<td><code>SupportPodPidsLimit</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.10</td>
<td>1.13</td>
</tr>
<tr>
<td><code>SupportPodPidsLimit</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.14</td>
<td>1.19</td>
</tr>
<tr>
<td><code>SupportPodPidsLimit</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.20</td>
<td>-</td>
</tr>
<tr>
<td><code>Sysctls</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.11</td>
<td>1.20</td>
</tr>
<tr>
<td><code>Sysctls</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.21</td>
<td></td>
</tr>
<tr>
<td><code>TaintBasedEvictions</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.6</td>
<td>1.12</td>
</tr>
<tr>
<td><code>TaintBasedEvictions</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.13</td>
<td>1.17</td>
</tr>
<tr>
<td><code>TaintBasedEvictions</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.18</td>
<td>-</td>
</tr>
<tr>
<td><code>TaintNodesByCondition</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.8</td>
<td>1.11</td>
</tr>
<tr>
<td><code>TaintNodesByCondition</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.12</td>
<td>1.16</td>
</tr>
<tr>
<td><code>TaintNodesByCondition</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.17</td>
<td>-</td>
</tr>
<tr>
<td><code>TokenRequest</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.10</td>
<td>1.11</td>
</tr>
<tr>
<td><code>TokenRequest</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.12</td>
<td>1.19</td>
</tr>
<tr>
<td><code>TokenRequest</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.20</td>
<td>-</td>
</tr>
<tr>
<td><code>TokenRequestProjection</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.11</td>
<td>1.11</td>
</tr>
<tr>
<td><code>TokenRequestProjection</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.12</td>
<td>1.19</td>
</tr>
<tr>
<td><code>TokenRequestProjection</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.20</td>
<td>-</td>
</tr>
<tr>
<td><code>ValidateProxyRedirects</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.12</td>
<td>1.13</td>
</tr>
<tr>
<td><code>ValidateProxyRedirects</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.14</td>
<td>1.21</td>
</tr>
<tr>
<td><code>ValidateProxyRedirects</code></td>
<td><code>true</code></td>
<td>Deprecated</td>
<td>1.22</td>
<td>-</td>
</tr>
<tr>
<td><code>VolumePVCDataSource</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.15</td>
<td>1.15</td>
</tr>
<tr>
<td><code>VolumePVCDataSource</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.16</td>
<td>1.17</td>
</tr>
<tr>
<td><code>VolumePVCDataSource</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.18</td>
<td>-</td>
</tr>
<tr>
<td><code>VolumeScheduling</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.9</td>
<td>1.9</td>
</tr>
<tr>
<td><code>VolumeScheduling</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.10</td>
<td>1.12</td>
</tr>
<tr>
<td><code>VolumeScheduling</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.13</td>
<td>-</td>
</tr>
<tr>
<td><code>VolumeSnapshotDataSource</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.12</td>
<td>1.16</td>
</tr>
<tr>
<td><code>VolumeSnapshotDataSource</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.17</td>
<td>1.19</td>
</tr>
<tr>
<td><code>VolumeSnapshotDataSource</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.20</td>
<td>-</td>
</tr>
<tr>
<td><code>VolumeSubpath</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.10</td>
<td>-</td>
</tr>
<tr>
<td><code>VolumeSubpathEnvExpansion</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.14</td>
<td>1.14</td>
</tr>
<tr>
<td><code>VolumeSubpathEnvExpansion</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.15</td>
<td>1.16</td>
</tr>
<tr>
<td><code>VolumeSubpathEnvExpansion</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.17</td>
<td>-</td>
</tr>
<tr>
<td><code>WarningHeaders</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.19</td>
<td>1.21</td>
</tr>
<tr>
<td><code>WarningHeaders</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.22</td>
<td>-</td>
</tr>
<tr>
<td><code>WatchBookmark</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.15</td>
<td>1.15</td>
</tr>
<tr>
<td><code>WatchBookmark</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.16</td>
<td>1.16</td>
</tr>
<tr>
<td><code>WatchBookmark</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.17</td>
<td>-</td>
</tr>
<tr>
<td><code>WindowsEndpointSliceProxying</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.19</td>
<td>1.20</td>
</tr>
<tr>
<td><code>WindowsEndpointSliceProxying</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.21</td>
<td>1.21</td>
</tr>
<tr>
<td><code>WindowsEndpointSliceProxying</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.22</td>
<td>-</td>
</tr>
<tr>
<td><code>WindowsGMSA</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.14</td>
<td>1.15</td>
</tr>
<tr>
<td><code>WindowsGMSA</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.16</td>
<td>1.17</td>
</tr>
<tr>
<td><code>WindowsGMSA</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.18</td>
<td>-</td>
</tr>
<tr>
<td><code>WindowsHostProcessContainers</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.22</td>
<td></td>
</tr>
<tr>
<td><code>WindowsRunAsUserName</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.16</td>
<td>1.16</td>
</tr>
<tr>
<td><code>WindowsRunAsUserName</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.17</td>
<td>1.17</td>
</tr>
<tr>
<td><code>WindowsRunAsUserName</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.18</td>
<td>-</td>
</tr>
</tbody>
</table>

<!--
## Using a feature

### Feature stages
-->
<h2 id="using-a-feature">使用特性  </h2>
<h3 id="feature-stages">特性阶段   </h3>
<!--
A feature can be in *Alpha*, *Beta* or *GA* stage.
An *Alpha* feature means:
-->
<p>处于 <em>Alpha</em> 、<em>Beta</em> 、 <em>GA</em> 阶段的特性。</p>
<p><em>Alpha</em> 特性代表：</p>
<!--
* Disabled by default.
* Might be buggy. Enabling the feature may expose bugs.
* Support for feature may be dropped at any time without notice.
* The API may change in incompatible ways in a later software release without notice.
* Recommended for use only in short-lived testing clusters, due to increased
  risk of bugs and lack of long-term support.
-->
<ul>
<li>默认禁用。</li>
<li>可能有错误，启用此特性可能会导致错误。</li>
<li>随时可能删除对此特性的支持，恕不另行通知。</li>
<li>在以后的软件版本中，API 可能会以不兼容的方式更改，恕不另行通知。</li>
<li>建议将其仅用于短期测试中，因为开启特性会增加错误的风险，并且缺乏长期支持。</li>
</ul>
<!--
A *Beta* feature means:
-->
<p><em>Beta</em> 特性代表：</p>
<!--
* Enabled by default.
* The feature is well tested. Enabling the feature is considered safe.
* Support for the overall feature will not be dropped, though details may change.
* The schema and/or semantics of objects may change in incompatible ways in a
  subsequent beta or stable release. When this happens, we will provide instructions
  for migrating to the next version. This may require deleting, editing, and
  re-creating API objects. The editing process may require some thought.
  This may require downtime for applications that rely on the feature.
* Recommended for only non-business-critical uses because of potential for
  incompatible changes in subsequent releases. If you have multiple clusters
  that can be upgraded independently, you may be able to relax this restriction.
-->
<ul>
<li>默认启用。</li>
<li>该特性已经经过良好测试。启用该特性是安全的。</li>
<li>尽管详细信息可能会更改，但不会放弃对整体特性的支持。</li>
<li>对象的架构或语义可能会在随后的 Beta 或稳定版本中以不兼容的方式更改。当发生这种情况时，我们将提供迁移到下一版本的说明。此特性可能需要删除、编辑和重新创建 API 对象。编辑过程可能需要慎重操作，因为这可能会导致依赖该特性的应用程序停机。</li>
<li>推荐仅用于非关键业务用途，因为在后续版本中可能会发生不兼容的更改。如果你具有多个可以独立升级的，则可以放宽此限制。</li>
</ul>
<blockquote class="note callout">
  <div><strong>说明：</strong> <!--
Please do try *Beta* features and give feedback on them!
After they exit beta, it may not be practical for us to make more changes.
-->
<p>请试用 <em>Beta</em> 特性并提供相关反馈！
一旦特性结束 Beta 状态，我们就不太可能再对特性进行大幅修改。</div>
</blockquote>
<!--
A *General Availability* (GA) feature is also referred to as a *stable* feature. It means:
-->
<p><em>General Availability</em> (GA) 特性也称为 <em>稳定</em> 特性，<em>GA</em> 特性代表着：</p>
<!--
* The feature is always enabled; you cannot disable it.
* The corresponding feature gate is no longer needed.
* Stable versions of features will appear in released software for many subsequent versions.
-->
<ul>
<li>此特性会一直启用；你不能禁用它。</li>
<li>不再需要相应的特性门控。</li>
<li>对于许多后续版本，特性的稳定版本将出现在发行的软件中。</li>
</ul>
<!--
## List of feature gates {#feature-gates}

Each feature gate is designed for enabling/disabling a specific feature:
-->
<h3 id="特性门控列表">特性门控列表</h3>
<p>每个特性门控均用于启用或禁用某个特定的特性：</p>
<!--
- `APIListChunking`: Enable the API clients to retrieve (`LIST` or `GET`)
  resources from API server in chunks.
- `APIPriorityAndFairness`: Enable managing request concurrency with
  prioritization and fairness at each server. (Renamed from `RequestManagement`)
- `APIResponseCompression`: Compress the API responses for `LIST` or `GET` requests.
- `APIServerIdentity`: Assign each API server an ID in a cluster.
- `APIServerTracing`: Add support for distributed tracing in the API server.
-->
<ul>
<li><code>APIListChunking</code>：启用 API 客户端以块的形式从 API 服务器检索（“LIST” 或 “GET”）资源。</li>
<li><code>APIPriorityAndFairness</code>: 在每个服务器上启用优先级和公平性来管理请求并发。（由 <code>RequestManagement</code> 重命名而来）</li>
<li><code>APIResponseCompression</code>：压缩 “LIST” 或 “GET” 请求的 API 响应。</li>
<li><code>APIServerIdentity</code>：为集群中的每个 API 服务器赋予一个 ID。</li>
<li><code>APIServerTracing</code>: 为集群中的每个 API 服务器添加对分布式跟踪的支持。</li>
</ul>
<!--
- `Accelerators`: Enable Nvidia GPU support when using Docker
- `AdvancedAuditing`: Enable [advanced auditing](/docs/tasks/debug-application-cluster/audit/#advanced-audit)
- `AffinityInAnnotations`: Enable setting
  [Pod affinity or anti-affinity](/docs/concepts/scheduling-eviction/assign-pod-node/#affinity-and-anti-affinity).
- `AllowExtTrafficLocalEndpoints`: Enable a service to route external requests to node local endpoints.
- `AllowInsecureBackendProxy`: Enable the users to skip TLS verification of
  kubelets on Pod log requests.
- `AnyVolumeDataSource`: Enable use of any custom resource as the `DataSource` of a
  <a class='glossary-tooltip' title='声明在持久卷中定义的存储资源，以便可以将其挂载为容器中的卷。' data-toggle='tooltip' data-placement='top' href='/zh/docs/concepts/storage/persistent-volumes/' target='_blank' aria-label='PVC'>PVC</a>.
- `AppArmor`: Enable AppArmor based mandatory access control on Linux nodes when using Docker.
   See [AppArmor Tutorial](/docs/tutorials/clusters/apparmor/) for more details.
-->
<ul>
<li><code>Accelerators</code>：使用 Docker 时启用 Nvidia GPU 支持。</li>
<li><code>AdvancedAuditing</code>：启用<a href="/zh/docs/tasks/debug-application-cluster/audit/#advanced-audit">高级审计功能</a>。</li>
<li><code>AffinityInAnnotations</code>：启用 <a href="/zh/docs/concepts/scheduling-eviction/assign-pod-node/#affinity-and-anti-affinity">Pod 亲和或反亲和</a>。</li>
<li><code>AllowExtTrafficLocalEndpoints</code>：启用服务用于将外部请求路由到节点本地终端。</li>
<li><code>AllowInsecureBackendProxy</code>：允许用户在执行 Pod 日志访问请求时跳过 TLS 验证。</li>
<li><code>AnyVolumeDataSource</code>: 允许使用任何自定义的资源来做作为
<a class='glossary-tooltip' title='声明在持久卷中定义的存储资源，以便可以将其挂载为容器中的卷。' data-toggle='tooltip' data-placement='top' href='/zh/docs/concepts/storage/persistent-volumes/' target='_blank' aria-label='PVC'>PVC</a> 中的 <code>DataSource</code>.</li>
<li><code>AppArmor</code>：使用 Docker 时，在 Linux 节点上启用基于 AppArmor 机制的强制访问控制。
请参见 <a href="/zh/docs/tutorials/clusters/apparmor/">AppArmor 教程</a> 获取详细信息。</li>
</ul>
<!--
- `AttachVolumeLimit`: Enable volume plugins to report limits on number of volumes
  that can be attached to a node.
  See [dynamic volume limits](/docs/concepts/storage/storage-limits/#dynamic-volume-limits) for more details.
- `BalanceAttachedNodeVolumes`: Include volume count on node to be considered for balanced resource allocation
  while scheduling. A node which has closer CPU, memory utilization, and volume count is favored by the scheduler
  while making decisions.
- `BlockVolume`: Enable the definition and consumption of raw block devices in Pods.
  See [Raw Block Volume Support](/docs/concepts/storage/persistent-volumes/#raw-block-volume-support)
   for more details.
- `BoundServiceAccountTokenVolume`: Migrate ServiceAccount volumes to use a projected volume consisting of a
  ServiceAccountTokenVolumeProjection. Cluster admins can use metric `serviceaccount_stale_tokens_total` to
  monitor workloads that are depending on the extended tokens. If there are no such workloads, turn off
  extended tokens by starting `kube-apiserver` with flag `--service-account-extend-token-expiration=false`.
  Check [Bound Service Account Tokens](https://github.com/kubernetes/enhancements/blob/master/keps/sig-auth/1205-bound-service-account-tokens/README.md)
  for more details.
- `ControllerManagerLeaderMigration`: Enables Leader Migration for 
  [kube-controller-manager](/docs/tasks/administer-cluster/controller-manager-leader-migration/#initial-leader-migration-configuration) and 
  [cloud-controller-manager](/docs/tasks/administer-cluster/controller-manager-leader-migration/#deploy-cloud-controller-manager) which allows a cluster operator to live migrate 
  controllers from the kube-controller-manager into an external controller-manager 
  (e.g. the cloud-controller-manager) in an HA cluster without downtime.
-->
<ul>
<li><code>AttachVolumeLimit</code>：启用卷插件用于报告可连接到节点的卷数限制。有关更多详细信息，请参阅
<a href="/zh/docs/concepts/storage/storage-limits/#dynamic-volume-limits">动态卷限制</a>。</li>
<li><code>BalanceAttachedNodeVolumes</code>：在进行平衡资源分配的调度时，考虑节点上的卷数。
调度器在决策时会优先考虑 CPU、内存利用率和卷数更近的节点。</li>
<li><code>BlockVolume</code>：在 Pod 中启用原始块设备的定义和使用。有关更多详细信息，请参见
<a href="/zh/docs/concepts/storage/persistent-volumes/#raw-block-volume-support">原始块卷支持</a>。</li>
<li><code>BoundServiceAccountTokenVolume</code>：迁移 ServiceAccount 卷以使用由
ServiceAccountTokenVolumeProjection 组成的投射卷。集群管理员可以使用
<code>serviceaccount_stale_tokens_total</code> 度量值来监控依赖于扩展令牌的负载。
如果没有这种类型的负载，你可以在启动 <code>kube-apiserver</code> 时添加
<code>--service-account-extend-token-expiration=false</code> 参数关闭扩展令牌。查看
<a href="https://github.com/kubernetes/enhancements/blob/master/keps/sig-auth/1205-bound-service-account-tokens/README.md">绑定服务账号令牌</a>
获取更多详细信息。</li>
<li><code>ControllerManagerLeaderMigration</code>: 为
<a href="/zh/docs/tasks/administer-cluster/controller-manager-leader-migration/#initial-leader-migration-configuration">kube-controller-manager</a> 和
<a href="/zh/docs/tasks/administer-cluster/controller-manager-leader-migration/#deploy-cloud-controller-manager">cloud-controller-manager</a>
启用 Leader 迁移，它允许集群管理者在没有停机的高可用集群环境下，实时
把 kube-controller-manager 迁移迁移到外部的 controller-manager (例如 cloud-controller-manager) 中。</li>
</ul>
<!--
- `CPUManager`: Enable container level CPU affinity support, see
  [CPU Management Policies](/docs/tasks/administer-cluster/cpu-management-policies/).
- `CPUManagerPolicyOptions`: Allow fine-tuning of CPUManager policies.
- `CRIContainerLogRotation`: Enable container log rotation for CRI container runtime. The default max size of a log file is 10MB and the
  default max number of log files allowed for a container is 5. These values can be configured in the kubelet config.
  See the [logging at node level](/docs/concepts/cluster-administration/logging/#logging-at-the-node-level) documentation for more details.
- `CSIBlockVolume`: Enable external CSI volume drivers to support block storage.
  See the [`csi` raw block volume support](/docs/concepts/storage/volumes/#csi-raw-block-volume-support)
  documentation for more details.
- `CSIDriverRegistry`: Enable all logic related to the CSIDriver API object in
  csi.storage.k8s.io.
- `CSIInlineVolume`: Enable CSI Inline volumes support for pods.
- `CSIMigration`: Enables shims and translation logic to route volume
  operations from in-tree plugins to corresponding pre-installed CSI plugins
-->
<ul>
<li><code>CPUManager</code>：启用容器级别的 CPU 亲和性支持，有关更多详细信息，请参见
<a href="/zh/docs/tasks/administer-cluster/cpu-management-policies/">CPU 管理策略</a>。</li>
<li><code>CRIContainerLogRotation</code>：为 CRI 容器运行时启用容器日志轮换。日志文件的默认最大大小为
10MB，缺省情况下，一个容器允许的最大日志文件数为5。这些值可以在kubelet配置中配置。
更多细节请参见 <a href="/zh/docs/concepts/cluster-administration/logging/#logging-at-the-node-level">日志架构</a>。</li>
<li><code>CPUManagerPolicyOptions</code>: 允许微调 CPU 管理策略。</li>
<li><code>CSIBlockVolume</code>：启用外部 CSI 卷驱动程序用于支持块存储。有关更多详细信息，请参见
<a href="/zh/docs/concepts/storage/volumes/#csi-raw-block-volume-support"><code>csi</code> 原始块卷支持</a>。</li>
<li><code>CSIDriverRegistry</code>：在 csi.storage.k8s.io 中启用与 CSIDriver API 对象有关的所有逻辑。</li>
<li><code>CSIInlineVolume</code>：为 Pod 启用 CSI 内联卷支持。</li>
<li><code>CSIMigration</code>：确保封装和转换逻辑能够将卷操作从内嵌插件路由到相应的预安装 CSI 插件。</li>
</ul>
<!--
- `CSIMigrationAWS`: Enables shims and translation logic to route volume
  operations from the AWS-EBS in-tree plugin to EBS CSI plugin. Supports
  falling back to in-tree EBS plugin if a node does not have EBS CSI plugin
  installed and configured. Requires CSIMigration feature flag enabled.
- `CSIMigrationAWSComplete`: Stops registering the EBS in-tree plugin in
  kubelet and volume controllers and enables shims and translation logic to
  route volume operations from the AWS-EBS in-tree plugin to EBS CSI plugin.
  Requires CSIMigration and CSIMigrationAWS feature flags enabled and EBS CSI
  plugin installed and configured on all nodes in the cluster. This flag has
  been deprecated in favor of the `InTreePluginAWSUnregister` feature flag
  which prevents the registration of in-tree EBS plugin.
- `CSIMigrationAzureDisk`: Enables shims and translation logic to route volume
  operations from the Azure-Disk in-tree plugin to AzureDisk CSI plugin.
  Supports falling back to in-tree AzureDisk plugin if a node does not have
  AzureDisk CSI plugin installed and configured. Requires CSIMigration feature
  flag enabled.
- `CSIMigrationAzureDiskComplete`: Stops registering the Azure-Disk in-tree
  plugin in kubelet and volume controllers and enables shims and translation
  logic to route volume operations from the Azure-Disk in-tree plugin to
  AzureDisk CSI plugin. Requires CSIMigration and CSIMigrationAzureDisk feature
  flags enabled and AzureDisk CSI plugin installed and configured on all nodes
  in the cluster. This flag has been deprecated in favor of the
  `InTreePluginAzureFileUnregister` feature flag which prevents the registration
   of in-tree AzureFile plugin.
-->
<ul>
<li><code>CSIMigrationAWS</code>：确保填充和转换逻辑能够将卷操作从 AWS-EBS 内嵌插件路由到 EBS CSI 插件。
如果节点未安装和配置 EBS CSI 插件，则支持回退到内嵌 EBS 插件。
这需要启用 CSIMigration 特性标志。</li>
<li><code>CSIMigrationAWSComplete</code>：停止在 kubelet 和卷控制器中注册 EBS 内嵌插件，
并启用 shims 和转换逻辑将卷操作从AWS-EBS 内嵌插件路由到 EBS CSI 插件。
这需要启用 CSIMigration 和 CSIMigrationAWS 特性标志，并在集群中的所有节点上安装和配置
EBS CSI 插件。该特性标志已被废弃，取而代之的是 <code>InTreePluginAWSUnregister</code> ，这会阻止注册 EBS 内嵌插件。</li>
<li><code>CSIMigrationAzureDisk</code>：确保填充和转换逻辑能够将卷操作从 Azure 磁盘内嵌插件路由到
Azure 磁盘 CSI 插件。如果节点未安装和配置 AzureDisk CSI 插件，
支持回退到内建 AzureDisk 插件。这需要启用 CSIMigration 特性标志。</li>
<li><code>CSIMigrationAzureDiskComplete</code>：停止在 kubelet 和卷控制器中注册 Azure 磁盘内嵌插件，
并启用 shims 和转换逻辑以将卷操作从 Azure 磁盘内嵌插件路由到 AzureDisk CSI 插件。
这需要启用 CSIMigration 和 CSIMigrationAzureDisk 特性标志，
并在集群中的所有节点上安装和配置 AzureDisk CSI 插件。该特性标志已被废弃，取而代之的是
能防止注册内嵌 AzureDisk 插件的 <code>InTreePluginAzureDiskUnregister</code> 特性标志。</li>
</ul>
<!--
- `CSIMigrationAzureFile`: Enables shims and translation logic to route volume
  operations from the Azure-File in-tree plugin to AzureFile CSI plugin.
  Supports falling back to in-tree AzureFile plugin if a node does not have
  AzureFile CSI plugin installed and configured. Requires CSIMigration feature
  flag enabled.
- `CSIMigrationAzureFileComplete`: Stops registering the Azure-File in-tree
  plugin in kubelet and volume controllers and enables shims and translation
  logic to route volume operations from the Azure-File in-tree plugin to
  AzureFile CSI plugin. Requires CSIMigration and CSIMigrationAzureFile feature
  flags  enabled and AzureFile CSI plugin installed and configured on all nodes
  in the cluster. This flag has been deprecated in favor of the
  `InTreePluginAzureFileUnregister` feature flag which prevents the registration of in-tree AzureFile plugin.
-->
<ul>
<li><code>CSIMigrationAzureFile</code>：确保封装和转换逻辑能够将卷操作从 Azure 文件内嵌插件路由到
Azure 文件 CSI 插件。如果节点未安装和配置 AzureFile CSI 插件，
支持回退到内嵌 AzureFile 插件。这需要启用 CSIMigration 特性标志。</li>
<li><code>CSIMigrationAzureFileComplete</code>：停止在 kubelet 和卷控制器中注册 Azure-File 内嵌插件，
并启用 shims 和转换逻辑以将卷操作从 Azure-File 内嵌插件路由到 AzureFile CSI 插件。
这需要启用 CSIMigration 和 CSIMigrationAzureFile 特性标志，
并在集群中的所有节点上安装和配置 AzureFile CSI 插件。该特性标志已被废弃，取而代之的是
能防止注册内嵌 AzureDisk 插件的 <code>InTreePluginAzureFileUnregister</code> 特性标志。</li>
</ul>
<!--
- `CSIMigrationGCE`: Enables shims and translation logic to route volume
  operations from the GCE-PD in-tree plugin to PD CSI plugin. Supports falling
  back to in-tree GCE plugin if a node does not have PD CSI plugin installed and
  configured. Requires CSIMigration feature flag enabled.
- `CSIMigrationGCEComplete`: Stops registering the GCE-PD in-tree plugin in
  kubelet and volume controllers and enables shims and translation logic to
  route volume operations from the GCE-PD in-tree plugin to PD CSI plugin.
  Requires CSIMigration and CSIMigrationGCE feature flags enabled and PD CSI
  plugin installed and configured on all nodes in the cluster. This flag has
  been deprecated in favor of the `InTreePluginGCEUnregister` feature flag which prevents the registration of in-tree GCE PD plugin.
-->
<ul>
<li><code>CSIMigrationGCE</code>：启用 shims 和转换逻辑，将卷操作从 GCE-PD 内嵌插件路由到
PD CSI 插件。如果节点未安装和配置 PD CSI 插件，支持回退到内嵌 GCE 插件。
这需要启用 CSIMigration 特性标志。</li>
<li><code>CSIMigrationGCEComplete</code>：停止在 kubelet 和卷控制器中注册 GCE-PD 内嵌插件，
并启用 shims 和转换逻辑以将卷操作从 GCE-PD 内嵌插件路由到 PD CSI 插件。
这需要启用 CSIMigration 和 CSIMigrationGCE 特性标志，并在集群中的所有节点上
安装和配置 PD CSI 插件。该特性标志已被废弃，取而代之的是
能防止注册内嵌 GCE PD 插件的 <code>InTreePluginGCEUnregister</code> 特性标志。</li>
</ul>
<!--
- `CSIMigrationOpenStack`: Enables shims and translation logic to route volume
  operations from the Cinder in-tree plugin to Cinder CSI plugin. Supports
  falling back to in-tree Cinder plugin if a node does not have Cinder CSI
  plugin installed and configured. Requires CSIMigration feature flag enabled.
- `CSIMigrationOpenStackComplete`: Stops registering the Cinder in-tree plugin in
  kubelet and volume controllers and enables shims and translation logic to route
  volume operations from the Cinder in-tree plugin to Cinder CSI plugin.
  Requires CSIMigration and CSIMigrationOpenStack feature flags enabled and Cinder
  CSI plugin installed and configured on all nodes in the cluster. This flag has
  been deprecated in favor of the `InTreePluginOpenStackUnregister` feature flag which prevents the registration of in-tree openstack cinder plugin.
-->
<ul>
<li><code>CSIMigrationOpenStack</code>：确保填充和转换逻辑能够将卷操作从 Cinder 内嵌插件路由到
Cinder CSI 插件。如果节点未安装和配置 Cinder CSI 插件，支持回退到内嵌 Cinder 插件。
这需要启用 CSIMigration 特性标志。</li>
<li><code>CSIMigrationOpenStackComplete</code>：停止在 kubelet 和卷控制器中注册 Cinder 内嵌插件，
并启用 shims 和转换逻辑将卷操作从 Cinder 内嵌插件路由到 Cinder CSI 插件。
这需要启用 CSIMigration 和 CSIMigrationOpenStack 特性标志，并在集群中的所有节点上
安装和配置 Cinder CSI 插件。该特性标志已被废弃，取而代之的是
能防止注册内嵌 openstack cinder 插件的 <code>InTreePluginOpenStackUnregister</code> 特性标志。</li>
</ul>
<!--
- `CSIMigrationvSphere`: Enables shims and translation logic to route volume operations
  from the vSphere in-tree plugin to vSphere CSI plugin.
  Supports falling back to in-tree vSphere plugin if a node does not have vSphere
  CSI plugin installed and configured. Requires CSIMigration feature flag enabled.
- `CSIMigrationvSphereComplete`: Stops registering the vSphere in-tree plugin in kubelet
  and volume controllers and enables shims and translation logic to route volume operations
  from the vSphere in-tree plugin to vSphere CSI plugin. Requires CSIMigration and
  CSIMigrationvSphere feature flags enabled and vSphere CSI plugin installed and
  configured on all nodes in the cluster. This flag has been deprecated in favor
  of the `InTreePluginvSphereUnregister` feature flag which prevents the registration of in-tree vsphere plugin.
-->
<ul>
<li><code>CSIMigrationvSphere</code>: 允许封装和转换逻辑将卷操作从 vSphere 内嵌插件路由到
vSphere CSI 插件。如果节点未安装和配置 vSphere CSI 插件，则支持回退到
vSphere 内嵌插件。这需要启用 CSIMigration 特性标志。</li>
<li><code>CSIMigrationvSphereComplete</code>: 停止在 kubelet 和卷控制器中注册 vSphere 内嵌插件，
并启用 shims 和转换逻辑以将卷操作从 vSphere 内嵌插件路由到 vSphere CSI 插件。
这需要启用 CSIMigration 和 CSIMigrationvSphere 特性标志，并在集群中的所有节点上
安装和配置 vSphere CSI 插件。该特性标志已被废弃，取而代之的是
能防止注册内嵌 vsphere 插件的 <code>InTreePluginvSphereUnregister</code> 特性标志。</li>
</ul>
<!--
- `CSINodeInfo`: Enable all logic related to the CSINodeInfo API object in csi.storage.k8s.io.
- `CSIPersistentVolume`: Enable discovering and mounting volumes provisioned through a
  [CSI (Container Storage Interface)](https://github.com/kubernetes/community/blob/master/contributors/design-proposals/storage/container-storage-interface.md)
  compatible volume plugin.
- `CSIServiceAccountToken`: Enable CSI drivers to receive the pods' service account token
  that they mount volumes for. See
  [Token Requests](https://kubernetes-csi.github.io/docs/token-requests.html).
- `CSIStorageCapacity`: Enables CSI drivers to publish storage capacity information
  and the Kubernetes scheduler to use that information when scheduling pods. See
  [Storage Capacity](/docs/concepts/storage/storage-capacity/).
  Check the [`csi` volume type](/docs/concepts/storage/volumes/#csi) documentation for more details.
-->
<ul>
<li><code>CSINodeInfo</code>：在 csi.storage.k8s.io 中启用与 CSINodeInfo API 对象有关的所有逻辑。</li>
<li><code>CSIPersistentVolume</code>：启用发现和挂载通过
<a href="https://github.com/kubernetes/community/blob/master/contributors/design-proposals/storage/container-storage-interface.md">CSI（容器存储接口）</a>
兼容卷插件配置的卷。</li>
<li><code>CSIServiceAccountToken</code>: 允许 CSI 驱动接收挂载卷目标 Pods 的服务账户令牌。
参阅<a href="https://kubernetes-csi.github.io/docs/token-requests.html">令牌请求（Token Requests）</a>。</li>
<li><code>CSIStorageCapacity</code>: 使 CSI 驱动程序可以发布存储容量信息，并使 Kubernetes
调度程序在调度 Pod 时使用该信息。参见
<a href="/zh/docs/concepts/storage/storage-capacity/">存储容量</a>。
详情请参见 <a href="/zh/docs/concepts/storage/volumes/#csi"><code>csi</code> 卷类型</a>。</li>
</ul>
<!--
- `CSIVolumeFSGroupPolicy`: Allows CSIDrivers to use the `fsGroupPolicy` field.
  This field controls whether volumes created by a CSIDriver support volume ownership
  and permission modifications when these volumes are mounted.
- `CSIVolumeHealth`: Enable support for CSI volume health monitoring on node.
- `CSRDuration`: Allows clients to request a duration for certificates issued
  via the Kubernetes CSR API.
- `ConfigurableFSGroupPolicy`: Allows user to configure volume permission change policy
  for fsGroups when mounting a volume in a Pod. See
  [Configure volume permission and ownership change policy for Pods](/docs/tasks/configure-pod-container/security-context/#configure-volume-permission-and-ownership-change-policy-for-pods)
  for more details.
- `ControllerManagerLeaderMigration`: Enables leader migration for
  `kube-controller-manager` and `cloud-controller-manager`.
- `CronJobControllerV2`: Use an alternative implementation of the
  <a class='glossary-tooltip' title='周期调度的任务（作业）。' data-toggle='tooltip' data-placement='top' href='/zh/docs/concepts/workloads/controllers/cron-jobs/' target='_blank' aria-label='CronJob'>CronJob</a> controller. Otherwise,
  version 1 of the same controller is selected.
-->
<ul>
<li><code>CSIVolumeFSGroupPolicy</code>: 允许 CSIDrivers 使用 <code>fsGroupPolicy</code> 字段.
该字段能控制由 CSIDriver 创建的卷在挂载这些卷时是否支持卷所有权和权限修改。</li>
<li><code>CSIVolumeHealth</code>: 启用对节点上的 CSI volume 运行状况监控的支持</li>
<li><code>CSRDuration</code>: 允许客户端来通过请求 Kubernetes CSR API 签署的证书的持续时间。</li>
<li><code>ConfigurableFSGroupPolicy</code>：在 Pod 中挂载卷时，允许用户为 fsGroup
配置卷访问权限和属主变更策略。请参见
<a href="/zh/docs/tasks/configure-pod-container/security-context/#configure-volume-permission-and-ownership-change-policy-for-pods">为 Pod 配置卷访问权限和属主变更策略</a>。</li>
<li><code>ControllerManagerLeaderMigration</code>: 为 <code>kube-controller-manager</code> 和 <code>cloud-controller-manager</code>
开启 leader 迁移功能。</li>
<li><code>CronJobControllerV2</code>：使用 <a class='glossary-tooltip' title='周期调度的任务（作业）。' data-toggle='tooltip' data-placement='top' href='/zh/docs/concepts/workloads/controllers/cron-jobs/' target='_blank' aria-label='CronJob'>CronJob</a>
控制器的一种替代实现。否则，系统会选择同一控制器的 v1 版本。</li>
</ul>
<!--
- `CustomCPUCFSQuotaPeriod`: Enable nodes to change `cpuCFSQuotaPeriod` in
  [kubelet config](/docs/tasks/administer-cluster/kubelet-config-file/).
- `CustomPodDNS`: Enable customizing the DNS settings for a Pod using its `dnsConfig` property.
   Check [Pod's DNS Config](/docs/concepts/services-networking/dns-pod-service/#pods-dns-config)
   for more details.
- `CustomResourceDefaulting`: Enable CRD support for default values in OpenAPI v3 validation schemas.
- `CustomResourcePublishOpenAPI`: Enables publishing of CRD OpenAPI specs.
- `CustomResourceSubresources`: Enable `/status` and `/scale` subresources
  on resources created from [CustomResourceDefinition](/docs/concepts/extend-kubernetes/api-extension/custom-resources/).
- `CustomResourceValidation`: Enable schema based validation on resources created from
  [CustomResourceDefinition](/docs/concepts/extend-kubernetes/api-extension/custom-resources/).
- `CustomResourceWebhookConversion`: Enable webhook-based conversion
  on resources created from [CustomResourceDefinition](/docs/concepts/extend-kubernetes/api-extension/custom-resources/).
- `DaemonSetUpdateSurge`: Enables the DaemonSet workloads to maintain
  availability during update per node.
-->
<ul>
<li><code>CustomCPUCFSQuotaPeriod</code>：使节点能够更改
<a href="/zh/docs/tasks/administer-cluster/kubelet-config-file/">kubelet 配置</a>.
中的 <code>cpuCFSQuotaPeriod</code>。</li>
<li><code>CustomPodDNS</code>：允许使用 Pod 的 <code>dnsConfig</code> 属性自定义其 DNS 设置。
更多详细信息，请参见
<a href="/zh/docs/concepts/services-networking/dns-pod-service/#pods-dns-config">Pod 的 DNS 配置</a>。</li>
<li><code>CustomResourceDefaulting</code>：为 CRD 启用在其 OpenAPI v3 验证模式中提供默认值的支持。</li>
<li><code>CustomResourcePublishOpenAPI</code>：启用 CRD OpenAPI 规范的发布。</li>
<li><code>CustomResourceSubresources</code>：对于用
<a href="/zh/docs/concepts/extend-kubernetes/api-extension/custom-resources/">CustomResourceDefinition</a>
创建的资源启用其 <code>/status</code> 和 <code>/scale</code> 子资源。</li>
<li><code>CustomResourceValidation</code>：对于用
<a href="/zh/docs/concepts/extend-kubernetes/api-extension/custom-resources/">CustomResourceDefinition</a>
创建的资源启用基于模式的验证。</li>
<li><code>CustomResourceWebhookConversion</code>：对于用
<a href="/zh/docs/concepts/extend-kubernetes/api-extension/custom-resources/">CustomResourceDefinition</a>
创建的资源启用基于 Webhook 的转换。</li>
<li><code>DaemonSetUpdateSurge</code>: 使 DaemonSet 工作负载在每个节点的更新期间保持可用性。</li>
</ul>
<!--
- `DefaultPodTopologySpread`: Enables the use of `PodTopologySpread` scheduling plugin to do
  [default spreading](/docs/concepts/workloads/pods/pod-topology-spread-constraints/#internal-default-constraints).
- `DelegateFSGroupToCSIDriver`: If supported by the CSI driver, delegates the
  role of applying `fsGroup` from a Pod's `securityContext` to the driver by
  passing `fsGroup` through the NodeStageVolume and NodePublishVolume CSI calls.
- `DevicePlugins`: Enable the [device-plugins](/docs/concepts/extend-kubernetes/compute-storage-net/device-plugins/)
  based resource provisioning on nodes.
- `DisableAcceleratorUsageMetrics`:
  [Disable accelerator metrics collected by the kubelet](/docs/concepts/cluster-administration/system-metrics/#disable-accelerator-metrics).
- `DisableCloudProviders`: Disables any functionality in `kube-apiserver`,
  `kube-controller-manager` and `kubelet` related to the `--cloud-provider`
  component flag.
- `DownwardAPIHugePages`: Enables usage of hugepages in
  [downward API](/docs/tasks/inject-data-application/downward-api-volume-expose-pod-information).
- `DryRun`: Enable server-side [dry run](/docs/reference/using-api/api-concepts/#dry-run) requests
  so that validation, merging, and mutation can be tested without committing.
- `DynamicAuditing`: Used to enable dynamic auditing before v1.19.
-->
<ul>
<li><code>DefaultPodTopologySpread</code>: 启用 <code>PodTopologySpread</code> 调度插件来完成
<a href="/zh/docs/concepts/workloads/pods/pod-topology-spread-constraints/#internal-default-constraints">默认的调度传播</a>.</li>
<li><code>DelegateFSGroupToCSIDriver</code>: 如果 CSI 驱动程序支持，则通过 NodeStageVolume 和
NodePublishVolume CSI 调用传递 <code>fsGroup</code> ，将应用 <code>fsGroup</code> 从 Pod 的
<code>securityContext</code> 的角色委托给驱动。</li>
<li><code>DevicePlugins</code>：在节点上启用基于
<a href="/zh/docs/concepts/extend-kubernetes/compute-storage-net/device-plugins/">设备插件</a>的
资源制备。</li>
<li><code>DisableAcceleratorUsageMetrics</code>：
<a href="/zh/docs/concepts/cluster-administration/system-metrics/#disable-accelerator-metrics">禁用 kubelet 收集加速器指标</a>.</li>
<li><code>DisableCloudProviders</code>: 禁用 <code>kube-apiserver</code>，
<code>kube-controller-manager</code> 和 <code>kubelet</code> 组件的 <code>--cloud-provider</code> 标志相关
的所有功能。</li>
<li><code>DownwardAPIHugePages</code>：允许在
<a href="/zh/docs/tasks/inject-data-application/downward-api-volume-expose-pod-information">下行（Downward）API</a>
中使用巨页信息。</li>
<li><code>DryRun</code>：启用在服务器端对请求进行
<a href="/zh/docs/reference/using-api/api-concepts/#dry-run">彩排（Dry Run）</a>，
以便测试验证、合并和修改，同时避免提交更改。</li>
<li><code>DynamicAuditing</code>：在 v1.19 版本前用于启用动态审计。</li>
</ul>
<!--
- `DynamicKubeletConfig`: Enable the dynamic configuration of kubelet. See
  [Reconfigure kubelet](/docs/tasks/administer-cluster/reconfigure-kubelet/).
- `DynamicProvisioningScheduling`: Extend the default scheduler to be aware of
  volume topology and handle PV provisioning.
  This feature is superseded by the `VolumeScheduling` feature completely in v1.12.
- `DynamicVolumeProvisioning`: Enable the
  [dynamic provisioning](/docs/concepts/storage/dynamic-provisioning/) of persistent volumes to Pods.
- `EfficientWatchResumption`: Allows for storage-originated bookmark (progress
  notify) events to be delivered to the users. This is only applied to watch
  operations.
- `EnableAggregatedDiscoveryTimeout`: Enable the five second
  timeout on aggregated discovery calls.
-->
<ul>
<li><code>DynamicKubeletConfig</code>：启用 kubelet 的动态配置。请参阅
<a href="/zh/docs/tasks/administer-cluster/reconfigure-kubelet/">重新配置 kubelet</a>。</li>
<li><code>DynamicProvisioningScheduling</code>：扩展默认调度器以了解卷拓扑并处理 PV 配置。
此特性已在 v1.12 中完全被 <code>VolumeScheduling</code> 特性取代。</li>
<li><code>DynamicVolumeProvisioning</code>：启用持久化卷到 Pod 的
<a href="/zh/docs/concepts/storage/dynamic-provisioning/">动态预配置</a>。</li>
<li><code>EfficientWatchResumption</code>：允许从存储发起的 bookmark（进度通知）事件被
通知到用户。此特性仅适用于 watch 操作。</li>
<li><code>EnableAggregatedDiscoveryTimeout</code>：对聚集的发现调用启用五秒钟超时设置。</li>
</ul>
<!--
- `EnableEquivalenceClassCache`: Enable the scheduler to cache equivalence of
  nodes when scheduling Pods.
- `EndpointSlice`: Enables EndpointSlices for more scalable and extensible
   network endpoints. See [Enabling EndpointSlices](/docs/tasks/administer-cluster/enabling-endpointslices/).
- `EndpointSliceNodeName`: Enables EndpointSlice `nodeName` field.
- `EndpointSliceProxying`: When enabled, kube-proxy running
   on Linux will use EndpointSlices as the primary data source instead of
   Endpoints, enabling scalability and performance improvements. See
   [Enabling Endpoint Slices](/docs/tasks/administer-cluster/enabling-endpointslices/).
- `EndpointSliceTerminatingCondition`: Enables EndpointSlice `terminating` and `serving`
   condition fields.
-->
<ul>
<li><code>EnableEquivalenceClassCache</code>：调度 Pod 时，使 scheduler 缓存节点的等效项。</li>
<li><code>EndpointSlice</code>：启用 EndpointSlice 以实现可扩缩性和可扩展性更好的网络端点。
参阅<a href="/zh/docs/tasks/administer-cluster/enabling-endpointslices/">启用 EndpointSlice</a>。</li>
<li><code>EndpointSliceNodeName</code>：允许使用 EndpointSlice 的 <code>nodeName</code> 字段。</li>
<li><code>EndpointSliceProxying</code>：启用此特性门控时，Linux 上运行的 kube-proxy 会使用
EndpointSlices 而不是 Endpoints 作为其主要数据源，从而使得可扩缩性和性能
提升成为可能。参阅
<a href="/zh/docs/tasks/administer-cluster/enabling-endpointslices/">启用 EndpointSlice</a>。</li>
<li><code>EndpointSliceTerminatingCondition</code>：允许使用 EndpointSlice 的 <code>terminating</code> 和
<code>serving</code> 状况字段。</li>
</ul>
<!--
- `EphemeralContainers`: Enable the ability to add
  <a class='glossary-tooltip' title='您可以在 Pod 中临时运行的一种容器类型' data-toggle='tooltip' data-placement='top' href='/zh/docs/concepts/workloads/pods/ephemeral-containers/' target='_blank' aria-label='ephemeral containers'>ephemeral containers</a>
  to running pods.
- `EvenPodsSpread`: Enable pods to be scheduled evenly across topology domains. See
  [Pod Topology Spread Constraints](/docs/concepts/workloads/pods/pod-topology-spread-constraints/).
- `ExecProbeTimeout`: Ensure kubelet respects exec probe timeouts.
  This feature gate exists in case any of your existing workloads depend on a
  now-corrected fault where Kubernetes ignored exec probe timeouts. See
  [readiness probes](/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/#configure-probes).
-->
<ul>
<li><code>EphemeralContainers</code>：启用添加
<a class='glossary-tooltip' title='您可以在 Pod 中临时运行的一种容器类型' data-toggle='tooltip' data-placement='top' href='/zh/docs/concepts/workloads/pods/ephemeral-containers/' target='_blank' aria-label='临时容器'>临时容器</a>
到正在运行的 Pod 的特性。</li>
<li><code>EvenPodsSpread</code>：使 Pod 能够在拓扑域之间平衡调度。请参阅
<a href="/zh/docs/concepts/workloads/pods/pod-topology-spread-constraints/">Pod 拓扑扩展约束</a>。</li>
<li><code>ExecProbeTimeout</code>：确保 kubelet 会遵从 exec 探针的超时值设置。
此特性门控的主要目的是方便你处理现有的、依赖于已被修复的缺陷的工作负载；
该缺陷导致 Kubernetes 会忽略 exec 探针的超时值设置。
参阅<a href="/zh/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/#configure-probes">就绪态探针</a>.</li>
</ul>
<!--
- `ExpandCSIVolumes`: Enable the expanding of CSI volumes.
- `ExpandedDNSConfig`: Enable kubelet and kube-apiserver to allow more DNS
  search paths and longer list of DNS search paths. See
  [Expanded DNS Configuration](/docs/concepts/services-networking/dns-pod-service/#expanded-dns-configuration).
- `ExpandInUsePersistentVolumes`: Enable expanding in-use PVCs. See
  [Resizing an in-use PersistentVolumeClaim](/docs/concepts/storage/persistent-volumes/#resizing-an-in-use-persistentvolumeclaim).
- `ExpandPersistentVolumes`: Enable the expanding of persistent volumes. See
  [Expanding Persistent Volumes Claims](/docs/concepts/storage/persistent-volumes/#expanding-persistent-volumes-claims).
- `ExperimentalCriticalPodAnnotation`: Enable annotating specific pods as *critical*
  so that their [scheduling is guaranteed](/docs/tasks/administer-cluster/guaranteed-scheduling-critical-addon-pods/).
  This feature is deprecated by Pod Priority and Preemption as of v1.13.
-->
<ul>
<li><code>ExpandCSIVolumes</code>: 启用扩展 CSI 卷。</li>
<li><code>ExpandedDNSConfig</code>: 在 kubelet 和 kube-apiserver 上启用后，
允许更多的 DNS 搜索域和搜索域列表。 参阅
<a href="/zh/docs/concepts/services-networking/dns-pod-service/#expanded-dns-configuration">扩展 DNS 配置</a>.</li>
<li><code>ExpandInUsePersistentVolumes</code>：启用扩充使用中的 PVC 的尺寸。请查阅
<a href="/zh/docs/concepts/storage/persistent-volumes/#resizing-an-in-use-persistentvolumeclaim">调整使用中的 PersistentVolumeClaim 的大小</a>。</li>
<li><code>ExpandPersistentVolumes</code>：允许扩充持久卷。请查阅
<a href="/zh/docs/concepts/storage/persistent-volumes/#expanding-persistent-volumes-claims">扩展持久卷申领</a>。</li>
<li><code>ExperimentalCriticalPodAnnotation</code>：启用将特定 Pod 注解为 <em>critical</em> 的方式，用于
<a href="/zh/docs/tasks/administer-cluster/guaranteed-scheduling-critical-addon-pods/">确保其被调度</a>。
从 v1.13 开始已弃用此特性，转而使用 Pod 优先级和抢占功能。</li>
</ul>
<!--
- `ExperimentalHostUserNamespaceDefaulting`: Enabling the defaulting user
   namespace to host. This is for containers that are using other host namespaces,
   host mounts, or containers that are privileged or using specific non-namespaced
   capabilities (e.g. `MKNODE`, `SYS_MODULE` etc.). This should only be enabled
   if user namespace remapping is enabled in the Docker daemon.
- `ExternalPolicyForExternalIP`: Fix a bug where ExternalTrafficPolicy is not applied to Service ExternalIPs.
- `GCERegionalPersistentDisk`: Enable the regional PD feature on GCE.
- `GenericEphemeralVolume`: Enables ephemeral, inline volumes that support all features
  of normal volumes (can be provided by third-party storage vendors, storage capacity tracking,
  restore from snapshot, etc.).
  See [Ephemeral Volumes](/docs/concepts/storage/ephemeral-volumes/).
- `GracefulNodeShutdown`: Enables support for graceful shutdown in kubelet.
  During a system shutdown, kubelet will attempt to detect the shutdown event
  and gracefully terminate pods running on the node. See
  [Graceful Node Shutdown](/docs/concepts/architecture/nodes/#graceful-node-shutdown)
  for more details.
-->
<ul>
<li><code>ExperimentalHostUserNamespaceDefaulting</code>：启用主机默认的用户名字空间。
这适用于使用其他主机名字空间、主机安装的容器，或具有特权或使用特定的非名字空间功能
（例如 MKNODE、SYS_MODULE 等）的容器。
如果在 Docker 守护程序中启用了用户名字空间重新映射，则启用此选项。</li>
<li><code>ExternalPolicyForExternalIP</code>： 修复 ExternalPolicyForExternalIP 没有应用于 Service ExternalIPs 的 bug。</li>
<li><code>GCERegionalPersistentDisk</code>：在 GCE 上启用带地理区域信息的 PD 特性。</li>
<li><code>GenericEphemeralVolume</code>：启用支持临时的内联卷，这些卷支持普通卷
（可以由第三方存储供应商提供、存储容量跟踪、从快照还原等等）的所有功能。请参见
<a href="/zh/docs/concepts/storage/ephemeral-volumes/">临时卷</a>。</li>
<li><code>GracefulNodeShutdown</code>：在 kubelet 中启用体面地关闭节点的支持。
在系统关闭时，kubelet 会尝试监测该事件并体面地终止节点上运行的 Pods。参阅
<a href="/zh/docs/concepts/architecture/nodes/#graceful-node-shutdown">体面地关闭节点</a>
以了解更多细节。</li>
</ul>
<!--
- `HPAContainerMetrics`: Enable the `HorizontalPodAutoscaler` to scale based on
  metrics from individual containers in target pods.
- `HPAScaleToZero`: Enables setting `minReplicas` to 0 for `HorizontalPodAutoscaler`
  resources when using custom or external metrics.
- `HugePages`: Enable the allocation and consumption of pre-allocated
  [huge pages](/docs/tasks/manage-hugepages/scheduling-hugepages/).
- `HugePageStorageMediumSize`: Enable support for multiple sizes pre-allocated
  [huge pages](/docs/tasks/manage-hugepages/scheduling-hugepages/).
-->
<ul>
<li><code>HPAContainerMetrics</code>：允许 <code>HorizontalPodAutoscaler</code> 基于目标 Pods 中各容器
的度量值来执行扩缩操作。</li>
<li><code>HPAScaleToZero</code>：使用自定义指标或外部指标时，可将 <code>HorizontalPodAutoscaler</code>
资源的 <code>minReplicas</code> 设置为 0。</li>
<li><code>HugePages</code>：启用分配和使用预分配的
<a href="/zh/docs/tasks/manage-hugepages/scheduling-hugepages/">巨页资源</a>。</li>
<li><code>HugePageStorageMediumSize</code>：启用支持多种大小的预分配
<a href="/zh/docs/tasks/manage-hugepages/scheduling-hugepages/">巨页资源</a>。</li>
</ul>
<!--
- `HyperVContainer`: Enable
  [Hyper-V isolation](https://docs.microsoft.com/en-us/virtualization/windowscontainers/manage-containers/hyperv-container)
  for Windows containers.
- `ImmutableEphemeralVolumes`: Allows for marking individual Secrets and ConfigMaps as
  immutable for better safety and performance.
- `InTreePluginAWSUnregister`: Stops registering the aws-ebs in-tree plugin in kubelet
  and volume controllers.
- `InTreePluginAzureDiskUnregister`: Stops registering the azuredisk in-tree plugin in kubelet
  and volume controllers.
- `InTreePluginAzureFileUnregister`: Stops registering the azurefile in-tree plugin in kubelet
  and volume controllers.
- `InTreePluginGCEUnregister`: Stops registering the gce-pd in-tree plugin in kubelet
  and volume controllers.
- `InTreePluginOpenStackUnregister`: Stops registering the OpenStack cinder in-tree plugin in kubelet
  and volume controllers.
- `InTreePluginvSphereUnregister`: Stops registering the vSphere in-tree plugin in kubelet
  and volume controllers.
- `IndexedJob`: Allows the [Job](/docs/concepts/workloads/controllers/job/)
  controller to manage Pod completions per completion index.
- `IngressClassNamespacedParams`: Allow namespace-scoped parameters reference in
  `IngressClass` resource. This feature adds two fields - `Scope` and `Namespace`
  to `IngressClass.spec.parameters`.
- `Initializers`: Allow asynchronous coordination of object creation using the
  Initializers admission plugin.
- `IPv6DualStack`: Enable [dual stack](/docs/concepts/services-networking/dual-stack/)
  support for IPv6.
- `JobTrackingWithFinalizers`: Enables tracking [Job](/docs/concepts/workloads/controllers/job)
  completions without relying on Pods remaining in the cluster indefinitely.
  The Job controller uses Pod finalizers and a field in the Job status to keep
  track of the finished Pods to count towards completion.
- `KubeletConfigFile`: Enable loading kubelet configuration 
  from a file specified using a config file.
  See [setting kubelet parameters via a config file](/docs/tasks/administer-cluster/kubelet-config-file/)
  for more details.
- `KubeletCredentialProviders`: Enable kubelet exec credential providers for image pull credentials.
- `KubeletInUserNamespace`: Enables support for running kubelet in a <a class='glossary-tooltip' title='A Linux kernel feature to emulate superuser privilege for unprivileged users.' data-toggle='tooltip' data-placement='top' href='https://man7.org/linux/man-pages/man7/user_namespaces.7.html' target='_blank' aria-label='user namespace'>user namespace</a>.
   See [Running Kubernetes Node Components as a Non-root User](/docs/tasks/administer-cluster/kubelet-in-userns/).
- `KubeletPluginsWatcher`: Enable probe-based plugin watcher utility to enable kubelet
  to discover plugins such as [CSI volume drivers](/docs/concepts/storage/volumes/#csi).
-->
<ul>
<li><code>HyperVContainer</code>：为 Windows 容器启用
<a href="https://docs.microsoft.com/en-us/virtualization/windowscontainers/manage-containers/hyperv-container">Hyper-V 隔离</a>。</li>
<li><code>ImmutableEphemeralVolumes</code>：允许将各个 Secret 和 ConfigMap 标记为不可变更的，
以提高安全性和性能。</li>
<li><code>InTreePluginAWSUnregister</code>: 在 kubelet 和 卷控制器上关闭注册 aws-ebs 内嵌插件。</li>
<li><code>InTreePluginAzureDiskUnregister</code>: 在 kubelet 和 卷控制器上关闭注册 azuredisk 内嵌插件。</li>
<li><code>InTreePluginAzureFileUnregister</code>: 在 kubelet 和 卷控制器上关闭注册 azurefile 内嵌插件。</li>
<li><code>InTreePluginGCEUnregister</code>: 在 kubelet 和 卷控制器上关闭注册 gce-pd 内嵌插件。</li>
<li><code>InTreePluginOpenStackUnregister</code>: 在 kubelet 和 卷控制器上关闭注册 OpenStack cinder 内嵌插件。</li>
<li><code>InTreePluginvSphereUnregister</code>: 在 kubelet 和 卷控制器上关闭注册 vSphere 内嵌插件。</li>
<li><code>IndexedJob</code>：允许 <a href="/zh/docs/concepts/workloads/controllers/job/">Job</a> 控制器按每个完成的索引去管理 Pod 完成。</li>
<li><code>IngressClassNamespacedParams</code>：允许引用命名空间范围的参数引用 <code>IngressClass</code>资源。该特性增加了两个字段 —— <code>Scope</code> 和 <code>Namespace</code> 到 <code>IngressClass.spec.parameters</code>。</li>
<li><code>Initializers</code>： 使用 Initializers 准入插件允许异步协调对象创建。</li>
<li><code>IPv6DualStack</code>：启用 <a href="/zh/docs/concepts/services-networking/dual-stack/">双协议栈</a>
以支持 IPv6。</li>
<li><code>JobTrackingWithFinalizers</code>: 启用跟踪 <a href="/zh/docs/concepts/workloads/controllers/job">Job</a>
完成情况，而不是永远从集群剩余 pod 来获取信息判断完成情况。Job 控制器使
用 Pod finalizers 和 Job 状态中的一个字段来跟踪已完成的 Pod 以计算完成。</li>
<li><code>KubeletConfigFile</code>：启用从使用配置文件指定的文件中加载 kubelet 配置。
有关更多详细信息，请参见
<a href="/zh/docs/tasks/administer-cluster/kubelet-config-file/">通过配置文件设置 kubelet 参数</a>。</li>
<li><code>KubeletCredentialProviders</code>：允许使用 kubelet exec 凭据提供程序来设置
镜像拉取凭据。</li>
<li><code>KubeletInUserNamespace</code>: 支持在 <a class='glossary-tooltip' title='A Linux kernel feature to emulate superuser privilege for unprivileged users.' data-toggle='tooltip' data-placement='top' href='https://man7.org/linux/man-pages/man7/user_namespaces.7.html' target='_blank' aria-label='user namespace'>user namespace</a> 里运行 kubelet 。
请参见 <a href="/zh/docs/tasks/administer-cluster/kubelet-in-userns/">使用非 Root 用户来运行 Kubernetes 节点组件</a>.</li>
<li><code>KubeletPluginsWatcher</code>：启用基于探针的插件监视应用程序，使 kubelet 能够发现
类似 <a href="/zh/docs/concepts/storage/volumes/#csi">CSI 卷驱动程序</a>这类插件。</li>
</ul>
<!--
- `KubeletPodResources`: Enable the kubelet's pod resources gRPC endpoint. See
  [Support Device Monitoring](https://github.com/kubernetes/enhancements/blob/master/keps/sig-node/606-compute-device-assignment/README.md)
  for more details.
- `KubeletPodResourcesGetAllocatable`: Enable the kubelet's pod resources `GetAllocatableResources` functionality.
  This API augments the [resource allocation reporting](/docs/concepts/extend-kubernetes/compute-storage-net/device-plugins/#monitoring-device-plugin-resources)
  with informations about the allocatable resources, enabling clients to properly track the free compute resources on a node.
- `LegacyNodeRoleBehavior`: When disabled, legacy behavior in service load balancers and
  node disruption will ignore the `node-role.kubernetes.io/master` label in favor of the
  feature-specific labels provided by `NodeDisruptionExclusion` and `ServiceNodeExclusion`.
-->
<ul>
<li><code>KubeletPodResources</code>：启用 kubelet 上 Pod 资源 GRPC 端点。更多详细信息，请参见
<a href="https://github.com/kubernetes/enhancements/blob/master/keps/sig-node/compute-device-assignment.md">支持设备监控</a>。</li>
<li><code>KubeletPodResourcesGetAllocatable</code>：启用 kubelet 的 pod 资源
的 <code>GetAllocatableResources</code> 功能。
该 API 增强了[资源分配报告]（/zh/docs/concepts/extend-kubernetes/compute-storage-net/device-plugins/#monitoring-device-plugin-resources）
包含有关可分配资源的信息，使客户端能够正确跟踪节点上的可用计算资源。</li>
<li><code>LegacyNodeRoleBehavior</code>：禁用此门控时，服务负载均衡器中和节点干扰中的原先行为
会忽略 <code>node-role.kubernetes.io/master</code> 标签，使用 <code>NodeDisruptionExclusion</code> 和
<code>ServiceNodeExclusion</code> 对应特性所提供的标签。</li>
</ul>
<!--
- `LocalStorageCapacityIsolation`: Enable the consumption of
  [local ephemeral storage](/docs/concepts/configuration/manage-resources-containers/)
  and also the `sizeLimit` property of an
  [emptyDir volume](/docs/concepts/storage/volumes/#emptydir).
- `LocalStorageCapacityIsolationFSQuotaMonitoring`: When `LocalStorageCapacityIsolation`
  is enabled for
  [local ephemeral storage](/docs/concepts/configuration/manage-resources-containers/)
  and the backing filesystem for [emptyDir volumes](/docs/concepts/storage/volumes/#emptydir)
  supports project quotas and they are enabled, use project quotas to monitor
  [emptyDir volume](/docs/concepts/storage/volumes/#emptydir) storage consumption rather than
  filesystem walk for better performance and accuracy.
- `LogarithmicScaleDown`: Enable semi-random selection of pods to evict on controller scaledown
  based on logarithmic bucketing of pod timestamps.
- `MemoryManager`: Allows setting memory affinity for a container based on
  NUMA topology.
- `MemoryQoS`: Enable memory protection and usage throttle on pod / container using cgroup v2 memory controller.
- `MixedProtocolLBService`: Enable using different protocols in the same `LoadBalancer` type
  Service instance.
- `MountContainers`: Enable using utility containers on host as
  the volume mounter.
-->
<ul>
<li><code>LocalStorageCapacityIsolation</code>：允许使用
<a href="/zh/docs/concepts/configuration/manage-resources-containers/">本地临时存储</a>
以及 <a href="/zh/docs/concepts/storage/volumes/#emptydir">emptyDir 卷</a> 的 <code>sizeLimit</code> 属性。</li>
<li><code>LocalStorageCapacityIsolationFSQuotaMonitoring</code>：如果
<a href="/zh/docs/concepts/configuration/manage-resources-containers/">本地临时存储</a>
启用了 <code>LocalStorageCapacityIsolation</code>，并且
<a href="/zh/docs/concepts/storage/volumes/#emptydir">emptyDir 卷</a>
的后备文件系统支持项目配额，并且启用了这些配额，将使用项目配额来监视
<a href="/zh/docs/concepts/storage/volumes/#emptydir">emptyDir 卷</a>的存储消耗
而不是遍历文件系统，以此获得更好的性能和准确性。</li>
<li><code>LogarithmicScaleDown</code>：启用 Pod 的半随机（semi-random）选择，控制器将根据 Pod 时间戳的对数桶按比例缩小去驱逐 Pod。</li>
<li><code>MemoryManager</code>: 允许基于 NUMA 拓扑为容器设置内存亲和性。</li>
<li><code>MemoryQoS</code>: 使用 cgroup v2 内存控制器在 pod / 容器上启用内存保护和使用限制。</li>
<li><code>MixedProtocolLBService</code>：允许在同一 <code>LoadBalancer</code> 类型的 Service 实例中使用不同
的协议。</li>
<li><code>MountContainers</code>：允许使用主机上的工具容器作为卷挂载程序。</li>
</ul>
<!--
- `MountPropagation`: Enable sharing volume mounted by one container to other containers or pods.
  For more details, please see [mount propagation](/docs/concepts/storage/volumes/#mount-propagation).
- `NamespaceDefaultLabelName`: Configure the API Server to set an immutable <a class='glossary-tooltip' title='用来为对象设置可标识的属性标记；这些标记对用户而言是有意义且重要的。' data-toggle='tooltip' data-placement='top' href='/zh/docs/concepts/overview/working-with-objects/labels/' target='_blank' aria-label='label'>label</a>
  `kubernetes.io/metadata.name` on all namespaces, containing the namespace name.
- `NetworkPolicyEndPort`: Enable use of the field `endPort` in NetworkPolicy objects, allowing the selection of a port range instead of a single port.
- `NodeDisruptionExclusion`: Enable use of the node label `node.kubernetes.io/exclude-disruption`
  which prevents nodes from being evacuated during zone failures.
- `NodeLease`: Enable the new Lease API to report node heartbeats, which could be used as a node health signal.
- `NodeSwap`: Enable the kubelet to allocate swap memory for Kubernetes workloads on a node.
  Must be used with `KubeletConfiguration.failSwapOn` set to false.
  For more details, please see [swap memory](/docs/concepts/architecture/nodes/#swap-memory)
- `NonPreemptingPriority`: Enable `preemptionPolicy` field for PriorityClass and Pod.
- `PVCProtection`: Enable the prevention of a PersistentVolumeClaim (PVC) from
  being deleted when it is still used by any Pod.
- `PodDeletionCost`: Enable the [Pod Deletion Cost](/docs/content/en/docs/concepts/workloads/controllers/replicaset/#pod-deletion-cost)
   feature which allows users to influence ReplicaSet downscaling order.
- `PersistentLocalVolumes`: Enable the usage of `local` volume type in Pods.
  Pod affinity has to be specified if requesting a `local` volume.
- `PodDisruptionBudget`: Enable the [PodDisruptionBudget](/docs/tasks/run-application/configure-pdb/) feature.
- `PodAffinityNamespaceSelector`: Enable the [Pod Affinity Namespace Selector](/docs/concepts/scheduling-eviction/assign-pod-node/#namespace-selector)
  and [CrossNamespacePodAffinity](/docs/concepts/policy/resource-quotas/#cross-namespace-pod-affinity-quota) quota scope features.
- `PodOverhead`: Enable the [PodOverhead](/docs/concepts/scheduling-eviction/pod-overhead/)
  feature to account for pod overheads.
-->
<ul>
<li><code>MountPropagation</code>：启用将一个容器安装的共享卷共享到其他容器或 Pod。
更多详细信息，请参见<a href="/zh/docs/concepts/storage/volumes/#mount-propagation">挂载传播</a>。</li>
<li><code>NamespaceDefaultLabelName</code>：配置 API 服务器以在所有名字空间上设置一个不可变的 <a class='glossary-tooltip' title='用来为对象设置可标识的属性标记；这些标记对用户而言是有意义且重要的。' data-toggle='tooltip' data-placement='top' href='/zh/docs/concepts/overview/working-with-objects/labels/' target='_blank' aria-label='label'>label</a>
<code>kubernetes.io/metadata.name</code>，也包括名字空间。</li>
<li><code>NodeDisruptionExclusion</code>：启用节点标签 <code>node.kubernetes.io/exclude-disruption</code>，
以防止在可用区发生故障期间驱逐节点。</li>
<li><code>NodeLease</code>：启用新的 Lease（租期）API 以报告节点心跳，可用作节点运行状况信号。</li>
<li><code>NodeSwap</code>: 启用 kubelet 为节点上的 Kubernetes 工作负载分配交换内存的能力。
必须将 <code>KubeletConfiguration.failSwapOn</code> 设置为 false 的情况下才能使用。
更多详细信息，请参见 <a href="/zh/docs/concepts/architecture/nodes/#swap-memory">交换内存</a>。</li>
<li><code>NonPreemptingPriority</code>：为 PriorityClass 和 Pod 启用 <code>preemptionPolicy</code> 选项。</li>
<li><code>PVCProtection</code>：启用防止仍被某 Pod 使用的 PVC 被删除的特性。</li>
<li><code>PodDeletionCost</code>：启用 <a href="/zh/docs/concepts/workloads/controllers/replicaset/#pod-deletion-cost">Pod 删除成本</a> 功能。
该功能使用户可以影响 ReplicaSet 的降序顺序。</li>
<li><code>PersistentLocalVolumes</code>：允许在 Pod 中使用 <code>local（本地）</code> 卷类型。
如果请求 <code>local</code> 卷，则必须指定 Pod 亲和性属性。</li>
<li><code>PodDisruptionBudget</code>：启用 <a href="/zh/docs/tasks/run-application/configure-pdb/">PodDisruptionBudget</a> 特性。</li>
<li><code>PodAffinityNamespaceSelector</code>：启用 <a href="/zh/docs/concepts/scheduling-eviction/assign-pod-node/#namespace-selector">Pod 亲和性名称空间选择器</a>
和 <a href="/zh/docs/concepts/policy/resource-quotas/#cross-namespace-pod-affinity-quota">CrossNamespacePodAffinity</a> 资源配额功能。</li>
<li><code>PodOverhead</code>：启用 <a href="/zh/docs/concepts/scheduling-eviction/pod-overhead/">PodOverhead</a>
特性以考虑 Pod 开销。</li>
</ul>
<!--
- `PodPriority`: Enable the descheduling and preemption of Pods based on their
  [priorities](/docs/concepts/scheduling-eviction/pod-priority-preemption/).
- `PodReadinessGates`: Enable the setting of `PodReadinessGate` field for extending
  Pod readiness evaluation.  See [Pod readiness gate](/docs/concepts/workloads/pods/pod-lifecycle/#pod-readiness-gate)
  for more details.
- `PodSecurity`: Enables the `PodSecurity` admission plugin.
- `PodShareProcessNamespace`: Enable the setting of `shareProcessNamespace` in a Pod for sharing
  a single process namespace between containers running in a pod.  More details can be found in
  [Share Process Namespace between Containers in a Pod](/docs/tasks/configure-pod-container/share-process-namespace/).
- `PreferNominatedNode`: This flag tells the scheduler whether the nominated
  nodes will be checked first before looping through all the other nodes in
  the cluster.
- `ProbeTerminationGracePeriod`: Enable [setting probe-level
  `terminationGracePeriodSeconds`](/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/#probe-level-terminationgraceperiodseconds)
   on pods.  See the [enhancement proposal](https://github.com/kubernetes/enhancements/tree/master/keps/sig-node/2238-liveness-probe-grace-period) for more details.
- `ProcMountType`: Enables control over the type proc mounts for containers
  by setting the `procMount` field of a SecurityContext.
- `ProxyTerminatingEndpoints`: Enable the kube-proxy to handle terminating
  endpoints when `ExternalTrafficPolicy=Local`.
- `QOSReserved`: Allows resource reservations at the QoS level preventing pods
  at lower QoS levels from bursting into resources requested at higher QoS levels
  (memory only for now).
- `ReadWriteOncePod`: Enables the usage of `ReadWriteOncePod` PersistentVolume
  access mode.
- `RemainingItemCount`: Allow the API servers to show a count of remaining
  items in the response to a
  [chunking list request](/docs/reference/using-api/api-concepts/#retrieving-large-results-sets-in-chunks).
-->
<ul>
<li><code>PodPriority</code>：根据 <a href="/zh/docs/concepts/scheduling-eviction/pod-priority-preemption/">优先级</a>
启用 Pod 的调度和抢占。</li>
<li><code>PodReadinessGates</code>：启用 <code>podReadinessGate</code> 字段的设置以扩展 Pod 准备状态评估。
有关更多详细信息，请参见
<a href="/zh/docs/concepts/workloads/pods/pod-lifecycle/#pod-readiness-gate">Pod 就绪状态判别</a>。</li>
<li><code>PodSecurity</code>: 开启 <code>PodSecurity</code> 准入控制插件。</li>
<li><code>PodShareProcessNamespace</code>：在 Pod 中启用 <code>shareProcessNamespace</code> 的设置，
以便在 Pod 中运行的容器之间共享同一进程名字空间。更多详细信息，请参见
<a href="/zh/docs/tasks/configure-pod-container/share-process-namespace/">在 Pod 中的容器间共享同一进程名字空间</a>。</li>
<li><code>PreferNominatedNode</code>: 这个标志告诉调度器在循环遍历集群中的所有其他节点
之前，是否首先检查指定的节点。</li>
<li><code>ProbeTerminationGracePeriod</code>：在 Pod 上 启用
<a href="/zh/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/#probe-level-terminationgraceperiodseconds">设置探测器级别 <code>terminationGracePeriodSeconds</code></a>。
有关更多信息，请参见 <a href="https://github.com/kubernetes/enhancements/tree/master/keps/sig-node/2238-liveness-probe-grace-period">enhancement proposal</a>。</li>
<li><code>ProcMountType</code>：允许容器通过设置 SecurityContext 的 <code>procMount</code> 字段来控制
对 proc 文件系统的挂载方式。</li>
<li><code>ProxyTerminatingEndpoints</code>: 当 <code>ExternalTrafficPolicy=Local</code> 时，
允许 kube-proxy 来处理终止过程中的端点。</li>
<li><code>QOSReserved</code>：允许在 QoS 级别进行资源预留，以防止处于较低 QoS 级别的 Pod
突发进入处于较高 QoS 级别的请求资源（目前仅适用于内存）。</li>
<li><code>ReadWriteOncePod</code>: 允许使用 <code>ReadWriteOncePod</code> 访问模式的 PersistentVolume。</li>
<li><code>RemainingItemCount</code>：允许 API 服务器在
<a href="/zh/docs/reference/using-api/api-concepts/#retrieving-large-results-sets-in-chunks">分块列表请求</a>
的响应中显示剩余条目的个数。</li>
</ul>
<!--
- `RemoveSelfLink`: Deprecates and removes `selfLink` from ObjectMeta and
  ListMeta.
- `RequestManagement`: Enables managing request concurrency with prioritization and fairness
  at each API server. Deprecated by `APIPriorityAndFairness` since 1.17.
- `ResourceLimitsPriorityFunction`: Enable a scheduler priority function that
  assigns a lowest possible score of 1 to a node that satisfies at least one of
  the input Pod's cpu and memory limits. The intent is to break ties between
  nodes with same scores.
- `ResourceQuotaScopeSelectors`: Enable resource quota scope selectors.
- `RootCAConfigMap`: Configure the `kube-controller-manager` to publish a
  <a class='glossary-tooltip' title='ConfigMap 是一种 API 对象，用来将非机密性的数据保存到键值对中。使用时可以用作环境变量、命令行参数或者存储卷中的配置文件。' data-toggle='tooltip' data-placement='top' href='/zh/docs/tasks/configure-pod-container/configure-pod-configmap/' target='_blank' aria-label='ConfigMap'>ConfigMap</a> named `kube-root-ca.crt`
  to every namespace. This ConfigMap contains a CA bundle used for verifying connections
  to the kube-apiserver. See
  [Bound Service Account Tokens](https://github.com/kubernetes/enhancements/blob/master/keps/sig-auth/1205-bound-service-account-tokens/README.md)
  for more details.
-->
<ul>
<li><code>RemoveSelfLink</code>：将 ObjectMeta 和 ListMeta 中的 <code>selfLink</code> 字段废弃并删除。</li>
<li><code>RequestManagement</code>：允许在每个 API 服务器上通过优先级和公平性管理请求并发性。
自 1.17 以来已被 <code>APIPriorityAndFairness</code> 弃用。</li>
<li><code>ResourceLimitsPriorityFunction</code>：启用某调度器优先级函数，
该函数将最低得分 1 指派给至少满足输入 Pod 的 CPU 和内存限制之一的节点，
目的是打破得分相同的节点之间的关联。</li>
<li><code>ResourceQuotaScopeSelectors</code>：启用资源配额范围选择器。</li>
<li><code>RootCAConfigMap</code>：配置 <code>kube-controller-manager</code>，使之发布一个名为 <code>kube-root-ca.crt</code>
的 <a class='glossary-tooltip' title='ConfigMap 是一种 API 对象，用来将非机密性的数据保存到键值对中。使用时可以用作环境变量、命令行参数或者存储卷中的配置文件。' data-toggle='tooltip' data-placement='top' href='/zh/docs/tasks/configure-pod-container/configure-pod-configmap/' target='_blank' aria-label='ConfigMap'>ConfigMap</a>，到
所有名字空间中。该 ConfigMap 包含用来验证与 kube-apiserver 之间连接的
CA 证书包。参阅
<a href="https://github.com/kubernetes/enhancements/blob/master/keps/sig-auth/1205-bound-service-account-tokens/README.md">绑定服务账户令牌</a>
以了解更多细节。</li>
</ul>
<!--
- `RotateKubeletClientCertificate`: Enable the rotation of the client TLS certificate on the kubelet.
  See [kubelet configuration](/docs/reference/command-line-tools-reference/kubelet-tls-bootstrapping/#kubelet-configuration) for more details.
- `RotateKubeletServerCertificate`: Enable the rotation of the server TLS certificate on the kubelet.
  See [kubelet configuration](/docs/reference/command-line-tools-reference/kubelet-tls-bootstrapping/#kubelet-configuration)
  for more details.
- `RunAsGroup`: Enable control over the primary group ID set on the init
  processes of containers.
- `RuntimeClass`: Enable the [RuntimeClass](/docs/concepts/containers/runtime-class/) feature
  for selecting container runtime configurations.
- `ScheduleDaemonSetPods`: Enable DaemonSet Pods to be scheduled by the default scheduler
  instead of the DaemonSet controller.
-->
<ul>
<li><code>RotateKubeletClientCertificate</code>：在 kubelet 上启用客户端 TLS 证书的轮换。
更多详细信息，请参见
<a href="/zh/docs/reference/command-line-tools-reference/kubelet-tls-bootstrapping/#kubelet-configuration">kubelet 配置</a>。</li>
<li><code>RotateKubeletServerCertificate</code>：在 kubelet 上启用服务器 TLS 证书的轮换。
更多详细信息，请参见
<a href="/zh/docs/reference/command-line-tools-reference/kubelet-tls-bootstrapping/#kubelet-configuration">kubelet 配置</a>。</li>
<li><code>RunAsGroup</code>：启用对容器初始化过程中设置的主要组 ID 的控制。</li>
<li><code>RuntimeClass</code>：启用 <a href="/zh/docs/concepts/containers/runtime-class/">RuntimeClass</a>
特性用于选择容器运行时配置。</li>
<li><code>ScheduleDaemonSetPods</code>：启用 DaemonSet Pods 由默认调度程序而不是
DaemonSet 控制器进行调度。</li>
</ul>
<!--
- `SCTPSupport`: Enables the _SCTP_ `protocol` value in Pod, Service,
  Endpoints, EndpointSlice, and NetworkPolicy definitions.
- `SeccompDefault`: Enables the use of `RuntimeDefault` as the default seccomp profile for all workloads.
  The seccomp profile is specified in the `securityContext` of a Pod and/or a Container.
- `SelectorIndex`: Allows label and field based indexes in API server watch
  cache to accelerate list operations.
- `ServerSideApply`: Enables the [Sever Side Apply (SSA)](/docs/reference/using-api/server-side-apply/)
  feature on the API Server.
- `ServiceAccountIssuerDiscovery`: Enable OIDC discovery endpoints (issuer and
  JWKS URLs) for the service account issuer in the API server. See
  [Configure Service Accounts for Pods](/docs/tasks/configure-pod-container/configure-service-account/#service-account-issuer-discovery)
  for more details.
- `ServiceAppProtocol`: Enables the `appProtocol` field on Services and Endpoints.
- `ServiceInternalTrafficPolicy`: Enables the `internalTrafficPolicy` field on Services
- `ServiceLBNodePortControl`: Enables the `allocateLoadBalancerNodePorts` field on Services.
- `ServiceLoadBalancerClass`: Enables the `loadBalancerClass` field on Services. See
  [Specifying class of load balancer implementation](/docs/concepts/services-networking/service/#load-balancer-class) for more details.
- `ServiceLoadBalancerFinalizer`: Enable finalizer protection for Service load balancers.
-->
<ul>
<li><code>SCTPSupport</code>：在 Pod、Service、Endpoints、NetworkPolicy 定义中
允许将 <em>SCTP</em> 用作 <code>protocol</code> 值。</li>
<li><code>SeccompDefault</code>: 允许将所有工作负载的默认  seccomp 配置文件为 <code>RuntimeDefault</code>。
seccomp 配置在 Pod 或者容器的 <code>securityContext</code> 字段中指定。</li>
<li><code>SelectorIndex</code>: 允许在 API 服务器 watch 的缓存中基于标签和字段的索引来加速 list 的操作。</li>
<li><code>ServerSideApply</code>：在 API 服务器上启用
<a href="/zh/docs/reference/using-api/server-side-apply/">服务器端应用（SSA）</a> 。</li>
<li><code>ServiceAccountIssuerDiscovery</code>：在 API 服务器中为服务帐户颁发者启用 OIDC 发现端点
（颁发者和 JWKS URL）。详情参见
<a href="/zh/docs/tasks/configure-pod-container/configure-service-account/#service-account-issuer-discovery">为 Pod 配置服务账户</a> 。</li>
<li><code>ServiceAppProtocol</code>：为 Service 和 Endpoints 启用 <code>appProtocol</code> 字段。</li>
<li><code>ServiceInternalTrafficPolicy</code>：为服务启用 <code>internalTrafficPolicy</code> 字段。</li>
<li><code>ServiceLBNodePortControl</code>：为服务启用 <code>allocateLoadBalancerNodePorts</code> 字段。
<code>ServiceLoadBalancerClass</code>: 为服务启用 <code>loadBalancerClass</code> 字段。
有关更多信息，请参见 <a href="/zh/docs/concepts/services-networking/service/#load-balancer-class">负载均衡器类的定义 implementation</a>。</li>
<li><code>ServiceLoadBalancerFinalizer</code>：为服务负载均衡启用终结器（finalizers）保护。</li>
</ul>
<!--
- `ServiceNodeExclusion`: Enable the exclusion of nodes from load balancers
  created by a cloud provider. A node is eligible for exclusion if labelled with
  "`node.kubernetes.io/exclude-from-external-load-balancers`".
- `ServiceTopology`: Enable service to route traffic based upon the Node
  topology of the cluster. See
  [ServiceTopology](/docs/concepts/services-networking/service-topology/)
  for more details.
- `SetHostnameAsFQDN`: Enable the ability of setting Fully Qualified Domain
  Name(FQDN) as the hostname of a pod. See
  [Pod's `setHostnameAsFQDN` field](/docs/concepts/services-networking/dns-pod-service/#pod-sethostnameasfqdn-field).
- `SizeMemoryBackedVolumes`: Enable kubelets to determine the size limit for
  memory-backed volumes (mainly `emptyDir` volumes).
-->
<ul>
<li><code>ServiceNodeExclusion</code>：启用从云提供商创建的负载均衡中排除节点。
如果节点标记有 <code>node.kubernetes.io/exclude-from-external-load-balancers</code>，
标签，则可以排除该节点。</li>
<li><code>ServiceTopology</code>：启用服务拓扑可以让一个服务基于集群的节点拓扑进行流量路由。
有关更多详细信息，请参见
<a href="/zh/docs/concepts/services-networking/service-topology/">服务拓扑</a>。</li>
<li><code>SetHostnameAsFQDN</code>：启用将全限定域名（FQDN）设置为 Pod 主机名的功能。
请参见<a href="/zh/docs/concepts/services-networking/dns-pod-service/#pod-sethostnameasfqdn-field">为 Pod 设置 <code>setHostnameAsFQDN</code> 字段</a>。</li>
<li><code>SizeMemoryBackedVolumes</code>：允许 kubelet 检查基于内存制备的卷的尺寸约束
（目前主要针对 <code>emptyDir</code> 卷）。</li>
</ul>
<!--
- `StartupProbe`: Enable the
  [startup](/docs/concepts/workloads/pods/pod-lifecycle/#when-should-you-use-a-startup-probe)
  probe in the kubelet.
- `StatefulSetMinReadySeconds`: Allows `minReadySeconds` to be respected by
  the StatefulSet controller.
- `StorageObjectInUseProtection`: Postpone the deletion of PersistentVolume or
  PersistentVolumeClaim objects if they are still being used.
- `StorageVersionAPI`: Enable the
  [storage version API](/docs/reference/generated/kubernetes-api/v1.22/#storageversion-v1alpha1-internal-apiserver-k8s-io).
- `StorageVersionHash`: Allow API servers to expose the storage version hash in the
  discovery.
- `StreamingProxyRedirects`: Instructs the API server to intercept (and follow)
   redirects from the backend (kubelet) for streaming requests.
  Examples of streaming requests include the `exec`, `attach` and `port-forward` requests.
-->
<ul>
<li><code>StartupProbe</code>：在 kubelet 中启用
<a href="/zh/docs/concepts/workloads/pods/pod-lifecycle/#when-should-you-use-a-startup-probe">启动探针</a>。</li>
<li><code>StatefulSetMinReadySeconds</code>: 允许 StatefulSet 控制器采纳 <code>minReadySeconds</code> 设置。</li>
<li><code>StorageObjectInUseProtection</code>：如果仍在使用 PersistentVolume 或
PersistentVolumeClaim 对象，则将其删除操作推迟。</li>
<li><code>StorageVersionAPI</code>: 启用
<a href="/docs/reference/generated/kubernetes-api/v1.22/#storageversion-v1alpha1-internal-apiserver-k8s-io">存储版本 API</a>。</li>
<li><code>StorageVersionHash</code>：允许 API 服务器在版本发现中公开存储版本的哈希值。</li>
<li><code>StreamingProxyRedirects</code>：指示 API 服务器拦截（并跟踪）后端（kubelet）
的重定向以处理流请求。
流请求的例子包括 <code>exec</code>、<code>attach</code> 和 <code>port-forward</code> 请求。</li>
</ul>
<!--
- `SupportIPVSProxyMode`: Enable providing in-cluster service load balancing using IPVS.
  See [service proxies](/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies) for more details.
- `SupportNodePidsLimit`: Enable the support to limiting PIDs on the Node.
  The parameter `pid=<number>` in the `--system-reserved` and `--kube-reserved`
  options can be specified to ensure that the specified number of process IDs
  will be reserved for the system as a whole and for Kubernetes system daemons
  respectively.
- `SupportPodPidsLimit`: Enable the support to limiting PIDs in Pods.
- `SuspendJob`: Enable support to suspend and resume Jobs. See
  [the Jobs docs](/docs/concepts/workloads/controllers/job/) for
  more details.
- `Sysctls`: Enable support for namespaced kernel parameters (sysctls) that can be
  set for each pod. See
  [sysctls](/docs/tasks/administer-cluster/sysctl-cluster/) for more details.
-->
<ul>
<li><code>SupportIPVSProxyMode</code>：启用使用 IPVS 提供内服务负载平衡。更多详细信息，请参见
<a href="/zh/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies">服务代理</a>。</li>
<li><code>SupportNodePidsLimit</code>：启用支持，限制节点上的 PID 用量。
<code>--system-reserved</code> 和 <code>--kube-reserved</code> 中的参数 <code>pid=&lt;数值&gt;</code> 可以分别用来
设定为整个系统所预留的进程 ID 个数和为 Kubernetes 系统守护进程预留的进程
ID 个数。</li>
<li><code>SupportPodPidsLimit</code>：启用支持限制 Pod 中的进程 PID。</li>
<li><code>SuspendJob</code>： 启用支持以暂停和恢复作业。 更多详细信息，请参见
<a href="zh//docs/concepts/workloads/controllers/job/">Jobs 文档</a>。</li>
<li><code>Sysctls</code>：允许为每个 Pod 设置的名字空间内核参数（sysctls）。
更多详细信息，请参见 <a href="/zh/docs/tasks/administer-cluster/sysctl-cluster/">sysctls</a>。</li>
</ul>
<!--
- `TTLAfterFinished`: Allow a
  [TTL controller](/docs/concepts/workloads/controllers/ttlafterfinished/)
  to clean up resources after they finish execution.
- `TaintBasedEvictions`: Enable evicting pods from nodes based on taints on Nodes
  and tolerations on Pods.
  See [taints and tolerations](/docs/concepts/scheduling-eviction/taint-and-toleration/)
  for more details.
- `TaintNodesByCondition`: Enable automatic tainting nodes based on
  [node conditions](/docs/concepts/architecture/nodes/#condition).
- `TokenRequest`: Enable the `TokenRequest` endpoint on service account resources.
- `TokenRequestProjection`: Enable the injection of service account tokens into a
  Pod through a [`projected` volume](/docs/concepts/storage/volumes/#projected).
- `TopologyAwareHints`: Enables topology aware routing based on topology hints
  in EndpointSlices. See [Topology Aware
  Hints](/docs/concepts/services-networking/topology-aware-hints/) for more
  details.
- `TopologyManager`: Enable a mechanism to coordinate fine-grained hardware resource
  assignments for different components in Kubernetes. See
  [Control Topology Management Policies on a node](/docs/tasks/administer-cluster/topology-manager/).
-->
<ul>
<li><code>TTLAfterFinished</code>：资源完成执行后，允许
<a href="/zh/docs/concepts/workloads/controllers/ttlafterfinished/">TTL 控制器</a>清理资源。</li>
<li><code>TaintBasedEvictions</code>：根据节点上的污点和 Pod 上的容忍度启用从节点驱逐 Pod 的特性。
更多详细信息可参见<a href="/zh/docs/concepts/scheduling-eviction/taint-and-toleration/">污点和容忍度</a>。</li>
<li><code>TaintNodesByCondition</code>：根据<a href="/zh/docs/concepts/scheduling-eviction/taint-and-toleration/">节点状况</a>
启用自动为节点标记污点。</li>
<li><code>TokenRequest</code>：在服务帐户资源上启用 <code>TokenRequest</code> 端点。</li>
<li><code>TokenRequestProjection</code>：启用通过
<a href="/zh/docs/concepts/storage/volumes/#projected"><code>projected</code> 卷</a>
将服务帐户令牌注入到 Pod 中的特性。</li>
<li><code>TopologyAwareHints</code>： 在 EndpointSlices 中启用基于拓扑提示的拓扑感知路由。
更多详细信息可参见<a href="/zh/docs/concepts/services-networking/topology-aware-hints/">Topology Aware Hints</a></li>
<li><code>TopologyManager</code>：启用一种机制来协调 Kubernetes 不同组件的细粒度硬件资源分配。
详见<a href="/zh/docs/tasks/administer-cluster/topology-manager/">控制节点上的拓扑管理策略</a>。</li>
</ul>
<!--
- `ValidateProxyRedirects`: This flag controls whether the API server should
  validate that redirects are only followed to the same host. Only used if the
  `StreamingProxyRedirects` flag is enabled.
- `VolumeCapacityPriority`: Enable support for prioritizing nodes in different
  topologies based on available PV capacity.
- `VolumePVCDataSource`: Enable support for specifying an existing PVC as a DataSource.
- `VolumeScheduling`: Enable volume topology aware scheduling and make the
  PersistentVolumeClaim (PVC) binding aware of scheduling decisions. It also
  enables the usage of [`local`](/docs/concepts/storage/volumes/#local) volume
  type when used together with the `PersistentLocalVolumes` feature gate.
- `VolumeSnapshotDataSource`: Enable volume snapshot data source support.
- `VolumeSubpath`: Allow mounting a subpath of a volume in a container.
-->
<ul>
<li><code>ValidateProxyRedirects</code>： 这个标志控制 API 服务器是否应该验证只跟随到相同的主机的重定向。
仅在启用 <code>StreamingProxyRedirects</code> 标志时被使用。</li>
<li><code>VolumeCapacityPriority</code>: 基于可用 PV 容量的拓扑，启用对不同节点的优先级支持。</li>
<li><code>VolumePVCDataSource</code>：启用对将现有 PVC 指定数据源的支持。</li>
<li><code>VolumeScheduling</code>：启用卷拓扑感知调度，并使 PersistentVolumeClaim（PVC）
绑定能够了解调度决策；当与 PersistentLocalVolumes 特性门控一起使用时，
还允许使用 <a href="/zh/docs/concepts/storage/volumes/#local"><code>local</code></a> 卷类型。</li>
<li><code>VolumeSnapshotDataSource</code>：启用卷快照数据源支持。</li>
<li><code>VolumeSubpath</code>： 允许在容器中挂载卷的子路径。</li>
</ul>
<!--
- `VolumeSubpathEnvExpansion`: Enable `subPathExpr` field for expanding environment
  variables into a `subPath`.
- `WarningHeaders`: Allow sending warning headers in API responses.
- `WatchBookmark`: Enable support for watch bookmark events.
- `WinDSR`: Allows kube-proxy to create DSR loadbalancers for Windows.
- `WinOverlay`: Allows kube-proxy to run in overlay mode for Windows.
- `WindowsEndpointSliceProxying`: When enabled, kube-proxy running on Windows
  will use EndpointSlices as the primary data source instead of Endpoints,
  enabling scalability and performance improvements. See
  [Enabling Endpoint Slices](/docs/concepts/administer-cluster/enabling-endpointslices/).
- `WindowsGMSA`: Enables passing of GMSA credential specs from pods to container runtimes.
- `WindowsHostProcessContainers`: Enables support for Windows HostProcess containers.
- `WindowsRunAsUserName` : Enable support for running applications in Windows containers
  with as a non-default user. See
  [Configuring RunAsUserName](/docs/tasks/configure-pod-container/configure-runasusername)
  for more details.
-->
<ul>
<li><code>VolumeSubpathEnvExpansion</code>：启用 <code>subPathExpr</code> 字段用于将环境变量在 <code>subPath</code>
中展开。</li>
<li><code>WarningHeaders</code>：允许在 API 响应中发送警告头部。</li>
<li><code>WatchBookmark</code>：启用对 watch 操作中 bookmark 事件的支持。</li>
<li><code>WinDSR</code>：允许 kube-proxy 为 Windows 创建 DSR 负载均衡。</li>
<li><code>WinOverlay</code>：允许 kube-proxy 在 Windows 的覆盖网络模式下运行。</li>
<li><code>WindowsEndpointSliceProxying</code>: 当启用时，运行在 Windows 上的 kube-proxy
将使用 EndpointSlices 而不是 Endpoints 作为主要数据源，从而实现可伸缩性和并改进性能。
详情请参见<a href="/zh/docs/tasks/administer-cluster/enabling-endpointslices/">启用端点切片</a>.</li>
<li><code>WindowsGMSA</code>：允许将 GMSA 凭据规范从 Pod 传递到容器运行时。</li>
<li><code>WindowsHostProcessContainers</code>: 启用对 Windows HostProcess 容器的支持。</li>
<li><code>WindowsRunAsUserName</code>：提供使用非默认用户在 Windows 容器中运行应用程序的支持。
详情请参见
<a href="/zh/docs/tasks/configure-pod-container/configure-runasusername">配置 RunAsUserName</a>。</li>
</ul>
<h2 id="接下来">接下来</h2>
<!--
* The [deprecation policy](/docs/reference/using-api/deprecation-policy/) for Kubernetes explains
  the project's approach to removing features and components.
-->
<ul>
<li>Kubernetes 的<a href="/zh/docs/reference/using-api/deprecation-policy/">弃用策略</a>
介绍了项目针对已移除特性和组件的处理方法。</li>
</ul>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-29e506a6018204679ef5459653a7aa1f">9.2 - kubelet</h1>
    
	<h2 id="简介">简介</h2>
<!--
The kubelet is the primary "node agent" that runs on each
node. It can register the node with the apiserver using one of: the hostname; a flag to override the hostname; or specific logic for a cloud provider.
-->
<p>kubelet 是在每个 Node 节点上运行的主要 “节点代理”。它可以使用以下之一向 apiserver 注册：
主机名（hostname）；覆盖主机名的参数；某云驱动的特定逻辑。</p>
<!--
The kubelet works in terms of a PodSpec. A PodSpec is a YAML or JSON object
that describes a pod. The kubelet takes a set of PodSpecs that are provided through various mechanisms (primarily through the apiserver) and ensures that the containers described in those PodSpecs are running and healthy. The kubelet doesn't manage containers which were not created by Kubernetes.
-->
<p>kubelet 是基于 PodSpec 来工作的。每个 PodSpec 是一个描述 Pod 的 YAML 或 JSON 对象。
kubelet 接受通过各种机制（主要是通过 apiserver）提供的一组 PodSpec，并确保这些
PodSpec 中描述的容器处于运行状态且运行状况良好。
kubelet 不管理不是由 Kubernetes 创建的容器。</p>
<!--
Other than from an PodSpec from the apiserver, there are three ways that a container manifest can be provided to the Kubelet.
-->
<p>除了来自 apiserver 的 PodSpec 之外，还可以通过以下三种方式将容器清单（manifest）提供给 kubelet。</p>
<!--
File: Path passed as a flag on the command line. Files under this path will be monitored periodically for updates. The monitoring period is 20s by default and is configurable via a flag.
-->
<p>文件（File）：利用命令行参数传递路径。kubelet 周期性地监视此路径下的文件是否有更新。
监视周期默认为 20s，且可通过参数进行配置。</p>
<!--
HTTP endpoint: HTTP endpoint passed as a parameter on the command line. This endpoint is checked every 20 seconds (also configurable with a flag).
-->
<p>HTTP 端点（HTTP endpoint）：利用命令行参数指定 HTTP 端点。
此端点的监视周期默认为 20 秒，也可以使用参数进行配置。</p>
<!--
HTTP server: The kubelet can also listen for HTTP and respond to a simple API (underspec'd currently) to submit a new manifest.
-->
<p>HTTP 服务器（HTTP server）：kubelet 还可以侦听 HTTP 并响应简单的 API
（目前没有完整规范）来提交新的清单。</p>
<pre tabindex="0"><code>kubelet [flags]
</code></pre><h2 id="选项">选项</h2>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--add-dir-header</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
If true, adds the file directory to the header
-->
设置为 true 表示将文件目录添加到日志消息的头部
</td>
</tr>
<tr>
<td colspan="2">--address ip&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值：0.0.0.0</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The IP address for the Kubelet to serve on (set to `0.0.0.0` for all IPv4 interfaces and `::` for all IPv6 interfaces)  (DEPRECATED: This parameter should be set via the config file specified by the Kubelet's `--config` flag. See https://kubernetes.io/docs/tasks/administer-cluster/kubelet-config-file/ for more information.)
-->
kubelet 用来提供服务的 IP 地址（设置为<code>0.0.0.0</code> 表示使用所有 IPv4 接口，
设置为 <code>::</code> 表示使用所有 IPv6 接口）。已弃用：应在 <code>--config</code> 所给的
配置文件中进行设置。（<a href="https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/">进一步了解</a>）
</td>
</tr>
<tr>
<td colspan="2">--allowed-unsafe-sysctls strings</td>
</tr>  
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Comma-separated whitelist of unsafe sysctls or unsafe sysctl patterns (ending in `*`). Use these at your own risk. (DEPRECATED: This parameter should be set via the config file specified by the Kubelet's `--config` flag. See https://kubernetes.io/docs/tasks/administer-cluster/kubelet-config-file/ for more information.)
-->
用逗号分隔的字符串序列设置允许使用的非安全的 sysctls 或 sysctl 模式（以 <code>*</code> 结尾) 。
使用此参数时风险自担。已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href="https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/">进一步了解</a>）.
</td>
</tr>
<tr>
<td colspan="2">--alsologtostderr</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
log to standard error as well as files
-->
设置为 true 表示将日志输出到文件的同时输出到 stderr
</td>
</tr>
<tr>
<td colspan="2">--anonymous-auth&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值：true</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Enables anonymous requests to the Kubelet server. Requests that are not rejected by another authentication method are treated as anonymous requests. Anonymous requests have a username of `system:anonymous`, and a group name of `system:unauthenticated`. (DEPRECATED: This parameter should be set via the config file specified by the Kubelet's `--config` flag. See https://kubernetes.io/docs/tasks/administer-cluster/kubelet-config-file/ for more information.)
-->
设置为 true 表示 kubelet 服务器可以接受匿名请求。未被任何认证组件拒绝的请求将被视为匿名请求。
匿名请求的用户名为 <code>system:anonymous</code>，用户组为 <code>system:unauthenticated</code>。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href="https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/">进一步了解</a>）
</td>
</tr>
<tr>
<td colspan="2">--authentication-token-webhook</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Use the TokenReview API to determine authentication for bearer tokens. (DEPRECATED: This parameter should be set via the config file specified by the Kubelet's --config flag. See https://kubernetes.io/docs/tasks/administer-cluster/kubelet-config-file/ for more information.)
-->
使用 <code>TokenReview</code> API 对持有者令牌进行身份认证。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href="https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/">进一步了解</a>）
</td>
</tr>
<tr>
<td colspan="2">--authentication-token-webhook-cache-ttl duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值：<code>2m0s</code></td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The duration to cache responses from the webhook token authenticator. (default 2m0s) (DEPRECATED: This parameter should be set via the config file specified by the Kubelet's --config flag. See https://kubernetes.io/docs/tasks/administer-cluster/kubelet-config-file/ for more information.)
-->
对 Webhook 令牌认证组件所返回的响应的缓存时间。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href="https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/">进一步了解</a>）
</td>
</tr>
<tr>
<td colspan="2">--authorization-mode string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Authorization mode for Kubelet server. Valid options are `AlwaysAllow` or `Webhook`. `Webhook` mode uses the `SubjectAccessReview` API to determine authorization. (default "AlwaysAllow" when `--config` flag is not provided; "Webhook" when `--config` flag presents.) (DEPRECATED: This parameter should be set via the config file specified by the Kubelet's --config flag. See https://kubernetes.io/docs/tasks/administer-cluster/kubelet-config-file/ for more information.)
-->
kubelet 服务器的鉴权模式。可选值包括：<code>AlwaysAllow</code>、<code>Webhook</code>。<code>Webhook</code> 模式使用 <code>SubjectAccessReview</code> API 鉴权。
当 <code>--config</code> 参数未被设置时，默认值为 <code>AlwaysAllow</code>，当使用了
<code>--config</code> 时，默认值为 <code>Webhook</code>。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href="https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/">进一步了解</a>）
</td>
</tr>
<tr>
<td colspan="2">--authorization-webhook-cache-authorized-ttl duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值：<code>5m0s</code></td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The duration to cache 'authorized' responses from the webhook authorizer. (DEPRECATED: This parameter should be set via the config file specified by the Kubelet's `--config` flag. See https://kubernetes.io/docs/tasks/administer-cluster/kubelet-config-file/ for more information.)
-->
对 Webhook 认证组件所返回的 “Authorized（已授权）” 应答的缓存时间。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href="https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/">进一步了解</a>）
</td>
</tr>
<tr>
<td colspan="2">--authorization-webhook-cache-unauthorized-ttl duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default: `30s`-->默认值：<code>30s</code></td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The duration to cache 'unauthorized' responses from the webhook authorizer. (DEPRECATED: This parameter should be set via the config file specified by the Kubelet's `--config` flag. See https://kubernetes.io/docs/tasks/administer-cluster/kubelet-config-file/ for more information.)
-->
对 Webhook 认证组件所返回的 “Unauthorized（未授权）” 应答的缓存时间。
<code>--config</code> 时，默认值为 <code>Webhook</code>。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href="https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/">进一步了解</a>）
</td>
</tr>
<tr>
<td colspan="2">--azure-container-registry-config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to the file container Azure container registry configuration information.
-->
包含 Azure 容器镜像库配置信息的文件的路径。
</td>
</tr>
<tr>
<td colspan="2">--bootstrap-kubeconfig string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to a kubeconfig file that will be used to get client certificate for kubelet. If the file specified by `--kubeconfig` does not exist, the bootstrap kubeconfig is used to request a client certificate from the API server. On success, a kubeconfig file referencing the generated client certificate and key is written to the path specified by `--kubeconfig`. The client certificate and key file will be stored in the directory pointed by `--cert-dir`.
-->
某 kubeconfig 文件的路径，该文件将用于获取 kubelet 的客户端证书。
如果 <code>--kubeconfig</code> 所指定的文件不存在，则使用引导所用 kubeconfig
从 API 服务器请求客户端证书。成功后，将引用生成的客户端证书和密钥的 kubeconfig
写入 --kubeconfig 所指定的路径。客户端证书和密钥文件将存储在 <code>--cert-dir</code>
所指的目录。
</td>
</tr>
<tr>
<td colspan="2">--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default: `/var/lib/kubelet/pki`-->默认值：<code>/var/lib/kubelet/pki</code></td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The directory where the TLS certs are located. If `--tls-cert-file` and `--tls-private-key-file` are provided, this flag will be ignored.
-->
TLS 证书所在的目录。如果设置了 <code>--tls-cert-file</code> 和 <code>--tls-private-key-file</code>，
则此标志将被忽略。
</td>
</tr>
<tr>
<td colspan="2">--cgroup-driver string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!-- Default: `cgroupfs`-->默认值：<code>cgroupfs</code></td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Driver that the kubelet uses to manipulate cgroups on the host.  Possible values: `cgroupfs`, `systemd`. (DEPRECATED: This parameter should be set via the config file specified by the Kubelet's `--config` flag. See https://kubernetes.io/docs/tasks/administer-cluster/kubelet-config-file/ for more information.)
-->
kubelet 用来操作本机 cgroup 时使用的驱动程序。支持的选项包括 <code>cgroupfs</code>
和 <code>systemd</code>。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href="https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/">进一步了解</a>）
/td>
</tr>
<tr>
<td colspan="2">--cgroup-root string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default: `''`-->默认值：<code>""</code></td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Optional root cgroup to use for pods. This is handled by the container runtime on a best effort basis. Default: '', which means use the container runtime default. (DEPRECATED: This parameter should be set via the config file specified by the Kubelet's --config flag. See https://kubernetes.io/docs/tasks/administer-cluster/kubelet-config-file/ for more information.)
-->
可选的选项，为 Pod 设置根 cgroup。容器运行时会尽可能使用此配置。
默认值 <code>""</code> 意味着将使用容器运行时的默认设置。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href="https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/">进一步了解</a>）
</td>
</tr>
<tr>
<td colspan="2">--cgroups-per-qos&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!-- Default: `true`-->默认值：<code>true</code></td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Enable creation of QoS cgroup hierarchy, if true top level QoS and pod cgroups are created. (DEPRECATED: This parameter should be set via the config file specified by the Kubelet's `--config` flag. See https://kubernetes.io/docs/tasks/administer-cluster/kubelet-config-file/ for more information.)
-->
启用创建 QoS cgroup 层次结构。此值为 true 时 kubelet 为 QoS 和 Pod 创建顶级的 cgroup。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href="https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/">进一步了解</a>）
</td>
</tr>
<tr>
<td colspan="2">--chaos-chance float</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
If &gt; 0.0, introduce random client errors and latency. Intended for testing. (DEPRECATED: will be removed in a future version.)
-->
如果此值大于 0.0，则引入随机客户端错误和延迟。用于测试。
已启用：将在未来版本中移除。
</td>
</tr>
<tr>
<td colspan="2">--client-ca-file string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
If set, any request presenting a client certificate signed by one of the authorities in the client-ca-file is authenticated with an identity corresponding to the CommonName of the client certificate. (DEPRECATED: This parameter should be set via the config file specified by the Kubelet's --config flag. See https://kubernetes.io/docs/tasks/administer-cluster/kubelet-config-file/ for more information.)
-->
如果设置了此参数，则使用对应文件中机构之一检查请求中所携带的客户端证书。
若客户端证书通过身份认证，则其对应身份为其证书中所设置的 CommonName。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href="https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/">进一步了解</a>）
</td>
</tr>
<tr>
<td colspan="2">--cloud-config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The path to the cloud provider configuration file. Empty string for no configuration file. (DEPRECATED: will be removed in 1.23, in favor of removing cloud providers code from Kubelet.)
-->
云驱动配置文件的路径。空字符串表示没有配置文件。
已弃用：将在 1.23 版本中移除，以便于从 kubelet 中去除云驱动代码。
</td>
</tr>
<tr>
<td colspan="2">--cloud-provider string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The provider for cloud services. Set to empty string for running with no cloud provider. If set, the cloud provider determines the name of the node (consult cloud provider documentation to determine if and how the hostname is used). (DEPRECATED: will be removed in 1.23, in favor of removing cloud provider code from Kubelet.)
-->
云服务的提供者。设置为空字符串表示在没有云驱动的情况下运行。
如果设置了此标志，则云驱动负责确定节点的名称（参考云提供商文档以确定是否以及如何使用主机名）。
已弃用：将在 1.23 版本中移除，以便于从 kubelet 中去除云驱动代码。
</td>
</tr>
<tr>
<td colspan="2">--cluster-dns strings</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Comma-separated list of DNS server IP address. This value is used for containers DNS server in case of Pods with "dnsPolicy=ClusterFirst". Note: all DNS servers appearing in the list MUST serve the same set of records otherwise name resolution within the cluster may not work correctly. There is no guarantee as to which DNS server may be contacted for name resolution. (DEPRECATED: This parameter should be set via the config file specified by the Kubelet's `--config` flag. See https://kubernetes.io/docs/tasks/administer-cluster/kubelet-config-file/ for more information.)
-->
DNS 服务器的 IP 地址，以逗号分隔。此标志值用于 Pod 中设置了 “<code>dnsPolicy=ClusterFirst</code>”
时为容器提供 DNS 服务。注意：列表中出现的所有 DNS 服务器必须包含相同的记录组，
否则集群中的名称解析可能无法正常工作。至于名称解析过程中会牵涉到哪些 DNS 服务器，
这一点无法保证。
<code>--config</code> 时，默认值为 <code>Webhook</code>。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href="https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/">进一步了解</a>）
</td>
</tr>
<tr>
<td colspan="2">--cluster-domain string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Domain for this cluster. If set, kubelet will configure all containers to search this domain in addition to the host's search domains (DEPRECATED: This parameter should be set via the config file specified by the Kubelet's `--config` flag. See https://kubernetes.io/docs/tasks/administer-cluster/kubelet-config-file/ for more information.)
-->
集群的域名。如果设置了此值，kubelet 除了将主机的搜索域配置到所有容器之外，还会为其
配置所搜这里指定的域名。
<code>--config</code> 时，默认值为 <code>Webhook</code>。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href="https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/">进一步了解</a>）
</td>
</tr>
<tr>
<td colspan="2">--cni-bin-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!-- Default: `/opt/cni/bin`-->默认值：<code>/opt/cni/bin</code></td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
&lt;Warning: Alpha feature&gt; A comma-separated list of full paths of directories in which to search for CNI plugin binaries. This docker-specific flag only works when container-runtime is set to `docker`.
-->
&lt;警告：alpha 特性&gt; 此值为以逗号分隔的完整路径列表。
kubelet 将在所指定路径中搜索 CNI 插件的可执行文件。
仅当容器运行环境设置为 <code>docker</code> 时，此特定于 docker 的参数才有效。
</td>
</tr>
<tr>
<td colspan="2">--cni-cache-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!-- Default: `/var/lib/cni/cache`-->默认值：<code>/var/lib/cni/cache</code></td>
</tr>
<tr>                                            
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
&lt;Warning: Alpha feature&gt; The full path of the directory in which CNI should store cache files. This docker-specific flag only works when container-runtime is set to `docker`.
-->
&lt;警告：alpha 特性&gt; 此值为一个目录的全路径名。CNI 将在其中缓存文件。
仅当容器运行环境设置为 <code>docker</code> 时，此特定于 docker 的参数才有效。
</td>
</tr>
<tr>
<td colspan="2">--cni-conf-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!-- Default: `/etc/cni/net.d`-->默认值：<code>/etc/cni/net.d</code></td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
&lt;Warning: Alpha feature&gt; The full path of the directory in which to search for CNI config files. This docker-specific flag only works when container-runtime is set to `docker`.
-->
&lt;警告：alpha 特性&gt; 此值为某目录的全路径名。kubelet 将在其中搜索 CNI 配置文件。
仅当容器运行环境设置为 <code>docker</code> 时，此特定于 docker 的参数才有效。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The Kubelet will load its initial configuration from this file. The path may be absolute or relative; relative paths start at the Kubelet's current working directory. Omit this flag to use the built-in default configuration values. Command-line flags override configuration from this file.
-->
kubelet 将从此标志所指的文件中加载其初始配置。此路径可以是绝对路径，也可以是相对路径。
相对路径按 kubelet 的当前工作目录起计。省略此参数时 kubelet 会使用内置的默认配置值。
命令行参数会覆盖此文件中的配置。
</td>
</tr>
<tr>
<td colspan="2">--container-log-max-files int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default: 5-->默认值：5</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Set the maximum number of container log files that can be present for a container. The number must be &ge; 2. This flag can only be used with `--container-runtime=remote`. (DEPRECATED: This parameter should be set via the config file specified by the Kubelet's --config flag. See https://kubernetes.io/docs/tasks/administer-cluster/kubelet-config-file/ for more information.)
-->
设置容器的日志文件个数上限。此值必须不小于 2。
此标志只能与 <code>--container-runtime=remote</code> 标志一起使用。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href="https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/">进一步了解</a>）
</td>
</tr>    
<tr>
<td colspan="2">--container-log-max-size string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!-- Default: `10Mi`-->默认值：<code>10Mi</code></td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Set the maximum size (e.g. 10Mi) of container log file before it is rotated. This flag can only be used with `--container-runtime=remote`.  (DEPRECATED: This parameter should be set via the config file specified by the Kubelet's --config flag. See https://kubernetes.io/docs/tasks/administer-cluster/kubelet-config-file/ for more information.)
-->
设置容器日志文件在轮换生成新文件时之前的最大值（例如，<code>10Mi</code>）。
此标志只能与 <code>--container-runtime=remote</code> 标志一起使用。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href="https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/">进一步了解</a>）
</td>
</tr>
<tr>
<td colspan="2">--container-runtime string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default: `docker`-->默认值：<code>docker</code></td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The container runtime to use. Possible values: `docker`, `remote`.
-->
要使用的容器运行时。目前支持 <code>docker<code>、</code>remote</code>。
</td>
</tr>
<tr>
<td colspan="2">--container-runtime-endpoint string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default: `unix:///var/run/dockershim.sock`-->默认值：<code>unix:///var/run/dockershim.sock</code></td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[Experimental] The endpoint of remote runtime service. Currently unix socket endpoint is supported on Linux, while npipe and tcp endpoints are supported on windows. Examples: `unix:///var/run/dockershim.sock`, `npipe:////./pipe/dockershim`.
-->
[实验性特性] 远程运行时服务的端点。目前支持 Linux 系统上的 UNIX 套接字和
Windows 系统上的 npipe 和 TCP 端点。例如：
<code>unix:///var/run/dockershim.sock</code>、
<code>npipe:////./pipe/dockershim</code>。
</td>
</tr>
<tr>
<td colspan="2">--contention-profiling</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Enable lock contention profiling, if profiling is enabled (DEPRECATED: This parameter should be set via the config file specified by the Kubelet's --config flag. See https://kubernetes.io/docs/tasks/administer-cluster/kubelet-config-file/ for more information.)
-->
当启用了性能分析时，启用锁竞争分析。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href="https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/">进一步了解</a>）
</td>
</tr>
<tr>
<td colspan="2">--cpu-cfs-quota&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default: `true`-->默认值：<code>true</code></td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Enable CPU CFS quota enforcement for containers that specify CPU limits (DEPRECATED: This parameter should be set via the config file specified by the Kubelet's `--config` flag. See https://kubernetes.io/docs/tasks/administer-cluster/kubelet-config-file/ for more information.)
-->
为设置了 CPU 限制的容器启用 CPU CFS 配额保障。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href="https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/">进一步了解</a>）
</td>
</tr>
<tr>
<td colspan="2">--cpu-cfs-quota-period duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default: `100ms`-->默认值：<code>100ms</code></td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Sets CPU CFS quota period value, `cpu.cfs_period_us`, defaults to Linux Kernel default. (DEPRECATED: This parameter should be set via the config file specified by the Kubelet's `--config` flag. See https://kubernetes.io/docs/tasks/administer-cluster/kubelet-config-file/ for more information.)
-->
设置 CPU CFS 配额周期 <code>cpu.cfs_period_us</code>。默认使用 Linux 内核所设置的默认值 。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href="https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/">进一步了解</a>）
</td>
</tr>
<tr>
<td colspan="2">--cpu-manager-policy string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：<code>none</code></td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
CPU Manager policy to use. Possible values: 'none', 'static'. Default: 'none' (default "none") (DEPRECATED: This parameter should be set via the config file specified by the Kubelet's --config flag. See https://kubernetes.io/docs/tasks/administer-cluster/kubelet-config-file/ for more information.)
-->
要使用的 CPU 管理器策略。可选值包括：<code>none</code> 和 <code>static</code>。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href="https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/">进一步了解</a>）
</td>
</tr>
<tr>
<td colspan="2">--cpu-manager-reconcile-period duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default: `10s`-->默认值：<code>10s</code></td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
&lt;Warning: Alpha feature&gt; CPU Manager reconciliation period. Examples: `10s`, or `1m`. If not supplied, defaults to node status update frequency. (DEPRECATED: This parameter should be set via the config file specified by the Kubelet's `--config` flag. See https://kubernetes.io/docs/tasks/administer-cluster/kubelet-config-file/ for more information.)
-->
&lt;警告：alpha 特性&gt; 设置 CPU 管理器的调和时间。例如：<code>10s</code> 或者 <code>1m</code>。
如果未设置，默认使用节点状态更新频率。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href="https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/">进一步了解</a>）
</td>
</tr>
<tr>
<td colspan="2">--docker-endpoint string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default: `unix:///var/run/docker.sock`-->默认值：<code>unix:///var/run/docker.sock</code></td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Use this for the `docker` endpoint to communicate with. This docker-specific flag only works when container-runtime is set to `docker`.
-->
使用这里的端点与 docker 端点通信。
仅当容器运行环境设置为 <code>docker</code> 时，此特定于 docker 的参数才有效。
</td>
</tr>
<tr>
<td colspan="2">--dynamic-config-dir string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The Kubelet will use this directory for checkpointing downloaded configurations and tracking configuration health. The Kubelet will create this directory if it does not already exist. The path may be absolute or relative; relative paths start at the Kubelet's current working directory. Providing this flag enables dynamic Kubelet configuration. The `DynamicKubeletConfig` feature gate must be enabled to pass this flag; this gate currently defaults to `true` because the feature is beta.
-->
kubelet 使用此目录来保存所下载的配置，跟踪配置运行状况。
如果目录不存在，则 kubelet 创建该目录。此路径可以是绝对路径，也可以是相对路径。
相对路径从 kubelet 的当前工作目录计算。
设置此参数将启用动态 kubelet 配置。必须启用 <code>DynamicKubeletConfig</code>
特性门控之后才能设置此标志；由于此特性为 beta 阶段，对应的特性门控当前默认为
<code>true</code>。
</td>
</tr>
<tr>
<td colspan="2">--enable-controller-attach-detach&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default: `true`-->默认值：<code>true</code></td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Enables the Attach/Detach controller to manage attachment/detachment of volumes scheduled to this node, and disables kubelet from executing any attach/detach operations.
-->
启用 Attach/Detach 控制器来挂接和摘除调度到该节点的卷，同时禁用 kubelet 执行挂接和摘除操作。
</td>
</tr>
<tr>
<td colspan="2">--enable-debugging-handlers&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: `true`</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Enables server endpoints for log collection and local running of containers and commands (default true) (DEPRECATED: This parameter should be set via the config file specified by the Kubelet's --config flag. See https://kubernetes.io/docs/tasks/administer-cluster/kubelet-config-file/ for more information.)
-->
启用服务器上用于日志收集和在本地运行容器和命令的端点。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href="https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/">进一步了解</a>）
</td>
</tr>
<tr>
<td colspan="2">--enable-server&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!-- Default: `true`--></td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Enable the Kubelet's server. (DEPRECATED: This parameter should be set via the config file specified by the Kubelet's `--config` flag. See https://kubernetes.io/docs/tasks/administer-cluster/kubelet-config-file/ for more information.)
-->
启用 kubelet 服务器。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href="https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/">进一步了解</a>）
</td>
</tr>
<tr>
<td colspan="2">--enforce-node-allocatable strings&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: `pods`</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
A comma separated list of levels of node allocatable enforcement to be enforced by kubelet. Acceptable options are `none`, `pods`, `system-reserved`, and `kube-reserved`. If the latter two options are specified, `--system-reserved-cgroup` and `--kube-reserved-cgroup` must also be set, respectively. If `none` is specified, no additional options should be set. See https://kubernetes.io/docs/tasks/administer-cluster/reserve-compute-resources/ for more details. (DEPRECATED: This parameter should be set via the config file specified by the Kubelet's --config flag. See https://kubernetes.io/docs/tasks/administer-cluster/kubelet-config-file/ for more information.)
-->
用逗号分隔的列表，包含由 kubelet 强制执行的节点可分配资源级别。
可选配置为：<code>none</code>、<code>pods</code>、<code>system-reserved</code> 和 <code>kube-reserved</code>。
在设置 <code>system-reserved</code> 和 <code>kube-reserved</code> 这两个值时，同时要求设置
<code>--system-reserved-cgroup</code> 和 <code>--kube-reserved-cgroup</code> 这两个参数。
如果设置为 <code>none</code>，则不需要设置其他参数。
<a href="https://kubernetes.io/zh/docs/tasks/administer-cluster/reserve-compute-resources/">参考相关文档</a>。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href="https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/">进一步了解</a>）
</td>
</tr>
<tr>
<td colspan="2">--event-burst int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!-- Default: 10-->默认值：10</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Maximum size of a bursty event records, temporarily allows event records to burst to this number, while still not exceeding `--event-qps`. Only used if `--event-qps` &gt; 0. (DEPRECATED: This parameter should be set via the config file specified by the Kubelet's `--config` flag. See https://kubernetes.io/docs/tasks/administer-cluster/kubelet-config-file/ for more information.)
-->
事件记录的个数的突发峰值上限，在遵从 <code>--event-qps</code> 阈值约束的前提下
临时允许事件记录达到此数目。仅在 <code>--event-qps</code> 大于 0 时使用。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href="https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/">进一步了解</a>）
</td>
</tr>
<tr>
<td colspan="2">--event-qps int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: 5</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
If &gt; `0`, limit event creations per second to this value. If `0`, unlimited. (DEPRECATED: This parameter should be set via the config file specified by the Kubelet's `--config` flag. See https://kubernetes.io/docs/tasks/administer-cluster/kubelet-config-file/ for more information.)
-->
设置大于 0 的值表示限制每秒可生成的事件数量。设置为 0 表示不限制。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href="https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/">进一步了解</a>）
</td>
</tr>
<tr>
<td colspan="2">--eviction-hard string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default: `imagefs.available<15%,memory.available<100Mi,nodefs.available<10%`-->默认值：<code>imagefs.available&lt;15%,memory.available&lt;100Mi,nodefs.available&lt;10%</code></td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
A set of eviction thresholds (e.g. `memory.available<1Gi`) that if met would trigger a pod eviction. On a Linux node, the default value also includes `nodefs.inodesFree<5%`. (DEPRECATED: This parameter should be set via the config file specified by the Kubelet's `--config` flag. See https://kubernetes.io/docs/tasks/administer-cluster/kubelet-config-file/ for more information.)
-->
触发 Pod 驱逐操作的一组硬性门限（例如：<code>memory.available&lt;1Gi</code>
（内存可用值小于 1 G））设置。在 Linux 节点上，默认值还包括
<code>nodefs.inodesFree<5%</code>。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href="https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/">进一步了解</a>）
</td>
</tr>
<tr>
<td colspan="2">--eviction-max-pod-grace-period int32</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Maximum allowed grace period (in seconds) to use when terminating pods in response to a soft eviction threshold being met. If negative, defer to pod specified value. (DEPRECATED: This parameter should be set via the config file specified by the Kubelet's `--config` flag. See https://kubernetes.io/docs/tasks/administer-cluster/kubelet-config-file/ for more information.)
-->
响应满足软性驱逐阈值（Soft Eviction Threshold）而终止 Pod 时使用的最长宽限期（以秒为单位）。
如果设置为负数，则遵循 Pod 的指定值。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href="https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/">进一步了解</a>）
</td>
</tr>
<tr>
<td colspan="2">--eviction-minimum-reclaim mapStringString</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
A set of minimum reclaims (e.g. `imagefs.available=2Gi`) that describes the minimum amount of resource the kubelet will reclaim when performing a pod eviction if that resource is under pressure. (DEPRECATED: This parameter should be set via the config file specified by the Kubelet's `--config` flag. See https://kubernetes.io/docs/tasks/administer-cluster/kubelet-config-file/ for more information.)
-->
当某资源压力过大时，kubelet 将执行 Pod 驱逐操作。
此参数设置软性驱逐操作需要回收的资源的最小数量（例如：<code>imagefs.available=2Gi</code>）。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href="https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/">进一步了解</a>）
</td>
</tr>
<tr>
<td colspan="2">--eviction-pressure-transition-period duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default: `5m0s`-->默认值：<code>5m0s</code></td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Duration for which the kubelet has to wait before transitioning out of an eviction pressure condition. (DEPRECATED: This parameter should be set via the config file specified by the Kubelet's `--config` flag. See https://kubernetes.io/docs/tasks/administer-cluster/kubelet-config-file/ for more information.)
-->
kubelet 在驱逐压力状况解除之前的最长等待时间。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href="https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/">进一步了解</a>）
</td>
</tr>
<tr>
<td colspan="2">--eviction-soft mapStringString</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
A set of eviction thresholds (e.g. `memory.available>1.5Gi`) that if met over a corresponding grace period would trigger a pod eviction. (DEPRECATED: This parameter should be set via the config file specified by the Kubelet's `--config` flag. See https://kubernetes.io/docs/tasks/administer-cluster/kubelet-config-file/ for more information.)
-->
设置一组驱逐阈值（例如：<code>memory.available&lt;1.5Gi</code>）。
如果在相应的宽限期内达到该阈值，则会触发 Pod 驱逐操作。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href="https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/">进一步了解</a>）
</td>
</tr>
<tr>
<td colspan="2">--eviction-soft-grace-period mapStringString</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
A set of eviction grace periods (e.g. `memory.available=1m30s`) that correspond to how long a soft eviction threshold must hold before triggering a pod eviction. (DEPRECATED: This parameter should be set via the config file specified by the Kubelet's `--config` flag. See https://kubernetes.io/docs/tasks/administer-cluster/kubelet-config-file/ for more information.)
-->
设置一组驱逐宽限期（例如，<code>memory.available=1m30s</code>），对应于触发软性 Pod
驱逐操作之前软性驱逐阈值所需持续的时间长短。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href="https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/">进一步了解</a>）
</td>
</tr>
<tr>
<td colspan="2">--exit-on-lock-contention</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Whether kubelet should exit upon lock-file contention.
-->
设置为 true 表示当发生锁文件竞争时 kubelet 可以退出。
</td>
</tr>
<tr>
<td colspan="2">--experimental-allocatable-ignore-eviction&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default: `false`-->默认值：<code>false</code></td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
When set to `true`, Hard eviction thresholds will be ignored while calculating node allocatable. See https://kubernetes.io/docs/tasks/administer-cluster/reserve-compute-resources/ for more details. (DEPRECATED: will be removed in 1.23)
-->
设置为 <code>true</code> 表示在计算节点可分配资源数量时忽略硬性逐出阈值设置。
参考<a href="https://kubernetes.io/docs/tasks/administer-cluster/reserve-compute-resources/">
相关文档</a>。
已启用：将在 1.23 版本中移除。
</td>
</tr>
<tr>
<td colspan="2">--experimental-bootstrap-kubeconfig string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
(DEPRECATED: Use --bootstrap-kubeconfig)
-->
已弃用：应使用 <code>--bootstrap-kubeconfig</code> 标志
</td>
</tr>
<tr>
<td colspan="2">--experimental-check-node-capabilities-before-mount</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[Experimental] if set to `true`, the kubelet will check the underlying node for required components (binaries, etc.) before performing the mount (DEPRECATED: will be removed in 1.23, in favor of using CSI.)
-->
[实验性特性] 设置为 <code>true</code> 表示 kubelet 在进行挂载卷操作之前要
在本节点上检查所需的组件（如可执行文件等）是否存在。
已弃用：将在 1.23 版本中移除，以便使用 CSI。
</td>
</tr>
<tr>
<td colspan="2">--experimental-kernel-memcg-notification</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
If enabled, the kubelet will integrate with the kernel memcg notification to determine if memory eviction thresholds are crossed rather than polling. This flag will be removed in 1.23. (DEPRECATED: This parameter should be set via the config file specified by the Kubelet's `--config` flag. See https://kubernetes.io/docs/tasks/administer-cluster/kubelet-config-file/ for more information.)
-->
设置为 true 表示 kubelet 将会集成内核的 memcg 通知机制而不是使用轮询机制来
判断是否达到了内存驱逐阈值。
此标志将在 1.23 版本移除。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href="https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/">进一步了解</a>）
</td>
</tr>
<tr>
<td colspan="2">--experimental-log-sanitization</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[Experimental] When enabled prevents logging of fields tagged as sensitive (passwords, keys, tokens). Runtime log sanitization may introduce significant computation overhead and therefore should not be enabled in production. (DEPRECATED: This parameter should be set via the config file specified by the Kubelet's --config flag. See https://kubernetes.io/docs/tasks/administer-cluster/kubelet-config-file/ for more information.)
-->
[试验性功能] 启用此标志之后，kubelet 会避免将标记为敏感的字段（密码、密钥、令牌等）
写入日志中。运行时的日志清理可能会带来相当的计算开销，因此不应该在
产品环境中启用。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href="https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/">进一步了解</a>）
</tr>
<tr>
<td colspan="2">--experimental-mounter-path string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default: `mount`-->默认值：<code>mount</code></td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[Experimental] Path of mounter binary. Leave empty to use the default `mount`. (DEPRECATED: will be removed in 1.23, in favor of using CSI.)
-->
[实验性特性] 卷挂载器（mounter）的可执行文件的路径。设置为空表示使用默认挂载器 <code>mount</code>。
已弃用：将在 1.23 版本移除以支持 CSI。
</td>
</tr>
<tr>
<td colspan="2">--fail-swap-on&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default: `true`-->默认值：<code>true</code></td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Makes the Kubelet fail to start if swap is enabled on the node. (DEPRECATED: This parameter should be set via the config file specified by the Kubelet's `--config` flag. See https://kubernetes.io/docs/tasks/administer-cluster/kubelet-config-file/ for more information.)
-->
设置为 true 表示如果主机启用了交换分区，kubelet 将直接失败。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href="https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/">进一步了解</a>）
</td>
</tr>
<tr>
<td colspan="2">--feature-gates mapStringBool</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
A set of `key=value` pairs that describe feature gates for alpha/experimental features. Options are:<br/>
APIListChunking=true|false (BETA - default=true)<br/>
APIPriorityAndFairness=true|false (BETA - default=true)<br/>
APIResponseCompression=true|false (BETA - default=true)<br/>
APIServerIdentity=true|false (ALPHA - default=false)<br/>
AllAlpha=true|false (ALPHA - default=false)<br/>
AllBeta=true|false (BETA - default=false)<br/>
AllowInsecureBackendProxy=true|false (BETA - default=true)<br/>
AnyVolumeDataSource=true|false (ALPHA - default=false)<br/>
AppArmor=true|false (BETA - default=true)<br/>
BalanceAttachedNodeVolumes=true|false (ALPHA - default=false)<br/>
BoundServiceAccountTokenVolume=true|false (ALPHA - default=false)<br/>
CPUManager=true|false (BETA - default=true)<br/>
CSIInlineVolume=true|false (BETA - default=true)<br/>
CSIMigration=true|false (BETA - default=true)<br/>
CSIMigrationAWS=true|false (BETA - default=false)<br/>
CSIMigrationAWSComplete=true|false (ALPHA - default=false)<br/>
CSIMigrationAzureDisk=true|false (BETA - default=false)<br/>
CSIMigrationAzureDiskComplete=true|false (ALPHA - default=false)<br/>
CSIMigrationAzureFile=true|false (ALPHA - default=false)<br/>
CSIMigrationAzureFileComplete=true|false (ALPHA - default=false)<br/>
CSIMigrationGCE=true|false (BETA - default=false)<br/>
CSIMigrationGCEComplete=true|false (ALPHA - default=false)<br/>
CSIMigrationOpenStack=true|false (BETA - default=false)<br/>
CSIMigrationOpenStackComplete=true|false (ALPHA - default=false)<br/>
CSIMigrationvSphere=true|false (BETA - default=false)<br/>
CSIMigrationvSphereComplete=true|false (BETA - default=false)<br/>
CSIServiceAccountToken=true|false (ALPHA - default=false)<br/>
CSIStorageCapacity=true|false (ALPHA - default=false)<br/>
CSIVolumeFSGroupPolicy=true|false (BETA - default=true)<br/>
ConfigurableFSGroupPolicy=true|false (BETA - default=true)<br/>
CronJobControllerV2=true|false (ALPHA - default=false)<br/>
CustomCPUCFSQuotaPeriod=true|false (ALPHA - default=false)<br/>
DefaultPodTopologySpread=true|false (BETA - default=true)<br/>
DevicePlugins=true|false (BETA - default=true)<br/>
DisableAcceleratorUsageMetrics=true|false (BETA - default=true)<br/>
DownwardAPIHugePages=true|false (ALPHA - default=false)<br/>
DynamicKubeletConfig=true|false (BETA - default=true)<br/>
EfficientWatchResumption=true|false (ALPHA - default=false)<br/>
EndpointSlice=true|false (BETA - default=true)<br/>
EndpointSliceNodeName=true|false (ALPHA - default=false)<br/>
EndpointSliceProxying=true|false (BETA - default=true)<br/>
EndpointSliceTerminatingCondition=true|false (ALPHA - default=false)<br/>
EphemeralContainers=true|false (ALPHA - default=false)<br/>
ExpandCSIVolumes=true|false (BETA - default=true)<br/>
ExpandInUsePersistentVolumes=true|false (BETA - default=true)<br/>
ExpandPersistentVolumes=true|false (BETA - default=true)<br/>
ExperimentalHostUserNamespaceDefaulting=true|false (BETA - default=false)<br/>
GenericEphemeralVolume=true|false (ALPHA - default=false)<br/>
GracefulNodeShutdown=true|false (ALPHA - default=false)<br/>
HPAContainerMetrics=true|false (ALPHA - default=false)<br/>
HPAScaleToZero=true|false (ALPHA - default=false)<br/>
HugePageStorageMediumSize=true|false (BETA - default=true)<br/>
IPv6DualStack=true|false (ALPHA - default=false)<br/>
ImmutableEphemeralVolumes=true|false (BETA - default=true)<br/>
KubeletCredentialProviders=true|false (ALPHA - default=false)<br/>
KubeletPodResources=true|false (BETA - default=true)<br/>
LegacyNodeRoleBehavior=true|false (BETA - default=true)<br/>
LocalStorageCapacityIsolation=true|false (BETA - default=true)<br/>
LocalStorageCapacityIsolationFSQuotaMonitoring=true|false (ALPHA - default=false)<br/>
MixedProtocolLBService=true|false (ALPHA - default=false)<br/>
NodeDisruptionExclusion=true|false (BETA - default=true)<br/>
NonPreemptingPriority=true|false (BETA - default=true)<br/>
PodDisruptionBudget=true|false (BETA - default=true)<br/>
PodOverhead=true|false (BETA - default=true)<br/>
ProcMountType=true|false (ALPHA - default=false)<br/>
QOSReserved=true|false (ALPHA - default=false)<br/>
RemainingItemCount=true|false (BETA - default=true)<br/>
RemoveSelfLink=true|false (BETA - default=true)<br/>
RootCAConfigMap=true|false (BETA - default=true)<br/>
RotateKubeletServerCertificate=true|false (BETA - default=true)<br/>
RunAsGroup=true|false (BETA - default=true)<br/>
ServerSideApply=true|false (BETA - default=true)<br/>
ServiceAccountIssuerDiscovery=true|false (BETA - default=true)<br/>
ServiceLBNodePortControl=true|false (ALPHA - default=false)<br/>
ServiceNodeExclusion=true|false (BETA - default=true)<br/>
ServiceTopology=true|false (ALPHA - default=false)<br/>
SetHostnameAsFQDN=true|false (BETA - default=true)<br/>
SizeMemoryBackedVolumes=true|false (ALPHA - default=false)<br/>
StorageVersionAPI=true|false (ALPHA - default=false)<br/>
StorageVersionHash=true|false (BETA - default=true)<br/>
Sysctls=true|false (BETA - default=true)<br/>
TTLAfterFinished=true|false (ALPHA - default=false)<br/>
TopologyManager=true|false (BETA - default=true)<br/>
ValidateProxyRedirects=true|false (BETA - default=true)<br/>
WarningHeaders=true|false (BETA - default=true)<br/>
WinDSR=true|false (ALPHA - default=false)<br/>
WinOverlay=true|false (BETA - default=true)<br/>
WindowsEndpointSliceProxying=true|false (ALPHA - default=false)<br/>
(DEPRECATED: This parameter should be set via the config file specified by the Kubelet's `--config` flag. See https://kubernetes.io/docs/tasks/administer-cluster/kubelet-config-file/ for more information.)
-->
用于 alpha 实验性质的特性开关组，每个开关以 key=value 形式表示。当前可用开关包括：
APIListChunking=true|false (BETA - 默认值为 true)<br/>
APIPriorityAndFairness=true|false (BETA - 默认值为 true)<br/>
APIResponseCompression=true|false (BETA - 默认值为 true)<br/>
APIServerIdentity=true|false (ALPHA - 默认值为 false)<br/>
AllAlpha=true|false (ALPHA - 默认值为 false)<br/>
AllBeta=true|false (BETA - 默认值为 false)<br/>
AllowInsecureBackendProxy=true|false (BETA - 默认值为 true)<br/>
AnyVolumeDataSource=true|false (ALPHA - 默认值为 false)<br/>
AppArmor=true|false (BETA - 默认值为 true)<br/>
BalanceAttachedNodeVolumes=true|false (ALPHA - 默认值为 false)<br/>
BoundServiceAccountTokenVolume=true|false (ALPHA - 默认值为 false)<br/>
CPUManager=true|false (BETA - 默认值为 true)<br/>
CSIInlineVolume=true|false (BETA - 默认值为 true)<br/>
CSIMigration=true|false (BETA - 默认值为 true)<br/>
CSIMigrationAWS=true|false (BETA - 默认值为 false)<br/>
CSIMigrationAWSComplete=true|false (ALPHA - 默认值为 false)<br/>
CSIMigrationAzureDisk=true|false (BETA - 默认值为 false)<br/>
CSIMigrationAzureDiskComplete=true|false (ALPHA - 默认值为 false)<br/>
CSIMigrationAzureFile=true|false (ALPHA - 默认值为 false)<br/>
CSIMigrationAzureFileComplete=true|false (ALPHA - 默认值为 false)<br/>
CSIMigrationGCE=true|false (BETA - 默认值为 false)<br/>
CSIMigrationGCEComplete=true|false (ALPHA - 默认值为 false)<br/>
CSIMigrationOpenStack=true|false (BETA - 默认值为 false)<br/>
CSIMigrationOpenStackComplete=true|false (ALPHA - 默认值为 false)<br/>
CSIMigrationvSphere=true|false (BETA - 默认值为 false)<br/>
CSIMigrationvSphereComplete=true|false (BETA - 默认值为 false)<br/>
CSIServiceAccountToken=true|false (ALPHA - 默认值为 false)<br/>
CSIStorageCapacity=true|false (ALPHA - 默认值为 false)<br/>
CSIVolumeFSGroupPolicy=true|false (BETA - 默认值为 true)<br/>
ConfigurableFSGroupPolicy=true|false (BETA - 默认值为 true)<br/>
CronJobControllerV2=true|false (ALPHA - 默认值为 false)<br/>
CustomCPUCFSQuotaPeriod=true|false (ALPHA - 默认值为 false)<br/>
DefaultPodTopologySpread=true|false (BETA - 默认值为 true)<br/>
DevicePlugins=true|false (BETA - 默认值为 true)<br/>
DisableAcceleratorUsageMetrics=true|false (BETA - 默认值为 true)<br/>
DownwardAPIHugePages=true|false (ALPHA - 默认值为 false)<br/>
DynamicKubeletConfig=true|false (BETA - 默认值为 true)<br/>
EfficientWatchResumption=true|false (ALPHA - 默认值为 false)<br/>
EndpointSlice=true|false (BETA - 默认值为 true)<br/>
EndpointSliceNodeName=true|false (ALPHA - 默认值为 false)<br/>
EndpointSliceProxying=true|false (BETA - 默认值为 true)<br/>
EndpointSliceTerminatingCondition=true|false (ALPHA - 默认值为 false)<br/>
EphemeralContainers=true|false (ALPHA - 默认值为 false)<br/>
ExpandCSIVolumes=true|false (BETA - 默认值为 true)<br/>
ExpandInUsePersistentVolumes=true|false (BETA - 默认值为 true)<br/>
ExpandPersistentVolumes=true|false (BETA - 默认值为 true)<br/>
ExperimentalHostUserNamespaceDefaulting=true|false (BETA - 默认值为 false)<br/>
GenericEphemeralVolume=true|false (ALPHA - 默认值为 false)<br/>
GracefulNodeShutdown=true|false (ALPHA - 默认值为 false)<br/>
HPAContainerMetrics=true|false (ALPHA - 默认值为 false)<br/>
HPAScaleToZero=true|false (ALPHA - 默认值为 false)<br/>
HugePageStorageMediumSize=true|false (BETA - 默认值为 true)<br/>
IPv6DualStack=true|false (ALPHA - 默认值为 false)<br/>
ImmutableEphemeralVolumes=true|false (BETA - 默认值为 true)<br/>
KubeletCredentialProviders=true|false (ALPHA - 默认值为 false)<br/>
KubeletPodResources=true|false (BETA - 默认值为 true)<br/>
LegacyNodeRoleBehavior=true|false (BETA - 默认值为 true)<br/>
LocalStorageCapacityIsolation=true|false (BETA - 默认值为 true)<br/>
LocalStorageCapacityIsolationFSQuotaMonitoring=true|false (ALPHA - 默认值为 false)<br/>
MixedProtocolLBService=true|false (ALPHA - 默认值为 false)<br/>
NodeDisruptionExclusion=true|false (BETA - 默认值为 true)<br/>
NonPreemptingPriority=true|false (BETA - 默认值为 true)<br/>
PodDisruptionBudget=true|false (BETA - 默认值为 true)<br/>
PodOverhead=true|false (BETA - 默认值为 true)<br/>
ProcMountType=true|false (ALPHA - 默认值为 false)<br/>
QOSReserved=true|false (ALPHA - 默认值为 false)<br/>
RemainingItemCount=true|false (BETA - 默认值为 true)<br/>
RemoveSelfLink=true|false (BETA - 默认值为 true)<br/>
RootCAConfigMap=true|false (BETA - 默认值为 true)<br/>
RotateKubeletServerCertificate=true|false (BETA - 默认值为 true)<br/>
RunAsGroup=true|false (BETA - 默认值为 true)<br/>
ServerSideApply=true|false (BETA - 默认值为 true)<br/>
ServiceAccountIssuerDiscovery=true|false (BETA - 默认值为 true)<br/>
ServiceLBNodePortControl=true|false (ALPHA - 默认值为 false)<br/>
ServiceNodeExclusion=true|false (BETA - 默认值为 true)<br/>
ServiceTopology=true|false (ALPHA - 默认值为 false)<br/>
SetHostnameAsFQDN=true|false (BETA - 默认值为 true)<br/>
SizeMemoryBackedVolumes=true|false (ALPHA - 默认值为 false)<br/>
StorageVersionAPI=true|false (ALPHA - 默认值为 false)<br/>
StorageVersionHash=true|false (BETA - 默认值为 true)<br/>
Sysctls=true|false (BETA - 默认值为 true)<br/>
TTLAfterFinished=true|false (ALPHA - 默认值为 false)<br/>
TopologyManager=true|false (BETA - 默认值为 true)<br/>
ValidateProxyRedirects=true|false (BETA - 默认值为 true)<br/>
WarningHeaders=true|false (BETA - 默认值为 true)<br/>
WinDSR=true|false (ALPHA - 默认值为 false)<br/>
WinOverlay=true|false (BETA - 默认值为 true)<br/>
WindowsEndpointSliceProxying=true|false (ALPHA - 默认值为 false)<br/>
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href="https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/">进一步了解</a>）
</td>
</tr>
<tr>
<td colspan="2">--file-check-frequency duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default: `20s`-->默认值：<code>20s</code></td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Duration between checking config files for new data. (DEPRECATED: This parameter should be set via the config file specified by the Kubelet's `--config` flag. See https://kubernetes.io/docs/tasks/administer-cluster/kubelet-config-file/ for more information.)
-->
检查配置文件中新数据的时间间隔。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href="https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/">进一步了解</a>）
</td>
</tr>
<tr>
<td colspan="2">--hairpin-mode string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default: `promiscuous-bridge`-->默认值：<code>promiscuous-bridge</code></td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
How should the kubelet setup hairpin NAT. This allows endpoints of a Service to load balance back to themselves if they should try to access their own Service. Valid values are `promiscuous-bridge`, `hairpin-veth` and `none`. (DEPRECATED: This parameter should be set via the config file specified by the Kubelet's `--config` flag. See https://kubernetes.io/docs/tasks/administer-cluster/kubelet-config-file/ for more information.)
-->
设置 kubelet 执行发夹模式（hairpin）网络地址转译的方式。
该模式允许后端端点对其自身服务的访问能够再次经由负载均衡转发回自身。
可选项包括 “<code>promiscuous-bridge</code>”、“<code>hairpin-veth</code>” 和 “<code>none</code>”。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href="https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/">进一步了解</a>）
</td>
</tr>
<tr>
<td colspan="2">--healthz-bind-address ip&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default: `127.0.0.1`-->默认值：<code>127.0.0.1</code></td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The IP address for the healthz server to serve on (set to `0.0.0.0` for all IPv4 interfaces and `::` for all IPv6 interfaces). (DEPRECATED: This parameter should be set via the config file specified by the Kubelet's `--config` flag. See https://kubernetes.io/docs/tasks/administer-cluster/kubelet-config-file/ for more information.)
-->
用于运行 healthz 服务器的 IP 地址（设置为 <code>0.0.0.0</code> 表示使用所有 IPv4 接口，
设置为 <code>::</code> 表示使用所有 IPv6 接口。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href="https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/">进一步了解</a>）
</td>
</tr>
<tr>
<td colspan="2">--healthz-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default: 10248-->默认值：10248</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The port of the localhost healthz endpoint (set to `0` to disable). (DEPRECATED: This parameter should be set via the config file specified by the Kubelet's `--config` flag. See https://kubernetes.io/docs/tasks/administer-cluster/kubelet-config-file/ for more information.)
-->
本地 healthz 端点使用的端口（设置为 0 表示禁用）。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href="https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/">进一步了解</a>）
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for kubelet
-->
kubelet 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">--hostname-override string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
If non-empty, will use this string as identification instead of the actual hostname. If `--cloud-provider` is set, the cloud provider determines the name of the node (consult cloud provider documentation to determine if and how the hostname is used).
-->
如果为非空，将使用此字符串而不是实际的主机名作为节点标识。如果设置了
<code>--cloud-provider</code>，则云驱动将确定节点的名称
（请查阅云服务商文档以确定是否以及如何使用主机名）。
</td>
</tr>
<tr>
<td colspan="2">--housekeeping-interval duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default: `10s`-->默认值：<code>10s</code></td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Interval between container housekeepings (default 10s)
-->
清理容器操作的时间间隔。
</td>
</tr>
<tr>
<td colspan="2">--http-check-frequency duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default: `20s`-->默认值：<code>20s</code></td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Duration between checking HTTP for new data. (DEPRECATED: This parameter should be set via the config file specified by the Kubelet's `--config` flag. See https://kubernetes.io/docs/tasks/administer-cluster/kubelet-config-file/ for more information.)
-->
HTTP 服务以获取新数据的时间间隔。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href="https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/">进一步了解</a>）
</td>
</tr>
<tr>
<td colspan="2">--image-credential-provider-bin-dir string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The path to the directory where credential provider plugin binaries are located.
-->
指向凭据提供组件可执行文件所在目录的路径。
</td>
</tr>
<tr>
<td colspan="2">--image-credential-provider-config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The path to the credential provider plugin config file.</td>
-->
指向凭据提供插件配置文件所在目录的路径。
</tr>
<tr>
<td colspan="2">--image-gc-high-threshold int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default: 85-->默认值：85</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The percent of disk usage after which image garbage collection is always run. Values must be within the range [0, 100], To disable image garbage collection, set to 100.   (DEPRECATED: This parameter should be set via the config file specified by the Kubelet's `--config` flag. See https://kubernetes.io/docs/tasks/administer-cluster/kubelet-config-file/ for more information.)
-->
镜像垃圾回收上限。磁盘使用空间达到该百分比时，镜像垃圾回收将持续工作。
值必须在 [0，100] 范围内。要禁用镜像垃圾回收，请设置为 100。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href="https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/">进一步了解</a>）
</td>
</tr>
<tr>
<td colspan="2">--image-gc-low-threshold int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default: 80-->默认值：80</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The percent of disk usage before which image garbage collection is never run. Lowest disk usage to garbage collect to. Values must be within the range [0, 100] and should not be larger than that of `--image-gc-high-threshold`. (DEPRECATED: This parameter should be set via the config file specified by the Kubelet's `--config` flag. See https://kubernetes.io/docs/tasks/administer-cluster/kubelet-config-file/ for more information.)
-->
镜像垃圾回收下限。磁盘使用空间在达到该百分比之前，镜像垃圾回收操作不会运行。
值必须在 [0，100] 范围内，并且不得大于 <code>--image-gc-high-threshold</code>的值。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href="https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/">进一步了解</a>）
</td>
</tr>
<tr>
<td colspan="2">--image-pull-progress-deadline duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default: `1m0s`-->默认值：<code>1m0s</code></td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
If no pulling progress is made before this deadline, the image pulling will be cancelled. This docker-specific flag only works when container-runtime is set to `docker`.
-->
如果在该参数值所设置的期限之前没有拉取镜像的进展，镜像拉取操作将被取消。
仅当容器运行环境设置为 <code>docker</code> 时，此特定于 docker 的参数才有效。
</td>
</tr>
<tr>
<td colspan="2">--image-service-endpoint string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[Experimental] The endpoint of remote image service. If not specified, it will be the same with `--container-runtime-endpoint` by default. Currently UNIX socket endpoint is supported on Linux, while npipe and TCP endpoints are supported on Windows.  Examples: `unix:///var/run/dockershim.sock`, `npipe:////./pipe/dockershim`
-->
[实验性特性] 远程镜像服务的端点。若未设定则默认情况下使用 <code>--container-runtime-endpoint</code>
的值。目前支持的类型包括在 Linux 系统上的 UNIX 套接字端点和 Windows 系统上的 npipe 和 TCP 端点。
例如：<code>unix:///var/run/dockershim.sock</code>、<code>npipe:////./pipe/dockershim</code>。
</td>
</tr>
<tr>
<td colspan="2">--iptables-drop-bit int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default: 15-->默认值：15</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The bit of the `fwmark` space to mark packets for dropping. Must be within the range [0, 31]. (DEPRECATED: This parameter should be set via the config file specified by the Kubelet's `--config` flag. See https://kubernetes.io/docs/tasks/administer-cluster/kubelet-config-file/ for more information.)
-->
标记数据包将被丢弃的 fwmark 位设置。必须在 [0，31] 范围内。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href="https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/">进一步了解</a>）
</td>
</tr>
<tr>
<td colspan="2">--iptables-masquerade-bit int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default: 14-->默认值：14</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The bit of the `fwmark` space to mark packets for SNAT. Must be within the range [0, 31]. Please match this parameter with corresponding parameter in `kube-proxy`. (DEPRECATED: This parameter should be set via the config file specified by the Kubelet's `--config` flag. See https://kubernetes.io/docs/tasks/administer-cluster/kubelet-config-file/ for more information.)
-->
标记数据包将进行 SNAT 的 fwmark 空间位设置。必须在 [0，31] 范围内。
请将此参数与 <code>kube-proxy</code> 中的相应参数匹配。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href="https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/">进一步了解</a>）
</td>
</tr>
<tr>
<td colspan="2">--keep-terminated-pod-volumes</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Keep terminated pod volumes mounted to the node after the pod terminates. Can be useful for debugging volume related issues. (DEPRECATED: will be removed in a future version)
-->
设置为 true 表示 Pod 终止后仍然保留之前挂载过的卷，常用于调试与卷有关的问题。
已弃用：将未来版本中移除。
</td>
</tr>
<tr>
<td colspan="2">--kernel-memcg-notification</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
If enabled, the kubelet will integrate with the kernel memcg notification to determine if memory eviction thresholds are crossed rather than polling. (DEPRECATED: This parameter should be set via the config file specified by the Kubelet's `--config` flag. See https://kubernetes.io/docs/tasks/administer-cluster/kubelet-config-file/ for more information.)
-->
若启用，则 kubelet 将与内核中的 memcg 通知机制集成，不再使用轮询的方式来判定
是否 Pod 达到内存驱逐阈值。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href="https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/">进一步了解</a>）
</td>
</tr>
<tr>
<td colspan="2">--kube-api-burst int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default: 10-->默认值：10</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Burst to use while talking with kubernetes apiserver. (DEPRECATED: This parameter should be set via the config file specified by the Kubelet's --config flag. See https://kubernetes.io/docs/tasks/administer-cluster/kubelet-config-file/ for more information.)
-->
每秒发送到 apiserver 的突发请求数量上限。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href="https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/">进一步了解</a>）
</td>
</tr>
<tr>
<td colspan="2">--kube-api-content-type string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default: `application/vnd.kubernetes.protobuf`-->默认值：<code>application/vnd.kubernetes.protobuf</code></td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Content type of requests sent to apiserver. (default "application/vnd.kubernetes.protobuf") (DEPRECATED: This parameter should be set via the config file specified by the Kubelet's --config flag. See https://kubernetes.io/docs/tasks/administer-cluster/kubelet-config-file/ for more information.)
-->
发送到 apiserver 的请求的内容类型。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href="https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/">进一步了解</a>）
</td>
</tr>
<tr>
<td colspan="2">--kube-api-qps int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default: 5-->默认值：5</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
QPS to use while talking with kubernetes apiserver. (DEPRECATED: This parameter should be set via the config file specified by the Kubelet's --config flag. See https://kubernetes.io/docs/tasks/administer-cluster/kubelet-config-file/ for more information.)
-->
与 apiserver 通信的每秒查询个数（QPS）。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href="https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/">进一步了解</a>）
</td>
</tr>
<tr>
<td colspan="2">--kube-reserved mapStringString&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default: &lt;None&gt;-->默认值：&lt;None&gt;</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
A set of `<resource name>=<resource quantity>` (e.g. `cpu=200m,memory=500Mi,ephemeral-storage=1Gi,pid='100'`) pairs that describe resources reserved for kubernetes system components. Currently `cpu`, `memory` and local `ephemeral-storage` for root file system are supported. See http://kubernetes.io/docs/user-guide/compute-resources for more detail. (DEPRECATED: This parameter should be set via the config file specified by the Kubelet's `--config` flag. See https://kubernetes.io/docs/tasks/administer-cluster/kubelet-config-file/ for more information.)
-->
kubernetes 系统预留的资源配置，以一组 <code>资源名称=资源数量</code> 格式表示。
（例如：<code>cpu=200m,memory=500Mi,ephemeral-storage=1Gi,pid='100'</code>）。
当前支持 <code>cpu</code>、<code>memory</code> 和用于根文件系统的 <code>ephemeral-storage</code>。
请参阅<a href="http://kubernetes.io/zh/docs/concepts/configuration/manage-resources-containers/">相关文档</a>获取更多信息。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href="https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/">进一步了解</a>）
</td>
</tr>
<tr>
<td colspan="2">--kube-reserved-cgroup string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default: `''`-->默认值：<code>""</code></td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Absolute name of the top level cgroup that is used to manage kubernetes components for which compute resources were reserved via `--kube-reserved` flag. Ex. `/kube-reserved`. (DEPRECATED: This parameter should be set via the config file specified by the Kubelet's `--config` flag. See https://kubernetes.io/docs/tasks/administer-cluster/kubelet-config-file/ for more information.)
-->
给出某个顶层 cgroup 绝对名称，该 cgroup 用于管理通过标志 <code>--kube-reserved</code>
为 kubernetes 组件所预留的计算资源。例如：<code>"/kube-reserved"</code>。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href="https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/">进一步了解</a>）
</td>
</tr>
<tr>
<td colspan="2">--kubeconfig string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to a kubeconfig file, specifying how to connect to the API server. Providing `--kubeconfig` enables API server mode, omitting `--kubeconfig` enables standalone mode. 
-->
kubeconfig 配置文件的路径，指定如何连接到 API 服务器。
提供 <code>--kubeconfig</code> 将启用 API 服务器模式，而省略 <code>--kubeconfig</code> 将启用独立模式。
</td>
</tr>
<tr>
<td colspan="2">--kubelet-cgroups string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Optional absolute name of cgroups to create and run the Kubelet in. (DEPRECATED: This parameter should be set via the config file specified by the Kubelet's --config flag. See https://kubernetes.io/docs/tasks/administer-cluster/kubelet-config-file/ for more information.)
-->
用于创建和运行 kubelet 的 cgroup 的绝对名称。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href="https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/">进一步了解</a>）
</td>
</tr>
<tr>
<td colspan="2">--lock-file string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
<Warning: Alpha feature> The path to file for kubelet to use as a lock file.
-->
&lt;警告：alpha 特性&gt; kubelet 使用的锁文件的路径。
</td>
</tr>
<tr>
<td colspan="2">--log-backtrace-at traceLocation&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default: `:0`-->默认值：<code>:0</code></td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
When logging hits line `<file>:<N>`, emit a stack trace.
-->
形式为 <code>&lt;file&gt;:&lt;N&gt;</code>。
当日志逻辑执行到命中 &lt;file&gt; 的第 &lt;N&gt; 行时，转储调用堆栈。
</td>
</tr>
<tr>
<td colspan="2">--log-dir string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
If non-empty, write log files in this directory
-->
如果此值为非空，则在所指定的目录中写入日志文件。
</td>
</tr>
<tr>
<td colspan="2">--log-file string</td>  
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
If non-empty, use this log file
-->
如果此值非空，使用所给字符串作为日志文件名。
</td>
</tr>
<tr>
<td colspan="2">--log-file-max-size uint&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default: 1800-->默认值：1800</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Defines the maximum size a log file can grow to. Unit is megabytes. If the value is 0, the maximum file size is unlimited.
-->
设置日志文件的最大值。单位为兆字节（M）。如果值为 0，则表示文件大小无限制。
</td>
</tr>
<tr>
<td colspan="2">--log-flush-frequency duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default: `5s`-->默认值：<code>5s</code></td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Maximum number of seconds between log flushes
-->
两次日志刷新之间的最大秒数（默认值为 5s）。
</td>
</tr>
<tr>
<td colspan="2">--logging-format string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default: `text`-->默认值：<code>"text"</code></td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Sets the log format. Permitted formats: `text`, `json`.\nNon-default formats don't honor these flags: `--add-dir-header`, `--alsologtostderr`, `--log-backtrace-at`, `--log_dir`, `--log-file`, `--log-file-max-size`, `--logtostderr`, `--skip_headers`, `--skip_log_headers`, `--stderrthreshold`, `--log-flush-frequency`.\nNon-default choices are currently alpha and subject to change without warning. (DEPRECATED: This parameter should be set via the config file specified by the Kubelet's `--config` flag. See https://kubernetes.io/docs/tasks/administer-cluster/kubelet-config-file/ for more information.)
-->
设置日志文件格式。可以设置的格式有：<code>"text"</code>、<code>"json"</code>。
非默认的格式不会使用以下标志的配置：<code>--add-dir-header</code>, <code>--alsologtostderr</code>,
<code>--log-backtrace-at</code>, <code>--log-dir</code>, <code>--log-file</code>,
<code>--log-file-max-size</code>, <code>--logtostderr</code>, <code>--skip-headers</code>,
<code>--skip-log-headers</code>, <code>--stderrthreshold</code>, <code>--log-flush-frequency</code>。
非默认选项的其它值都应视为 Alpha 特性，将来出现更改时不会额外警告。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href="https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/">进一步了解</a>）
</td>
</tr>
<tr>
<td colspan="2">--logtostderr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default: `true`-->默认值：<code>true</code></td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
log to standard error instead of files (default true)
-->
日志输出到 stderr 而不是文件。
</td>
</tr>
<tr>
<td colspan="2">--make-iptables-util-chains&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default: `true`-->默认值：<code>true</code></td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
If true, kubelet will ensure `iptables` utility rules are present on host. (DEPRECATED: This parameter should be set via the config file specified by the Kubelet's `--config` flag. See https://kubernetes.io/docs/tasks/administer-cluster/kubelet-config-file/ for more information.)
-->
设置为 true 表示 kubelet 将确保 <code>iptables</code> 规则在主机上存在。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href="https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/">进一步了解</a>）
</td>
</tr>
<tr>
<td colspan="2">--manifest-url string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
URL for accessing additional Pod specifications to run (DEPRECATED: This parameter should be set via the config file specified by the Kubelet's `--config` flag. See https://kubernetes.io/docs/tasks/administer-cluster/kubelet-config-file/ for more information.)
-->
用于访问要运行的其他 Pod 规范的 URL。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href="https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/">进一步了解</a>）
</td>
</tr>
<tr>
<td colspan="2">--manifest-url-header string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Comma-separated list of HTTP headers to use when accessing the URL provided to `--manifest-url`. Multiple headers with the same name will be added in the same order provided. This flag can be repeatedly invoked. For example: `--manifest-url-header 'a:hello,b:again,c:world' --manifest-url-header 'b:beautiful'` (DEPRECATED: This parameter should be set via the config file specified by the Kubelet's `--config` flag. See https://kubernetes.io/docs/tasks/administer-cluster/kubelet-config-file/ for more information.)
-->
取值为由 HTTP 头部组成的逗号分隔列表，在访问 <code>--manifest-url</code> 所给出的 URL 时使用。
名称相同的多个头部将按所列的顺序添加。该参数可以多次使用。例如：
<code>--manifest-url-header 'a:hello,b:again,c:world' --manifest-url-header 'b:beautiful'</code>。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href="https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/">进一步了解</a>）
</td>
</tr>
<tr>
<td colspan="2">--master-service-namespace string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default: `default`-->默认值：<code>default</code></td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The namespace from which the kubernetes master services should be injected into pods. (DEPRECATED: This flag will be removed in a future version.)
-->
kubelet 向 Pod 注入 Kubernetes 主控服务信息时使用的命名空间。
已弃用：此标志将在未来的版本中删除。
</td>
</tr>
<tr>
<td colspan="2">--max-open-files int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default: 1000000-->默认值：1000000</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Number of files that can be opened by Kubelet process. (DEPRECATED: This parameter should be set via the config file specified by the Kubelet's `--config` flag. See https://kubernetes.io/docs/tasks/administer-cluster/kubelet-config-file/ for more information.)
-->
kubelet 进程可以打开的最大文件数量。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href="https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/">进一步了解</a>）
</td>
</tr>
<tr>
<td colspan="2">--max-pods int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default: 110-->默认值：110</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Number of Pods that can run on this Kubelet. (DEPRECATED: This parameter should be set via the config file specified by the Kubelet's `--config` flag. See https://kubernetes.io/docs/tasks/administer-cluster/kubelet-config-file/ for more information.)
-->
此 kubelet 能运行的 Pod 最大数量。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href="https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/">进一步了解</a>）
</td>
</tr>
<tr>
<td colspan="2">--maximum-dead-containers int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default: -1-->默认值：-1</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Maximum number of old instances of containers to retain globally. Each container takes up some disk space. To disable, set to a negative number. (DEPRECATED: Use `--eviction-hard` or `--eviction-soft` instead. Will be removed in a future version.)
-->
设置全局可保留的已停止容器实例个数上限。
每个实例会占用一些磁盘空间。要禁用，请设置为负数。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href="https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/">进一步了解</a>）
</td>
</tr>
<tr>
<td colspan="2">--maximum-dead-containers-per-container int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default: 1-->默认值：1</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Maximum number of old instances to retain per container. Each container takes up some disk space. (DEPRECATED: Use --eviction-hard or --eviction-soft instead. Will be removed in a future version.)
-->
每个已停止容器可以保留的的最大实例数量。每个容器占用一些磁盘空间。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href="https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/">进一步了解</a>）
</td>
</tr>
<tr>
<td colspan="2">--minimum-container-ttl-duration duration</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Minimum age for a finished container before it is garbage collected.  Examples: '300ms', '10s' or '2h45m' (DEPRECATED: Use --eviction-hard or --eviction-soft instead. Will be removed in a future version.)
-->
已结束的容器在被垃圾回收清理之前的最少存活时间。
例如：<code>300ms</code>、<code>10s</code> 或者 <code>2h45m</code>。
已弃用：请改用 <code>--eviction-hard</code> 或者 <code>--eviction-soft</code>。
此标志将在未来的版本中删除。
</td>
</tr>
<tr>
<td colspan="2">--minimum-image-ttl-duration duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default: `2m0s`-->默认值：<code>2m0s</code></td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Minimum age for an unused image before it is garbage collected.  Examples: `300ms`, `10s` or `2h45m`. (DEPRECATED: This parameter should be set via the config file specified by the Kubelet's `--config` flag. See https://kubernetes.io/docs/tasks/administer-cluster/kubelet-config-file/ for more information.)
-->
不再使用的镜像在被垃圾回收清理之前的最少存活时间。
例如：<code>300ms</code>、<code>10s</code> 或者 <code>2h45m</code>。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href="https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/">进一步了解</a>）
</td>
</tr>
<tr>
<td colspan="2">--network-plugin string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
<Warning: Alpha feature> The name of the network plugin to be invoked for various events in kubelet/pod lifecycle. This docker-specific flag only works when container-runtime is set to docker.
-->
&lt;警告：alpha 特性&gt; 设置 kubelet/Pod 生命周期中各种事件调用的网络插件的名称。
仅当容器运行环境设置为 <code>docker</code> 时，此特定于 docker 的参数才有效。
</td>
</tr>
<tr>
<td colspan="2">--network-plugin-mtu int32</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
<Warning: Alpha feature> The MTU to be passed to the network plugin, to override the default. Set to 0 to use the default 1460 MTU. This docker-specific flag only works when container-runtime is set to docker.
-->
&lt;警告：alpha 特性&gt; 传递给网络插件的 MTU 值，将覆盖默认值。
设置为 0 则使用默认的 MTU 1460。仅当容器运行环境设置为 <code>docker</code> 时，
此特定于 docker 的参数才有效。
</td>
</tr>
<tr>
<td colspan="2">--node-ip string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
IP address of the node. If set, kubelet will use this IP address for the node
-->
节点的 IP 地址。如果设置，kubelet 将使用该 IP 地址作为节点的 IP 地址。
</td>
</tr>
<tr>
<td colspan="2">--node-labels mapStringString</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
&lt;Warning: Alpha feature&gt;Labels to add when registering the node in the cluster. Labels must be `key=value pairs` separated by `,`. Labels in the `kubernetes.io` namespace must begin with an allowed prefix (`kubelet.kubernetes.io`, `node.kubernetes.io`) or be in the specifically allowed set (`beta.kubernetes.io/arch`, `beta.kubernetes.io/instance-type`, `beta.kubernetes.io/os`, `failure-domain.beta.kubernetes.io/region`, `failure-domain.beta.kubernetes.io/zone`, `kubernetes.io/arch`, `kubernetes.io/hostname`, `kubernetes.io/os`, `node.kubernetes.io/instance-type`, `topology.kubernetes.io/region`, `topology.kubernetes.io/zone`)
-->
&lt;警告：alpha 特性&gt; kubelet 在集群中注册本节点时设置的标签。标签以
<code>key=value</code> 的格式表示，多个标签以逗号分隔。名字空间 <code>kubernetes.io</code>
中的标签必须以 <code>kubelet.kubernetes.io</code> 或 <code>node.kubernetes.io</code> 为前缀，
或者在以下明确允许范围内：
<code>beta.kubernetes.io/arch</code>, <code>beta.kubernetes.io/instance-type</code>,
<code>beta.kubernetes.io/os</code>, <code>failure-domain.beta.kubernetes.io/region</code>,
<code>failure-domain.beta.kubernetes.io/zone</code>, <code>kubernetes.io/arch</code>,
<code>kubernetes.io/hostname</code>, <code>kubernetes.io/os</code>,
<code>node.kubernetes.io/instance-type</code>, <code>topology.kubernetes.io/region</code>,
<code>topology.kubernetes.io/zone</code>。
</td>
</tr>
<tr>
<td colspan="2">--node-status-max-images int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default: 50-->默认值：50</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The maximum number of images to report in `node.status.images`. If `-1` is specified, no cap will be applied. (DEPRECATED: This parameter should be set via the config file specified by the Kubelet's `--config` flag. See https://kubernetes.io/docs/tasks/administer-cluster/kubelet-config-file/ for more information.)
-->
在 <code>node.status.images</code> 中可以报告的最大镜像数量。如果指定为 -1，则不设上限。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href="https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/">进一步了解</a>）
</td>
</tr>
<tr>
<td colspan="2">--node-status-update-frequency duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default: `10s`-->默认值：<code>10s</code></td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Specifies how often kubelet posts node status to master. Note: be cautious when changing the constant, it must work with nodeMonitorGracePeriod in Node controller. (DEPRECATED: This parameter should be set via the config file specified by the Kubelet's `--config` flag. See https://kubernetes.io/docs/tasks/administer-cluster/kubelet-config-file/ for more information.)
-->
指定 kubelet 向主控节点汇报节点状态的时间间隔。注意：更改此常量时请务必谨慎，
它必须与节点控制器中的 <code>nodeMonitorGracePeriod</code> 一起使用。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href="https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/">进一步了解</a>）
</td>
</tr>
<tr>
<td colspan="2">--non-masquerade-cidr string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default: `10.0.0.0/8`-->默认值：<code>10.0.0.0/8</code></td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Traffic to IPs outside this range will use IP masquerade. Set to '0.0.0.0/0' to never masquerade. (default "10.0.0.0/8") (DEPRECATED: will be removed in a future version)
-->
kubelet 向该 IP 段之外的 IP 地址发送的流量将使用 IP 伪装技术。
设置为 <code>0.0.0.0/0</code> 则不使用伪装。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href="https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/">进一步了解</a>）
</td>
</tr>
<tr>
<td colspan="2">--one-output</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
If true, only write logs to their native severity level (vs also writing to each lower severity level.
-->
如果设置此标志为 <code>true</code>，则仅将日志写入其原来的严重性级别中，
而不是同时将其写入更低严重性级别中。
</td>
</tr>
<tr>
<td colspan="2">--oom-score-adj int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default: -999-->默认值：-999</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The oom-score-adj value for kubelet process. Values must be within the range [-1000, 1000] (DEPRECATED: This parameter should be set via the config file specified by the Kubelet's --config flag. See https://kubernetes.io/docs/tasks/administer-cluster/kubelet-config-file/ for more information.)
-->
kubelet 进程的 oom-score-adj 参数值。有效范围为 <code>[-1000，1000]</code>。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href="https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/">进一步了解</a>）
</td>
</tr>
<tr>
<td colspan="2">--pod-cidr string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The CIDR to use for pod IP addresses, only used in standalone mode. In cluster mode, this is obtained from the master. For IPv6, the maximum number of IP's allocated is 65536 (DEPRECATED: This parameter should be set via the config file specified by the Kubelet's `--config` flag. See https://kubernetes.io/docs/tasks/administer-cluster/kubelet-config-file/ for more information.)
-->
用于给 Pod 分配 IP 地址的 CIDR 地址池，仅在独立运行模式下使用。
在集群模式下，CIDR 设置是从主服务器获取的。对于 IPv6，分配的 IP 的最大数量为 65536。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href="https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/">进一步了解</a>）
</td>
</tr>
<tr>
<td colspan="2">--pod-infra-container-image string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default: `k8s.gcr.io/pause:3.2`-->默认值：<code>k8s.gcr.io/pause:3.2</code></td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
 Specified image will not be pruned by the image garbage collector. When container-runtime is set to `docker`, all containers in each pod will use the network/ipc namespaces from this image. Other CRI implementations have their own configuration to set this image.
-->
所指定的镜像不会被镜像垃圾收集器删除。
当容器运行环境设置为 <code>docker</code> 时，各个 Pod 中的所有容器都会
使用此镜像中的网络和 IPC 名字空间。
其他 CRI 实现有自己的配置来设置此镜像。
</td>
</tr>
<tr>
<td colspan="2">--pod-manifest-path string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to the directory containing static pod files to run, or the path to a single static pod file. Files starting with dots will be ignored. (DEPRECATED: This parameter should be set via the config file specified by the Kubelet's `--config` flag. See https://kubernetes.io/docs/tasks/administer-cluster/kubelet-config-file/ for more information.)
-->
设置包含要运行的静态 Pod 的文件的路径，或单个静态 Pod 文件的路径。以点（<code>.</code>）
开头的文件将被忽略。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href="https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/">进一步了解</a>）
</td>
</tr>
<tr>
<td colspan="2">--pod-max-pids int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default: -1-->默认值：-1</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Set the maximum number of processes per pod.  If `-1`, the kubelet defaults to the node allocatable PID capacity. (DEPRECATED: This parameter should be set via the config file specified by the Kubelet's `--config` flag. See https://kubernetes.io/docs/tasks/administer-cluster/kubelet-config-file/ for more information.)
-->
设置每个 Pod 中的最大进程数目。如果为 -1，则 kubelet 使用节点可分配的 PID 容量作为默认值。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href="https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/">进一步了解</a>）
</td>
</tr>
<tr>
<td colspan="2">--pods-per-core int32</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Number of Pods per core that can run on this Kubelet. The total number of Pods on this Kubelet cannot exceed `--max-pods`, so `--max-pods` will be used if this calculation results in a larger number of Pods allowed on the Kubelet. A value of `0` disables this limit. (DEPRECATED: This parameter should be set via the config file specified by the Kubelet's `--config` flag. See https://kubernetes.io/docs/tasks/administer-cluster/kubelet-config-file/ for more information.)
-->
kubelet 在每个处理器核上可运行的 Pod 数量。此 kubelet 上的 Pod 总数不能超过
<code>--max-pods</code> 标志值。因此，如果此计算结果导致在 kubelet 
上允许更多数量的 Pod，则使用 <code>--max-pods</code> 值。值为 0 表示不作限制。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href="https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/">进一步了解</a>）
</td>
</tr>
<tr>
<td colspan="2">--port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default: 10250-->默认值：10250</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The port for the Kubelet to serve on. (DEPRECATED: This parameter should be set via the config file specified by the Kubelet's --config flag. See https://kubernetes.io/docs/tasks/administer-cluster/kubelet-config-file/ for more information.)
-->
kubelet 服务监听的本机端口号。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href="https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/">进一步了解</a>）
</td>
</tr>
<tr>
<td colspan="2">--protect-kernel-defaults</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Default kubelet behaviour for kernel tuning. If set, kubelet errors if any of kernel tunables is different than kubelet defaults. (DEPRECATED: This parameter should be set via the config file specified by the Kubelet's --config flag. See https://kubernetes.io/docs/tasks/administer-cluster/kubelet-config-file/ for more information.)
-->
设置 kubelet 的默认内核调整行为。如果已设置该参数，当任何内核可调参数与
kubelet 默认值不同时，kubelet 都会出错。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href="https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/">进一步了解</a>）
</td>
</tr>
<tr>
<td colspan="2">--provider-id string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Unique identifier for identifying the node in a machine database, i.e cloud provider. (DEPRECATED: This parameter should be set via the config file specified by the Kubelet's `--config` flag. See https://kubernetes.io/docs/tasks/administer-cluster/kubelet-config-file/ for more information.)
-->
设置主机数据库（即，云驱动）中用来标识节点的唯一标识。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href="https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/">进一步了解</a>）
</td>
</tr>
<tr>
<td colspan="2">--qos-reserved mapStringString</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
&lt;Warning: Alpha feature&gt; A set of `<resource name>=<percentage>` (e.g. `memory=50%`) pairs that describe how pod resource requests are reserved at the QoS level. Currently only memory is supported. Requires the `QOSReserved` feature gate to be enabled. (DEPRECATED: This parameter should be set via the config file specified by the Kubelet's `--config` flag. See https://kubernetes.io/docs/tasks/administer-cluster/kubelet-config-file/ for more information.)
-->
&lt;警告：alpha 特性&gt; 设置在指定的 QoS 级别预留的 Pod 资源请求，以一组
<code>"资源名称=百分比"</code> 的形式进行设置，例如 <code>memory=50%</code>。
当前仅支持内存（memory）。要求启用 <code>QOSReserved</code> 特性门控。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href="https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/">进一步了解</a>）
</td>
</tr>
<tr>
<td colspan="2">--read-only-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default: 10255-->默认值：10255</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The read-only port for the Kubelet to serve on with no authentication/authorization (set to `0` to disable). (DEPRECATED: This parameter should be set via the config file specified by the Kubelet's `--config` flag. See https://kubernetes.io/docs/tasks/administer-cluster/kubelet-config-file/ for more information.)
-->
kubelet 可以在没有身份验证/鉴权的情况下提供只读服务的端口（设置为 0 表示禁用）。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href="https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/">进一步了解</a>）
</td>
</tr>
<tr>
<td colspan="2">--really-crash-for-testing</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
If true, when panics occur crash. Intended for testing. (DEPRECATED: will be removed in a future version.)
-->
设置为 true 表示发生失效时立即崩溃。仅用于测试。
已弃用：将在未来版本中移除。
</td>
</tr>
<tr>
<td colspan="2">--redirect-container-streaming</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Enables container streaming redirect. If false, kubelet will proxy container streaming data between the API server and container runtime; if `true`, kubelet will return an HTTP redirect to the API server, and the API server will access container runtime directly. The proxy approach is more secure, but introduces some overhead. The redirect approach is more performant, but less secure because the connection between apiserver and container runtime may not be authenticated. (DEPRECATED: Container streaming redirection will be removed from the kubelet in v1.20, and this flag will be removed in v1.22. For more details, see http://git.k8s.io/enhancements/keps/sig-node/20191205-container-streaming-requests.md)
-->
启用容器流数据重定向。如果设置为 false，则 kubelet 将在 apiserver 和容器运行时
之间转发容器流数据；如果设置为 true，则 kubelet 将返回指向 apiserver 的 HTTP 重定向信息，
而 apiserver 将直接访问容器运行时。代理方法更安全，但会带来一些开销。
重定向方法性能更高，但安全性较低，因为 apiserver 和容器运行时之间的连接可能未通过身份验证。<br/>
已弃用：容器流数据重定向会在 v1.20 中从 kubelet 中移除，此标志会在 v1.22
中移除。
相关信息可参见<a href="http://git.k8s.io/enhancements/keps/sig-node/20191205-container-streaming-requests.md">改进说明</a>。
</td>
</tr>
<tr>
<td colspan="2">--register-node&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default: `true`-->默认值：<code>true</code></td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Register the node with the API server. If `--kubeconfig` is not provided, this flag is irrelevant, as the Kubelet won't have an API server to register with.
-->
将本节点注册到 API 服务器。如果未提供 <code>--kubeconfig</code> 标志设置，
则此参数无关紧要，因为 kubelet 将没有要注册的 API 服务器。
</td>
</tr>
<tr>
<td colspan="2">--register-schedulable&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default: `true`-->默认值：true</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Register the node as schedulable. Won't have any effect if `--register-node` is false. (DEPRECATED: will be removed in a future version)
-->
注册本节点为可调度的节点。当 <code>--register-node</code>标志为 false 时此设置无效。
已弃用：此参数将在未来的版本中删除。
</td>
</tr>
<tr>
<td colspan="2">--register-with-taints mapStringString</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Register the node with the given list of taints (comma separated `<key>=<value>:<effect>`). No-op if `--register-node` is `false`. (DEPRECATED: will be removed in a future version)
-->
设置本节点的污点标记，格式为 <code>&lt;key&gt;=&lt;value&gt;:&lt;effect&gt;</code>，
以逗号分隔。当 <code>--register-node</code> 为 false 时此标志无效。
已弃用：将在未来版本中移除。
</td>
</tr>
<tr>
<td colspan="2">--registry-burst int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default: 10-->默认值：10</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Maximum size of a bursty pulls, temporarily allows pulls to burst to this number, while still not exceeding `--registry-qps`. Only used if `--registry-qps > 0`. (DEPRECATED: This parameter should be set via the config file specified by the Kubelet's `--config` flag. See https://kubernetes.io/docs/tasks/administer-cluster/kubelet-config-file/ for more information.)
-->
设置突发性镜像拉取的个数上限，在不超过 <code>--registration-qps</code> 设置值的前提下
暂时允许此参数所给的镜像拉取个数。仅在 <code>--registry-qps</code> 大于 0 时使用。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href="https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/">进一步了解</a>）
</td>
</tr>
<tr>
<td colspan="2">--registry-qps int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: 5</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
If &gt; 0, limit registry pull QPS to this value.  If `0`, unlimited. (DEPRECATED: This parameter should be set via the config file specified by the Kubelet's `--config` flag. See https://kubernetes.io/docs/tasks/administer-cluster/kubelet-config-file/ for more information.)
-->
如此值大于 0，可用来限制镜像仓库的 QPS 上限。设置为 0，表示不受限制。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href="https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/">进一步了解</a>）
</td>
</tr>
<tr>
<td colspan="2">--reserved-cpus string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
A comma-separated list of CPUs or CPU ranges that are reserved for system and kubernetes usage. This specific list will supersede cpu counts in `--system-reserved` and `--kube-reserved`. (DEPRECATED: This parameter should be set via the config file specified by the Kubelet's `--config` flag. See https://kubernetes.io/docs/tasks/administer-cluster/kubelet-config-file/ for more information.)
-->
用逗号分隔的一组 CPU 或 CPU 范围列表，给出为系统和 Kubernetes 保留使用的 CPU。
此列表所给出的设置优先于通过 <code>--system-reserved</code> 和
<code>--kube-reskube-reserved</code> 所保留的 CPU 个数配置。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href="https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/">进一步了解</a>）
</td>
</tr>
<tr>
<td colspan="2">--resolv-conf string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default: `/etc/resolv.conf`-->默认值：<code>/etc/resolv.conf</code></td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Resolver configuration file used as the basis for the container DNS resolution configuration. (DEPRECATED: This parameter should be set via the config file specified by the Kubelet's `--config` flag. See https://kubernetes.io/docs/tasks/administer-cluster/kubelet-config-file/ for more information.)
-->
名字解析服务的配置文件名，用作容器 DNS 解析配置的基础。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href="https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/">进一步了解</a>）
</td>
</tr>
<tr>
<td colspan="2">--root-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default: `/var/lib/kubelet`-->默认值：<code>/var/lib/kubelet</code></td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Directory path for managing kubelet files (volume mounts, etc).
-->
设置用于管理 kubelet 文件的根目录（例如挂载卷的相关文件等）。
</td>
</tr>
<tr>
<td colspan="2">--rotate-certificates</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
&lt;Warning: Beta feature&gt; Auto rotate the kubelet client certificates by requesting new certificates from the `kube-apiserver` when the certificate expiration approaches. (DEPRECATED: This parameter should be set via the config file specified by the Kubelet's `--config` flag. See https://kubernetes.io/docs/tasks/administer-cluster/kubelet-config-file/ for more information.)
-->
&lt;警告：Beta 特性&gt; 设置当客户端证书即将过期时 kubelet 自动从
<code>kube-apiserver</code> 请求新的证书进行轮换。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href="https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/">进一步了解</a>）
</td>
</tr>
<tr>
<td colspan="2">--rotate-server-certificates</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Auto-request and rotate the kubelet serving certificates by requesting new certificates from the `kube-apiserver` when the certificate expiration approaches. Requires the `RotateKubeletServerCertificate` feature gate to be enabled, and approval of the submitted `CertificateSigningRequest` objects. (DEPRECATED: This parameter should be set via the config file specified by the Kubelet's `--config` flag. See https://kubernetes.io/docs/tasks/administer-cluster/kubelet-config-file/ for more information.)
-->
当 kubelet 的服务证书即将过期时自动从 kube-apiserver 请求新的证书进行轮换。
要求启用 <code>RotateKubeletServerCertificate</code> 特性门控，以及对提交的
<code>CertificateSigningRequest</code> 对象进行批复（Approve）操作。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href="https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/">进一步了解</a>）
</td>
</tr>
<tr>
<td colspan="2">--runonce</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
If `true`, exit after spawning pods from local manifests or remote urls. Exclusive with `--enable-server` (DEPRECATED: This parameter should be set via the config file specified by the Kubelet's --config flag. See https://kubernetes.io/docs/tasks/administer-cluster/kubelet-config-file/ for more information.)
-->
设置为 true 表示从本地清单或远程 URL 创建完 Pod 后立即退出 kubelet 进程。
与 <code>--enable-server</code> 标志互斥。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href="https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/">进一步了解</a>）
</td>
</tr>
<tr>
<td colspan="2">--runtime-cgroups string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Optional absolute name of cgroups to create and run the runtime in.
-->
设置用于创建和运行容器运行时的 cgroup 的绝对名称。
</td>
</tr>
<tr>
<td colspan="2">--runtime-request-timeout duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default: `2m0s`-->默认值：<code>2m0s</code></td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Timeout of all runtime requests except long running request - `pull`, `logs`, `exec` and `attach`. When timeout exceeded, kubelet will cancel the request, throw out an error and retry later. (DEPRECATED: This parameter should be set via the config file specified by the Kubelet's `--config` flag. See https://kubernetes.io/docs/tasks/administer-cluster/kubelet-config-file/ for more information.)
-->
设置除了长时间运行的请求（包括 <code>pull</code>、<code>logs</code>、<code>exec</code>
和 <code>attach</code> 等操作）之外的其他运行时请求的超时时间。
到达超时时间时，请求会被取消，抛出一个错误并会等待重试。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href="https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/">进一步了解</a>）
</td>
</tr>
<tr>
<td colspan="2">--seccomp-profile-root string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default: `/var/lib/kubelet/seccomp`-->默认值：<code>/var/lib/kubelet/seccomp</code></td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
&lt;Warning: Alpha feature&gt; Directory path for seccomp profiles. (DEPRECATED: will be removed in 1.23, in favor of using the `<root-dir>/seccomp` directory)
-->
&lt;警告：alpha 特性&gt; seccomp 配置文件目录。
已弃用：将在 1.23 版本中移除，以使用 <code>&lt;root-dir&gt;/seccomp</code> 目录。
</td>
</tr>
<tr>
<td colspan="2">--serialize-image-pulls&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default: `true`-->默认值：<code>true</code></td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Pull images one at a time. We recommend *not* changing the default value on nodes that run docker daemon with version &lt; 1.9 or an `aufs` storage backend. Issue #10959 has more details. (DEPRECATED: This parameter should be set via the config file specified by the Kubelet's `--config` flag. See https://kubernetes.io/docs/tasks/administer-cluster/kubelet-config-file/ for more information.)
-->
逐一拉取镜像。建议 *不要* 在 docker 守护进程版本低于 1.9 或启用了 Aufs 存储后端的节点上
更改默认值。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href="https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/">进一步了解</a>）
</td>
</tr>
<tr>
<td colspan="2">--skip-headers</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
If true, avoid header prefixes in the log messages
-->
设置为 true 时在日志消息中去掉标头前缀。
</td>
</tr>
<tr>
<td colspan="2">--skip-log-headers</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
If true, avoid headers when opening log files
-->
设置为 true，打开日志文件时去掉标头。
</td>
</tr>
<tr>
<td colspan="2">--stderrthreshold int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default: 2-->默认值：2</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
logs at or above this threshold go to stderr.
-->
设置严重程度达到或超过此阈值的日志输出到标准错误输出。
</td>
</tr>
<tr>
<td colspan="2">--streaming-connection-idle-timeout duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default: `4h0m0s`-->默认值：<code>4h0m0s</code></td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Maximum time a streaming connection can be idle before the connection is automatically closed. `0` indicates no timeout. Example: `5m`. (DEPRECATED: This parameter should be set via the config file specified by the Kubelet's `--config` flag. See https://kubernetes.io/docs/tasks/administer-cluster/kubelet-config-file/ for more information.)
-->
设置流连接在自动关闭之前可以空闲的最长时间。0 表示没有超时限制。
例如：<code>5m</code>。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href="https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/">进一步了解</a>）
</td>
</tr>
<tr>
<td colspan="2">--sync-frequency duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default: `1m0s`-->默认值：<code>1m0s</code></td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Max period between synchronizing running containers and config. (DEPRECATED: This parameter should be set via the config file specified by the Kubelet's `--config` flag. See https://kubernetes.io/docs/tasks/administer-cluster/kubelet-config-file/ for more information.)
-->
在运行中的容器与其配置之间执行同步操作的最长时间间隔。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href="https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/">进一步了解</a>）
</td>
</tr>
<tr>
<td colspan="2">--system-cgroups /</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Optional absolute name of cgroups in which to place all non-kernel processes that are not already inside a cgroup under `/`. Empty for no container. Rolling back the flag requires a reboot. (DEPRECATED: This parameter should be set via the config file specified by the Kubelet's `--config` flag. See https://kubernetes.io/docs/tasks/administer-cluster/kubelet-config-file/ for more information.)
-->
此标志值为一个 cgroup 的绝对名称，用于所有尚未放置在根目录下某 cgroup 内的非内核进程。
空值表示不指定 cgroup。回滚该参数需要重启机器。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href="https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/">进一步了解</a>）
</td>
</tr>
<tr>
<td colspan="2">--system-reserved mapStringString&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default: none-->默认值：无</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
A set of `<resource name>=<resource quantity>` (e.g. `cpu=200m,memory=500Mi,ephemeral-storage=1Gi,pid='100'`) pairs that describe resources reserved for non-kubernetes components. Currently only `cpu` and `memory` are supported. See http://kubernetes.io/docs/user-guide/compute-resources for more detail. (DEPRECATED: This parameter should be set via the config file specified by the Kubelet's `--config` flag. See https://kubernetes.io/docs/tasks/administer-cluster/kubelet-config-file/ for more information.)
-->
系统预留的资源配置，以一组 <code>资源名称=资源数量</code> 的格式表示，
（例如：<code>cpu=200m,memory=500Mi,ephemeral-storage=1Gi,pid='100'</code>）。
目前仅支持 <code>cpu</code> 和 <code>memory</code> 的设置。
更多细节可参考
<a href="http://kubernetes.io/zh/docs/concepts/configuration/manage-resources-containers/">相关文档</a>。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href="https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/">进一步了解</a>）
</td>
</tr>
<tr>
<td colspan="2">--system-reserved-cgroup string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default: `''`-->默认值：<code>""</code></td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Absolute name of the top level cgroup that is used to manage non-kubernetes components for which compute resources were reserved via `--system-reserved` flag. Ex. `/system-reserved`. (DEPRECATED: This parameter should be set via the config file specified by the Kubelet's `--config` flag. See https://kubernetes.io/docs/tasks/administer-cluster/kubelet-config-file/ for more information.)
-->
此标志给出一个顶层 cgroup 绝对名称，该 cgroup 用于管理非 kubernetes 组件，
这些组件的计算资源通过 <code>--system-reserved</code> 标志进行预留。
例如 <code>"/system-reserved"</code>。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href="https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/">进一步了解</a>）
</td>
</tr>
<tr>
<td colspan="2">--tls-cert-file string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
File containing x509 Certificate used for serving HTTPS (with intermediate certs, if any, concatenated after server cert). If `--tls-cert-file` and `--tls-private-key-file` are not provided, a self-signed certificate and key are generated for the public address and saved to the directory passed to `--cert-dir`. (DEPRECATED: This parameter should be set via the config file specified by the Kubelet's `--config` flag. See https://kubernetes.io/docs/tasks/administer-cluster/kubelet-config-file/ for more information.)
-->
包含 x509 证书的文件路径，用于 HTTPS 认证。
如果有中间证书，则中间证书要串接在在服务器证书之后。
如果未提供 <code>--tls-cert-file</code> 和 <code>--tls-private-key-file</code>，
kubelet 会为公开地址生成自签名证书和密钥，并将其保存到通过
<code>--cert-dir</code> 指定的目录中。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href="https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/">进一步了解</a>）
</td>
</tr>
<tr>
<td colspan="2">--tls-cipher-suites string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Comma-separated list of cipher suites for the server. If omitted, the default Go cipher suites will be used. Possible values: TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA,TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256,TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA,TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384,TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305,TLS_ECDHE_ECDSA_WITH_RC4_128_SHA,TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA,TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA,TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256,TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA,TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384,TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305,TLS_ECDHE_RSA_WITH_RC4_128_SHA,TLS_RSA_WITH_3DES_EDE_CBC_SHA,TLS_RSA_WITH_AES_128_CBC_SHA,TLS_RSA_WITH_AES_128_CBC_SHA256,TLS_RSA_WITH_AES_128_GCM_SHA256,TLS_RSA_WITH_AES_256_CBC_SHA,TLS_RSA_WITH_AES_256_GCM_SHA384,TLS_RSA_WITH_RC4_128_SHA (DEPRECATED: This parameter should be set via the config file specified by the Kubelet's --config flag. See https://kubernetes.io/docs/tasks/administer-cluster/kubelet-config-file/ for more information.)
-->
服务器端加密算法列表，以逗号分隔。如果不设置，则使用 Go 语言加密包的默认算法列表。<br/>
可选加密算法包括：TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA,TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256,TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA,TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384,TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305,TLS_ECDHE_ECDSA_WITH_RC4_128_SHA,TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA,TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA,TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256,TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA,TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384,TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305,TLS_ECDHE_RSA_WITH_RC4_128_SHA,TLS_RSA_WITH_3DES_EDE_CBC_SHA,TLS_RSA_WITH_AES_128_CBC_SHA,TLS_RSA_WITH_AES_128_CBC_SHA256,TLS_RSA_WITH_AES_128_GCM_SHA256,TLS_RSA_WITH_AES_256_CBC_SHA,TLS_RSA_WITH_AES_256_GCM_SHA384,TLS_RSA_WITH_RC4_128_SHA <br/>
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href="https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/">进一步了解</a>）
</td>
</tr>
<tr>
<td colspan="2">--tls-min-version string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Minimum TLS version supported. Possible values: `VersionTLS10`, `VersionTLS11`, `VersionTLS12`, `VersionTLS13` (DEPRECATED: This parameter should be set via the config file specified by the Kubelet's `--config` flag. See https://kubernetes.io/docs/tasks/administer-cluster/kubelet-config-file/ for more information.)
-->
设置支持的最小 TLS 版本号，可选的版本号包括：<code>VersionTLS10</code>、
<code>VersionTLS11</code>、<code>VersionTLS12</code> 和 <code>VersionTLS13</code>。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href="https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/">进一步了解</a>）
</td>
</tr>
<tr>
<td colspan="2">--tls-private-key-file string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
File containing x509 private key matching `--tls-cert-file`. (DEPRECATED: This parameter should be set via the config file specified by the Kubelet's `--config` flag. See https://kubernetes.io/docs/tasks/administer-cluster/kubelet-config-file/ for more information.)
-->
包含与 <code>--tls-cert-file</code> 对应的 x509 私钥文件路径。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href="https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/">进一步了解</a>）
</td>
</tr>
<tr>
<td colspan="2">--topology-manager-policy string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default: `none`-->默认值：<code>none</code></td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Topology Manager policy to use. Possible values: `none`, `best-effort`, `restricted`, `single-numa-node`. (DEPRECATED: This parameter should be set via the config file specified by the Kubelet's `--config` flag. See https://kubernetes.io/docs/tasks/administer-cluster/kubelet-config-file/ for more information.)
-->
设置拓扑管理策略（Topology Manager policy）。可选值包括：<code>none</code>、
<code>best-effort</code>、<code>restricted</code> 和 <code>single-numa-node</code>。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href="https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/">进一步了解</a>）
</td>
</tr>
<tr>
<td colspan="2">--topology-manager-scope string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default: `container`-->默认值：<code>container</code></td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Scope to which topology hints applied. Topology Manager collects hints from Hint Providers and applies them to defined scope to ensure the pod admission. Possible values: 'container' (default), 'pod'. (default "container") (DEPRECATED: This parameter should be set via the config file specified by the Kubelet's --config flag. See https://kubernetes.io/docs/tasks/administer-cluster/kubelet-config-file/ for more information.)
-->
拓扑提示信息使用范围。拓扑管理器从提示提供者（Hints Providers）处收集提示信息，
并将其应用到所定义的范围以确保 Pod 准入。
可选值包括：<code>container</code>（默认）、<code>pod</code>。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href="https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/">进一步了解</a>）
</td>
</tr>
<tr>
<td colspan="2">-v, --v Level</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
number for the log level verbosity
-->
设置 kubelet 日志级别详细程度的数值。
</td>
</tr>
<tr>
<td colspan="2">--version version[=true]</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Print version information and quit
-->
打印 kubelet 版本信息并退出。
</td>
</tr>
<tr>
<td colspan="2">--vmodule moduleSpec</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Comma-separated list of `pattern=N` settings for file-filtered logging
-->
以逗号分隔的 <code>pattern=N</code> 设置列表，用于文件过滤的日志记录
</td>
</tr>
<tr>
<td colspan="2">--volume-plugin-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default: `/usr/libexec/kubernetes/kubelet-plugins/volume/exec/`-->默认值：<code>/usr/libexec/kubernetes/kubelet-plugins/volume/exec/</code></td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The full path of the directory in which to search for additional third party volume plugins. (DEPRECATED: This parameter should be set via the config file specified by the Kubelet's `--config` flag. See https://kubernetes.io/docs/tasks/administer-cluster/kubelet-config-file/ for more information.)
-->
用来搜索第三方存储卷插件的目录。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href="https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/">进一步了解</a>）
</td>
</tr>
<tr>
<td colspan="2">--volume-stats-agg-period duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default: `1m0s`-->默认值：<code>1m0s</code></td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Specifies interval for kubelet to calculate and cache the volume disk usage for all pods and volumes. To disable volume calculations, set to `0`. (DEPRECATED: This parameter should be set via the config file specified by the Kubelet's `--config` flag. See https://kubernetes.io/docs/tasks/administer-cluster/kubelet-config-file/ for more information.)
-->
指定 kubelet 计算和缓存所有 Pod 和卷的磁盘用量总值的时间间隔。要禁用磁盘用量计算，
请设置为 0。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href="https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/">进一步了解</a>）
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-ec8ff2888d36f533a57bc9704ccc84e0">9.3 - kube-apiserver</h1>
    
	<!--
The file is auto-generated from the Go source code of the component using a generic
[generator](https://github.com/kubernetes-sigs/reference-docs/). To learn how
to generate the reference documentation, please read
[Contributing to the reference documentation](/docs/contribute/generate-ref-docs/).
To update the reference conent, please follow the 
[Contributing upstream](/docs/contribute/generate-ref-docs/contribute-upstream/)
guide. You can file document formatting bugs against the
[reference-docs](https://github.com/kubernetes-sigs/reference-docs/) project.
-->
<h2 id="简介">简介</h2>
<!-- 
The Kubernetes API server validates and configures data
for the api objects which include pods, services, replicationcontrollers, and
others. The API Server services REST operations and provides the frontend to the
cluster's shared state through which all other components interact.
-->
<p>Kubernetes API 服务器验证并配置 API 对象的数据，
这些对象包括 pods、services、replicationcontrollers 等。
API 服务器为 REST 操作提供服务，并为集群的共享状态提供前端，
所有其他组件都通过该前端进行交互。</p>
<pre tabindex="0"><code>kube-apiserver [flags]
</code></pre><h2 id="选项">选项</h2>
<table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--add-dir-header</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
If true, adds the file directory to the header of the log messages
-->
<p>如果为 true，则将文件目录添加到日志消息的标题中</p>
</td>
</tr>
<tr>
<td colspan="2">--admission-control-config-file string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
File with admission control configuration.
-->
<p>包含准入控制配置的文件。</p>
</td>
</tr>
<tr>
<td colspan="2">--advertise-address string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The IP address on which to advertise the apiserver to members of the cluster. 
This address must be reachable by the rest of the cluster. If blank, 
the --bind-address will be used. If --bind-address is unspecified, 
the host's default interface will be used.
-->
<p>
向集群成员通知 apiserver 消息的 IP 地址。
这个地址必须能够被集群中其他成员访问。
如果 IP 地址为空，将会使用 --bind-address，
如果未指定 --bind-address，将会使用主机的默认接口地址。
</p>
</td>
</tr>
<tr>
<td colspan="2">--allow-metric-labels stringToString&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值：[]</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;"><p>
<!--
The map from metric-label to value allow-list of this label. The key's format is &lt;MetricName&gt;,&lt;LabelName&gt;. The value's format is &lt;allowed_value&gt;,&lt;allowed_value&gt;...e.g. metric1,label1='v1,v2,v3', metric1,label2='v1,v2,v3' metric2,label1='v1,v2,v3'.
-->
允许使用的指标标签到指标值的映射列表。键的格式为 &lt;MetricName&gt;,&lt;LabelName&gt;.
值的格式为 &lt;allowed_value&gt;,&lt;allowed_value&gt;...。 
例如：<code>metric1,label1='v1,v2,v3', metric1,label2='v1,v2,v3' metric2,label1='v1,v2,v3'</code>。
</p></td>
</tr>
<tr>
<td colspan="2">--allow-privileged</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
If true, allow privileged containers. [default=false]
-->
如果为 true, 将允许特权容器。[默认值=false]
</td>
</tr>
<tr>
<td colspan="2">--alsologtostderr</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
log to standard error as well as files
-->
在向文件输出日志的同时，也将日志写到标准输出。
</td>
</tr>
<tr>
<td colspan="2">--anonymous-auth&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值：true</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Enables anonymous requests to the secure port of the API server. 
Requests that are not rejected by another authentication method 
are treated as anonymous requests. Anonymous requests have a 
username of system:anonymous, and a group name of system:unauthenticated.
-->
启用到 API 服务器的安全端口的匿名请求。
未被其他认证方法拒绝的请求被当做匿名请求。
匿名请求的用户名为 <code>system:anonymous</code>，
用户组名为 </code>system:unauthenticated</code>。
</td>
</tr>
<tr>
<td colspan="2">--api-audiences strings</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Identifiers of the API. The service account token authenticator will 
validate that tokens used against the API are bound to at least one 
of these audiences. If the --service-account-issuer flag is configured 
and this flag is not, this field defaults to a single element list 
containing the issuer URL.
-->
API 的标识符。 
服务帐户令牌验证者将验证针对 API 使用的令牌是否已绑定到这些受众中的至少一个。 
如果配置了 <code>--service-account-issuer</code> 标志，但未配置此标志，
则此字段默认为包含发布者 URL 的单个元素列表。
</td>
</tr>
<tr>
<td colspan="2">--apiserver-count int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值：1</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The number of apiservers running in the cluster, must be a positive number. 
(In use when --endpoint-reconciler-type=master-count is enabled.)
-->
集群中运行的 API 服务器数量，必须为正数。
（在启用 --endpoint-reconciler-type=master-count 时使用。）
</td>
</tr>
<tr>
<td colspan="2">--audit-log-batch-buffer-size int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值：10000</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The size of the buffer to store events before batching and writing. Only used in batch mode.
-->
批处理和写入之前用于存储事件的缓冲区大小。
仅在批处理模式下使用。
</td>
</tr>
<tr>
<td colspan="2">--audit-log-batch-max-size int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值：1</td>
</tr><tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The maximum size of a batch. Only used in batch mode.
-->
每个批次的最大大小。仅在批处理模式下使用。
</td>
</tr>
<tr>
<td colspan="2">--audit-log-batch-max-wait duration</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The amount of time to wait before force writing the batch that hadn't reached the max size. 
Only used in batch mode.
-->
强制写入尚未达到最大大小的批次之前要等待的时间。
仅在批处理模式下使用。
</td>
</tr>
<tr>
<td colspan="2">--audit-log-batch-throttle-burst int</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Maximum number of requests sent at the same moment if ThrottleQPS was not utilized before. 
Only used in batch mode.
-->
如果之前未使用 ThrottleQPS，则为同时发送的最大请求数。
仅在批处理模式下使用。
</td>
</tr>
<tr>
<td colspan="2">--audit-log-batch-throttle-enable</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Whether batching throttling is enabled. Only used in batch mode.
-->
是否启用了批量限制。仅在批处理模式下使用。
</td>
</tr>
<tr>
<td colspan="2">--audit-log-batch-throttle-qps float</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Maximum average number of batches per second. Only used in batch mode.
-->
每秒的最大平均批次数。仅在批处理模式下使用。
</td>
</tr>
<tr>
<td colspan="2">--audit-log-compress</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
If set, the rotated log files will be compressed using gzip.
-->
若设置了此标志，则被轮换的日志文件会使用 gzip 压缩。
</td>
</tr>
<tr>
<td colspan="2">--audit-log-format string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值："json" </td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Format of saved audits. "legacy" indicates 1-line text format for each event. 
"json" indicates structured json format. Known formats are legacy,json.
-->
所保存的审计格式。
"legacy" 表示每行一个事件的文本格式。"json" 表示结构化的 JSON 格式。
已知格式为 legacy，json。
</td>
</tr>
<tr>
<td colspan="2">--audit-log-maxage int</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The maximum number of days to retain old audit log files based on the timestamp encoded in their filename.
-->
根据文件名中编码的时间戳保留旧审计日志文件的最大天数。
</td>
</tr>
<tr>
<td colspan="2">--audit-log-maxbackup int</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The maximum number of old audit log files to retain.
-->
要保留的旧的审计日志文件个数上限。
</td>
</tr>
<tr>
<td colspan="2">--audit-log-maxsize int</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The maximum size in megabytes of the audit log file before it gets rotated.
-->
轮换之前，审计日志文件的最大大小（以兆字节为单位）。
</td>
</tr>
<tr>
<td colspan="2">--audit-log-mode string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值："blocking"</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Strategy for sending audit events. Blocking indicates sending events should block server responses. 
Batch causes the backend to buffer and write events asynchronously. 
Known modes are batch,blocking,blocking-strict.
-->
用来发送审计事件的策略。
阻塞（blocking）表示发送事件应阻止服务器响应。
批处理（batch）会导致后端异步缓冲和写入事件。
已知的模式是批处理（batch），阻塞（blocking），严格阻塞（blocking-strict）。
</td>
</tr>
<tr>
<td colspan="2">--audit-log-path string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
If set, all requests coming to the apiserver will be logged to this file.
'-' means standard out.
-->
如果设置，则所有到达 API 服务器的请求都将记录到该文件中。
"-" 表示标准输出。
</td>
</tr>
<tr>
<td colspan="2">--audit-log-truncate-enabled</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Whether event and batch truncating is enabled.
-->
是否启用事件和批次截断。
</td>
</tr>
<tr>
<td colspan="2">--audit-log-truncate-max-batch-size int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值：10485760</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Maximum size of the batch sent to the underlying backend. Actual serialized size can be 
several hundreds of bytes greater. If a batch exceeds this limit, it is split into 
several batches of smaller size.
-->
发送到下层后端的每批次的最大数据量。
实际的序列化大小可能会增加数百个字节。
如果一个批次超出此限制，则将其分成几个较小的批次。
</td>
</tr>
<tr>
<td colspan="2">--audit-log-truncate-max-event-size int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值：102400</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Maximum size of the audit event sent to the underlying backend. If the size of an event
is greater than this number, first request and response are removed, and if this doesn't 
reduce the size enough, event is discarded.
-->
发送到下层后端的每批次的最大数据量。
如果事件的大小大于此数字，则将删除第一个请求和响应；
如果这样做没有减小足够大的程度，则将丢弃事件。
</td>
</tr>
<tr>
<td colspan="2">--audit-log-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值："audit.k8s.io/v1"</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
API group and version used for serializing audit events written to log.
-->
用于对写入日志的审计事件执行序列化的 API 组和版本。
</td>
</tr>
<tr>
<td colspan="2">--audit-policy-file string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to the file that defines the audit policy configuration.
-->
定义审计策略配置的文件的路径。
</td>
</tr>
<tr>
<td colspan="2">--audit-webhook-batch-buffer-size int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值：10000</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The size of the buffer to store events before batching and writing. Only used in batch mode.
-->
划分批次和写入之前用于存储事件的缓冲区大小。
仅在批处理模式下使用。
</td>
</tr>
<tr>
<td colspan="2">--audit-webhook-batch-max-size int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值：400</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The maximum size of a batch. Only used in batch mode.
-->
批次的最大大小。
仅在批处理模式下使用。
</td>
</tr>
<tr>
<td colspan="2">--audit-webhook-batch-max-wait duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值：30s</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The amount of time to wait before force writing the batch that hadn't reached the max size. 
Only used in batch mode.
-->
强制写入尚未达到最大大小的批处理之前要等待的时间。
仅在批处理模式下使用。
</td>
</tr>
<tr>
<td colspan="2">--audit-webhook-batch-throttle-burst int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值：15</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Maximum number of requests sent at the same moment if ThrottleQPS was not utilized before. 
Only used in batch mode.
-->
如果之前未使用 ThrottleQPS，同时发送的最大请求数。
仅在批处理模式下使用。
</td>
</tr>
<tr>
<td colspan="2">--audit-webhook-batch-throttle-enable&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值：true</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Whether batching throttling is enabled. Only used in batch mode.
-->
是否启用了批量限制。仅在批处理模式下使用。
</td>
</tr>
<tr>
<td colspan="2">--audit-webhook-batch-throttle-qps float32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值：10</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Maximum average number of batches per second. Only used in batch mode.
-->
每秒的最大平均批次数。仅在批处理模式下使用。
</td>
</tr>
<tr>
<td colspan="2">--audit-webhook-config-file string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to a kubeconfig formatted file that defines the audit webhook configuration.
-->
定义审计 webhook 配置的 kubeconfig 格式文件的路径。
</tr>
<tr>
<td colspan="2">--audit-webhook-initial-backoff duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值：10s</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The amount of time to wait before retrying the first failed request.
-->
重试第一个失败的请求之前要等待的时间。
</td>
</tr>
<tr>
<td colspan="2">--audit-webhook-mode string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值："batch"</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Strategy for sending audit events. Blocking indicates sending events should block server responses. 
Batch causes the backend to buffer and write events asynchronously. Known modes are batch,blocking,blocking-strict.
-->
发送审计事件的策略。
阻止（Blocking）表示发送事件应阻止服务器响应。
批处理（Batch）导致后端异步缓冲和写入事件。
已知的模式是批处理（batch），阻塞（blocking），严格阻塞（blocking-strict）。
</td>
</tr>
<tr>
<td colspan="2">--audit-webhook-truncate-enabled</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Whether event and batch truncating is enabled.
-->
是否启用事件和批处理截断。
</td>
</tr>
<tr>
<td colspan="2">--audit-webhook-truncate-max-batch-size int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值：10485760</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- 
Maximum size of the batch sent to the underlying backend. Actual serialized size can be 
several hundreds of bytes greater. If a batch exceeds this limit, it is split into 
several batches of smaller size.
-->
发送到下层后端的批次的最大数据量。
实际的序列化大小可能会增加数百个字节。
如果一个批次超出此限制，则将其分成几个较小的批次。
</td>
</tr>
<tr>
<td colspan="2">--audit-webhook-truncate-max-event-size int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值：102400</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Maximum size of the audit event sent to the underlying backend. If the size of an event
is greater than this number, first request and response are removed, and if this doesn't
reduce the size enough, event is discarded.
-->
发送到下层后端的批次的最大数据量。
如果事件的大小大于此数字，则将删除第一个请求和响应；
如果事件和事件的大小没有减小到一定幅度，则将丢弃事件。
</td>
</tr>
<tr>
<td colspan="2">--audit-webhook-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值："audit.k8s.io/v1"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
API group and version used for serializing audit events written to webhook.
-->
用于序列化写入 Webhook 的审计事件的 API 组和版本。
</td>
</tr>
<tr>
<td colspan="2">--authentication-token-webhook-cache-ttl duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->2m0s</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The duration to cache responses from the webhook token authenticator.
-->
对来自 Webhook 令牌身份验证器的响应的缓存时间。
</td>
</tr>
<tr>
<td colspan="2">--authentication-token-webhook-config-file string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
File with webhook configuration for token authentication in kubeconfig format. 
The API server will query the remote service to determine authentication for bearer tokens.
-->
包含 Webhook 配置的 kubeconfig 格式文件，用于进行令牌认证。
API 服务器将查询远程服务，以对持有者令牌进行身份验证。
</td>
</tr>
<tr>
<td colspan="2">--authentication-token-webhook-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值："v1beta1"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The API version of the authentication.k8s.io TokenReview to send to and expect from the webhook.
-->
与 Webhook 之间交换 authentication.k8s.io TokenReview 时使用的 API 版本。
</td>
</tr>
<tr>
<td colspan="2">--authorization-mode stringSlice&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值："AlwaysAllow"</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Ordered list of plug-ins to do authorization on secure port. Comma-delimited list of: 
AlwaysAllow,AlwaysDeny,ABAC,Webhook,RBAC,Node.
-->
在安全端口上进行鉴权的插件的顺序列表。
逗号分隔的列表：AlwaysAllow、AlwaysDeny、ABAC、Webhook、RBAC、Node。
</td>
</tr>
<tr>
<td colspan="2">--authorization-policy-file string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
File with authorization policy in json line by line format, 
used with --authorization-mode=ABAC, on the secure port.
-->
包含鉴权策略的文件，其内容为分行 JSON 格式，
在安全端口上与 --authorization-mode=ABAC 一起使用。
</td>
</tr>
<tr>
<td colspan="2">--authorization-webhook-cache-authorized-ttl duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值：5m0s</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The duration to cache 'authorized' responses from the webhook authorizer.
-->
对来自 Webhook 鉴权组件的 “授权（authorized）” 响应的缓存时间。
</td>
</tr>
<tr>
<td colspan="2">--authorization-webhook-cache-unauthorized-ttl duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值：30s</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The duration to cache 'unauthorized' responses from the webhook authorizer.
-->
对来自 Webhook 鉴权模块的 “未授权（unauthorized）” 响应的缓存时间。
</td>
</tr>
<tr>
<td colspan="2">--authorization-webhook-config-file string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
File with webhook configuration in kubeconfig format, used with --authorization-mode=Webhook. 
The API server will query the remote service to determine access on the API server's secure port.
-->
包含 Webhook 配置的文件，其格式为 kubeconfig，
与 --authorization-mode=Webhook 一起使用。
API 服务器将查询远程服务，以对 API 服务器的安全端口的访问执行鉴权。
</td>
</tr>
<tr>
<td colspan="2">--authorization-webhook-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值："v1beta1"</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The API version of the authorization.k8s.io SubjectAccessReview to send to and expect from the webhook.
-->
与 Webhook 之间交换 authorization.k8s.io SubjectAccessReview 时使用的 API 版本。
</td>
</tr>
<tr>
<td colspan="2">--azure-container-registry-config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to the file containing Azure container registry configuration information.
-->
包含 Azure 容器仓库配置信息的文件的路径。
</td>
</tr>
<tr>
<td colspan="2">--bind-address string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值："0.0.0.0"</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The IP address on which to listen for the --secure-port port. The associated interface(s) 
must be reachable by the rest of the cluster, and by CLI/web clients. If blank or an 
unspecified address (0.0.0.0 or ::), all interfaces will be used.
-->
用来监听 <code>--secure-port</code> 端口的 IP 地址。
集群的其余部分以及 CLI/web 客户端必须可以访问所关联的接口。
如果为空白或未指定地址（<tt>0.0.0.0</tt> 或 <tt>::</tt>），则将使用所有接口。
</td>
</tr>
<tr>
<td colspan="2">--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值："/var/run/kubernetes"</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The directory where the TLS certs are located. If --tls-cert-file and 
--tls-private-key-file are provided, this flag will be ignored.
-->
TLS 证书所在的目录。
如果提供了 <code>--tls-cert-file</code> 和 <code>--tls-private-key-file</code>
标志值，则将忽略此标志。
</td>
</tr>
<tr>
<td colspan="2">--client-ca-file string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
If set, any request presenting a client certificate signed by one of the authorities 
in the client-ca-file is authenticated with an identity corresponding to the CommonName 
of the client certificate.
-->
如果已设置，则使用与客户端证书的 CommonName 对应的标识对任何出示由
client-ca 文件中的授权机构之一签名的客户端证书的请求进行身份验证。
</td>
</tr>
<tr>
<td colspan="2">--cloud-config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The path to the cloud provider configuration file. Empty string for no configuration file.
-->
云厂商配置文件的路径。空字符串表示无配置文件。
</td>
</tr>
<tr>
<td colspan="2">--cloud-provider string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The provider for cloud services. Empty string for no provider.
-->
云服务提供商。空字符串表示没有云厂商。
</td>
</tr>
<tr>
<td colspan="2">--cloud-provider-gce-l7lb-src-cidrs cidrs&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值："130.211.0.0/22,35.191.0.0/16"</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
CIDRs opened in GCE firewall for L7 LB traffic proxy & health checks
-->
在 GCE 防火墙中打开 CIDR，以进行第 7 层负载均衡流量代理和健康状况检查。
</td>
</tr>
<tr>
<td colspan="2">--contention-profiling</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Enable lock contention profiling, if profiling is enabled
-->
如果启用了性能分析，则启用锁争用性能分析。
</td>
</tr>
<tr>
<td colspan="2">--cors-allowed-origins strings</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
List of allowed origins for CORS, comma separated.  
An allowed origin can be a regular expression to support subdomain matching. 
If this list is empty CORS will not be enabled.
-->
CORS 允许的来源清单，以逗号分隔。
允许的来源可以是支持子域匹配的正则表达式。
如果此列表为空，则不会启用 CORS。
</td>
</tr>
<tr>
<td colspan="2">--default-not-ready-toleration-seconds int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default: -->默认值：300</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Indicates the tolerationSeconds of the toleration for notReady:NoExecute that is added by default to every pod that does not already have such a toleration.
-->
对污点 NotReady:NoExecute 的容忍时长（以秒计）。 
默认情况下这一容忍度会被添加到尚未具有此容忍度的每个 pod 中。
</td>
</tr>
<tr>
<td colspan="2">--default-unreachable-toleration-seconds int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值：300</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Indicates the tolerationSeconds of the toleration for unreachable:NoExecute 
that is added by default to every pod that does not already have such a toleration.
-->
对污点 Unreachable:NoExecute 的容忍时长（以秒计）
默认情况下这一容忍度会被添加到尚未具有此容忍度的每个 pod 中。
</td>
</tr>
<tr>
<td colspan="2">--default-watch-cache-size int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值：100</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Default watch cache size. If zero, watch cache will be disabled for resources 
that do not have a default watch size set.
-->
默认监听（watch）缓存大小。
如果为零，则将为没有设置默认监视大小的资源禁用监视缓存。
</td>
</tr>
<tr>
<td colspan="2">--delete-collection-workers int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值： 1</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Number of workers spawned for DeleteCollection call. These are used to speed up namespace cleanup.
-->
为 DeleteCollection 调用而产生的工作线程数。
这些用于加速名字空间清理。
</td>
</tr>
<tr>
<td colspan="2">--disable-admission-plugins strings</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
admission plugins that should be disabled although they are in the default enabled plugins list (NamespaceLifecycle, LimitRanger, ServiceAccount, TaintNodesByCondition, Priority, DefaultTolerationSeconds, DefaultStorageClass, StorageObjectInUseProtection, PersistentVolumeClaimResize, RuntimeClass, CertificateApproval, CertificateSigning, CertificateSubjectRestriction, DefaultIngressClass, MutatingAdmissionWebhook, ValidatingAdmissionWebhook, ResourceQuota). Comma-delimited list of admission plugins: AlwaysAdmit, AlwaysDeny, AlwaysPullImages, CertificateApproval, CertificateSigning, CertificateSubjectRestriction, DefaultIngressClass, DefaultStorageClass, DefaultTolerationSeconds, DenyServiceExternalIPs, EventRateLimit, ExtendedResourceToleration, ImagePolicyWebhook, LimitPodHardAntiAffinityTopology, LimitRanger, MutatingAdmissionWebhook, NamespaceAutoProvision, NamespaceExists, NamespaceLifecycle, NodeRestriction, OwnerReferencesPermissionEnforcement, PersistentVolumeClaimResize, PersistentVolumeLabel, PodNodeSelector, PodSecurityPolicy, PodTolerationRestriction, Priority, ResourceQuota, RuntimeClass, SecurityContextDeny, ServiceAccount, StorageObjectInUseProtection, TaintNodesByCondition, ValidatingAdmissionWebhook. The order of plugins in this flag does not matter.
-->
尽管位于默认启用的插件列表中（NamespaceLifecycle、LimitRanger、ServiceAccount、TaintNodesByCondition、Priority、DefaultTolerationSeconds、DefaultStorageClass、StorageObjectInUseProtection、PersistentVolumeClaimResize、RuntimeClass、CertificateApproval、CertificateSigning、CertificateSubjectRestriction、DefaultIngressClass、MutatingAdmissionWebhook、ValidatingAdmissionWebhook、ResourceQuota）仍须被禁用的插件。
<br/>取值为逗号分隔的准入插件列表：AlwaysAdmit、AlwaysDeny、AlwaysPullImages、CertificateApproval、CertificateSigning、CertificateSubjectRestriction、DefaultIngressClass、DefaultStorageClass、DefaultTolerationSeconds、DenyServiceExternalIPs、EventRateLimit、ExtendedResourceToleration、ImagePolicyWebhook、LimitPodHardAntiAffinityTopology、LimitRanger、MutatingAdmissionWebhook、NamespaceAutoProvision、NamespaceExists、NamespaceLifecycle、NodeRestriction、OwnerReferencesPermissionEnforcement、PersistentVolumeClaimResize、PersistentVolumeLabel、PodNodeSelector、PodSecurityPolicy、PodTolerationRestriction、Priority、ResourceQuota、RuntimeClass、SecurityContextDeny、ServiceAccount、StorageObjectInUseProtection、TaintNodesByCondition、ValidatingAdmissionWebhook。
<br/>该标志中插件的顺序无关紧要。
</td>
</tr>
<tr>
<td colspan="2">--disabled-metrics strings</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
This flag provides an escape hatch for misbehaving metrics. You must provide the fully qualified metric name in order to disable it. Disclaimer: disabling metrics is higher in precedence than showing hidden metrics.
-->
此标志为行为不正确的度量指标提供一种处理方案。
你必须提供完全限定的指标名称才能将其禁止。
声明：禁用度量值的行为优先于显示已隐藏的度量值。
</td>
</tr>
<tr>
<td colspan="2">--egress-selector-config-file string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
File with apiserver egress selector configuration.
-->
带有 API 服务器出站选择器配置的文件。
</td>
</tr>
<tr>
<td colspan="2">--enable-admission-plugins stringSlice</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
admission plugins that should be enabled in addition to default enabled ones (
NamespaceLifecycle, LimitRanger, ServiceAccount, TaintNodesByCondition, Priority, DefaultTolerationSeconds, DefaultStorageClass, StorageObjectInUseProtection, PersistentVolumeClaimResize, RuntimeClass, CertificateApproval, CertificateSigning, CertificateSubjectRestriction, DefaultIngressClass, MutatingAdmissionWebhook, ValidatingAdmissionWebhook, ResourceQuota).
Comma-delimited list of admission plugins:
AlwaysAdmit, AlwaysDeny, AlwaysPullImages, CertificateApproval, CertificateSigning, CertificateSubjectRestriction, DefaultIngressClass, DefaultStorageClass, DefaultTolerationSeconds, DenyServiceExternalIPs, EventRateLimit, ExtendedResourceToleration, ImagePolicyWebhook, LimitPodHardAntiAffinityTopology, LimitRanger, MutatingAdmissionWebhook, NamespaceAutoProvision, NamespaceExists, NamespaceLifecycle, NodeRestriction, OwnerReferencesPermissionEnforcement, PersistentVolumeClaimResize, PersistentVolumeLabel, PodNodeSelector, PodSecurityPolicy, PodTolerationRestriction, Priority, ResourceQuota, RuntimeClass, SecurityContextDeny, ServiceAccount, StorageObjectInUseProtection, TaintNodesByCondition, ValidatingAdmissionWebhook.
The order of plugins in this flag does not matter.
-->
除了默认启用的插件（NamespaceLifecycle、LimitRanger、ServiceAccount、TaintNodesByCondition、Priority、DefaultTolerationSeconds、DefaultStorageClass、StorageObjectInUseProtection、PersistentVolumeClaimResize、RuntimeClass、CertificateApproval、CertificateSigning、CertificateSubjectRestriction、DefaultIngressClass、MutatingAdmissionWebhook、ValidatingAdmissionWebhook、ResourceQuota）之外要启用的插件
</br>取值为逗号分隔的准入插件列表：AlwaysAdmit、AlwaysDeny、AlwaysPullImages、CertificateApproval、CertificateSigning、CertificateSubjectRestriction、DefaultIngressClass、DefaultStorageClass、DefaultTolerationSeconds、DenyServiceExternalIPs、EventRateLimit、ExtendedResourceToleration、ImagePolicyWebhook、LimitPodHardAntiAffinityTopology、LimitRanger、MutatingAdmissionWebhook、NamespaceAutoProvision、NamespaceExists、NamespaceLifecycle、NodeRestriction、OwnerReferencesPermissionEnforcement、PersistentVolumeClaimResize、PersistentVolumeLabel、PodNodeSelector、PodSecurityPolicy、PodTolerationRestriction、Priority、ResourceQuota、RuntimeClass、SecurityContextDeny、ServiceAccount、StorageObjectInUseProtection、TaintNodesByCondition、ValidatingAdmissionWebhook
<br/>该标志中插件的顺序无关紧要。
</td>
</tr>
<tr>
<td colspan="2">--enable-aggregator-routing</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Turns on aggregator routing requests to endpoints IP rather than cluster IP.
-->
允许聚合器将请求路由到端点 IP 而非集群 IP。
</td>
</tr>
<tr>
<td colspan="2">--enable-bootstrap-token-auth</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Enable to allow secrets of type 'bootstrap.kubernetes.io/token' in the 'kube-system'
namespace to be used for TLS bootstrapping authentication.
-->
启用以允许将 "kube-system" 名字空间中类型为 "bootstrap.kubernetes.io/token"
的 Secret 用于 TLS 引导身份验证。
</td>
</tr>
<tr>
<td colspan="2">--enable-garbage-collector&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值：true</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Enables the generic garbage collector. MUST be synced with the corresponding flag of the kube-controller-manager.
-->
启用通用垃圾收集器。必须与 kube-controller-manager 的相应标志同步。
</td>
</tr>
<tr>
<td colspan="2">--enable-priority-and-fairness&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值：true</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
If true and the APIPriorityAndFairness feature gate is enabled, 
replace the max-in-flight handler with an enhanced one that queues 
and dispatches with priority and fairness
-->
如果为 true 且启用了 <code>APIPriorityAndFairness</code> 特性门控，
请使用增强的处理程序替换 max-in-flight 处理程序，
以便根据优先级和公平性完成排队和调度。
</td>
</tr>
<tr>
<td colspan="2">--encryption-provider-config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The file containing configuration for encryption providers to be used for storing secrets in etcd
-->
包含加密提供程序配置信息的文件，用在 etcd 中所存储的 Secret 上。
</td>
</tr>
<tr>
<td colspan="2">--endpoint-reconciler-type string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值："lease"</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Use an endpoint reconciler (master-count, lease, none)
-->
使用端点协调器（<code>master-count</code>、<code>lease</code> 或 <code>none</code>）。
</td>
</tr>
<tr>
<td colspan="2">--etcd-cafile string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
SSL Certificate Authority file used to secure etcd communication.
-->
用于保护 etcd 通信的 SSL 证书颁发机构文件。
</td>
</tr>
<tr>
<td colspan="2">--etcd-certfile string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
SSL certification file used to secure etcd communication.
-->
用于保护 etcd 通信的 SSL 证书文件。
</td>
</tr>
<tr>
<td colspan="2">--etcd-compaction-interval duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值：5m0s</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The interval of compaction requests. If 0, the compaction request from apiserver is disabled.
-->
压缩请求的间隔。
如果为0，则禁用来自 API 服务器的压缩请求。
</td>
</tr>
<tr>
<td colspan="2">--etcd-count-metric-poll-period duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值：1m0s</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Frequency of polling etcd for number of resources per type. 0 disables the metric collection.
-->
针对每种类型的资源数量轮询 etcd 的频率。
0 值表示禁用度量值收集。
</td>
</tr>
<tr>
<td colspan="2">--etcd-db-metric-poll-interval duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值：30s</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The interval of requests to poll etcd and update metric. 0 disables the metric collection
-->
轮询 etcd 和更新度量值的请求间隔。0 值表示禁用度量值收集。
</td>
</tr>
<tr>
<td colspan="2">--etcd-healthcheck-timeout duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:—->默认值：2s</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The timeout to use when checking etcd health.
-->
检查 etcd 健康状况时使用的超时时长。
</td>
</tr>
<tr>
<td colspan="2">--etcd-keyfile string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
SSL key file used to secure etcd communication.<
-->
用于保护 etcd 通信的 SSL 密钥文件。
</td>
</tr>
<tr>
<td colspan="2">--etcd-prefix string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值："/registry"</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The prefix to prepend to all resource paths in etcd.
-->
要在 etcd 中所有资源路径之前添加的前缀。
</td>
</tr>
<tr>
<td colspan="2">--etcd-servers strings</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
List of etcd servers to connect with (scheme://ip:port), comma separated.
-->
要连接的 etcd 服务器列表（<code>scheme://ip:port</code>），以逗号分隔。
</td>
</tr>
<tr>
<td colspan="2">--etcd-servers-overrides strings</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Per-resource etcd servers overrides, comma separated. 
The individual override format: group/resource#servers, 
where servers are URLs, semicolon separated.
-->
etcd 服务器针对每个资源的重载设置，以逗号分隔。
单个替代格式：组/资源#服务器（group/resource#servers），
其中服务器是 URL，以分号分隔。
</td>
</tr>
<tr>
<td colspan="2">--event-ttl duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值：1h0m0s</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Amount of time to retain events.
-->
事件的保留时长。
</td>
</tr>
<tr>
<td colspan="2">--experimental-logging-sanitization</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--[Experimental] When enabled prevents logging of fields tagged as sensitive (passwords, keys, tokens).<br/>Runtime log sanitization may introduce significant computation overhead and therefore should not be enabled in production.
-->
[试验性功能] 启用此标志时，被标记为敏感的字段（密码、密钥、令牌）都不会被日志输出。<br/>
运行时的日志清理可能会引入相当程度的计算开销，因此不应该在产品环境中启用。
</td>
</tr>
<tr>
<td colspan="2">--external-hostname string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The hostname to use when generating externalized URLs for this master 
(e.g. Swagger API Docs or OpenID Discovery).
-->
为此主机生成外部化 UR L时要使用的主机名（例如 Swagger API 文档或 OpenID 发现）。
</td>
</tr>
<tr>
<td colspan="2">--feature-gates &lt;逗号分隔的 'key=True|False' 键值对&gt;</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
A set of key=value pairs that describe feature gates for alpha/experimental features. Options are:<br/>
APIListChunking=true|false (BETA - default=true)<br/>
APIPriorityAndFairness=true|false (BETA - default=true)<br/>
APIResponseCompression=true|false (BETA - default=true)<br/>
APIServerIdentity=true|false (ALPHA - default=false)<br/>
AllAlpha=true|false (ALPHA - default=false)<br/>
AllBeta=true|false (BETA - default=false)<br/>
AnyVolumeDataSource=true|false (ALPHA - default=false)<br/>
AppArmor=true|false (BETA - default=true)<br/>
BalanceAttachedNodeVolumes=true|false (ALPHA - default=false)<br/>
BoundServiceAccountTokenVolume=true|false (BETA - default=true)<br/>
CPUManager=true|false (BETA - default=true)<br/>
CSIInlineVolume=true|false (BETA - default=true)<br/>
CSIMigration=true|false (BETA - default=true)<br/>
CSIMigrationAWS=true|false (BETA - default=false)<br/>
CSIMigrationAzureDisk=true|false (BETA - default=false)<br/>
CSIMigrationAzureFile=true|false (BETA - default=false)<br/>
CSIMigrationGCE=true|false (BETA - default=false)<br/>
CSIMigrationOpenStack=true|false (BETA - default=true)<br/>
CSIMigrationvSphere=true|false (BETA - default=false)<br/>
CSIMigrationvSphereComplete=true|false (BETA - default=false)<br/>
CSIServiceAccountToken=true|false (BETA - default=true)<br/>
CSIStorageCapacity=true|false (BETA - default=true)<br/>
CSIVolumeFSGroupPolicy=true|false (BETA - default=true)<br/>
CSIVolumeHealth=true|false (ALPHA - default=false)<br/>
ConfigurableFSGroupPolicy=true|false (BETA - default=true)<br/>
ControllerManagerLeaderMigration=true|false (ALPHA - default=false)<br/>
CronJobControllerV2=true|false (BETA - default=true)<br/>
CustomCPUCFSQuotaPeriod=true|false (ALPHA - default=false)<br/>
DaemonSetUpdateSurge=true|false (ALPHA - default=false)<br/>
DefaultPodTopologySpread=true|false (BETA - default=true)<br/>
DevicePlugins=true|false (BETA - default=true)<br/>
DisableAcceleratorUsageMetrics=true|false (BETA - default=true)<br/>
DownwardAPIHugePages=true|false (BETA - default=false)<br/>
DynamicKubeletConfig=true|false (BETA - default=true)<br/>
EfficientWatchResumption=true|false (BETA - default=true)<br/>
EndpointSliceProxying=true|false (BETA - default=true)<br/>
EndpointSliceTerminatingCondition=true|false (ALPHA - default=false)<br/>
EphemeralContainers=true|false (ALPHA - default=false)<br/>
ExpandCSIVolumes=true|false (BETA - default=true)<br/>
ExpandInUsePersistentVolumes=true|false (BETA - default=true)<br/>
ExpandPersistentVolumes=true|false (BETA - default=true)<br/>
ExperimentalHostUserNamespaceDefaulting=true|false (BETA - default=false)<br/>
GenericEphemeralVolume=true|false (BETA - default=true)<br/>
GracefulNodeShutdown=true|false (BETA - default=true)<br/>
HPAContainerMetrics=true|false (ALPHA - default=false)<br/>
HPAScaleToZero=true|false (ALPHA - default=false)<br/>
HugePageStorageMediumSize=true|false (BETA - default=true)<br/>
IPv6DualStack=true|false (BETA - default=true)<br/>
InTreePluginAWSUnregister=true|false (ALPHA - default=false)<br/>
InTreePluginAzureDiskUnregister=true|false (ALPHA - default=false)<br/>
InTreePluginAzureFileUnregister=true|false (ALPHA - default=false)<br/>
InTreePluginGCEUnregister=true|false (ALPHA - default=false)<br/>
InTreePluginOpenStackUnregister=true|false (ALPHA - default=false)<br/>
InTreePluginvSphereUnregister=true|false (ALPHA - default=false)<br/>
IndexedJob=true|false (ALPHA - default=false)<br/>
IngressClassNamespacedParams=true|false (ALPHA - default=false)<br/>
KubeletCredentialProviders=true|false (ALPHA - default=false)<br/>
KubeletPodResources=true|false (BETA - default=true)<br/>
KubeletPodResourcesGetAllocatable=true|false (ALPHA - default=false)<br/>
LocalStorageCapacityIsolation=true|false (BETA - default=true)<br/>
LocalStorageCapacityIsolationFSQuotaMonitoring=true|false (ALPHA - default=false)<br/>
LogarithmicScaleDown=true|false (ALPHA - default=false)<br/>
MemoryManager=true|false (ALPHA - default=false)<br/>
MixedProtocolLBService=true|false (ALPHA - default=false)<br/>
NamespaceDefaultLabelName=true|false (BETA - default=true)<br/>
NetworkPolicyEndPort=true|false (ALPHA - default=false)<br/>
NonPreemptingPriority=true|false (BETA - default=true)<br/>
PodAffinityNamespaceSelector=true|false (ALPHA - default=false)<br/>
PodDeletionCost=true|false (ALPHA - default=false)<br/>
PodOverhead=true|false (BETA - default=true)<br/>
PreferNominatedNode=true|false (ALPHA - default=false)<br/>
ProbeTerminationGracePeriod=true|false (ALPHA - default=false)<br/>
ProcMountType=true|false (ALPHA - default=false)<br/>
QOSReserved=true|false (ALPHA - default=false)<br/>
RemainingItemCount=true|false (BETA - default=true)<br/>
RemoveSelfLink=true|false (BETA - default=true)<br/>
RotateKubeletServerCertificate=true|false (BETA - default=true)<br/>
ServerSideApply=true|false (BETA - default=true)<br/>
ServiceInternalTrafficPolicy=true|false (ALPHA - default=false)<br/>
ServiceLBNodePortControl=true|false (ALPHA - default=false)<br/>
ServiceLoadBalancerClass=true|false (ALPHA - default=false)<br/>
ServiceTopology=true|false (ALPHA - default=false)<br/>
SetHostnameAsFQDN=true|false (BETA - default=true)<br/>
SizeMemoryBackedVolumes=true|false (ALPHA - default=false)<br/>
StorageVersionAPI=true|false (ALPHA - default=false)<br/>
StorageVersionHash=true|false (BETA - default=true)<br/>
SuspendJob=true|false (ALPHA - default=false)<br/>
TTLAfterFinished=true|false (BETA - default=true)<br/>
TopologyAwareHints=true|false (ALPHA - default=false)<br/>
TopologyManager=true|false (BETA - default=true)<br/>
ValidateProxyRedirects=true|false (BETA - default=true)<br/>
VolumeCapacityPriority=true|false (ALPHA - default=false)<br/>
WarningHeaders=true|false (BETA - default=true)<br/>
WinDSR=true|false (ALPHA - default=false)<br/>
WinOverlay=true|false (BETA - default=true)<br/>
WindowsEndpointSliceProxying=true|false (BETA - default=true)
-->
<p>一组 key=value 对，用来描述测试性/试验性功能的特性门控。可选项有：
APIListChunking=true|false (BETA - 默认值=true)<br/>
APIPriorityAndFairness=true|false (BETA - 默认值=true)<br/>
APIResponseCompression=true|false (BETA - 默认值=true)<br/>
APIServerIdentity=true|false (ALPHA - 默认值=false)<br/>
AllAlpha=true|false (ALPHA - 默认值=false)<br/>
AllBeta=true|false (BETA - 默认值=false)<br/>
AnyVolumeDataSource=true|false (ALPHA - 默认值=false)<br/>
AppArmor=true|false (BETA - 默认值=true)<br/>
BalanceAttachedNodeVolumes=true|false (ALPHA - 默认值=false)<br/>
BoundServiceAccountTokenVolume=true|false (BETA - 默认值=true)<br/>
CPUManager=true|false (BETA - 默认值=true)<br/>
CSIInlineVolume=true|false (BETA - 默认值=true)<br/>
CSIMigration=true|false (BETA - 默认值=true)<br/>
CSIMigrationAWS=true|false (BETA - 默认值=false)<br/>
CSIMigrationAzureDisk=true|false (BETA - 默认值=false)<br/>
CSIMigrationAzureFile=true|false (BETA - 默认值=false)<br/>
CSIMigrationGCE=true|false (BETA - 默认值=false)<br/>
CSIMigrationOpenStack=true|false (BETA - 默认值=true)<br/>
CSIMigrationvSphere=true|false (BETA - 默认值=false)<br/>
CSIMigrationvSphereComplete=true|false (BETA - 默认值=false)<br/>
CSIServiceAccountToken=true|false (BETA - 默认值=true)<br/>
CSIStorageCapacity=true|false (BETA - 默认值=true)<br/>
CSIVolumeFSGroupPolicy=true|false (BETA - 默认值=true)<br/>
CSIVolumeHealth=true|false (ALPHA - 默认值=false)<br/>
ConfigurableFSGroupPolicy=true|false (BETA - 默认值=true)<br/>
ControllerManagerLeaderMigration=true|false (ALPHA - 默认值=false)<br/>
CronJobControllerV2=true|false (BETA - 默认值=true)<br/>
CustomCPUCFSQuotaPeriod=true|false (ALPHA - 默认值=false)<br/>
DaemonSetUpdateSurge=true|false (ALPHA - 默认值=false)<br/>
DefaultPodTopologySpread=true|false (BETA - 默认值=true)<br/>
DevicePlugins=true|false (BETA - 默认值=true)<br/>
DisableAcceleratorUsageMetrics=true|false (BETA - 默认值=true)<br/>
DownwardAPIHugePages=true|false (BETA - 默认值=false)<br/>
DynamicKubeletConfig=true|false (BETA - 默认值=true)<br/>
EfficientWatchResumption=true|false (BETA - 默认值=true)<br/>
EndpointSliceProxying=true|false (BETA - 默认值=true)<br/>
EndpointSliceTerminatingCondition=true|false (ALPHA - 默认值=false)<br/>
EphemeralContainers=true|false (ALPHA - 默认值=false)<br/>
ExpandCSIVolumes=true|false (BETA - 默认值=true)<br/>
ExpandInUsePersistentVolumes=true|false (BETA - 默认值=true)<br/>
ExpandPersistentVolumes=true|false (BETA - 默认值=true)<br/>
ExperimentalHostUserNamespace默认值ing=true|false (BETA - 默认值=false)<br/>
GenericEphemeralVolume=true|false (BETA - 默认值=true)<br/>
GracefulNodeShutdown=true|false (BETA - 默认值=true)<br/>
HPAContainerMetrics=true|false (ALPHA - 默认值=false)<br/>
HPAScaleToZero=true|false (ALPHA - 默认值=false)<br/>
HugePageStorageMediumSize=true|false (BETA - 默认值=true)<br/>
IPv6DualStack=true|false (BETA - 默认值=true)<br/>
InTreePluginAWSUnregister=true|false (ALPHA - 默认值=false)<br/>
InTreePluginAzureDiskUnregister=true|false (ALPHA - 默认值=false)<br/>
InTreePluginAzureFileUnregister=true|false (ALPHA - 默认值=false)<br/>
InTreePluginGCEUnregister=true|false (ALPHA - 默认值=false)<br/>
InTreePluginOpenStackUnregister=true|false (ALPHA - 默认值=false)<br/>
InTreePluginvSphereUnregister=true|false (ALPHA - 默认值=false)<br/>
IndexedJob=true|false (ALPHA - 默认值=false)<br/>
IngressClassNamespacedParams=true|false (ALPHA - 默认值=false)<br/>
KubeletCredentialProviders=true|false (ALPHA - 默认值=false)<br/>
KubeletPodResources=true|false (BETA - 默认值=true)<br/>
KubeletPodResourcesGetAllocatable=true|false (ALPHA - 默认值=false)<br/>
LocalStorageCapacityIsolation=true|false (BETA - 默认值=true)<br/>
LocalStorageCapacityIsolationFSQuotaMonitoring=true|false (ALPHA - 默认值=false)<br/>
LogarithmicScaleDown=true|false (ALPHA - 默认值=false)<br/>
MemoryManager=true|false (ALPHA - 默认值=false)<br/>
MixedProtocolLBService=true|false (ALPHA - 默认值=false)<br/>
NamespaceDefaultLabelName=true|false (BETA - 默认值=true)<br/>
NetworkPolicyEndPort=true|false (ALPHA - 默认值=false)<br/>
NonPreemptingPriority=true|false (BETA - 默认值=true)<br/>
PodAffinityNamespaceSelector=true|false (ALPHA - 默认值=false)<br/>
PodDeletionCost=true|false (ALPHA - 默认值=false)<br/>
PodOverhead=true|false (BETA - 默认值=true)<br/>
PreferNominatedNode=true|false (ALPHA - 默认值=false)<br/>
ProbeTerminationGracePeriod=true|false (ALPHA - 默认值=false)<br/>
ProcMountType=true|false (ALPHA - 默认值=false)<br/>
QOSReserved=true|false (ALPHA - 默认值=false)<br/>
RemainingItemCount=true|false (BETA - 默认值=true)<br/>
RemoveSelfLink=true|false (BETA - 默认值=true)<br/>
RotateKubeletServerCertificate=true|false (BETA - 默认值=true)<br/>
ServerSideApply=true|false (BETA - 默认值=true)<br/>
ServiceInternalTrafficPolicy=true|false (ALPHA - 默认值=false)<br/>
ServiceLBNodePortControl=true|false (ALPHA - 默认值=false)<br/>
ServiceLoadBalancerClass=true|false (ALPHA - 默认值=false)<br/>
ServiceTopology=true|false (ALPHA - 默认值=false)<br/>
SetHostnameAsFQDN=true|false (BETA - 默认值=true)<br/>
SizeMemoryBackedVolumes=true|false (ALPHA - 默认值=false)<br/>
StorageVersionAPI=true|false (ALPHA - 默认值=false)<br/>
StorageVersionHash=true|false (BETA - 默认值=true)<br/>
SuspendJob=true|false (ALPHA - 默认值=false)<br/>
TTLAfterFinished=true|false (BETA - 默认值=true)<br/>
TopologyAwareHints=true|false (ALPHA - 默认值=false)<br/>
TopologyManager=true|false (BETA - 默认值=true)<br/>
ValidateProxyRedirects=true|false (BETA - 默认值=true)<br/>
VolumeCapacityPriority=true|false (ALPHA - 默认值=false)<br/>
WarningHeaders=true|false (BETA - 默认值=true)<br/>
WinDSR=true|false (ALPHA - 默认值=false)<br/>
WinOverlay=true|false (BETA - 默认值=true)<br/>
WindowsEndpointSliceProxying=true|false (BETA - 默认值=true)</p>
</td>
</tr>
<tr>
<td colspan="2">--goaway-chance float</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
To prevent HTTP/2 clients from getting stuck on a single apiserver, 
randomly close a connection (GOAWAY). The client's other in-flight 
requests won't be affected, and the client will reconnect, likely 
landing on a different apiserver after going through the load 
balancer again. This argument sets the fraction of requests that 
will be sent a GOAWAY. Clusters with single apiservers, or which 
don't use a load balancer, should NOT enable this. Min is 0 (off), 
Max is .02 (1/50 requests); .001 (1/1000) is a recommended starting point.
-->
为防止 HTTP/2 客户端卡在单个 API 服务器上，可启用随机关闭连接（GOAWAY）。
客户端的其他运行中请求将不会受到影响，并且客户端将重新连接，
可能会在再次通过负载平衡器后登陆到其他 API 服务器上。 
此参数设置将发送 GOAWAY 的请求的比例。 
具有单个 API 服务器或不使用负载平衡器的群集不应启用此功能。 
最小值为0（关闭），最大值为 .02（1/50 请求）； 建议使用 .001（1/1000）。
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for kube-apiserver
-->
kube-apiserver 的帮助命令
</td>
</tr>
<tr>
<td colspan="2">--http2-max-streams-per-connection int</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The limit that the server gives to clients for the maximum number 
of streams in an HTTP/2 connection. Zero means to use golang's default.
-->
服务器为客户端提供的 HTTP/2 连接中最大流数的限制。
零表示使用 GoLang 的默认值。
</td>
</tr>
<tr>
<td colspan="2">--identity-lease-duration-seconds int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值：3600</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The duration of kube-apiserver lease in seconds, must be a positive number. (In use when the APIServerIdentity feature gate is enabled.)
-->
kube-apiserver 租约时长（按秒计），必须是正数。
（当 APIServerIdentity 特性门控被启用时使用此标志值）
</td>
</tr>
<tr>
<td colspan="2">--identity-lease-renew-interval-seconds int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值：10</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The interval of kube-apiserver renewing its lease in seconds, must be a positive number. (In use when the APIServerIdentity feature gate is enabled.)
-->
kube-apiserver 对其租约进行续期的时间间隔（按秒计），必须是正数。
（当 APIServerIdentity 特性门控被启用时使用此标志值）
</td>
</tr>
<tr>
<td colspan="2">--kubelet-certificate-authority string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to a cert file for the certificate authority.
-->
证书颁发机构的证书文件的路径。
</td>
</tr>
<tr>
<td colspan="2">--kubelet-client-certificate string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to a client cert file for TLS.
-->
TLS 的客户端证书文件的路径。
</td>
</tr>
<tr>
<td colspan="2">--kubelet-client-key string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to a client key file for TLS.
-->
TLS 客户端密钥文件的路径。
</td>
</tr>
<tr>
<td colspan="2">--kubelet-preferred-address-types strings&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值：Hostname,InternalDNS,InternalIP,ExternalDNS,ExternalIP</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
List of the preferred NodeAddressTypes to use for kubelet connections.
-->
用于 kubelet 连接的首选 NodeAddressTypes 列表。
</td>
</tr>
<tr>
<td colspan="2">--kubelet-timeout duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值：5s</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Timeout for kubelet operations.
-->
kubelet 操作超时时间。
</td>
</tr>
<tr>
<td colspan="2">--kubernetes-service-node-port int</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
If non-zero, the Kubernetes master service (which apiserver creates/maintains) 
will be of type NodePort, using this as the value of the port. If zero, 
the Kubernetes master service will be of type ClusterIP.
-->
如果非零，那么 Kubernetes 主服务（由 apiserver 创建/维护）将是 NodePort 类型，
使用它作为端口的值。
如果为零，则 Kubernetes 主服务将为 ClusterIP 类型。
</td>
</tr>
<tr>
<td colspan="2">--lease-reuse-duration-seconds int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值：60</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The time in seconds that each lease is reused. A lower value could avoid large number of objects reusing the same lease. Notice that a too small value may cause performance problems at storage layer.
-->
每个租约被重用的时长。
如果此值比较低，可以避免大量对象重用此租约。
注意，如果此值过小，可能导致存储层出现性能问题。
</td>
</tr>
<tr>
<td colspan="2">--livez-grace-period duration</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
This option represents the maximum amount of time it should take for apiserver 
to complete its startup sequence and become live. From apiserver's start time 
to when this amount of time has elapsed, /livez will assume that unfinished 
post-start hooks will complete successfully and therefore return true.
-->
此选项代表 API 服务器完成启动序列并生效所需的最长时间。
从 API 服务器的启动时间到这段时间为止，
<tt>/livez</tt> 将假定未完成的启动后钩子将成功完成，因此返回 true。
</td>
</tr>
<tr>
<td colspan="2">--log-backtrace-at traceLocation&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值：<tt>:0</tt></td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
when logging hits line file:N, emit a stack trace
-->
当日志机制执行到'文件 :N'时，生成堆栈跟踪。
</td>
</tr>
<tr>
<td colspan="2">--log-dir string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
If non-empty, write log files in this directory
-->
如果为非空，则在此目录中写入日志文件。
</td>
</tr>
<tr>
<td colspan="2">--log-file string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
If non-empty, use this log file
-->
如果为非空，使用此值作为日志文件。
</td>
</tr>
<tr>
<td colspan="2">--log-file-max-size uint&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值：1800</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Defines the maximum size a log file can grow to. Unit is megabytes. 
If the value is 0, the maximum file size is unlimited.
-->
定义日志文件可以增长到的最大大小。单位为兆字节。
如果值为 0，则最大文件大小为无限制。
</td>
</tr>
<tr>
<td colspan="2">--log-flush-frequency duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值：5s</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Maximum number of seconds between log flushes
-->
两次日志刷新之间的最大秒数
</td>
</tr>
<tr>
<td colspan="2">--logging-format string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值："text"</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Sets the log format. Permitted formats: "json", "text".<br/>Non-default formats don't honor these flags: --add_dir_header, --alsologtostderr, --log_backtrace_at, --log_dir, --log_file, --log_file_max_size, --logtostderr, --one_output, --skip_headers, --skip_log_headers, --stderrthreshold, --vmodule, --log-flush-frequency.<br/>Non-default choices are currently alpha and subject to change without warning.
-->
设置日志格式。允许的格式："json"，"json"。<br/>
非默认格式不支持以下标志：<code>--add-dir-header</code>、<code>--alsologtostderr</code>、<code>--log-backtrace-at</code>、<code>--log-dir</code>、<code>--log-file</code>、<code>--log-file-max-size</code>、<code>--logtostderr</code>、<code>--one-output</code>、<code>-skip-headers</code>、<code>-skip-log-headers</code>、<code>--stderrthreshold</code>、<code>-vmodule</code> 和 <code>--log-flush-frequency</code>。<br/>
当前非默认选择为 alpha，会随时更改而不会发出警告。
</td>
</tr>
<tr>
<td colspan="2">--logtostderr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值：true</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
log to standard error instead of files
-->
在标准错误而不是文件中输出日志记录。
</td>
</tr>
<tr>
<td colspan="2">--master-service-namespace string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值："default"</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
DEPRECATED: the namespace from which the Kubernetes master services should be injected into pods.
-->
已废弃：应该从其中将 Kubernetes 主服务注入到 Pod 中的名字空间。
</td>
</tr>
<tr>
<td colspan="2">--max-connection-bytes-per-sec int</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
If non-zero, throttle each user connection to this number of bytes/sec. Currently only applies to long-running requests.
-->
如果不为零，则将每个用户连接限制为该数（字节数/秒）。
当前仅适用于长时间运行的请求。
</td>
</tr>
<tr>
<td colspan="2">--max-mutating-requests-inflight int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值：200</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The maximum number of mutating requests in flight at a given time. 
When the server exceeds this, it rejects requests. Zero for no limit.
-->
在给定时间内进行中变更类型请求的最大个数。
当超过该值时，服务将拒绝所有请求。
零表示无限制。
</td>
</tr>
<tr>
<td colspan="2">--max-requests-inflight int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值：400</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The maximum number of non-mutating requests in flight at a given time. 
When the server exceeds this, it rejects requests. Zero for no limit.
-->
在给定时间内进行中非变更类型请求的最大数量。
当超过该值时，服务将拒绝所有请求。
零表示无限制。
</td>
</tr>
<tr>
<td colspan="2">--min-request-timeout int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值：1800</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--  
An optional field indicating the minimum number of seconds a handler must 
keep a request open before timing it out. Currently only honored by the 
watch request handler, which picks a randomized value above this number 
as the connection timeout, to spread out load.
-->
可选字段，表示处理程序在请求超时前，必须保持其处于打开状态的最小秒数。
当前只对监听（Watch）请求的处理程序有效，它基于这个值选择一个随机数作为连接超时值，
以达到分散负载的目的。
</td>
</tr>
<tr>
<td colspan="2">--oidc-ca-file string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
If set, the OpenID server's certificate will be verified by one of 
the authorities in the oidc-ca-file, otherwise the host's root CA set will be used.
-->
如果设置该值，将会使用 oidc-ca-file 中的机构之一对 OpenID 服务的证书进行验证，
否则将会使用主机的根 CA 对其进行验证。
</td>
</tr>
<tr>
<td colspan="2">--oidc-client-id string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The client ID for the OpenID Connect client, must be set if oidc-issuer-url is set.
-->
OpenID 连接客户端的要使用的客户 ID，如果设置了 oidc-issuer-url，则必须设置这个值。
</td>
</tr>
<tr>
<td colspan="2">--oidc-groups-claim string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
If provided, the name of a custom OpenID Connect claim for specifying user groups. 
The claim value is expected to be a string or array of strings. 
This flag is experimental, please see the authentication documentation for further details.
-->
如果提供该值，这个自定义 OpenID 连接声明将被用来设定用户组。
该声明值需要是一个字符串或字符串数组。
此标志为实验性的，请查阅身份认证相关文档进一步了解详细信息。
</td>
</tr>
<tr>
<td colspan="2">--oidc-groups-prefix string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
If provided, all groups will be prefixed with this value to 
prevent conflicts with other authentication strategies.
-->
如果提供了此值，则所有组都将以该值作为前缀，以防止与其他身份认证策略冲突。
</td>
</tr>
<tr>
<td colspan="2">--oidc-issuer-url string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The URL of the OpenID issuer, only HTTPS scheme will be accepted. 
If set, it will be used to verify the OIDC JSON Web Token (JWT).
-->
OpenID 颁发者 URL，只接受 HTTPS 方案。
如果设置该值，它将被用于验证 OIDC JSON Web Token(JWT)。
</td>
</tr>
<tr>
<td colspan="2">--oidc-required-claim &lt;逗号分隔的 'key=value' 键值对列表&gt;</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
A key=value pair that describes a required claim in the ID Token. 
If set, the claim is verified to be present in the ID Token with a matching value. 
Repeat this flag to specify multiple claims.
-->
描述 ID 令牌中必需声明的键值对。
如果设置此值，则会验证 ID 令牌中存在与该声明匹配的值。
重复此标志以指定多个声明。
</td>
</tr>
<tr>
<td colspan="2">--oidc-signing-algs strings&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值：RS256</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Comma-separated list of allowed JOSE asymmetric signing algorithms. 
JWTs with a 'alg' header value not in this list will be rejected. 
Values are defined by RFC 7518 https://tools.ietf.org/html/rfc7518#section-3.1.
-->
允许的 JOSE 非对称签名算法的逗号分隔列表。
若 JWT 所带的 "alg" 标头值不在列表中，则该 JWT 将被拒绝。
取值依据 RFC 7518 https://tools.ietf.org/html/rfc7518#section-3.1 定义。
</td>
</tr>
<tr>
<td colspan="2">--oidc-username-claim string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值："sub"</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The OpenID claim to use as the user name. Note that claims other than
 the default ('sub') is not guaranteed to be unique and immutable. 
 This flag is experimental, please see the authentication documentation for further details.
-->
要用作用户名的 OpenID 声明。
请注意，除默认声明（"sub"）以外的其他声明不能保证是唯一且不可变的。
此标志是实验性的，请参阅身份认证文档以获取更多详细信息。
</td>
</tr>
<tr>
<td colspan="2">--oidc-username-prefix string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
If provided, all usernames will be prefixed with this value. 
If not provided, username claims other than 'email' are prefixed
 by the issuer URL to avoid clashes. To skip any prefixing, provide the value '-'.
-->
如果提供，则所有用户名都将以该值作为前缀。
如果未提供，则除 "email" 之外的用户名声明都会添加颁发者 URL 作为前缀，以避免冲突。
要略过添加前缀处理，请设置值为 "-"。
</td>
</tr>
<tr>
<td colspan="2">--one-output</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
If true, only write logs to their native severity level (vs also writing to each lower severity level
-->
此标志为真时，日志只会被写入到其原生的严重性级别中（而不是同时写到所有较低
严重性级别中）。
</td>
</tr>
<tr>
<td colspan="2">--permit-address-sharing&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值：false</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;"><p>
<!--If true, SO_REUSEADDR will be used when binding the port. This allows binding to wildcard IPs like 0.0.0.0 and specific IPs in parallel, and it avoids waiting for the kernel to release sockets in TIME_WAIT state.
-->
若此标志为 true，则使用 <tt>SO_REUSEADDR</tt> 来绑定端口。
这样设置可以同时绑定到用通配符表示的类似 0.0.0.0 这种 IP 地址，
以及特定的 IP 地址。也可以避免等待内核释放 <tt>TIME_WAIT</tt> 状态的套接字。
</p></td>
</tr>
<tr>
<td colspan="2">--permit-port-sharing&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值：false</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
If true, SO_REUSEPORT will be used when binding the port, 
which allows more than one instance to bind on the same address and port. [default=false]
-->
如果为 true，则在绑定端口时将使用 <tt>SO_REUSEPORT</tt>，
这样多个实例可以绑定到同一地址和端口上。
</td>
</tr>
<tr>
<td colspan="2">--profiling&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值：true</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Enable profiling via web interface host:port/debug/pprof/
-->
通过 Web 接口 <code>host:port/debug/pprof/</code> 启用性能分析。
</td>
</tr>
<tr>
<td colspan="2">--proxy-client-cert-file string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Client certificate used to prove the identity of the aggregator or 
kube-apiserver when it must call out during a request. This includes 
proxying requests to a user api-server and calling out to webhook 
admission plugins. It is expected that this cert includes a signature 
from the CA in the --requestheader-client-ca-file flag. That CA is 
published in the 'extension-apiserver-authentication' configmap in 
the kube-system namespace. Components receiving calls from kube-aggregator 
should use that CA to perform their half of the mutual TLS verification.
-->
当必须调用外部程序以处理请求时，用于证明聚合器或者 kube-apiserver 的身份的客户端证书。
包括代理转发到用户 api-server 的请求和调用 Webhook 准入控制插件的请求。
Kubernetes 期望此证书包含来自于 --requestheader-client-ca-file 标志中所给 CA 的签名。
该 CA 在 kube-system 命名空间的 "extension-apiserver-authentication" ConfigMap 中公开。
从 kube-aggregator 收到调用的组件应该使用该 CA 进行各自的双向 TLS 验证。
</td>
</tr>
<tr>
<td colspan="2">--proxy-client-key-file string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Private key for the client certificate used to prove the identity of 
the aggregator or kube-apiserver when it must call out during a request. 
This includes proxying requests to a user api-server and calling out to 
webhook admission plugins.
-->
当必须调用外部程序来处理请求时，用来证明聚合器或者 kube-apiserver 的身份的客户端私钥。
这包括代理转发给用户 api-server 的请求和调用 Webhook 准入控制插件的请求。
</td>
</tr>
<tr>
<td colspan="2">--request-timeout duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值：1m0s</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
An optional field indicating the duration a handler must keep a request 
open before timing it out. This is the default request timeout for 
requests but may be overridden by flags such as --min-request-timeout 
for specific types of requests.
-->
可选字段，指示处理程序在超时之前必须保持打开请求的持续时间。 
这是请求的默认请求超时，但对于特定类型的请求，可能会被
<code>--min-request-timeout</code>等标志覆盖。
</td>
</tr>
<tr>
<td colspan="2">--requestheader-allowed-names strings</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
List of client certificate common names to allow to provide usernames 
in headers specified by --requestheader-username-headers. If empty, 
any client certificate validated by the authorities in 
--requestheader-client-ca-file is allowed.
-->
此值为客户端证书通用名称（Common Name）的列表；表中所列的表项可以用来提供用户名，
方式是使用 <code>--requestheader-username-headers</code> 所指定的头部。
如果为空，能够通过 <code>--requestheader-client-ca-file</code> 中机构
认证的客户端证书都是被允许的。
</td>
</tr>
<tr>
<td colspan="2">--requestheader-client-ca-file string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Root certificate bundle to use to verify client certificates on 
incoming requests before trusting usernames in headers specified 
by --requestheader-username-headers. WARNING: generally do not 
depend on authorization being already done for incoming requests.
-->
在信任请求头中以 <code>--requestheader-username-headers</code> 指示的用户名之前，
用于验证接入请求中客户端证书的根证书包。
警告：一般不要假定传入请求已被授权。
</td>
</tr>
<tr>
<td colspan="2">--requestheader-extra-headers-prefix strings</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
List of request header prefixes to inspect. X-Remote-Extra- is suggested.
-->
用于查验请求头部的前缀列表。建议使用 <code>X-Remote-Extra-</code>。
</td>
</tr>
<tr>
<td colspan="2">--requestheader-group-headers strings</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
List of request headers to inspect for groups. X-Remote-Group is suggested.
-->
用于查验用户组的请求头部列表。建议使用 <code>X-Remote-Group</code>。
</td>
</tr>
<tr>
<td colspan="2">--requestheader-username-headers strings</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
List of request headers to inspect for usernames. X-Remote-User is common.
-->
用于查验用户名的请求头头列表。建议使用 <code>X-Remote-User</code>。
</td>
</tr>
<tr>
<td colspan="2">--runtime-config &lt;逗号分隔的 'key=value' 对列表&gt;</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
A set of key=value pairs that enable or disable built-in APIs. Supported options are:
<br/>v1=true|false for the core API group
<br/>&lt;group&gt;/&lt;version&gt;=true|false for a specific API group and version (e.g. apps/v1=true)
<br/>api/all=true|false controls all API versions
<br/>api/ga=true|false controls all API versions of the form v[0-9]+
<br/>api/beta=true|false controls all API versions of the form v[0-9]+beta[0-9]+
<br/>api/alpha=true|false controls all API versions of the form v[0-9]+alpha[0-9]+
<br/>api/legacy is deprecated, and will be removed in a future version
-->
一组启用或禁用内置 API 的键值对。支持的选项包括：
<br/>v1=true|false（针对核心 API 组）
<br/>&lt;group&gt;/&lt;version&gt;=true|false（针对特定 API 组和版本，例如：apps/v1=true） 
<br/>api/all=true|false 控制所有 API 版本
<br/>api/ga=true|false 控制所有 v[0-9]+ API 版本
<br/>api/beta=true|false 控制所有 v[0-9]+beta[0-9]+ API 版本
<br/>api/alpha=true|false 控制所有 v[0-9]+alpha[0-9]+ API 版本
<br/>api/legacy 已弃用，并将在以后的版本中删除
</td>
</tr>
<tr>
<td colspan="2">--secure-port int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值：6443</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The port on which to serve HTTPS with authentication and authorization. 
It cannot be switched off with 0.
-->
带身份验证和鉴权机制的 HTTPS 服务端口。
不能用 0 关闭。
</td>
</tr>
<tr>
<td colspan="2">--service-account-extend-token-expiration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值：true</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Turns on projected service account expiration extension during token generation, 
which helps safe transition from legacy token to bound service account token feature. 
If this flag is enabled, admission injected tokens would be extended up to 
1 year to prevent unexpected failure during transition, ignoring value of service-account-max-token-expiration.
-->
在生成令牌时，启用投射服务帐户到期时间扩展，
这有助于从旧版令牌安全地过渡到绑定的服务帐户令牌功能。
如果启用此标志，则准入插件注入的令牌的过期时间将延长至 1 年，以防止过渡期间发生意外故障，
并忽略 service-account-max-token-expiration 的值。
</td>
</tr>
<tr>
<td colspan="2">--service-account-issuer string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Identifier of the service account token issuer. The issuer will assert this 
identifier in "iss" claim of issued tokens. This value is a string or URI. 
If this option is not a valid URI per the OpenID Discovery 1.0 spec, 
the ServiceAccountIssuerDiscovery feature will remain disabled, even if 
the feature gate is set to true. It is highly recommended that this value 
comply with the OpenID spec: https://openid.net/specs/openid-connect-discovery-1_0.html. 
In practice, this means that service-account-issuer must be an https URL. 
It is also highly recommended that this URL be capable of serving OpenID 
discovery documents at {service-account-issuer}/.well-known/openid-configuration.
-->
服务帐号令牌颁发者的标识符。
颁发者将在已办法令牌的 "iss" 声明中检查此标识符。
此值为字符串或 URI。
如果根据 OpenID Discovery 1.0 规范检查此选项不是有效的 URI，则即使特性门控设置为 true，
ServiceAccountIssuerDiscovery 功能也将保持禁用状态。 
强烈建议该值符合 OpenID 规范：https://openid.net/specs/openid-connect-discovery-1_0.html。 
实践中，这意味着 service-account-issuer 取值必须是 HTTPS URL。 
还强烈建议此 URL 能够在 {service-account-issuer}/.well-known/openid-configuration
处提供 OpenID 发现文档。
</td>
</tr>
<tr>
<td colspan="2">--service-account-jwks-uri string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Overrides the URI for the JSON Web Key Set in the discovery doc served at 
/.well-known/openid-configuration. This flag is useful if the discovery 
docand key set are served to relying parties from a URL other than the 
API server's external (as auto-detected or overridden with external-hostname). 
Only valid if the ServiceAccountIssuerDiscovery feature gate is enabled.
-->
覆盖 <code>/.well-known/openid-configuration</code> 提供的发现文档中 JSON Web 密钥集的 URI。
如果发现文档和密钥集是通过 API 服务器外部
（而非自动检测到或被外部主机名覆盖）之外的 URL 提供给依赖方的，则此标志很有用。
仅在启用 ServiceAccountIssuerDiscovery 特性门控的情况下有效。
</td>
</tr>
<tr>
<td colspan="2">--service-account-key-file strings</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
File containing PEM-encoded x509 RSA or ECDSA private or public keys,
used to verify ServiceAccount tokens. The specified file can contain 
multiple keys, and the flag can be specified multiple times with 
different files. If unspecified, --tls-private-key-file is used. 
Must be specified when --service-account-signing-key is provided
-->
包含 PEM 编码的 x509 RSA 或 ECDSA 私钥或公钥的文件，用于验证 ServiceAccount 令牌。
指定的文件可以包含多个键，并且可以使用不同的文件多次指定标志。
如果未指定，则使用 <code>--tls-private-key-file</code>。
提供 <code>--service-account-signing-key</code> 时必须指定。
</td>
</tr>
<tr>
<td colspan="2">--service-account-lookup&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值：true</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
If true, validate ServiceAccount tokens exist in etcd as part of authentication.
-->
如果为 true，则在身份认证时验证 etcd 中是否存在 ServiceAccount 令牌。
</td>
</tr>
<tr>
<td colspan="2">--service-account-max-token-expiration duration</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The maximum validity duration of a token created by the service account token issuer. 
If an otherwise valid TokenRequest with a validity duration larger than this value is requested, 
a token will be issued with a validity duration of this value.
-->
服务帐户令牌发布者创建的令牌的最长有效期。
如果请求有效期大于此值的有效令牌请求，将使用此值的有效期颁发令牌。
</td>
</tr>
<tr>
<td colspan="2">--service-account-signing-key-file string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to the file that contains the current private key of the service account token issuer. 
The issuer will sign issued ID tokens with this private key. 
-->
包含服务帐户令牌颁发者当前私钥的文件的路径。
颁发者将使用此私钥签署所颁发的 ID 令牌。
</td>
</tr>
<tr>
<td colspan="2">--service-cluster-ip-range string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
A CIDR notation IP range from which to assign service cluster IPs. 
This must not overlap with any IP ranges assigned to nodes or pods.
-->
CIDR 表示的 IP 范围用来为服务分配集群 IP。
此地址不得与指定给节点或 Pod 的任何 IP 范围重叠。
</td>
</tr>
<tr>
<td colspan="2">--service-node-port-range &lt;形式为 'N1-N2' 的字符串&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值：30000-32767</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
A port range to reserve for services with NodePort visibility. 
Example: '30000-32767'. Inclusive at both ends of the range.
-->
保留给具有 NodePort 可见性的服务的端口范围。
例如："30000-32767"。范围的两端都包括在内。
</td>
</tr>
<tr>
<td colspan="2">--show-hidden-metrics-for-version string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The previous version for which you want to show hidden metrics. Only the 
previous minor version is meaningful, other values will not be allowed. 
The format is &lt;major&gt;.&lt;minor&gt;, e.g.: '1.16'. The purpose of 
this format is make sure you have the opportunity to notice if the next
release hides additional metrics, rather than being surprised when they 
are permanently removed in the release after that.
-->
你要显示隐藏指标的先前版本。仅先前的次要版本有意义，不允许其他值。
格式为 &lt;major&gt;.&lt;minor&gt;，例如："1.16"。
这种格式的目的是确保你有机会注意到下一个版本是否隐藏了其他指标，
而不是在此之后将它们从发行版中永久删除时感到惊讶。
</td>
</tr>
<tr>
<td colspan="2">--shutdown-delay-duration duration</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Time to delay the termination. During that time the server keeps serving requests normally. 
The endpoints /healthz and /livez will return success, but /readyz immediately returns failure. 
Graceful termination starts after this delay has elapsed. 
This can be used to allow load balancer to stop sending traffic to this server.
-->
延迟终止时间。在此期间，服务器将继续正常处理请求。
端点 /healthz 和 /livez 将返回成功，但是 /readyz 立即返回失败。
在此延迟过去之后，将开始正常终止。
这可用于允许负载平衡器停止向该服务器发送流量。
</td>
</tr>
<tr>
<td colspan="2">--skip-headers</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
If true, avoid header prefixes in the log messages
-->
如果为 true，日志消息中避免标题前缀。
</td>
</tr>
<tr>
<td colspan="2">--skip-log-headers</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
If true, avoid headers when opening log files
-->
如果为 true，则在打开日志文件时避免标题。
</td>
</tr>
<tr>
<td colspan="2">--stderrthreshold int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值：2</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
logs at or above this threshold go to stderr
-->
将达到或超过此阈值的日志写到标准错误输出
</td>
</tr>
<tr>
<td colspan="2">--storage-backend string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The storage backend for persistence. Options: 'etcd3' (default).
-->
持久化存储后端。选项："etcd3"（默认）。
</td>
</tr>
<tr>
<td colspan="2">--storage-media-type string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值："application/vnd.kubernetes.protobuf"</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The media type to use to store objects in storage. 
Some resources or storage backends may only support a specific media type and will ignore this setting.
-->
用于在存储中存储对象的媒体类型。
某些资源或存储后端可能仅支持特定的媒体类型，并且将忽略此设置。
</td>
</tr>
<tr>
<td colspan="2">--strict-transport-security-directives strings</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;"><p>
<!--
List of directives for HSTS, comma separated. If this list is empty, then HSTS directives will not be added. Example: 'max-age=31536000,includeSubDomains,preload'
-->
为 HSTS 所设置的指令列表，用逗号分隔。
如果此列表为空，则不会添加 HSTS 指令。
例如： 'max-age=31536000,includeSubDomains,preload'
</p></td>
</tr>
<tr>
<td colspan="2">--tls-cert-file string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
File containing the default x509 Certificate for HTTPS. 
(CA cert, if any, concatenated after server cert).
If HTTPS serving is enabled, and --tls-cert-file and --tls-private-key-file are not provided, 
a self-signed certificate and key are generated for 
the public address and saved to the directory specified by --cert-dir.
-->
包含用于 HTTPS 的默认 x509 证书的文件。（CA 证书（如果有）在服务器证书之后并置）。
如果启用了 HTTPS 服务，并且未提供 <code>--tls-cert-file</code> 和
<code>--tls-private-key-file</code>，
为公共地址生成一个自签名证书和密钥，并将其保存到 <code>--cert-dir</code> 指定的目录中。
</td>
</tr>
<tr>
<td colspan="2">--tls-cipher-suites strings</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Comma-separated list of cipher suites for the server. 
If omitted, the default Go cipher suites will be used. 
<br/>Preferred values:
TLS_AES_128_GCM_SHA256, TLS_AES_256_GCM_SHA384, TLS_CHACHA20_POLY1305_SHA256, TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA, TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256, TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA, TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384, TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305, TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256, TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA, TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA, TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256, TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA, TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384, TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305, TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256, TLS_RSA_WITH_3DES_EDE_CBC_SHA, TLS_RSA_WITH_AES_128_CBC_SHA, TLS_RSA_WITH_AES_128_GCM_SHA256, TLS_RSA_WITH_AES_256_CBC_SHA, TLS_RSA_WITH_AES_256_GCM_SHA384.<br/>
Insecure values: 
TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256, TLS_ECDHE_ECDSA_WITH_RC4_128_SHA, TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256, TLS_ECDHE_RSA_WITH_RC4_128_SHA, TLS_RSA_WITH_AES_128_CBC_SHA256, TLS_RSA_WITH_RC4_128_SHA.
-->
服务器的密码套件的列表，以逗号分隔。如果省略，将使用默认的 Go 密码套件。
<br/>首选值：
TLS_AES_128_GCM_SHA256、TLS_AES_256_GCM_SHA384、TLS_CHACHA20_POLY1305_SHA256、TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA、TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256、TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA、TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384、TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305、TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256、TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA、TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA、TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256、TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA、TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384、TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305、TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256、TLS_RSA_WITH_3DES_EDE_CBC_SHA、TLS_RSA_WITH_AES_128_CBC_SHA、TLS_RSA_WITH_AES_128_GCM_SHA256、 TLS_RSA_WITH_AES_256_CBC_SHA, TLS_RSA_WITH_AES_256_GCM_SHA384.
不安全的值有：
TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256、TLS_ECDHE_ECDSA_WITH_RC4_128_SHA、TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256、TLS_ECDHE_RSA_WITH_RC4_128_SHA、TLS_RSA_WITH_AES_128_CBC_SHA256、TLS_RSA_WITH_RC4_128_SHA。
</td>
</tr>
<tr>
<td colspan="2">--tls-min-version string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Minimum TLS version supported. Possible values: VersionTLS10, VersionTLS11, VersionTLS12, VersionTLS13
-->
支持的最低 TLS 版本。可能的值：VersionTLS10，VersionTLS11，VersionTLS12，VersionTLS13
</td>
</tr>
<tr>
<td colspan="2">--tls-private-key-file string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
File containing the default x509 private key matching --tls-cert-file.
-->
包含匹配 <code>--tls-cert-file</code> 的 x509 证书私钥的文件。
</td>
</tr>
<tr>
<td colspan="2">--tls-sni-cert-key string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值： []</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
A pair of x509 certificate and private key file paths, optionally 
suffixed with a list of domain patterns which are fully qualified 
domain names, possibly with prefixed wildcard segments. The domain 
patterns also allow IP addresses, but IPs should only be used if 
the apiserver has visibility to the IP address requested by a client. 
If no domain patterns are provided, the names of the certificate are 
extracted. Non-wildcard matches trump over wildcard matches, explicit
domain patterns trump over extracted names. For multiple key/certificate 
pairs, use the --tls-sni-cert-key multiple times. Examples: 
"example.crt,example.key" or "foo.crt,foo.key:*.foo.com,foo.com".
-->
一对 x509 证书和私钥文件路径，（可选）后缀为全限定域名的域名模式列表，可以使用带有通配符的前缀。
域模式也允许使用 IP 地址，但仅当 apiserver 对客户端请求的IP地址具有可见性时，才应使用 IP。
如果未提供域模式，则提取证书的名称。
非通配符匹配优先于通配符匹配，显式域模式优先于提取出的名称。
对于多个密钥/证书对，请多次使用 <code>--tls-sni-cert-key</code>。
示例："example.crt,example.key" 或 "foo.crt,foo.key:\*.foo.com,foo.com"。
</td>
</tr>
<tr>
<td colspan="2">--token-auth-file string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
If set, the file that will be used to secure the secure port of the API server via token authentication.
-->
如果设置该值，这个文件将被用于通过令牌认证来保护 API 服务的安全端口。
</td>
</tr>
<tr>
<td colspan="2">-v, --v int</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
number for the log level verbosity
-->
日志级别详细程度的数字。
</td>
</tr>
<tr>
<td colspan="2">--version version[=true]</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Print version information and quit
-->
打印版本信息并退出
</td>
</tr>
<tr>
<td colspan="2">--vmodule &lt;用逗号分隔的多个 'pattern=N' 配置字符串&gt;</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
comma-separated list of pattern=N settings for file-filtered logging
-->
以逗号分隔的 <code>pattern=N</code> 设置列表，用于文件过滤的日志记录。
</td>
</tr>
<tr>
<td colspan="2">--watch-cache&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值：true</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Enable watch caching in the apiserver
-->
在 API 服务器中启用监视缓存。
</td>
</tr>
<tr>
<td colspan="2">--watch-cache-sizes strings</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Watch cache size settings for some resources (pods, nodes, etc.), comma separated. 
The individual setting format: resource[.group]#size, where resource is lowercase 
plural (no version), group is omitted for resources of apiVersion v1 (the legacy 
core API) and included for others, and size is a number. It takes effect when 
watch-cache is enabled. Some resources (replicationcontrollers, endpoints, nodes,
pods, services, apiservices.apiregistration.k8s.io) have system defaults set by 
heuristics, others default to default-watch-cache-size
-->
某些资源（Pods、Nodes 等）的监视缓存大小设置，以逗号分隔。
每个资源对应的设置格式：<code>resource[.group]#size</code>，其中
<code>resource</code> 为小写复数（无版本），
对于 apiVersion v1（旧版核心 API）的资源要省略 <code>group</code>，
对其它资源要给出 <code>group</code>；<code>size 为一个数字</code>。
启用 <code>watch-cache</code> 时，此功能生效。
某些资源（<code>replicationcontrollers</code>、<code>endpoints</code>、
<code>nodes</code>、<code>pods</code>、<code>services</code>、
<code>apiservices.apiregistration.k8s.io</code>）
具有通过启发式设置的系统默认值，其他资源默认为
<code>default-watch-cache-size<code>。
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-8a37271ec8fd36a3a1ce07c4c58533d9">9.4 - kube-controller-manager</h1>
    
	<!--
The file is auto-generated from the Go source code of the component using a generic
[generator](https://github.com/kubernetes-sigs/reference-docs/). To learn how
to generate the reference documentation, please read
[Contributing to the reference documentation](/docs/contribute/generate-ref-docs/).
To update the reference conent, please follow the 
[Contributing upstream](/docs/contribute/generate-ref-docs/contribute-upstream/)
guide. You can file document formatting bugs against the
[reference-docs](https://github.com/kubernetes-sigs/reference-docs/) project.
-->
<h2 id="简介">简介</h2>
<!--
The Kubernetes controller manager is a daemon that embeds
the core control loops shipped with Kubernetes. In applications of robotics and
automation, a control loop is a non-terminating loop that regulates the state of
the system. In Kubernetes, a controller is a control loop that watches the shared
state of the cluster through the apiserver and makes changes attempting to move the
current state towards the desired state. Examples of controllers that ship with
Kubernetes today are the replication controller, endpoints controller, namespace
controller, and serviceaccounts controller.
-->
<p>Kubernetes 控制器管理器是一个守护进程，内嵌随 Kubernetes 一起发布的核心控制回路。
在机器人和自动化的应用中，控制回路是一个永不休止的循环，用于调节系统状态。
在 Kubernetes 中，每个控制器是一个控制回路，通过 API 服务器监视集群的共享状态，
并尝试进行更改以将当前状态转为期望状态。
目前，Kubernetes 自带的控制器例子包括副本控制器、节点控制器、命名空间控制器和服务账号控制器等。</p>
<pre tabindex="0"><code>kube-controller-manager [flags]
</code></pre><h2 id="选项">选项</h2>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--add-dir-header</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
If true, adds the file directory to the header of the log messages
-->
若为 true，将文件目录添加到日志消息的头部。
</td>
</tr>
<tr>
<td colspan="2">--allocate-node-cidrs</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Should CIDRs for Pods be allocated and set on the cloud provider.
-->
基于云驱动来为 Pod 分配和设置子网掩码。
</td>
</tr>
<tr>
<td colspan="2">--allow-metric-labels stringToString&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值：""</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;"><p>
<p>
<!--
The map from metric-label to value allow-list of this label. The key's format is &lt;MetricName&gt;,&lt;LabelName&gt;. The value's format is &lt;allowed_value&gt;,&lt;allowed_value&gt;...e.g. metric1,label1='v1,v2,v3', metric1,label2='v1,v2,v3' metric2,label1='v1,v2,v3'.
-->
从度量值标签到准许值列表的映射。键名的格式为&lt;MetricName&gt;,&lt;LabelName&gt;。
准许值的格式为&lt;allowed_value&gt;,&lt;allowed_value&gt;...。
例如，<code>metric1,label1='v1,v2,v3', metric1,label2='v1,v2,v3'
metric2,label='v1,v2,v3'</code>。
</p>
</td>
</tr>
<tr>
<td colspan="2">--alsologtostderr</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
log to standard error as well as files
-->
在向文件输出日志的同时，也将日志写到标准输出。
</td>
</tr>
<tr>
<td colspan="2">--attach-detach-reconcile-sync-period duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值：1m0s</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The reconciler sync wait time between volume attach detach. This duration must be larger than one second, and increasing this value from the default may allow for volumes to be mismatched with pods.
-->
协调器（reconciler）在相邻两次对存储卷进行挂载和解除挂载操作之间的等待时间。
此时长必须长于 1 秒钟。此值设置为大于默认值时，可能导致存储卷无法与 Pods 匹配。
</td>
</tr>
<tr>
<td colspan="2">--authentication-kubeconfig string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
kubeconfig file pointing at the 'core' kubernetes server with enough rights to create tokenreviews.authentication.k8s.io. This is optional. If empty, all token requests are considered to be anonymous and no client CA is looked up in the cluster.
-->
此标志值为一个 kubeconfig 文件的路径名。该文件中包含与某 Kubernetes “核心” 
服务器相关的信息，并支持足够的权限以创建 tokenreviews.authentication.k8s.io。
此选项是可选的。如果设置为空值，所有令牌请求都会被认作匿名请求，
Kubernetes 也不再在集群中查找客户端的 CA 证书信息。
</td>
</tr>
<tr>
<td colspan="2">--authentication-skip-lookup</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
If false, the authentication-kubeconfig will be used to lookup missing authentication configuration from the cluster.
-->
此值为 false 时，通过 authentication-kubeconfig 参数所指定的文件会被用来
检索集群中缺失的身份认证配置信息。
</td>
</tr>
<tr>
<td colspan="2">--authentication-token-webhook-cache-ttl duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值：10s</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The duration to cache responses from the webhook token authenticator.
-->
对 Webhook 令牌认证设施返回结果的缓存时长。
</td>
</tr>
<tr>
<td colspan="2">--authentication-tolerate-lookup-failure</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
If true, failures to look up missing authentication configuration from the cluster are not considered fatal. Note that this can result in authentication that treats all requests as anonymous.
-->
此值为 true 时，即使无法从集群中检索到缺失的身份认证配置信息也无大碍。
需要注意的是，这样设置可能导致所有请求都被视作匿名请求。
</td>
</tr>
<tr>
<td colspan="2">--authorization-always-allow-paths strings&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值："/healthz,/readyz,/livez"</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
A list of HTTP paths to skip during authorization, i.e. these are authorized without contacting the 'core' kubernetes server.
-->
鉴权过程中会忽略的一个 HTTP 路径列表。
换言之，控制器管理器会对列表中路径的访问进行授权，并且无须征得
Kubernetes “核心” 服务器同意。
</td>
</tr>
<tr>
<td colspan="2">--authorization-kubeconfig string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
kubeconfig file pointing at the 'core' kubernetes server with enough rights to create subjectaccessreviews.authorization.k8s.io. This is optional. If empty, all requests not skipped by authorization are forbidden.
-->
包含 Kubernetes “核心” 服务器信息的 kubeconfig 文件路径，
所包含信息具有创建 subjectaccessreviews.authorization.k8s.io 的足够权限。
此参数是可选的。如果配置为空字符串，未被鉴权模块所忽略的请求都会被禁止。
</td>
</tr>
<tr>
<td colspan="2">--authorization-webhook-cache-authorized-ttl duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值：10s</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The duration to cache 'authorized' responses from the webhook authorizer.
-->
对 Webhook 形式鉴权组件所返回的“已授权（Authorized）”响应的缓存时长。
</td>
</tr>
<tr>
<td colspan="2">--authorization-webhook-cache-unauthorized-ttl duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值：10s</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The duration to cache 'unauthorized' responses from the webhook authorizer.
-->
对 Webhook 形式鉴权组件所返回的“未授权（Unauthorized）”响应的缓存时长。
</td>
</tr>
<tr>
<td colspan="2">--azure-container-registry-config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to the file containing Azure container registry configuration information.
-->
指向包含 Azure 容器仓库配置信息的文件的路径名。
</td>
</tr>
<tr>
<td colspan="2">--bind-address ip&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值：0.0.0.0</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The IP address on which to listen for the --secure-port port. The associated interface(s) must be reachable by the rest of the cluster, and by CLI/web clients. If blank or an unspecified address (0.0.0.0 or ::), all interfaces will be used.
-->
针对 <code>--secure-port</code> 端口上请求执行监听操作的 IP 地址。
所对应的网络接口必须从集群中其它位置可访问（含命令行及 Web 客户端）。
如果此值为空或者设定为非特定地址（<code>0.0.0.0</code> 或 <code>::</code>），
意味着所有网络接口都在监听范围。
</td>
</tr>
<tr>
<td colspan="2">--cert-dir string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The directory where the TLS certs are located. If --tls-cert-file and --tls-private-key-file are provided, this flag will be ignored.
-->
TLS 证书所在的目录。如果提供了 <code>--tls-cert-file</code> 和
<code>--tls-private-key-file</code>，此标志会被忽略。
</td>
</tr>
<tr>
<td colspan="2">--cidr-allocator-type string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值："RangeAllocator"</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Type of CIDR allocator to use
-->
要使用的 CIDR 分配器类型。
</td>
</tr>
<tr>
<td colspan="2">--client-ca-file string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
If set, any request presenting a client certificate signed by one of the authorities in the client-ca-file is authenticated with an identity corresponding to the CommonName of the client certificate.
-->
如果设置了此标志，对于所有能够提供客户端证书的请求，若该证书由
<code>--client-ca-file</code> 中所给机构之一签署，则该请求会被
成功认证为客户端证书中 CommonName 所标识的实体。
</td>
</tr>
<tr>
<td colspan="2">--cloud-config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The path to the cloud provider configuration file. Empty string for no configuration file.
-->
云驱动程序配置文件的路径。空字符串表示没有配置文件。
</td>
</tr>
<tr>
<td colspan="2">--cloud-provider string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The provider for cloud services. Empty string for no provider.
-->
云服务的提供者。空字符串表示没有对应的提供者（驱动）。
</td>
</tr>
<tr>
<td colspan="2">--cluster-cidr string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
CIDR Range for Pods in cluster. Requires --allocate-node-cidrs to be true
-->
集群中 Pods 的 CIDR 范围。要求 <code>--allocate-node-cidrs</code> 标志为 true。
</td>
</tr>
<tr>
<td colspan="2">--cluster-name string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值："kubernetes"</td -->
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The instance prefix for the cluster.
-->
集群实例的前缀。
</td>
</tr>
<tr>
<td colspan="2">--cluster-signing-cert-file string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Filename containing a PEM-encoded X509 CA certificate used to issue cluster-scoped certificates.  If specified, no more specific --cluster-signing-* flag may be specified.
-->
包含 PEM 编码格式的 X509 CA 证书的文件名。该证书用来发放集群范围的证书。
如果设置了此标志，则不能指定更具体的<code>--cluster-signing-*</code> 标志。
</td>
</tr>
<tr>
<td colspan="2">--cluster-signing-duration duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值：8760h0m0s</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- 
The length of duration signed certificates will be given. 
-->
所签名证书的有效期限。
</td>
</tr>
<tr>
<td colspan="2">--cluster-signing-key-file string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Filename containing a PEM-encoded RSA or ECDSA private key used to sign cluster-scoped certificates.
If specified, no more specific --cluster-signing-* flag may be specified.
-->
包含 PEM 编码的 RSA 或 ECDSA 私钥的文件名。该私钥用来对集群范围证书签名。
若指定了此选项，则不可再设置 <code>--cluster-signing-*</code> 参数。
</td>
</tr>
<tr>
<td colspan="2">--cluster-signing-kube-apiserver-client-cert-file string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- 
Filename containing a PEM-encoded X509 CA certificate used to issue certificates for the kubernetes.io/kube-apiserver-client signer.  If specified, --cluster-signing-{cert,key}-file must not be set.
-->
包含 PEM 编码的 X509 CA 证书的文件名，
该证书用于为 kubernetes.io/kube-apiserver-client 签署者颁发证书。 
如果指定，则不得设置 <code>--cluster-signing-{cert,key}-file</code>。
</td>
</tr>
<tr>
<td colspan="2">--cluster-signing-kube-apiserver-client-key-file string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--  
Filename containing a PEM-encoded RSA or ECDSA private key used to sign certificates for the kubernetes.io/kube-apiserver-client signer.  If specified, --cluster-signing-{cert,key}-file must not be set.
-->
包含 PEM 编码的 RSA 或 ECDSA 私钥的文件名，
该私钥用于为 kubernetes.io/kube-apiserver-client 签署者签名证书。 
如果指定，则不得设置 <code>--cluster-signing-{cert,key}-file</code>。
</td>
</tr>
<tr>
<td colspan="2">--cluster-signing-kubelet-client-cert-file string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Filename containing a PEM-encoded X509 CA certificate used to issue certificates for the kubernetes.io/kube-apiserver-client-kubelet signer.  If specified, --cluster-signing-{cert,key}-file must not be set.
-->
包含 PEM 编码的 X509 CA 证书的文件名，
该证书用于为 kubernetes.io/kube-apiserver-client-kubelet 签署者颁发证书。 
如果指定，则不得设置 <code>--cluster-signing-{cert,key}-file</code>。
</td>
</tr>
<tr>
<td colspan="2">--cluster-signing-kubelet-client-key-file string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Filename containing a PEM-encoded RSA or ECDSA private key used to sign certificates for the kubernetes.io/kube-apiserver-client-kubelet signer.  If specified, --cluster-signing-{cert,key}-file must not be set.
-->
包含 PEM 编码的 RSA 或 ECDSA 私钥的文件名，
该私钥用于为 kubernetes.io/kube-apiserver-client-kubelet 签署者签名证书。
如果指定，则不得设置 <code>--cluster-signing-{cert,key}-file</code>。
</td>
</tr>
<tr>
<td colspan="2">--cluster-signing-kubelet-serving-cert-file string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Filename containing a PEM-encoded X509 CA certificate used to issue certificates for the kubernetes.io/kubelet-serving signer.  If specified, --cluster-signing-{cert,key}-file must not be set.
-->
包含 PEM 编码的 X509 CA 证书的文件名，
该证书用于为 kubernetes.io/kubelet-serving 签署者颁发证书。
如果指定，则不得设置 </code>--cluster-signing-{cert,key}-file</code>。
</td>
</tr>
<tr>
<td colspan="2">--cluster-signing-kubelet-serving-key-file string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Filename containing a PEM-encoded RSA or ECDSA private key used to sign certificates for the kubernetes.io/kubelet-serving signer.  If specified, --cluster-signing-{cert,key}-file must not be set.
-->
包含 PEM 编码的 RSA或ECDSA 私钥的文件名，
该私钥用于对 kubernetes.io/kubelet-serving 签署者的证书进行签名。
如果指定，则不得设置 <code>--cluster-signing-{cert,key}-file</code>。
</td>
</tr>
<tr>
<td colspan="2">--cluster-signing-legacy-unknown-cert-file string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Filename containing a PEM-encoded X509 CA certificate used to issue certificates for the kubernetes.io/legacy-unknown signer.  If specified, --cluster-signing-{cert,key}-file must not be set.
-->
包含 PEM 编码的 X509 CA 证书的文件名，
用于为 kubernetes.io/legacy-unknown 签署者颁发证书。
如果指定，则不得设置 <code>--cluster-signing-{cert,key}-file</code>。
</td>
</tr>
<tr>
<td colspan="2">--cluster-signing-legacy-unknown-key-file string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Filename containing a PEM-encoded RSA or ECDSA private key used to sign certificates for the kubernetes.io/legacy-unknown signer.  If specified, --cluster-signing-{cert,key}-file must not be set.
-->
包含 PEM 编码的 RSA 或 ECDSA 私钥的文件名，
用于为 kubernetes.io/legacy-unknown 签署者签名证书。
如果指定，则不得设置 <code>--cluster-signing-{cert,key}-file</code>。
</td>
</tr>
<tr>
<td colspan="2">--concurrent-deployment-syncs int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值：5</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The number of deployment objects that are allowed to sync concurrently. Larger number = more responsive deployments, but more CPU (and network) load
-->
可以并发同步的 Deployment 对象个数。数值越大意味着对 Deployment 的响应越及时，
同时也意味着更大的 CPU（和网络带宽）压力。
</td>
</tr>
<tr>
<td colspan="2">--concurrent-endpoint-syncs int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值：5</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The number of endpoint syncing operations that will be done concurrently. Larger number = faster endpoint updating, but more CPU (and network) load
-->
可以并发执行的 Endpoints 同步操作个数。数值越大意味着更快的 Endpoints 更新操作，
同时也意味着更大的 CPU （和网络）压力。
</td>
</tr>
<tr>
<td colspan="2">--concurrent-gc-syncs int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值：20</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The number of garbage collector workers that are allowed to sync concurrently.
-->
可以并发同步的垃圾收集工作线程个数。
</td>
</tr>
<tr>
<td colspan="2">--concurrent-namespace-syncs int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值：10</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The number of namespace objects that are allowed to sync concurrently. Larger number = more responsive namespace termination, but more CPU (and network) load
-->
可以并发同步的 Namespace 对象个数。较大的数值意味着更快的名字空间终结操作，
不过也意味着更多的 CPU （和网络）占用。
</td>
</tr>
<tr>
<td colspan="2">--concurrent-rc-syncs int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值：5</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;"><p>
<!--
The number of replication controllers that are allowed to sync concurrently. Larger number = more responsive replica management, but more CPU (and network) load
-->
可以并发同步的副本控制器对象个数。较大的数值意味着更快的副本管理操作，
不过也意味着更多的 CPU （和网络）占用。
</p></td>
</tr>
<tr>
<td colspan="2">--concurrent-replicaset-syncs int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值：5</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The number of replica sets that are allowed to sync concurrently. Larger number = more responsive replica management, but more CPU (and network) load
-->
可以并发同步的 ReplicaSet 个数。数值越大意味着副本管理的响应速度越快，
同时也意味着更多的 CPU （和网络）占用。
</td>
</tr>
<tr>
<td colspan="2">--concurrent-resource-quota-syncs int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值：5</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The number of resource quotas that are allowed to sync concurrently. Larger number = more responsive quota management, but more CPU (and network) load
-->
可以并发同步的 ResourceQuota 对象个数。数值越大，配额管理的响应速度越快，
不过对 CPU （和网络）的占用也越高。
</td>
</tr>
<tr>
<td colspan="2">--concurrent-service-endpoint-syncs int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值：5</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The number of service endpoint syncing operations that will be done concurrently. Larger number = faster endpoint slice updating, but more CPU (and network) load. Defaults to 5.
-->
可以并发执行的服务端点同步操作个数。数值越大，端点片段（Endpoint Slice）
的更新速度越快，不过对 CPU （和网络）的占用也越高。默认值为 5。
</td>
</tr>
<tr>
<td colspan="2">--concurrent-service-syncs int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值：1</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The number of services that are allowed to sync concurrently. Larger number = more responsive service management, but more CPU (and network) load
-->
可以并发同步的 Service 对象个数。数值越大，服务管理的响应速度越快，
不过对 CPU （和网络）的占用也越高。
</td>
</tr>
<tr>
<td colspan="2">--concurrent-serviceaccount-token-syncs int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值：5</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The number of service account token objects that are allowed to sync concurrently. Larger number = more responsive token generation, but more CPU (and network) load
-->
可以并发同步的服务账号令牌对象个数。数值越大，令牌生成的速度越快，
不过对 CPU （和网络）的占用也越高。
</td>
</tr>
<tr>
<td colspan="2">--concurrent-statefulset-syncs int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值：5</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The number of statefulset objects that are allowed to sync concurrently. Larger number = more responsive statefulsets, but more CPU (and network) load
-->
可以并发同步的 StatefulSet 对象个数。数值越大，StatefulSet 管理的响应速度越快，
不过对 CPU （和网络）的占用也越高。
</td>
</tr>
<tr>
<td colspan="2">--concurrent-ttl-after-finished-syncs int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值：5</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The number of TTL-after-finished controller workers that are allowed to sync concurrently.
-->
可以并发同步的 TTL-after-finished 控制器线程个数。
</td>
</tr>
<tr>
<td colspan="2">--configure-cloud-routes&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值：true</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Should CIDRs allocated by allocate-node-cidrs be configured on the cloud provider.
-->
决定是否由 <code>--allocate-node-cidrs</code> 所分配的 CIDR 要通过云驱动程序来配置。
</td>
</tr>
<tr>
<td colspan="2">--contention-profiling</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Enable lock contention profiling, if profiling is enabled
-->
在启用了性能分析（profiling）时，也启用锁竞争情况分析。
</td>
</tr>
<tr>
<td colspan="2">--controller-start-interval duration</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Interval between starting controller managers.
-->
在两次启动控制器管理器之间的时间间隔。
</td>
</tr>
<tr>
<td colspan="2">--controllers strings&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值：<code>[*]</code></td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
A list of controllers to enable. '*' enables all on-by-default controllers, 'foo' enables the controller named 'foo', '-foo' disables the controller named 'foo'.<br/>All controllers: attachdetach, bootstrapsigner, cloud-node-lifecycle, clusterrole-aggregation, cronjob, csrapproving, csrcleaner, csrsigning, daemonset, deployment, disruption, endpoint, endpointslice, endpointslicemirroring, ephemeral-volume, garbagecollector, horizontalpodautoscaling, job, namespace, nodeipam, nodelifecycle, persistentvolume-binder, persistentvolume-expander, podgc, pv-protection, pvc-protection, replicaset, replicationcontroller, resourcequota, root-ca-cert-publisher, route, service, serviceaccount, serviceaccount-token, statefulset, tokencleaner, ttl, ttl-after-finished<br/>Disabled-by-default controllers: bootstrapsigner, tokencleaner
-->
要启用的控制器列表。<code>\*</code> 表示启用所有默认启用的控制器；
<code>foo</code> 启用名为 foo 的控制器；
<code>-foo</code> 表示禁用名为 foo 的控制器。<br/>
控制器的全集：attachdetach、bootstrapsigner、cloud-node-lifecycle、clusterrole-aggregation、cronjob、csrapproving、csrcleaner、csrsigning、daemonset、deployment、disruption、endpoint、endpointslice、endpointslicemirroring、ephemeral-volume、garbagecollector、horizontalpodautoscaling、job、namespace、nodeipam、nodelifecycle、persistentvolume-binder、persistentvolume-expander、podgc、pv-protection、pvc-protection、replicaset、replicationcontroller、resourcequota、root-ca-cert-publisher、route、service、serviceaccount、serviceaccount-token、statefulset、tokencleaner、ttl、ttl-after-finished<br/>
默认禁用的控制器有：bootstrapsigner 和 tokencleaner。</td>
</tr>
<tr>
<td colspan="2">--deployment-controller-sync-period duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值：30s</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Period for syncing the deployments.
-->
Deployment 资源的同步周期。
</td>
</tr>
<tr>
<td colspan="2">--disable-attach-detach-reconcile-sync</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Disable volume attach detach reconciler sync. Disabling this may cause volumes to be mismatched with pods. Use wisely.
-->
禁用卷挂接/解挂调节器的同步。禁用此同步可能导致卷存储与 Pod 之间出现错位。
请小心使用。
</td>
</tr>
<tr>
<td colspan="2">--disabled-metrics strings</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;"><p>
<!--
This flag provides an escape hatch for misbehaving metrics. You must provide the fully qualified metric name in order to disable it. Disclaimer: disabling metrics is higher in precedence than showing hidden metrics.
-->
此标志提供对行为异常的度量值的防控措施。你必须提供度量值的
完全限定名称才能将其禁用。<B>声明</B>：禁用度量值的操作比显示隐藏度量值
的操作优先级高。
</p></td>
</tr>
<tr>
<td colspan="2">--enable-dynamic-provisioning&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值：true</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Enable dynamic provisioning for environments that support it.
-->
在环境允许的情况下启用动态卷制备。
</td>
</tr>
<tr>
<td colspan="2">--enable-garbage-collector&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值：true</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Enables the generic garbage collector. MUST be synced with the corresponding flag of the kube-apiserver.
-->
启用通用垃圾收集器。必须与 kube-apiserver 中对应的标志一致。
</td>
</tr>
<tr>
<td colspan="2">--enable-hostpath-provisioner</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Enable HostPath PV provisioning when running without a cloud provider. This allows testing and development of provisioning features.  HostPath provisioning is not supported in any way, won't work in a multi-node cluster, and should not be used for anything other than testing or development.
-->
在没有云驱动程序的情况下，启用 HostPath 持久卷的制备。
此参数便于对卷供应功能进行开发和测试。HostPath 卷的制备并非受支持的功能特性，
在多节点的集群中也无法工作，因此除了开发和测试环境中不应使用。
</td>
</tr>
<tr>
<td colspan="2">--enable-leader-migration</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;"><p>
<!--
Whether to enable controller leader migration.
-->
此标志决定是否启用控制器领导者迁移。
</p></td>
</tr>
<tr>
<td colspan="2">--enable-taint-manager&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值：true</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
WARNING: Beta feature. If set to true enables NoExecute Taints and will evict all not-tolerating Pod running on Nodes tainted with this kind of Taints.
-->
警告：此为Beta 阶段特性。设置为 true 时会启用 NoExecute 污点，
并在所有标记了此污点的节点上逐出所有无法忍受该污点的 Pods。
</td>
</tr>
<tr>
<td colspan="2">--endpoint-updates-batch-period duration</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The length of endpoint updates batching period. Processing of pod changes will be delayed by this duration to join them with potential upcoming updates and reduce the overall number of endpoints updates. Larger number = higher endpoint programming latency, but lower number of endpoints revision generated
-->
端点（Endpoint）批量更新周期时长。对 Pods 变更的处理会被延迟，
以便将其与即将到来的更新操作合并，从而减少端点更新操作次数。
较大的数值意味着端点更新的迟滞时间会增长，也意味着所生成的端点版本个数会变少。
</td>
</tr>
<tr>
<td colspan="2">--endpointslice-updates-batch-period duration</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The length of endpoint slice updates batching period. Processing of pod changes will be delayed by this duration to join them with potential upcoming updates and reduce the overall number of endpoints updates. Larger number = higher endpoint programming latency, but lower number of endpoints revision generated
-->
端点片段（Endpoint Slice）批量更新周期时长。对 Pods 变更的处理会被延迟，
以便将其与即将到来的更新操作合并，从而减少端点更新操作次数。
较大的数值意味着端点更新的迟滞时间会增长，也意味着所生成的端点版本个数会变少。
</td>
</tr>
<tr>
<td colspan="2">--experimental-logging-sanitization</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[Experimental] When enabled prevents logging of fields tagged as sensitive (passwords, keys, tokens).<br/>Runtime log sanitization may introduce significant computation overhead and therefore should not be enabled in production.
-->
[试验性功能] 当启用此标志时，被标记为敏感的字段（密码、密钥、令牌）不会被日志输出。<br/>
运行时的日志清理操作可能会引入相当程度的计算开销，因此不应在生产环境中启用。
</td>
</tr>
<tr>
<td colspan="2">--external-cloud-volume-plugin string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The plugin to use when cloud provider is set to external. Can be empty, should only be set when cloud-provider is external. Currently used to allow node and volume controllers to work for in tree cloud providers.
-->
当云驱动程序设置为 external 时要使用的插件名称。此字符串可以为空。
只能在云驱动程序为 external 时设置。目前用来保证节点控制器和卷控制器能够
在三种云驱动上正常工作。
</td>
</tr>
<tr>
<td colspan="2">--feature-gates &lt;<!--comma-separated 'key=True|False' pairs-->逗号分隔的 'key=True|False' 对列表&gt;</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<p>
<!--
A set of key=value pairs that describe feature gates for alpha/experimental features. Options are:<br/>
APIListChunking=true|false (BETA - default=true)<br/>
APIPriorityAndFairness=true|false (BETA - default=true)<br/>
APIResponseCompression=true|false (BETA - default=true)<br/>
APIServerIdentity=true|false (ALPHA - default=false)<br/>
AllAlpha=true|false (ALPHA - default=false)<br/>
AllBeta=true|false (BETA - default=false)<br/>
AnyVolumeDataSource=true|false (ALPHA - default=false)<br/>
AppArmor=true|false (BETA - default=true)<br/>
BalanceAttachedNodeVolumes=true|false (ALPHA - default=false)<br/>
BoundServiceAccountTokenVolume=true|false (BETA - default=true)<br/>
CPUManager=true|false (BETA - default=true)<br/>
CSIInlineVolume=true|false (BETA - default=true)<br/>
CSIMigration=true|false (BETA - default=true)<br/>
CSIMigrationAWS=true|false (BETA - default=false)<br/>
CSIMigrationAzureDisk=true|false (BETA - default=false)<br/>
CSIMigrationAzureFile=true|false (BETA - default=false)<br/>
CSIMigrationGCE=true|false (BETA - default=false)<br/>
CSIMigrationOpenStack=true|false (BETA - default=true)<br/>
CSIMigrationvSphere=true|false (BETA - default=false)<br/>
CSIMigrationvSphereComplete=true|false (BETA - default=false)<br/>
CSIServiceAccountToken=true|false (BETA - default=true)<br/>
CSIStorageCapacity=true|false (BETA - default=true)<br/>
CSIVolumeFSGroupPolicy=true|false (BETA - default=true)<br/>
CSIVolumeHealth=true|false (ALPHA - default=false)<br/>
ConfigurableFSGroupPolicy=true|false (BETA - default=true)<br/>
ControllerManagerLeaderMigration=true|false (ALPHA - default=false)<br/>
CronJobControllerV2=true|false (BETA - default=true)<br/>
CustomCPUCFSQuotaPeriod=true|false (ALPHA - default=false)<br/>
DaemonSetUpdateSurge=true|false (ALPHA - default=false)<br/>
DefaultPodTopologySpread=true|false (BETA - default=true)<br/>
DevicePlugins=true|false (BETA - default=true)<br/>
DisableAcceleratorUsageMetrics=true|false (BETA - default=true)<br/>
DownwardAPIHugePages=true|false (BETA - default=false)<br/>
DynamicKubeletConfig=true|false (BETA - default=true)<br/>
EfficientWatchResumption=true|false (BETA - default=true)<br/>
EndpointSliceProxying=true|false (BETA - default=true)<br/>
EndpointSliceTerminatingCondition=true|false (ALPHA - default=false)<br/>
EphemeralContainers=true|false (ALPHA - default=false)<br/>
ExpandCSIVolumes=true|false (BETA - default=true)<br/>
ExpandInUsePersistentVolumes=true|false (BETA - default=true)<br/>
ExpandPersistentVolumes=true|false (BETA - default=true)<br/>
ExperimentalHostUserNamespaceDefaulting=true|false (BETA - default=false)<br/>
GenericEphemeralVolume=true|false (BETA - default=true)<br/>
GracefulNodeShutdown=true|false (BETA - default=true)<br/>
HPAContainerMetrics=true|false (ALPHA - default=false)<br/>
HPAScaleToZero=true|false (ALPHA - default=false)<br/>
HugePageStorageMediumSize=true|false (BETA - default=true)<br/>
IPv6DualStack=true|false (BETA - default=true)<br/>
InTreePluginAWSUnregister=true|false (ALPHA - default=false)<br/>
InTreePluginAzureDiskUnregister=true|false (ALPHA - default=false)<br/>
InTreePluginAzureFileUnregister=true|false (ALPHA - default=false)<br/>
InTreePluginGCEUnregister=true|false (ALPHA - default=false)<br/>
InTreePluginOpenStackUnregister=true|false (ALPHA - default=false)<br/>
InTreePluginvSphereUnregister=true|false (ALPHA - default=false)<br/>
IndexedJob=true|false (ALPHA - default=false)<br/>
IngressClassNamespacedParams=true|false (ALPHA - default=false)<br/>
KubeletCredentialProviders=true|false (ALPHA - default=false)<br/>
KubeletPodResources=true|false (BETA - default=true)<br/>
KubeletPodResourcesGetAllocatable=true|false (ALPHA - default=false)<br/>
LocalStorageCapacityIsolation=true|false (BETA - default=true)<br/>
LocalStorageCapacityIsolationFSQuotaMonitoring=true|false (ALPHA - default=false)<br/>
LogarithmicScaleDown=true|false (ALPHA - default=false)<br/>
MemoryManager=true|false (ALPHA - default=false)<br/>
MixedProtocolLBService=true|false (ALPHA - default=false)<br/>
NamespaceDefaultLabelName=true|false (BETA - default=true)<br/>
NetworkPolicyEndPort=true|false (ALPHA - default=false)<br/>
NonPreemptingPriority=true|false (BETA - default=true)<br/>
PodAffinityNamespaceSelector=true|false (ALPHA - default=false)<br/>
PodDeletionCost=true|false (ALPHA - default=false)<br/>
PodOverhead=true|false (BETA - default=true)<br/>
PreferNominatedNode=true|false (ALPHA - default=false)<br/>
ProbeTerminationGracePeriod=true|false (ALPHA - default=false)<br/>
ProcMountType=true|false (ALPHA - default=false)<br/>
QOSReserved=true|false (ALPHA - default=false)<br/>
RemainingItemCount=true|false (BETA - default=true)<br/>
RemoveSelfLink=true|false (BETA - default=true)<br/>
RotateKubeletServerCertificate=true|false (BETA - default=true)<br/>
ServerSideApply=true|false (BETA - default=true)<br/>
ServiceInternalTrafficPolicy=true|false (ALPHA - default=false)<br/>
ServiceLBNodePortControl=true|false (ALPHA - default=false)<br/>
ServiceLoadBalancerClass=true|false (ALPHA - default=false)<br/>
ServiceTopology=true|false (ALPHA - default=false)<br/>
SetHostnameAsFQDN=true|false (BETA - default=true)<br/>
SizeMemoryBackedVolumes=true|false (ALPHA - default=false)<br/>
StorageVersionAPI=true|false (ALPHA - default=false)<br/>
StorageVersionHash=true|false (BETA - default=true)<br/>
SuspendJob=true|false (ALPHA - default=false)<br/>
TTLAfterFinished=true|false (BETA - default=true)<br/>
TopologyAwareHints=true|false (ALPHA - default=false)<br/>
TopologyManager=true|false (BETA - default=true)<br/>
ValidateProxyRedirects=true|false (BETA - default=true)<br/>
VolumeCapacityPriority=true|false (ALPHA - default=false)<br/>
WarningHeaders=true|false (BETA - default=true)<br/>
WinDSR=true|false (ALPHA - default=false)<br/>
WinOverlay=true|false (BETA - default=true)<br/>
WindowsEndpointSliceProxying=true|false (BETA - default=true)
-->
一组 key=value 对，用来描述测试性/试验性功能的特性门控（Feature Gate）。可选项有：
APIListChunking=true|false (BETA - 默认值=true)<br/>
APIPriorityAndFairness=true|false (BETA - 默认值=true)<br/>
APIResponseCompression=true|false (BETA - 默认值=true)<br/>
APIServerIdentity=true|false (ALPHA - 默认值=false)<br/>
AllAlpha=true|false (ALPHA - 默认值=false)<br/>
AllBeta=true|false (BETA - 默认值=false)<br/>
AnyVolumeDataSource=true|false (ALPHA - 默认值=false)<br/>
AppArmor=true|false (BETA - 默认值=true)<br/>
BalanceAttachedNodeVolumes=true|false (ALPHA - 默认值=false)<br/>
BoundServiceAccountTokenVolume=true|false (BETA - 默认值=true)<br/>
CPUManager=true|false (BETA - 默认值=true)<br/>
CSIInlineVolume=true|false (BETA - 默认值=true)<br/>
CSIMigration=true|false (BETA - 默认值=true)<br/>
CSIMigrationAWS=true|false (BETA - 默认值=false)<br/>
CSIMigrationAzureDisk=true|false (BETA - 默认值=false)<br/>
CSIMigrationAzureFile=true|false (BETA - 默认值=false)<br/>
CSIMigrationGCE=true|false (BETA - 默认值=false)<br/>
CSIMigrationOpenStack=true|false (BETA - 默认值=true)<br/>
CSIMigrationvSphere=true|false (BETA - 默认值=false)<br/>
CSIMigrationvSphereComplete=true|false (BETA - 默认值=false)<br/>
CSIServiceAccountToken=true|false (BETA - 默认值=true)<br/>
CSIStorageCapacity=true|false (BETA - 默认值=true)<br/>
CSIVolumeFSGroupPolicy=true|false (BETA - 默认值=true)<br/>
CSIVolumeHealth=true|false (ALPHA - 默认值=false)<br/>
ConfigurableFSGroupPolicy=true|false (BETA - 默认值=true)<br/>
ControllerManagerLeaderMigration=true|false (ALPHA - 默认值=false)<br/>
CronJobControllerV2=true|false (BETA - 默认值=true)<br/>
CustomCPUCFSQuotaPeriod=true|false (ALPHA - 默认值=false)<br/>
DaemonSetUpdateSurge=true|false (ALPHA - 默认值=false)<br/>
DefaultPodTopologySpread=true|false (BETA - 默认值=true)<br/>
DevicePlugins=true|false (BETA - 默认值=true)<br/>
DisableAcceleratorUsageMetrics=true|false (BETA - 默认值=true)<br/>
DownwardAPIHugePages=true|false (BETA - 默认值=false)<br/>
DynamicKubeletConfig=true|false (BETA - 默认值=true)<br/>
EfficientWatchResumption=true|false (BETA - 默认值=true)<br/>
EndpointSliceProxying=true|false (BETA - 默认值=true)<br/>
EndpointSliceTerminatingCondition=true|false (ALPHA - 默认值=false)<br/>
EphemeralContainers=true|false (ALPHA - 默认值=false)<br/>
ExpandCSIVolumes=true|false (BETA - 默认值=true)<br/>
ExpandInUsePersistentVolumes=true|false (BETA - 默认值=true)<br/>
ExpandPersistentVolumes=true|false (BETA - 默认值=true)<br/>
ExperimentalHostUserNamespaceDefaulting=true|false (BETA - 默认值=false)<br/>
GenericEphemeralVolume=true|false (BETA - 默认值=true)<br/>
GracefulNodeShutdown=true|false (BETA - 默认值=true)<br/>
HPAContainerMetrics=true|false (ALPHA - 默认值=false)<br/>
HPAScaleToZero=true|false (ALPHA - 默认值=false)<br/>
HugePageStorageMediumSize=true|false (BETA - 默认值=true)<br/>
IPv6DualStack=true|false (BETA - 默认值=true)<br/>
InTreePluginAWSUnregister=true|false (ALPHA - 默认值=false)<br/>
InTreePluginAzureDiskUnregister=true|false (ALPHA - 默认值=false)<br/>
InTreePluginAzureFileUnregister=true|false (ALPHA - 默认值=false)<br/>
InTreePluginGCEUnregister=true|false (ALPHA - 默认值=false)<br/>
InTreePluginOpenStackUnregister=true|false (ALPHA - 默认值=false)<br/>
InTreePluginvSphereUnregister=true|false (ALPHA - 默认值=false)<br/>
IndexedJob=true|false (ALPHA - 默认值=false)<br/>
IngressClassNamespacedParams=true|false (ALPHA - 默认值=false)<br/>
KubeletCredentialProviders=true|false (ALPHA - 默认值=false)<br/>
KubeletPodResources=true|false (BETA - 默认值=true)<br/>
KubeletPodResourcesGetAllocatable=true|false (ALPHA - 默认值=false)<br/>
LocalStorageCapacityIsolation=true|false (BETA - 默认值=true)<br/>
LocalStorageCapacityIsolationFSQuotaMonitoring=true|false (ALPHA - 默认值=false)<br/>
LogarithmicScaleDown=true|false (ALPHA - 默认值=false)<br/>
MemoryManager=true|false (ALPHA - 默认值=false)<br/>
MixedProtocolLBService=true|false (ALPHA - 默认值=false)<br/>
NamespaceDefaultLabelName=true|false (BETA - 默认值=true)<br/>
NetworkPolicyEndPort=true|false (ALPHA - 默认值=false)<br/>
NonPreemptingPriority=true|false (BETA - 默认值=true)<br/>
PodAffinityNamespaceSelector=true|false (ALPHA - 默认值=false)<br/>
PodDeletionCost=true|false (ALPHA - 默认值=false)<br/>
PodOverhead=true|false (BETA - 默认值=true)<br/>
PreferNominatedNode=true|false (ALPHA - 默认值=false)<br/>
ProbeTerminationGracePeriod=true|false (ALPHA - 默认值=false)<br/>
ProcMountType=true|false (ALPHA - 默认值=false)<br/>
QOSReserved=true|false (ALPHA - 默认值=false)<br/>
RemainingItemCount=true|false (BETA - 默认值=true)<br/>
RemoveSelfLink=true|false (BETA - 默认值=true)<br/>
RotateKubeletServerCertificate=true|false (BETA - 默认值=true)<br/>
ServerSideApply=true|false (BETA - 默认值=true)<br/>
ServiceInternalTrafficPolicy=true|false (ALPHA - 默认值=false)<br/>
ServiceLBNodePortControl=true|false (ALPHA - 默认值=false)<br/>
ServiceLoadBalancerClass=true|false (ALPHA - 默认值=false)<br/>
ServiceTopology=true|false (ALPHA - 默认值=false)<br/>
SetHostnameAsFQDN=true|false (BETA - 默认值=true)<br/>
SizeMemoryBackedVolumes=true|false (ALPHA - 默认值=false)<br/>
StorageVersionAPI=true|false (ALPHA - 默认值=false)<br/>
StorageVersionHash=true|false (BETA - 默认值=true)<br/>
SuspendJob=true|false (ALPHA - 默认值=false)<br/>
TTLAfterFinished=true|false (BETA - 默认值=true)<br/>
TopologyAwareHints=true|false (ALPHA - 默认值=false)<br/>
TopologyManager=true|false (BETA - 默认值=true)<br/>
ValidateProxyRedirects=true|false (BETA - 默认值=true)<br/>
VolumeCapacityPriority=true|false (ALPHA - 默认值=false)<br/>
WarningHeaders=true|false (BETA - 默认值=true)<br/>
WinDSR=true|false (ALPHA - 默认值=false)<br/>
WinOverlay=true|false (BETA - 默认值=true)<br/>
WindowsEndpointSliceProxying=true|false (BETA - 默认值=true)
</p>
</td>
</tr>
<tr>
<td colspan="2">--flex-volume-plugin-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值："/usr/libexec/kubernetes/kubelet-plugins/volume/exec/"</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Full path of the directory in which the flex volume plugin should search for additional third party volume plugins.
-->
FlexVolume 插件要搜索第三方卷插件的目录路径全名。
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for kube-controller-manager
-->
kube-controller-manager 的帮助信息。
</td>
</tr>
<tr>
<td colspan="2">--horizontal-pod-autoscaler-cpu-initialization-period duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值：5m0s</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The period after pod start when CPU samples might be skipped.
-->
Pod 启动之后可以忽略 CPU 采样值的时长。
</td>
</tr>
<tr>
<td colspan="2">--horizontal-pod-autoscaler-downscale-stabilization duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值：5m0s</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The period for which autoscaler will look backwards and not scale down below any recommendation it made during that period.
-->
自动扩缩程序的回溯时长。自动扩缩器不会基于在给定的时长内所建议的规模
对负载执行规模缩小的操作。
</td>
</tr>
<tr>
<td colspan="2">--horizontal-pod-autoscaler-initial-readiness-delay duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值：30s</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The period after pod start during which readiness changes will be treated as initial readiness.
-->
Pod 启动之后，在此值所给定的时长内，就绪状态的变化都不会作为初始的就绪状态。
</td>
</tr>
<tr>
<td colspan="2">--horizontal-pod-autoscaler-sync-period duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值：15s</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The period for syncing the number of pods in horizontal pod autoscaler.
-->
水平 Pod 扩缩器对 Pods 数目执行同步操作的周期。
</td>
</tr>
<tr>
<td colspan="2">--horizontal-pod-autoscaler-tolerance float&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值：0.1</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The minimum change (from 1.0) in the desired-to-actual metrics ratio for the horizontal pod autoscaler to consider scaling.
-->
此值为目标值与实际值的比值与 1.0 的差值。只有超过此标志所设的阈值时，
HPA 才会考虑执行缩放操作。
</td>
</tr>
<tr>
<td colspan="2">--http2-max-streams-per-connection int</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The limit that the server gives to clients for the maximum number of streams in an HTTP/2 connection. Zero means to use golang's default.
-->
服务器为客户端所设置的 HTTP/2 连接中流式连接个数上限。
此值为 0 表示采用 Go 语言库所设置的默认值。
</td>
</tr>
<tr>
<td colspan="2">--kube-api-burst int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值：30</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Burst to use while talking with kubernetes apiserver.
-->
与 Kubernetes API 服务器通信时突发峰值请求个数上限。
</td>
</tr>
<tr>
<td colspan="2">--kube-api-content-type string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值："application/vnd.kubernetes.protobuf"</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Content type of requests sent to apiserver.
-->
向 API 服务器发送请求时使用的内容类型（Content-Type）。
</td>
</tr>
<tr>
<td colspan="2">--kube-api-qps float32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值：20</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
QPS to use while talking with kubernetes apiserver.
-->
与 API 服务器通信时每秒请求数（QPS）限制。
</td>
</tr>
<tr>
<td colspan="2">--kubeconfig string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to kubeconfig file with authorization and master location information.
-->
指向 kubeconfig 文件的路径。该文件中包含主控节点位置以及鉴权凭据信息。
</td>
</tr>
<tr>
<td colspan="2">--large-cluster-size-threshold int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值：50</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Number of nodes from which NodeController treats the cluster as large for the eviction logic purposes. --secondary-node-eviction-rate is implicitly overridden to 0 for clusters this size or smaller.
-->
节点控制器在执行 Pod 逐出操作逻辑时，基于此标志所设置的节点个数阈值来判断
所在集群是否为大规模集群。当集群规模小于等于此规模时，
<code>--secondary-node-eviction-rate</code> 会被隐式重设为 0。
</td>
</tr>
<tr>
<td colspan="2">--leader-elect&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值：true</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Start a leader election client and gain leadership before executing the main loop. Enable this when running replicated components for high availability.
-->
在执行主循环之前，启动领导选举（Leader Election）客户端，并尝试获得领导者身份。
在运行多副本组件时启用此标志有助于提高可用性。
</td>
</tr>
<tr>
<td colspan="2">--leader-elect-lease-duration duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值：15s</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The duration that non-leader candidates will wait after observing a leadership renewal until attempting to acquire leadership of a led but unrenewed leader slot. This is effectively the maximum duration that a leader can be stopped before it is replaced by another candidate. This is only applicable if leader election is enabled.
-->
对于未获得领导者身份的节点，在探测到领导者身份需要更迭时需要等待
此标志所设置的时长，才能尝试去获得曾经是领导者但尚未续约的席位。
本质上，这个时长也是现有领导者节点在被其他候选节点替代之前可以停止
的最长时长。只有集群启用了领导者选举机制时，此标志才起作用。
</td>
</tr>
<tr>
<td colspan="2">--leader-elect-renew-deadline duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值：10s</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The interval between attempts by the acting master to renew a leadership slot before it stops leading. This must be less than or equal to the lease duration. This is only applicable if leader election is enabled.
-->
当前执行领导者角色的节点在被停止履行领导职责之前可多次尝试续约领导者身份；
此标志给出相邻两次尝试之间的间歇时长。
此值必须小于或等于租期时长（Lease Duration）。
仅在集群启用了领导者选举时有效。
</td>
</tr>
<tr>
<td colspan="2">--leader-elect-resource-lock string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值："leases"</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The type of resource object that is used for locking during leader election. Supported options are 'endpoints', 'configmaps', 'leases', 'endpointsleases' and 'configmapsleases'.
-->
在领导者选举期间用于锁定的资源对象的类型。 支持的选项为 "endpoints"、
"configmaps"、"leases"、"endpointsleases" 和 "configmapsleases"。
</td>
</tr>
<tr>
<td colspan="2">--leader-elect-resource-name string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值："kube-controller-manager"</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The name of resource object that is used for locking during leader election.
-->
在领导者选举期间，用来执行锁操作的资源对象名称。
</td>
</tr>
<tr>
<td colspan="2">--leader-elect-resource-namespace string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值："kube-system"</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The namespace of resource object that is used for locking during leader election.
-->
在领导者选举期间，用来执行锁操作的资源对象的名字空间。
</td>
</tr>
<tr>
<td colspan="2">--leader-elect-retry-period duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值：2s</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The duration the clients should wait between attempting acquisition and renewal of a leadership. This is only applicable if leader election is enabled.
-->
尝试获得领导者身份时，客户端在相邻两次尝试之间要等待的时长。
此标志仅在启用了领导者选举的集群中起作用。
</td>
</tr>
<tr>
<td colspan="2">--leader-migration-config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;"><p>
<!--
Path to the config file for controller leader migration, or empty to use the value that reflects default configuration of the controller manager. The config file should be of type LeaderMigrationConfiguration, group controllermanager.config.k8s.io, version v1alpha1.
-->
控制器领导者迁移所用的配置文件路径。
此值为空意味着使用控制器管理器的默认配置。
配置文件应该是 <code>controllermanager.config.k8s.io</code> 组、
<code>v1alpha1</code> 版本的 <code>LeaderMigrationConfiguration</code> 结构。
</p></td>
</tr>
<tr>
<td colspan="2">--log-backtrace-at traceLocation&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值：<code>:0</code></td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
when logging hits line file:N, emit a stack trace
-->
当执行到 <code>file:N</code> 所给的文件和代码行时，日志机制会生成一个调用栈快照。
</td>
</tr>
<tr>
<td colspan="2">--log-dir string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
If non-empty, write log files in this directory.
-->
此标志为非空字符串时，日志文件会写入到所给的目录中。
</td>
</tr>
<tr>
<td colspan="2">--log-file string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
If non-empty, use this log file
-->
此标志为非空字符串时，意味着日志会写入到所给的文件中。
</td>
</tr>
<tr>
<td colspan="2">--log-file-max-size uint&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值：1800</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Defines the maximum size a log file can grow to. Unit is megabytes. If the value is 0, the maximum file size is unlimited.
-->
定义日志文件大小的上限。单位是兆字节（MB）。
若此值为 0，则不对日志文件尺寸进行约束。
</td>
</tr>
<tr>
<td colspan="2">--log-flush-frequency duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值：5s</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Maximum number of seconds between log flushes
-->
将内存中日志数据清除到日志文件中时，相邻两次清除操作之间最大间隔秒数。
</td>
</tr>
<tr>
<td colspan="2">--logging-format string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值："text"</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Sets the log format. Permitted formats: "json", "text".<br/>Non-default formats don't honor these flags: --add_dir_header, --alsologtostderr, --log_backtrace_at, --log_dir, --log_file, --log_file_max_size, --logtostderr, --one_output, --skip_headers, --skip_log_headers, --stderrthreshold, --vmodule, --log-flush-frequency.<br/>Non-default choices are currently alpha and subject to change without warning.
-->
设置日志格式。允许的格式："text"，"json"。
<br/>非默认格式不支持以下标志：<code>--add-dir-header</code>、
<code>--alsologtostderr</code>》、<code>--log-backtrace-at</code>、
<code>--log-dir</code>、<code>--log-file</code>、<code>--log-file-max-size</code>、
<code>--logtostderr</code>、<code>--one-output</code>、<code>--skip-headers</code>、
<code>--skip-log-headers</code>、<code>--stderrthreshold</code>、
<code>--vmodule</code>、<code>--log-flush-frequency</code>。
<br/>当前非默认选项为 Alpha 阶段，如有更改，恕不另行通知。
</td>
</tr>
<tr>
<td colspan="2">--logtostderr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值：true</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
log to standard error instead of files
-->
将日志写出到标准错误输出（stderr）而不是写入到日志文件。
</td>
</tr>
<tr>
<td colspan="2">--master string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The address of the Kubernetes API server (overrides any value in kubeconfig).
-->
Kubernetes API 服务器的地址。此值会覆盖 kubeconfig 文件中所给的地址。
</td>
</tr>
<tr>
<td colspan="2">--max-endpoints-per-slice int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值：100</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The maximum number of endpoints that will be added to an EndpointSlice. More endpoints per slice will result in less endpoint slices, but larger resources. Defaults to 100.
-->
每个 EndpointSlice 中可以添加的端点个数上限。每个片段中端点个数越多，
得到的片段个数越少，但是片段的规模会变得更大。默认值为 100。
</td>
</tr>
<tr>
<td colspan="2">--min-resync-period duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值：12h0m0s</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The resync period in reflectors will be random between MinResyncPeriod and 2*MinResyncPeriod.
-->
自省程序的重新同步时隔下限。实际时隔长度会在 <code>min-resync-period</code> 和
<code>2 * min-resync-period</code> 之间。
</td>
</tr>
<tr>
<td colspan="2">--mirroring-concurrent-service-endpoint-syncs int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值：5</td>
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The number of service endpoint syncing operations that will be done concurrently by the EndpointSliceMirroring controller. Larger number = faster endpoint slice updating, but more CPU (and network) load. Defaults to 5.
-->
EndpointSliceMirroring 控制器将同时执行的服务端点同步操作数。
较大的数量 = 更快的端点切片更新，但 CPU（和网络）负载更多。 默认为 5。
</td>
</tr>
<tr>
<td colspan="2">--mirroring-endpointslice-updates-batch-period duration</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The length of EndpointSlice updates batching period for EndpointSliceMirroring controller. Processing of EndpointSlice changes will be delayed by this duration to join them with potential upcoming updates and reduce the overall number of EndpointSlice updates. Larger number = higher endpoint programming latency, but lower number of endpoints revision generated
-->
EndpointSlice 的长度更新了 EndpointSliceMirroring 控制器的批处理周期。
EndpointSlice 更改的处理将延迟此持续时间，
以使它们与潜在的即将进行的更新结合在一起，并减少 EndpointSlice 更新的总数。 
较大的数量 = 较高的端点编程延迟，但是生成的端点修订版本数量较少
</td>
</tr>
<tr>
<td colspan="2">--mirroring-max-endpoints-per-subset int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值：1000</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The maximum number of endpoints that will be added to an EndpointSlice by the EndpointSliceMirroring controller. More endpoints per slice will result in less endpoint slices, but larger resources.
-->
EndpointSliceMirroring 控制器将添加到 EndpointSlice 的最大端点数。
每个分片的端点越多，端点分片越少，但资源越大。
</td>
</tr>
<tr>
<td colspan="2">--namespace-sync-period duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值：5m0s</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The period for syncing namespace life-cycle updates
-->
对名字空间对象进行同步的周期。
</td>
</tr>
<tr>
<td colspan="2">--node-cidr-mask-size int32</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Mask size for node cidr in cluster. Default is 24 for IPv4 and 64 for IPv6.
-->
集群中节点 CIDR 的掩码长度。对 IPv4 而言默认为 24；对 IPv6 而言默认为 64。
</td>
</tr>
<tr>
<td colspan="2">--node-cidr-mask-size-ipv4 int32</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Mask size for IPv4 node cidr in dual-stack cluster. Default is 24.
-->
在双堆栈（同时支持 IPv4 和 IPv6）的集群中，节点 IPV4 CIDR 掩码长度。默认为 24。
</td>
</tr>
<tr>
<td colspan="2">--node-cidr-mask-size-ipv6 int32</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Mask size for IPv6 node cidr in dual-stack cluster. Default is 64.
-->
在双堆栈（同时支持 IPv4 和 IPv6）的集群中，节点 IPv6 CIDR 掩码长度。默认为 64。
</td>
</tr>
<tr>
<td colspan="2">--node-eviction-rate float32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值：0.1</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Number of nodes per second on which pods are deleted in case of node failure when a zone is healthy (see --unhealthy-zone-threshold for definition of healthy/unhealthy). Zone refers to entire cluster in non-multizone clusters.
-->
当某区域变得不健康，节点失效时，每秒钟可以从此标志所设定的节点
个数上删除 Pods。请参阅 <code>--unhealthy-zone-threshold</code> 
以了解“健康”的判定标准。这里的区域（zone）在集群并不跨多个区域时
指的是整个集群。
</td>
</tr>
<tr>
<td colspan="2">--node-monitor-grace-period duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值：40s</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Amount of time which we allow running Node to be unresponsive before marking it unhealthy. Must be N times more than kubelet's nodeStatusUpdateFrequency, where N means number of retries allowed for kubelet to post node status.
-->
在将一个 Node 标记为不健康之前允许其无响应的时长上限。
必须比 kubelet 的 nodeStatusUpdateFrequency 大 N 倍；
这里 N 指的是 kubelet 发送节点状态的重试次数。
</td>
</tr>
<tr>
<td colspan="2">--node-monitor-period duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值：5s</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The period for syncing NodeStatus in NodeController.
-->
节点控制器对节点状态进行同步的重复周期。
</td>
</tr>
<tr>
<td colspan="2">--node-startup-grace-period duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值：1m0s</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Amount of time which we allow starting Node to be unresponsive before marking it unhealthy.
-->
在节点启动期间，节点可以处于无响应状态；
但超出此标志所设置的时长仍然无响应则该节点被标记为不健康。
</td>
</tr>
<tr>
<td colspan="2">--one-output</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
If true, only write logs to their native severity level (vs also writing to each lower severity level
-->
如果此标志为 true，则仅将日志写入其自身的严重性级别（而不是同时写入更低的严重性级别中）。
</td>
</tr>
<tr>
<td colspan="2">--permit-address-sharing</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;"><p>
<!--
If true, SO_REUSEADDR will be used when binding the port. This allows binding to wildcard IPs like 0.0.0.0 and specific IPs in parallel, and it avoids waiting for the kernel to release sockets in TIME_WAIT state.
-->
如果此标志为 true，则在绑定端口时使用 <code>SO_REUSEADDR</code>。
这就意味着可以同时绑定到 <code>0.0.0.0</code> 和特定的 IP 地址，
并且避免等待内核释放处于 <code>TIME_WAITE</code> 状态的套接字。
</p></td>
</tr>
<tr>
<td colspan="2">--permit-port-sharing</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
If true, SO_REUSEPORT will be used when binding the port, which allows more than one instance to bind on the same address and port. [default=false]
-->
如果为 true，则在绑定端口时将使用 <code>SO_REUSEPORT</code>，
这允许多个实例在同一地址和端口上进行绑定。
</td>
</tr>
<tr>
<td colspan="2">--pod-eviction-timeout duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值：5m0s</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The grace period for deleting pods on failed nodes.
-->
在失效的节点上删除 Pods 时为其预留的宽限期。
</td>
</tr>
<tr>
<td colspan="2">--profiling&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值：true</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Enable profiling via web interface host:port/debug/pprof/
-->
通过位于 <code>host:port/debug/pprof/</code> 的 Web 接口启用性能分析。
</td>
</tr>
<tr>
<td colspan="2">--pv-recycler-increment-timeout-nfs int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值：30</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
the increment of time added per Gi to ActiveDeadlineSeconds for an NFS scrubber pod
-->
NFS 清洗 Pod 在清洗用过的卷时，根据此标志所设置的秒数，为每清洗 1 GiB 数据
增加对应超时时长，作为 activeDeadlineSeconds。
</td>
</tr>
<tr>
<td colspan="2">--pv-recycler-minimum-timeout-hostpath int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值：60</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The minimum ActiveDeadlineSeconds to use for a HostPath Recycler pod.  This is for development and testing only and will not work in a multi-node cluster.
-->
对于 HostPath 回收器 Pod，设置其 activeDeadlineSeconds 参数下限。
此参数仅用于开发和测试目的，不适合在多节点集群中使用。
</td>
</tr>
<tr>
<td colspan="2">--pv-recycler-minimum-timeout-nfs int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值：300</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The minimum ActiveDeadlineSeconds to use for an NFS Recycler pod
-->
NFS 回收器 Pod 要使用的 activeDeadlineSeconds 参数下限。
</td>
</tr>
<tr>
<td colspan="2">--pv-recycler-pod-template-filepath-hostpath string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The file path to a pod definition used as a template for HostPath persistent volume recycling. This is for development and testing only and will not work in a multi-node cluster.
-->
对 HostPath 持久卷进行回收利用时，用作模版的 Pod 定义文件所在路径。
此标志仅用于开发和测试目的，不适合多节点集群中使用。
</td>
</tr>
<tr>
<td colspan="2">--pv-recycler-pod-template-filepath-nfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The file path to a pod definition used as a template for HostPath persistent volume recycling. This is for development and testing only and will not work in a multi-node cluster.
-->
对 NFS 卷执行回收利用时，用作模版的 Pod 定义文件所在路径。
</td>
</tr>
<tr>
<td colspan="2">--pv-recycler-timeout-increment-hostpath int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值：30</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
the increment of time added per Gi to ActiveDeadlineSeconds for a HostPath scrubber pod.  This is for development and testing only and will not work in a multi-node cluster.
-->
HostPath 清洗器 Pod 在清洗对应类型持久卷时，为每 GiB 数据增加此标志所设置的秒数，
作为其 activeDeadlineSeconds 参数。此标志仅用于开发和测试环境，不适合多节点集群环境。
</td>
</tr>
<tr>
<td colspan="2">--pvclaimbinder-sync-period duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值：15s</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The period for syncing persistent volumes and persistent volume claims
-->
持久卷（PV）和持久卷申领（PVC）对象的同步周期。
</td>
</tr>
<tr>
<td colspan="2">--requestheader-allowed-names strings</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
List of client certificate common names to allow to provide usernames in headers specified by --requestheader-username-headers. If empty, any client certificate validated by the authorities in --requestheader-client-ca-file is allowed.-->
标志值是客户端证书中的 Common Names 列表。其中所列的名称可以通过
<code>--requestheader-username-headers</code> 所设置的 HTTP 头部来提供用户名。
如果此标志值为空表，则被 <code>--requestheader-client-ca-file</code>
中机构所验证过的所有客户端证书都是允许的。
</td>
</tr>
<tr>
<td colspan="2">--requestheader-client-ca-file string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Root certificate bundle to use to verify client certificates on incoming requests before trusting usernames in headers specified by --requestheader-username-headers. WARNING: generally do not depend on authorization being already done for incoming requests.
-->
根证书包文件名。在信任通过 <code>--requestheader-username-headers</code>
所指定的任何用户名之前，要使用这里的证书来检查请求中的客户证书。
警告：一般不要依赖对请求所作的鉴权结果。
</td>
</tr>
<tr>
<td colspan="2">--requestheader-extra-headers-prefix strings&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值：<code>"x-remote-extra-"</code></td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
List of request header prefixes to inspect. X-Remote-Extra- is suggested.
-->
要插入的请求头部前缀。建议使用 <code>X-Remote-Exra-</code>。
</td>
</tr>
<tr>
<td colspan="2">--requestheader-group-headers strings&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值：<code>"x-remote-group"</code></td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
List of request headers to inspect for groups. X-Remote-Group is suggested.
-->
用来检查用户组名的请求头部名称列表。建议使用 <code>X-Remote-Group</code>。
</td>
</tr>
<tr>
<td colspan="2">--requestheader-username-headers strings&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值：<code>"x-remote-user"</code></td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
List of request headers to inspect for usernames. X-Remote-User is common.
-->
用来检查用户名的请求头部名称列表。建议使用 <code>X-Remote-User</code>。
</td>
</tr>
<tr>
<td colspan="2">--resource-quota-sync-period duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值：5m0s</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The period for syncing quota usage status in the system
-->
对系统中配额用量信息进行同步的周期。
</td>
</tr>
<tr>
<td colspan="2">--root-ca-file string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
If set, this root certificate authority will be included in service account's token secret. This must be a valid PEM-encoded CA bundle.
-->
如果此标志非空，则在服务账号的令牌 Secret 中会包含此根证书机构。
所指定标志值必须是一个合法的 PEM 编码的 CA 证书包。
</td>
</tr>
<tr>
<td colspan="2">--route-reconciliation-period duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值：10s</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The period for reconciling routes created for Nodes by cloud provider.
-->
对云驱动为节点所创建的路由信息进行调解的周期。
</td>
</tr>
<tr>
<td colspan="2">--secondary-node-eviction-rate float32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值：0.01</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Number of nodes per second on which pods are deleted in case of node failure when a zone is unhealthy (see --unhealthy-zone-threshold for definition of healthy/unhealthy). Zone refers to entire cluster in non-multizone clusters. This value is implicitly overridden to 0 if the cluster size is smaller than --large-cluster-size-threshold.
-->
当区域不健康，节点失效时，每秒钟从此标志所给的节点个数上删除 Pods。
参见 <code>--unhealthy-zone-threshold</code> 以了解“健康与否”的判定标准。
在只有一个区域的集群中，区域指的是整个集群。如果集群规模小于
<code>--large-cluster-size-threshold</code> 所设置的节点个数时，
此值被隐式地重设为 0。
</td>
</tr>
<tr>
<td colspan="2">--secure-port int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值：10257</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The port on which to serve HTTPS with authentication and authorization. If 0, don't serve HTTPS at all.
-->
在此端口上提供 HTTPS 身份认证和鉴权操作。若此标志值为 0，则不提供 HTTPS 服务。
</td>
</tr>
<tr>
<td colspan="2">--service-account-private-key-file string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Filename containing a PEM-encoded private RSA or ECDSA key used to sign service account tokens.
-->
包含 PEM 编码的 RSA 或 ECDSA 私钥数据的文件名，这些私钥用来对服务账号令牌签名。
</td>
</tr>
<tr>
<td colspan="2">--service-cluster-ip-range string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
CIDR Range for Services in cluster. Requires --allocate-node-cidrs to be true
-->
集群中 Service 对象的 CIDR 范围。要求 <code>--allocate-node-cidrs</code> 标志为 true。
</td>
</tr>
<tr>
<td colspan="2">--show-hidden-metrics-for-version string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The previous version for which you want to show hidden metrics. Only the previous minor version is meaningful, other values will not be allowed. The format is &lt;major&gt;.&lt;minor&gt;, e.g.: '1.16'. The purpose of this format is make sure you have the opportunity to notice if the next release hides additional metrics, rather than being surprised when they are permanently removed in the release after that.
-->
你希望展示隐藏度量值的上一个版本。只有上一个次版本号有意义，其他值都是不允许的。
字符串格式为 "&lt;major&gt;.&lt;minor&gt;"。例如："1.16"。
此格式的目的是确保你能够有机会注意到下一个版本隐藏了一些额外的度量值，
而不是在更新版本中某些度量值被彻底删除时措手不及。
</td>
</tr>
<tr>
<td colspan="2">--skip-headers</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
If true, avoid header prefixes in the log messages
-->
若此标志为 true，则在日志消息中避免写入头部前缀信息。
</td>
</tr>
<tr>
<td colspan="2">--skip-log-headers</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
If true, avoid headers when opening log files
-->
若此标志为 true，则在写入日志文件时避免写入头部信息。
</td>
</tr>
<tr>
<td colspan="2">--stderrthreshold severity&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值：2</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
logs at or above this threshold go to stderr
-->
等于或大于此阈值的日志信息会被写入到标准错误输出（stderr）。
</td>
</tr>
<tr>
<td colspan="2">--terminated-pod-gc-threshold int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值：12500</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Number of terminated pods that can exist before the terminated pod garbage collector starts deleting terminated pods. If &lt;= 0, the terminated pod garbage collector is disabled.
-->
在已终止 Pods 垃圾收集器删除已终止 Pods 之前，可以保留的已删除
Pods 的个数上限。若此值小于等于 0，则相当于禁止垃圾回收已终止的 Pods。
</td>
</tr>
<tr>
<td colspan="2">--tls-cert-file string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
File containing the default x509 Certificate for HTTPS. (CA cert, if any, concatenated after server cert). If HTTPS serving is enabled, and --tls-cert-file and --tls-private-key-file are not provided, a self-signed certificate and key are generated for the public address and saved to the directory specified by --cert-dir.
-->
包含 HTTPS 所用的默认 X509 证书的文件。如果有 CA 证书，会被串接在服务器证书之后。
若启用了 HTTPS 服务且 <code>--tls-cert-file</code> 和 <code>--tls-private-key-file</code>
标志未设置，
则为节点的公开地址生成自签名的证书和密钥，并保存到 <code>--cert-dir</code>
所给的目录中。
</td>
</tr>
<tr>
<td colspan="2">--tls-cipher-suites strings</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Comma-separated list of cipher suites for the server. If omitted, the default Go cipher suites will be used.<br/>Preferred values: TLS_AES_128_GCM_SHA256, TLS_AES_256_GCM_SHA384, TLS_CHACHA20_POLY1305_SHA256, TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA, TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256, TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA, TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384, TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305, TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256, TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA, TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA, TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256, TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA, TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384, TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305, TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256, TLS_RSA_WITH_3DES_EDE_CBC_SHA, TLS_RSA_WITH_AES_128_CBC_SHA, TLS_RSA_WITH_AES_128_GCM_SHA256, TLS_RSA_WITH_AES_256_CBC_SHA, TLS_RSA_WITH_AES_256_GCM_SHA384.<br/>Insecure values: TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256, TLS_ECDHE_ECDSA_WITH_RC4_128_SHA, TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256, TLS_ECDHE_RSA_WITH_RC4_128_SHA, TLS_RSA_WITH_AES_128_CBC_SHA256, TLS_RSA_WITH_RC4_128_SHA.
-->
供服务器使用的加密包的逗号分隔列表。若忽略此标志，则使用 Go 语言默认的加密包。<br/>
可选值包括：TLS_AES_128_GCM_SHA256、TLS_AES_256_GCM_SHA384、TLS_CHACHA20_POLY1305_SHA256、TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA、TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256、TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA、TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384、TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305、TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256、TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA、TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA、TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256、TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA、TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384、TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305、TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256、TLS_RSA_WITH_3DES_EDE_CBC_SHA、TLS_RSA_WITH_AES_128_CBC_SHA、TLS_RSA_WITH_AES_128_GCM_SHA256、TLS_RSA_WITH_AES_256_CBC_SHA、TLS_RSA_WITH_AES_256_GCM_SHA384. 
<br/>不安全的值: TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256、TLS_ECDHE_ECDSA_WITH_RC4_128_SHA、TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256、TLS_ECDHE_RSA_WITH_RC4_128_SHA、TLS_RSA_WITH_AES_128_CBC_SHA256、TLS_RSA_WITH_RC4_128_SHA
</td>
</tr>
<tr>
<td colspan="2">--tls-min-version string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Minimum TLS version supported. Possible values: VersionTLS10, VersionTLS11, VersionTLS12, VersionTLS13
-->
可支持的最低 TLS 版本。可选值包括：
“VersionTLS10”、“VersionTLS11”、“VersionTLS12”、“VersionTLS13”。
</td>
</tr>
<tr>
<td colspan="2">--tls-private-key-file string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
File containing the default x509 private key matching --tls-cert-file.
-->
包含与 <code>--tls-cert-file</code> 对应的默认 X509 私钥的文件。
</td>
</tr>
<tr>
<td colspan="2">--tls-sni-cert-key namedCertKey&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值：[]</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
A pair of x509 certificate and private key file paths, optionally suffixed with a list of domain patterns which are fully qualified domain names, possibly with prefixed wildcard segments. The domain patterns also allow IP addresses, but IPs should only be used if the apiserver has visibility to the IP address requested by a client. If no domain patterns are provided, the names of the certificate are extracted. Non-wildcard matches trump over wildcard matches, explicit domain patterns trump over extracted names. For multiple key/certificate pairs, use the --tls-sni-cert-key multiple times. Examples: "example.crt,example.key" or "foo.crt,foo.key:*.foo.com,foo.com".
-->
X509 证书和私钥文件路径的耦对。作为可选项，可以添加域名模式的列表，
其中每个域名模式都是可以带通配片段前缀的全限定域名（FQDN）。
域名模式也可以使用 IP 地址字符串，不过只有 API 服务器在所给 IP 地址上
对客户端可见时才可以使用 IP 地址。在未提供域名模式时，从证书中提取域名。
如果有非通配方式的匹配，则优先于通配方式的匹配；显式的域名模式优先于提取的域名。
当存在多个密钥/证书耦对时，可以多次使用 <code>--tls-sni-cert-key</code> 标志。
例如：<code>example.crt,example.key</code> 或 <code>foo.crt,foo.key:\*.foo.com,foo.com</code>。
</td>
</tr>
<tr>
<td colspan="2">--unhealthy-zone-threshold float32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值：0.55</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Fraction of Nodes in a zone which needs to be not Ready (minimum 3) for zone to be treated as unhealthy. 
-->
仅当给定区域中处于非就绪状态的节点（最少 3 个）的占比高于此值时，
才将该区域视为不健康。
</td>
</tr>
<tr>
<td colspan="2">--use-service-account-credentials</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
If true, use individual service account credentials for each controller.
-->
当此标志为 true 时，为每个控制器单独使用服务账号凭据。
</td>
</tr>
<tr>
<td colspan="2">-v, --v int</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
number for the log level verbosity-->
日志级别详细程度取值。
</td>
</tr>
<tr>
<td colspan="2">--version version[=true]</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Print version information and quit
-->
打印版本信息之后退出。
</td>
</tr>
<tr>
<td colspan="2">--vmodule &lt;<!--comma-separated 'pattern=N' settings-->逗号分隔的 'pattern=N' 配置值&gt;</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Comma-separated list of pattern=N settings for file-filtered logging
-->
由逗号分隔的列表，每一项都是 pattern=N 格式，用来执行根据文件过滤的日志行为。
</td>
</tr>
<tr>
<td colspan="2">--volume-host-allow-local-loopback&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值：true</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
If false, deny local loopback IPs in addition to any CIDR ranges in --volume-host-cidr-denylist
-->
此标志为 false 时，禁止本地回路 IP 地址和 <code>--volume-host-cidr-denylist</code>
中所指定的 CIDR 范围。
</td>
</tr>
<tr>
<td colspan="2">--volume-host-cidr-denylist strings</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
A comma-separated list of CIDR ranges to avoid from volume plugins.
-->
用逗号分隔的一个 CIDR 范围列表，禁止使用这些地址上的卷插件。
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-a727de6cb5a090d5f115f88a8606c438">9.5 - kube-proxy</h1>
    
	<!-- 
title: kube-proxy
content_type: tool-reference
weight: 28
-->
<!--
The file is auto-generated from the Go source code of the component using a generic
[generator](https://github.com/kubernetes-sigs/reference-docs/). To learn how
to generate the reference documentation, please read
[Contributing to the reference documentation](/docs/contribute/generate-ref-docs/).
To update the reference conent, please follow the 
[Contributing upstream](/docs/contribute/generate-ref-docs/contribute-upstream/)
guide. You can file document formatting bugs against the
[reference-docs](https://github.com/kubernetes-sigs/reference-docs/) project.
-->
<h2 id="简介">简介</h2>
<!--
The Kubernetes network proxy runs on each node. This
reflects services as defined in the Kubernetes API on each node and can do simple
TCP, UDP, and SCTP stream forwarding or round robin TCP, UDP, and SCTP forwarding across a set of backends.
Service cluster IPs and ports are currently found through Docker-links-compatible
environment variables specifying ports opened by the service proxy. There is an optional
addon that provides cluster DNS for these cluster IPs. The user must create a service
with the apiserver API to configure the proxy.
-->
<p>Kubernetes 网络代理在每个节点上运行。网络代理反映了每个节点上 Kubernetes API
中定义的服务，并且可以执行简单的 TCP、UDP 和 SCTP 流转发，或者在一组后端进行
循环 TCP、UDP 和 SCTP 转发。
当前可通过 Docker-links-compatible 环境变量找到服务集群 IP 和端口，
这些环境变量指定了服务代理打开的端口。
有一个可选的插件，可以为这些集群 IP 提供集群 DNS。
用户必须使用 apiserver API 创建服务才能配置代理。</p>
<pre tabindex="0"><code>kube-proxy [flags]
</code></pre><h2 id="选项">选项</h2>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--add-dir-header</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;"><p>
<!--
If true, adds the file directory to the header of the log messages
-->
若此标志为 true，则将文件目录添加到日志消息的头部。
</p></td>
</tr>
<tr>
<td colspan="2">--alsologtostderr</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;"><p>
<!--
log to standard error as well as files
-->
将日志输出到文件时也输出到标准错误输出（stderr）。
</p></td>
</tr>
<tr>
<td colspan="2">--azure-container-registry-config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;"><p>
<!--
Path to the file containing Azure container registry configuration information.
-->
包含 Azure 容器仓库配置信息的文件的路径。
</p>
</td>
</tr>
<tr>
<td colspan="2">--bind-address 0.0.0.0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值：0.0.0.0</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;"><p>
<!--
The IP address for the proxy server to serve on (set to '0.0.0.0' for all IPv4 interfaces and '::' for all IPv6 interfaces)
-->
代理服务器要使用的 IP 地址（设置为 '0.0.0.0' 表示要使用所有 IPv4 接口；
设置为 '::' 表示使用所有 IPv6 接口）。
</p>
</td>
</tr>
<tr>
<td colspan="2">--bind-address-hard-fail</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;"><p>
<!--
If true kube-proxy will treat failure to bind to a port as fatal and exit
-->
若此标志为 true，kube-proxy 会将无法绑定端口的失败操作视为致命错误并退出。
</p></td>
</tr>
<tr>
<td colspan="2">--boot-id-file string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值："/proc/sys/kernel/random/boot_id"</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;"><p>
<!--
Comma-separated list of files to check for boot-id. Use the first one that exists.
-->
用来检查 Boot-ID 的文件名，用逗号隔开。
第一个存在的文件会被使用。
</p></td>
</tr>
<tr>
<td colspan="2">--cleanup</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;"><p>
<!--
If true cleanup iptables and ipvs rules and exit.
-->
如果为 true，清理 iptables 和 ipvs 规则并退出。
</p>
</td>
</tr>
<tr>
<td colspan="2">--cluster-cidr string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;"><p>
<!--
The CIDR range of pods in the cluster. When configured, traffic sent to a Service cluster IP from outside this range will be masqueraded and traffic sent from pods to an external LoadBalancer IP will be directed to the respective cluster IP instead
-->
集群中 Pod 的 CIDR 范围。配置后，将从该范围之外发送到服务集群 IP
的流量被伪装，从 Pod 发送到外部 LoadBalancer IP 的流量将被重定向
到相应的集群 IP。
</p>
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;"><p>
<!--
The path to the configuration file.
-->
配置文件的路径。
</p>
</td>
</tr>
<tr>
<td colspan="2">--config-sync-period duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值：15m0s</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;"><p>
<!--
How often configuration from the apiserver is refreshed.  Must be greater than 0.
-->
来自 apiserver 的配置的刷新频率。必须大于 0。
</p>
</td>
</tr>
<tr>
<td colspan="2">--conntrack-max-per-core int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值：32768</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;"><p>
<!--
Maximum number of NAT connections to track per CPU core (0 to leave the limit as-is and ignore conntrack-min).
-->
每个 CPU 核跟踪的最大 NAT 连接数（0 表示保留当前限制并忽略 conntrack-min 设置）。
</p>
</td>
</tr>
<tr>
<td colspan="2">--conntrack-min int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值：131072</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;"><p>
<!--
Minimum number of conntrack entries to allocate, regardless of conntrack-max-per-core (set conntrack-max-per-core=0 to leave the limit as-is).
-->
无论 <code>conntrack-max-per-core</code> 多少，要分配的 conntrack
条目的最小数量（将 <code>conntrack-max-per-core</code> 设置为 0 即可
保持当前的限制）。
</p>
</td>
</tr>
<tr>
<td colspan="2">--conntrack-tcp-timeout-close-wait duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值：1h0m0s
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;"><p>
<!--
NAT timeout for TCP connections in the CLOSE_WAIT state
-->
处于 <code>CLOSE_WAIT</code> 状态的 TCP 连接的 NAT 超时。
</p>
</td>
</tr>
<tr>
<td colspan="2">--conntrack-tcp-timeout-established duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值：24h0m0s</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;"><p>
<!--
Idle timeout for established TCP connections (0 to leave as-is)
-->
已建立的 TCP 连接的空闲超时（0 保持当前设置）。
</p>
</td>
</tr>
<tr>
<td colspan="2">--detect-local-mode LocalMode</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;"><p>
<!-- Mode to use to detect local traffic -->
用于检测本地流量的模式。
</p>
</td>
</tr>
<tr>
<td colspan="2">--feature-gates &lt;<!--comma-separated 'key=True|False' pairs-->逗号分隔的 'key=True|False' 对’&gt;</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;"><p>
<!--
A set of key=value pairs that describe feature gates for alpha/experimental features. Options are:
<br/>
APIListChunking=true|false (BETA - default=true)<br/>
APIPriorityAndFairness=true|false (BETA - default=true)<br/>
APIResponseCompression=true|false (BETA - default=true)<br/>
APIServerIdentity=true|false (ALPHA - default=false)<br/>
AllAlpha=true|false (ALPHA - default=false)<br/>
AllBeta=true|false (BETA - default=false)<br/>
AnyVolumeDataSource=true|false (ALPHA - default=false)<br/>
AppArmor=true|false (BETA - default=true)<br/>
BalanceAttachedNodeVolumes=true|false (ALPHA - default=false)<br/>
BoundServiceAccountTokenVolume=true|false (BETA - default=true)<br/>
CPUManager=true|false (BETA - default=true)<br/>
CSIInlineVolume=true|false (BETA - default=true)<br/>
CSIMigration=true|false (BETA - default=true)<br/>
CSIMigrationAWS=true|false (BETA - default=false)<br/>
CSIMigrationAzureDisk=true|false (BETA - default=false)<br/>
CSIMigrationAzureFile=true|false (BETA - default=false)<br/>
CSIMigrationGCE=true|false (BETA - default=false)<br/>
CSIMigrationOpenStack=true|false (BETA - default=true)<br/>
CSIMigrationvSphere=true|false (BETA - default=false)<br/>
CSIMigrationvSphereComplete=true|false (BETA - default=false)<br/>
CSIServiceAccountToken=true|false (BETA - default=true)<br/>
CSIStorageCapacity=true|false (BETA - default=true)<br/>
CSIVolumeFSGroupPolicy=true|false (BETA - default=true)<br/>
CSIVolumeHealth=true|false (ALPHA - default=false)<br/>
ConfigurableFSGroupPolicy=true|false (BETA - default=true)<br/>
ControllerManagerLeaderMigration=true|false (ALPHA - default=false)<br/>
CronJobControllerV2=true|false (BETA - default=true)<br/>
CustomCPUCFSQuotaPeriod=true|false (ALPHA - default=false)<br/>
DaemonSetUpdateSurge=true|false (ALPHA - default=false)<br/>
DefaultPodTopologySpread=true|false (BETA - default=true)<br/>
DevicePlugins=true|false (BETA - default=true)<br/>
DisableAcceleratorUsageMetrics=true|false (BETA - default=true)<br/>
DownwardAPIHugePages=true|false (BETA - default=false)<br/>
DynamicKubeletConfig=true|false (BETA - default=true)<br/>
EfficientWatchResumption=true|false (BETA - default=true)<br/>
EndpointSliceProxying=true|false (BETA - default=true)<br/>
EndpointSliceTerminatingCondition=true|false (ALPHA - default=false)<br/>
EphemeralContainers=true|false (ALPHA - default=false)<br/>
ExpandCSIVolumes=true|false (BETA - default=true)<br/>
ExpandInUsePersistentVolumes=true|false (BETA - default=true)<br/>
ExpandPersistentVolumes=true|false (BETA - default=true)<br/>
ExperimentalHostUserNamespaceDefaulting=true|false (BETA - default=false)<br/>
GenericEphemeralVolume=true|false (BETA - default=true)<br/>
GracefulNodeShutdown=true|false (BETA - default=true)<br/>
HPAContainerMetrics=true|false (ALPHA - default=false)<br/>
HPAScaleToZero=true|false (ALPHA - default=false)<br/>
HugePageStorageMediumSize=true|false (BETA - default=true)<br/>
IPv6DualStack=true|false (BETA - default=true)<br/>
InTreePluginAWSUnregister=true|false (ALPHA - default=false)<br/>
InTreePluginAzureDiskUnregister=true|false (ALPHA - default=false)<br/>
InTreePluginAzureFileUnregister=true|false (ALPHA - default=false)<br/>
InTreePluginGCEUnregister=true|false (ALPHA - default=false)<br/>
InTreePluginOpenStackUnregister=true|false (ALPHA - default=false)<br/>
InTreePluginvSphereUnregister=true|false (ALPHA - default=false)<br/>
IndexedJob=true|false (ALPHA - default=false)<br/>
IngressClassNamespacedParams=true|false (ALPHA - default=false)<br/>
KubeletCredentialProviders=true|false (ALPHA - default=false)<br/>
KubeletPodResources=true|false (BETA - default=true)<br/>
KubeletPodResourcesGetAllocatable=true|false (ALPHA - default=false)<br/>
LocalStorageCapacityIsolation=true|false (BETA - default=true)<br/>
LocalStorageCapacityIsolationFSQuotaMonitoring=true|false (ALPHA - default=false)<br/>
LogarithmicScaleDown=true|false (ALPHA - default=false)<br/>
MemoryManager=true|false (ALPHA - default=false)<br/>
MixedProtocolLBService=true|false (ALPHA - default=false)<br/>
NamespaceDefaultLabelName=true|false (BETA - default=true)<br/>
NetworkPolicyEndPort=true|false (ALPHA - default=false)<br/>
NonPreemptingPriority=true|false (BETA - default=true)<br/>
PodAffinityNamespaceSelector=true|false (ALPHA - default=false)<br/>
PodDeletionCost=true|false (ALPHA - default=false)<br/>
PodOverhead=true|false (BETA - default=true)<br/>
PreferNominatedNode=true|false (ALPHA - default=false)<br/>
ProbeTerminationGracePeriod=true|false (ALPHA - default=false)<br/>
ProcMountType=true|false (ALPHA - default=false)<br/>
QOSReserved=true|false (ALPHA - default=false)<br/>
RemainingItemCount=true|false (BETA - default=true)<br/>
RemoveSelfLink=true|false (BETA - default=true)<br/>
RotateKubeletServerCertificate=true|false (BETA - default=true)<br/>
ServerSideApply=true|false (BETA - default=true)<br/>
ServiceInternalTrafficPolicy=true|false (ALPHA - default=false)<br/>
ServiceLBNodePortControl=true|false (ALPHA - default=false)<br/>
ServiceLoadBalancerClass=true|false (ALPHA - default=false)<br/>
ServiceTopology=true|false (ALPHA - default=false)<br/>
SetHostnameAsFQDN=true|false (BETA - default=true)<br/>
SizeMemoryBackedVolumes=true|false (ALPHA - default=false)<br/>
StorageVersionAPI=true|false (ALPHA - default=false)<br/>
StorageVersionHash=true|false (BETA - default=true)<br/>
SuspendJob=true|false (ALPHA - default=false)<br/>
TTLAfterFinished=true|false (BETA - default=true)<br/>
TopologyAwareHints=true|false (ALPHA - default=false)<br/>
TopologyManager=true|false (BETA - default=true)<br/>
ValidateProxyRedirects=true|false (BETA - default=true)<br/>
VolumeCapacityPriority=true|false (ALPHA - default=false)<br/>
WarningHeaders=true|false (BETA - default=true)<br/>
WinDSR=true|false (ALPHA - default=false)<br/>
WinOverlay=true|false (BETA - default=true)<br/>
WindowsEndpointSliceProxying=true|false (BETA - default=true)
-->
一组键=值（key=value）对，描述了 alpha/experimental 的特征。可选项有：
APIListChunking=true|false (BETA - 默认值=true)<br/>
APIPriorityAndFairness=true|false (BETA - 默认值=true)<br/>
APIResponseCompression=true|false (BETA - 默认值=true)<br/>
APIServerIdentity=true|false (ALPHA - 默认值=false)<br/>
AllAlpha=true|false (ALPHA - 默认值=false)<br/>
AllBeta=true|false (BETA - 默认值=false)<br/>
AnyVolumeDataSource=true|false (ALPHA - 默认值=false)<br/>
AppArmor=true|false (BETA - 默认值=true)<br/>
BalanceAttachedNodeVolumes=true|false (ALPHA - 默认值=false)<br/>
BoundServiceAccountTokenVolume=true|false (BETA - 默认值=true)<br/>
CPUManager=true|false (BETA - 默认值=true)<br/>
CSIInlineVolume=true|false (BETA - 默认值=true)<br/>
CSIMigration=true|false (BETA - 默认值=true)<br/>
CSIMigrationAWS=true|false (BETA - 默认值=false)<br/>
CSIMigrationAzureDisk=true|false (BETA - 默认值=false)<br/>
CSIMigrationAzureFile=true|false (BETA - 默认值=false)<br/>
CSIMigrationGCE=true|false (BETA - 默认值=false)<br/>
CSIMigrationOpenStack=true|false (BETA - 默认值=true)<br/>
CSIMigrationvSphere=true|false (BETA - 默认值=false)<br/>
CSIMigrationvSphereComplete=true|false (BETA - 默认值=false)<br/>
CSIServiceAccountToken=true|false (BETA - 默认值=true)<br/>
CSIStorageCapacity=true|false (BETA - 默认值=true)<br/>
CSIVolumeFSGroupPolicy=true|false (BETA - 默认值=true)<br/>
CSIVolumeHealth=true|false (ALPHA - 默认值=false)<br/>
ConfigurableFSGroupPolicy=true|false (BETA - 默认值=true)<br/>
ControllerManagerLeaderMigration=true|false (ALPHA - 默认值=false)<br/>
CronJobControllerV2=true|false (BETA - 默认值=true)<br/>
CustomCPUCFSQuotaPeriod=true|false (ALPHA - 默认值=false)<br/>
DaemonSetUpdateSurge=true|false (ALPHA - 默认值=false)<br/>
DefaultPodTopologySpread=true|false (BETA - 默认值=true)<br/>
DevicePlugins=true|false (BETA - 默认值=true)<br/>
DisableAcceleratorUsageMetrics=true|false (BETA - 默认值=true)<br/>
DownwardAPIHugePages=true|false (BETA - 默认值=false)<br/>
DynamicKubeletConfig=true|false (BETA - 默认值=true)<br/>
EfficientWatchResumption=true|false (BETA - 默认值=true)<br/>
EndpointSliceProxying=true|false (BETA - 默认值=true)<br/>
EndpointSliceTerminatingCondition=true|false (ALPHA - 默认值=false)<br/>
EphemeralContainers=true|false (ALPHA - 默认值=false)<br/>
ExpandCSIVolumes=true|false (BETA - 默认值=true)<br/>
ExpandInUsePersistentVolumes=true|false (BETA - 默认值=true)<br/>
ExpandPersistentVolumes=true|false (BETA - 默认值=true)<br/>
ExperimentalHostUserNamespaceDefaulting=true|false (BETA - 默认值=false)<br/>
GenericEphemeralVolume=true|false (BETA - 默认值=true)<br/>
GracefulNodeShutdown=true|false (BETA - 默认值=true)<br/>
HPAContainerMetrics=true|false (ALPHA - 默认值=false)<br/>
HPAScaleToZero=true|false (ALPHA - 默认值=false)<br/>
HugePageStorageMediumSize=true|false (BETA - 默认值=true)<br/>
IPv6DualStack=true|false (BETA - 默认值=true)<br/>
InTreePluginAWSUnregister=true|false (ALPHA - 默认值=false)<br/>
InTreePluginAzureDiskUnregister=true|false (ALPHA - 默认值=false)<br/>
InTreePluginAzureFileUnregister=true|false (ALPHA - 默认值=false)<br/>
InTreePluginGCEUnregister=true|false (ALPHA - 默认值=false)<br/>
InTreePluginOpenStackUnregister=true|false (ALPHA - 默认值=false)<br/>
InTreePluginvSphereUnregister=true|false (ALPHA - 默认值=false)<br/>
IndexedJob=true|false (ALPHA - 默认值=false)<br/>
IngressClassNamespacedParams=true|false (ALPHA - 默认值=false)<br/>
KubeletCredentialProviders=true|false (ALPHA - 默认值=false)<br/>
KubeletPodResources=true|false (BETA - 默认值=true)<br/>
KubeletPodResourcesGetAllocatable=true|false (ALPHA - 默认值=false)<br/>
LocalStorageCapacityIsolation=true|false (BETA - 默认值=true)<br/>
LocalStorageCapacityIsolationFSQuotaMonitoring=true|false (ALPHA - 默认值=false)<br/>
LogarithmicScaleDown=true|false (ALPHA - 默认值=false)<br/>
MemoryManager=true|false (ALPHA - 默认值=false)<br/>
MixedProtocolLBService=true|false (ALPHA - 默认值=false)<br/>
NamespaceDefaultLabelName=true|false (BETA - 默认值=true)<br/>
NetworkPolicyEndPort=true|false (ALPHA - 默认值=false)<br/>
NonPreemptingPriority=true|false (BETA - 默认值=true)<br/>
PodAffinityNamespaceSelector=true|false (ALPHA - 默认值=false)<br/>
PodDeletionCost=true|false (ALPHA - 默认值=false)<br/>
PodOverhead=true|false (BETA - 默认值=true)<br/>
PreferNominatedNode=true|false (ALPHA - 默认值=false)<br/>
ProbeTerminationGracePeriod=true|false (ALPHA - 默认值=false)<br/>
ProcMountType=true|false (ALPHA - 默认值=false)<br/>
QOSReserved=true|false (ALPHA - 默认值=false)<br/>
RemainingItemCount=true|false (BETA - 默认值=true)<br/>
RemoveSelfLink=true|false (BETA - 默认值=true)<br/>
RotateKubeletServerCertificate=true|false (BETA - 默认值=true)<br/>
ServerSideApply=true|false (BETA - 默认值=true)<br/>
ServiceInternalTrafficPolicy=true|false (ALPHA - 默认值=false)<br/>
ServiceLBNodePortControl=true|false (ALPHA - 默认值=false)<br/>
ServiceLoadBalancerClass=true|false (ALPHA - 默认值=false)<br/>
ServiceTopology=true|false (ALPHA - 默认值=false)<br/>
SetHostnameAsFQDN=true|false (BETA - 默认值=true)<br/>
SizeMemoryBackedVolumes=true|false (ALPHA - 默认值=false)<br/>
StorageVersionAPI=true|false (ALPHA - 默认值=false)<br/>
StorageVersionHash=true|false (BETA - 默认值=true)<br/>
SuspendJob=true|false (ALPHA - 默认值=false)<br/>
TTLAfterFinished=true|false (BETA - 默认值=true)<br/>
TopologyAwareHints=true|false (ALPHA - 默认值=false)<br/>
TopologyManager=true|false (BETA - 默认值=true)<br/>
ValidateProxyRedirects=true|false (BETA - 默认值=true)<br/>
VolumeCapacityPriority=true|false (ALPHA - 默认值=false)<br/>
WarningHeaders=true|false (BETA - 默认值=true)<br/>
WinDSR=true|false (ALPHA - 默认值=false)<br/>
WinOverlay=true|false (BETA - 默认值=true)<br/>
WindowsEndpointSliceProxying=true|false (BETA - 默认值=true)
</p>
</td>
</tr>
<tr>
<td colspan="2">--healthz-bind-address 0.0.0.0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值：<code>0.0.0.0:10256</code></td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;"><p>
<!--  
The IP address with port for the health check server to serve on 
(set to '0.0.0.0:10256' for all IPv4 interfaces and '[::]:10256' for all IPv6 interfaces). 
Set empty to disable.
-->
服务健康状态检查的 IP 地址和端口（设置为 '0.0.0.0:10256' 表示使用所有
IPv4 接口，设置为 '[::]:10256' 表示使用所有 IPv6 接口）；
设置为空则禁用。
</p>
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;"><p>
<!--
help for kube-proxy
-->
kube-proxy 操作的帮助命令。
</p>
</td>
</tr>
<tr>
<td colspan="2">--hostname-override string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;"><p>
<!--
If non-empty, will use this string as identification instead of the actual hostname.
-->
如果非空，将使用此字符串而不是实际的主机名作为标识。
</p>
</td>
</tr>
<tr>
<td colspan="2">--iptables-masquerade-bit int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值：14</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;"><p>
<!--
If using the pure iptables proxy, the bit of the fwmark space to mark packets requiring SNAT with.  Must be within the range [0, 31].
-->
在使用纯 iptables 代理时，用来设置 fwmark 空间的 bit，标记需要
SNAT 的数据包。必须在 [0,31] 范围内。
</p>
</td>
</tr>
<tr>
<td colspan="2">--iptables-min-sync-period duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值：1s</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;"><p>
<!--
The minimum interval of how often the iptables rules can be refreshed as endpoints and services change (e.g. '5s', '1m', '2h22m').
-->
iptables 规则可以随着端点和服务的更改而刷新的最小间隔（例如 '5s'、'1m'、'2h22m'）。
</p>
</td>
</tr>
<tr>
<td colspan="2">--iptables-sync-period duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值：30s</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;"><p>
<!--
The maximum interval of how often iptables rules are refreshed (e.g. '5s', '1m', '2h22m').  Must be greater than 0.
-->
刷新 iptables 规则的最大间隔（例如 '5s'、'1m'、'2h22m'）。必须大于 0。
</p>
</td>
</tr>
<tr>
<td colspan="2">--ipvs-exclude-cidrs strings</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;"><p>
<!--
A comma-separated list of CIDR's which the ipvs proxier should not touch when cleaning up IPVS rules.
-->
逗号分隔的 CIDR 列表，ipvs 代理在清理 IPVS 规则时不会此列表中的地址范围。
</p>
</td>
</tr>
<tr>
<td colspan="2">--ipvs-min-sync-period duration</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;"><p>
<!--
The minimum interval of how often the ipvs rules can be refreshed as endpoints and services change (e.g. '5s', '1m', '2h22m').
-->
ipvs 规则可以随着端点和服务的更改而刷新的最小间隔（例如 '5s'、'1m'、'2h22m'）。
</p>
</td>
</tr>
<tr>
<td colspan="2">--ipvs-scheduler string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;"><p>
<!--
The ipvs scheduler type when proxy mode is ipvs
-->
代理模式为 ipvs 时所选的 ipvs 调度器类型。
</p>
</td>
</tr>
<tr>
<td colspan="2">--ipvs-strict-arp</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;"><p>
<!--
Enable strict ARP by setting arp_ignore to 1 and arp_announce to 2
-->
通过将 <code>arp_ignore</code> 设置为 1 并将 <code>arp_announce</code>
设置为 2 启用严格的 ARP。
</p>
</td>
</tr>
<tr>
<td colspan="2">--ipvs-sync-period duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值：30s</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;"><p>
<!--
The maximum interval of how often ipvs rules are refreshed (e.g. '5s', '1m', '2h22m').  Must be greater than 0.
-->
刷新 ipvs 规则的最大间隔（例如 '5s'、'1m'、'2h22m'）。必须大于 0。
</p>
</td>
</tr>
<tr>
<td colspan="2">--ipvs-tcp-timeout duration</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;"><p>
<!--  
The timeout for idle IPVS TCP connections, 0 to leave as-is. (e.g. '5s', '1m', '2h22m').
-->
空闲 IPVS TCP 连接的超时时间，0 保持连接（例如 '5s'、'1m'、'2h22m'）。
</p>
</td>
</tr>
<tr>
<td colspan="2">--ipvs-tcpfin-timeout duration</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;"><p>
<!--  
The timeout for IPVS TCP connections after receiving a FIN packet, 0 to leave as-is. (e.g. '5s', '1m', '2h22m').
-->
收到 FIN 数据包后，IPVS TCP 连接的超时，0 保持当前设置不变。（例如 '5s'、'1m'、'2h22m'）。
</p>
</td>
</tr>
<tr>
<td colspan="2">--ipvs-udp-timeout duration</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;"><p>
<!--  
The timeout for IPVS UDP packets, 0 to leave as-is. (e.g. '5s', '1m', '2h22m').
-->
IPVS UDP 数据包的超时，0 保持当前设置不变。（例如 '5s'、'1m'、'2h22m'）。
</p>
</td>
</tr>
<tr>
<td colspan="2">--kube-api-burst int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值：10</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;"><p>
<!--
Burst to use while talking with kubernetes apiserver
-->
与 kubernetes apiserver 通信的突发数量。
</p>
</td>
</tr>
<tr>
<td colspan="2">--kube-api-content-type string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值："application/vnd.kubernetes.protobuf"</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;"><p>
<!--
Content type of requests sent to apiserver.
-->
发送到 apiserver 的请求的内容类型。
</p>
</td>
</tr>
<tr>
<td colspan="2">--kube-api-qps float32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值：5</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;"><p>
<!--
QPS to use while talking with kubernetes apiserver
-->
与 kubernetes apiserver 交互时使用的 QPS。
</p>
</td>
</tr>
<tr>
<td colspan="2">--kubeconfig string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;"><p>
<!--
Path to kubeconfig file with authorization information (the master location is set by the master flag).
-->
包含鉴权信息的 kubeconfig 文件的路径（主控节点位置由 master 标志设置）。
</p>
</td>
</tr>
<tr>
<td colspan="2">--log-backtrace-at &lt;<!--a string in the form 'file:N'-->形式为 'file:N' 的字符串&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: :0</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;"><p>
<!--
when logging hits line file:N, emit a stack trace
-->
当日志逻辑执行到文件 file 的第 N 行时，输出调用堆栈跟踪。
</p></td>
</tr>
<tr>
<td colspan="2">--log-dir string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;"><p>
<!--
If non-empty, write log files in this directory
-->
若此标志费控，则将日志文件写入到此标志所给的目录下。
</p>
</td>
</tr>
<tr>
<td colspan="2">--log-file string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;"><p>
<!--
If non-empty, use this log file
-->
若此标志非空，则该字符串作为日志文件名。
</p></td>
</tr>
<tr>
<td colspan="2">--log-file-max-size uint&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值：1800</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;"><p>
<!--
Defines the maximum size a log file can grow to. Unit is megabytes. If the value is 0, the maximum file size is unlimited.
-->
定义日志文件可增长到的最大尺寸。单位是兆字节（MB）。
如果此值为 0，则最大文件大小无限制。
</p></td>
</tr>
<tr>
<td colspan="2">--log-flush-frequency duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值：5s
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Maximum number of seconds between log flushes
-->
两次日志刷新之间的最大秒数。
</td>
</tr>
<tr>
<td colspan="2">--machine-id-file string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值："/etc/machine-id,/var/lib/dbus/machine-id"</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;"><p>
<!--
Comma-separated list of files to check for machine-id. Use the first one that exists.
-->
用来检查 Machine-ID 的文件列表，用逗号分隔。
使用找到的第一个文件。
</p></td>
</tr>
<tr>
<td colspan="2">--masquerade-all</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;"><p>
<!--
If using the pure iptables proxy, SNAT all traffic sent via Service cluster IPs (this not commonly needed)
-->
如果使用纯 iptables 代理，则对通过服务集群 IP 发送的所有流量
进行 SNAT（通常不需要）。
</p>
</td>
</tr>
<tr>
<td colspan="2">--master string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;"><p>
<!--
The address of the Kubernetes API server (overrides any value in kubeconfig)
-->
Kubernetes API 服务器的地址（覆盖 kubeconfig 中的相关值）。
</p>
</td>
</tr>
<tr>
<td colspan="2">--metrics-bind-address ipport&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值：<code>127.0.0.1:10249</code></td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;"><p>
<!--
The IP address with port for the metrics server to serve on 
(set to '0.0.0.0:10249' for all IPv4 interfaces and '[::]:10249' for all IPv6 interfaces). 
Set empty to disable.
-->
metrics 服务器要使用的 IP 地址和端口
（设置为 '0.0.0.0:10249' 则使用所有 IPv4 接口，设置为 '[::]:10249' 则使用所有 IPv6 接口）
设置为空则禁用。
</p>
</td>
</tr>
<tr>
<td colspan="2">--nodeport-addresses strings</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;"><p>
<!--
A string slice of values which specify the addresses to use for NodePorts. Values may be valid IP blocks (e.g. 1.2.3.0/24, 1.2.3.4/32). The default empty string slice ([]) means to use all local addresses.
-->
一个字符串值，指定用于 NodePort 服务的地址。
值可以是有效的 IP 块（例如 1.2.3.0/24, 1.2.3.4/32）。
默认的空字符串切片（[]）表示使用所有本地地址。
</p>
</td>
</tr>
<tr>
<td colspan="2">--one-output</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;"><p>
<!--
If true, only write logs to their native severity level (vs also writing to each lower severity level)
-->
若此标志为 true，则仅将日志写入到其原本的严重性级别之下
（而不是将其写入到所有更低严重性级别中）。
</p></td>
</tr>
<tr>
<td colspan="2">--oom-score-adj int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值：-999</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;"><p>
<!--
The oom-score-adj value for kube-proxy process. Values must be within the range [-1000, 1000]
-->
kube-proxy 进程中的 oom-score-adj 值，必须在 [-1000,1000] 范围内。
</p>
</td>
</tr>
<tr>
<td colspan="2">--profiling</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;"><p>
<!--
If true enables profiling via web interface on /debug/pprof handler.
-->
如果为 true，则通过 Web 接口 <code>/debug/pprof</code> 启用性能分析。
</p>
</td>
</tr>
<tr>
<td colspan="2">--proxy-mode string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;"><p>
<!--
Which proxy mode to use: 'userspace' (older) or 'iptables' (faster) or 'ipvs'. If blank, use the best-available proxy (currently iptables).  If the iptables proxy is selected, regardless of how, but the system's kernel or iptables versions are insufficient, this always falls back to the userspace proxy.
-->
使用哪种代理模式：'userspace'（较旧）或 'iptables'（较快）或 'ipvs'。
如果为空，使用最佳可用代理（当前为 iptables）。
如果选择了 iptables 代理（无论是否为显式设置），但系统的内核或
iptables 版本较低，总是会回退到 userspace 代理。
</p>
</td>
</tr>
<tr>
<td colspan="2">--proxy-port-range port-range</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;"><p>
<!--
Range of host ports (beginPort-endPort, single port or beginPort+offset, inclusive) that may be consumed in order to proxy service traffic. If (unspecified, 0, or 0-0) then ports will be randomly chosen.
-->
可以用来代理服务流量的主机端口范围（包括'起始端口-结束端口'、
'单个端口'、'起始端口+偏移'几种形式）。
如果未指定或者设置为 0（或 0-0），则随机选择端口。
</p>
</td>
</tr>
<tr>
<td colspan="2">--show-hidden-metrics-for-version string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;"><p>
<!--  
The previous version for which you want to show hidden metrics. Only the previous minor version is meaningful, other values will not be allowed. The format is &lt;major&gt;.&lt;minor&gt;, e.g.: '1.16'. The purpose of this format is make sure you have the opportunity to notice if the next release hides additional metrics, rather than being surprised when they are permanently removed in the release after that.
-->
要显示隐藏指标的先前版本。 
仅先前的次要版本有意义，不允许其他值。
格式为 &lt;major&gt;.&lt;minor&gt; ，例如：'1.16'。 
这种格式的目的是确保你有机会注意到下一个发行版是否隐藏了其他指标，
而不是在之后将其永久删除时感到惊讶。
</p>
</td>
</tr>
<tr>
<td colspan="2">--skip-headers</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;"><p>
<!--
If true, avoid header prefixes in the log messages
-->
若此标志为 true，则避免在日志消息中包含头部前缀。
</p></td>
</tr>
<tr>
<td colspan="2">--skip-log-headers</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;"><p>
<!--
If true, avoid headers when opening log files
-->
如果此标志为 true，则避免在打开日志文件时使用头部。
</p></td>
</tr>
<tr>
<td colspan="2">--stderrthreshold int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值：2</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;"><p>
<!--
logs at or above this threshold go to stderr
-->
如果日志消息处于或者高于此阈值所设置的级别，则将其输出到标准错误输出（stderr）。
</p></td>
</tr>
<tr>
<td colspan="2">--udp-timeout duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值：250ms</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;"><p>
<!--
How long an idle UDP connection will be kept open (e.g. '250ms', '2s').  Must be greater than 0. Only applicable for proxy-mode=userspace
-->
空闲 UDP 连接将保持打开的时长（例如 '250ms'，'2s'）。必须大于 0。
仅适用于 proxy-mode=userspace。
</p>
</td>
</tr>
<tr>
<td colspan="2">-v, --v int</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;"><p>
<!--
number for the log level verbosity
-->
用来设置日志详细程度的数值。
</p></td>
</tr>
<tr>
<td colspan="2">--version version[=true]</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;"><p>
<!--
Print version information and quit
-->
打印版本信息并退出。
</p>
</td>
</tr>
<tr>
<td colspan="2">--vmodule &lt;<!--comma-separated 'pattern=N' settings-->逗号分隔的 'pattern=N' 设置’&gt;</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;"><p>
<!--
comma-separated list of pattern=N settings for file-filtered logging
-->
用逗号分隔的列表，其中每一项为 'pattern=N' 格式。
用来支持基于文件过滤的日志机制。
</p></td>
</tr>
<tr>
<td colspan="2">--write-config-to string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;"><p>
<!--
If set, write the default configuration values to this file and exit.
-->
如果设置，将默认配置信息写入此文件并退出。
</p>
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-57e59e5ddd9db63da6c9d27cc0e2f254">9.6 - kube-scheduler</h1>
    
	<!-- 
title: kube-scheduler
content_type: tool-reference
weight: 30
auto_generated: true
-->
<h2 id="简介">简介</h2>
<!-- 
The Kubernetes scheduler is a control plane process which assigns
Pods to Nodes. The scheduler determines which Nodes are valid placements for
each Pod in the scheduling queue according to constraints and available
resources. The scheduler then ranks each valid Node and binds the Pod to a
suitable Node. Multiple different schedulers may be used within a cluster;
kube-scheduler is the reference implementation.
See [scheduling](/docs/concepts/scheduling-eviction/)
for more information about scheduling and the kube-scheduler component.
-->
<p>Kubernetes 调度器是一个控制面进程，负责将 Pods 指派到节点上。
调度器基于约束和可用资源为调度队列中每个 Pod 确定其可合法放置的节点。
调度器之后对所有合法的节点进行排序，将 Pod 绑定到一个合适的节点。
在同一个集群中可以使用多个不同的调度器；kube-scheduler 是其参考实现。
参阅<a href="/zh/docs/concepts/scheduling-eviction/">调度</a>
以获得关于调度和 kube-scheduler 组件的更多信息。</p>
<pre tabindex="0"><code>kube-scheduler [flags]
</code></pre><h2 id="选项">选项</h2>
<table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--add-dir-header</td>
</tr>
<tr><td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- 
If true, adds the file directory to the header of the log messages
-->
如果为 true，则将文件目录添加到日志消息的头部
</td>
</tr>
<tr><td colspan="2">--address string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值："0.0.0.0"</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- 
DEPRECATED: the IP address on which to listen for the --port port (set to 0.0.0.0 or :: for listening in all interfaces and IP families). See --bind-address instead. This parameter is ignored if a config file is specified in --config.
-->
已弃用： 要监听 --port 端口的 IP 地址（将其设置为 0.0.0.0 或者 :: 用于监听所有接口和 IP族）。 
请参阅 --bind-address。
如果在 --config 中指定了一个配置文件，这个参数将被忽略。
</td>
</tr>
<tr>
<td colspan="2">--algorithm-provider string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
DEPRECATED: the scheduling algorithm provider to use, this sets the default plugins for component config profiles. Choose one of: ClusterAutoscalerProvider | DefaultProvider
-->
已弃用： 要使用的调度算法驱动，此标志设置组件配置框架的默认插件。
可选值：ClusterAutoscalerProvider | DefaultProvider
</td>
</tr>
<tr>
<td colspan="2">--allow-metric-labels stringToString&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<!--Default-->默认值： []</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The map from metric-label to value allow-list of this label. The key's format is &lt;MetricName&gt;,&lt;LabelName&gt;. The value's format is &lt;allowed_value&gt;,&lt;allowed_value&gt;...e.g. metric1,label1='v1,v2,v3', metric1,label2='v1,v2,v3' metric2,label1='v1,v2,v3'.
-->
这个键值映射表设置 度量标签 所允许设置的值。
其中键的格式是 &lt;MetricName&gt;,&lt;LabelName&gt;。
值的格式是 &lt;allowed_value&gt;,&lt;allowed_value&gt;。
例如：metric1,label1='v1,v2,v3', metric1,label2='v1,v2,v3' metric2,label1='v1,v2,v3'。
</td>
</tr>
<tr>
<td colspan="2">--alsologtostderr</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
log to standard error as well as files
-->
日志记录到标准错误以及文件
</td>
</tr>
<tr>
<td colspan="2">--authentication-kubeconfig string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
kubeconfig file pointing at the 'core' kubernetes server with enough rights to create tokenreviews.authentication.k8s.io. This is optional. If empty, all token requests are considered to be anonymous and no client CA is looked up in the cluster.
-->
指向具有足够权限以创建 <code>tokenaccessreviews.authentication.k8s.io</code> 的
Kubernetes 核心服务器的 kubeconfig 文件。
这是可选的。如果为空，则所有令牌请求均被视为匿名请求，并且不会在集群中查找任何客户端 CA。
</td>
</tr>
<tr>
<td colspan="2">--authentication-skip-lookup</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
If false, the authentication-kubeconfig will be used to lookup missing authentication configuration from the cluster.
-->
如果为 false，则 authentication-kubeconfig 将用于从集群中查找缺少的身份验证配置。
</td>
</tr>
<tr>
<td colspan="2">--authentication-token-webhook-cache-ttl duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值：10s</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The duration to cache responses from the webhook token authenticator.
-->
缓存来自 Webhook 令牌身份验证器的响应的持续时间。
</td>
</tr>
<tr>
<td colspan="2">--authentication-tolerate-lookup-failure&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值：true</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
If true, failures to look up missing authentication configuration from the cluster are not considered fatal. Note that this can result in authentication that treats all requests as anonymous.
-->
如果为 true，则无法从集群中查找缺少的身份验证配置是致命的。
请注意，这可能导致身份验证将所有请求视为匿名。
</td>
</tr>
<tr>
<td colspan="2">--authorization-always-allow-paths strings&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值："/healthz,/readyz,/livez"</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
A list of HTTP paths to skip during authorization, i.e. these are authorized without contacting the 'core' kubernetes server.
-->
在授权过程中跳过的 HTTP 路径列表，即在不联系 'core'  kubernetes 服务器的情况下被授权的 HTTP 路径。
</td>
</tr>
<tr>
<td colspan="2">--authorization-kubeconfig string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
kubeconfig file pointing at the 'core' kubernetes server with enough rights to create subjectaccessreviews.authorization.k8s.io. This is optional. If empty, all requests not skipped by authorization are forbidden.
-->
指向具有足够权限以创建 subjectaccessreviews.authorization.k8s.io 的
Kubernetes 核心服务器的 kubeconfig 文件。这是可选的。
如果为空，则所有未被鉴权机制略过的请求都会被禁止。
</td>
</tr>
<tr>
<td colspan="2">--authorization-webhook-cache-authorized-ttl duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值：10s</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The duration to cache 'authorized' responses from the webhook authorizer.
-->
缓存来自 Webhook 授权者的 'authorized' 响应的持续时间。
</td>
</tr>
<tr>
<td colspan="2">--authorization-webhook-cache-unauthorized-ttl duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值：10s</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The duration to cache 'unauthorized' responses from the webhook authorizer.
-->
缓存来自 Webhook 授权者的 'unauthorized' 响应的持续时间。
</td>
</tr>
<tr>
<td colspan="2">--azure-container-registry-config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to the file containing Azure container registry configuration information.
-->
包含 Azure 容器仓库配置信息的文件的路径。
</td>
</tr>
<tr>
<td colspan="2">--bind-address string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值：0.0.0.0</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The IP address on which to listen for the --secure-port port. The associated interface(s) must be reachable by the rest of the cluster, and by CLI/web clients. If blank or an unspecified address (0.0.0.0 or ::), all interfaces will be used.
-->
监听 --secure-port 端口的 IP 地址。
集群的其余部分以及 CLI/ Web 客户端必须可以访问关联的接口。
如果为空，将使用所有接口（0.0.0.0 表示使用所有 IPv4 接口，"::" 表示使用所有 IPv6 接口）。
如果为空或未指定地址 (0.0.0.0 或 ::)，所有接口将被使用。
</td>
</tr>
<tr>
<td colspan="2">--cert-dir string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The directory where the TLS certs are located. If --tls-cert-file and --tls-private-key-file are provided, this flag will be ignored.
-->
TLS 证书所在的目录。如果提供了--tls-cert-file 和 --tls private-key-file，
则将忽略此参数。
</td>
</tr>
<tr>
<td colspan="2">--client-ca-file string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
If set, any request presenting a client certificate signed by one of the authorities in the client-ca-file is authenticated with an identity corresponding to the CommonName of the client certificate.
-->
如果已设置，由 client-ca-file 中的证书机构签名的客户端证书的任何请求都将使用
与客户端证书的 CommonName 对应的身份进行身份验证。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The path to the configuration file. The following flags can overwrite fields in this file:<br/>
--algorithm-provider<br/>
--policy-config-file<br/>
--policy-configmap<br/>
--policy-configmap-namespace
-->
配置文件的路径。以下标志会覆盖此文件中的值：<br/>
--algorithm-provider<br/>
--policy-config-file<br/>
--policy-configmap<br/>
--policy-configmap-namespace
</td>
</tr>
<tr>
<td colspan="2">--contention-profiling&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default-->默认值: true</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
DEPRECATED: enable lock contention profiling, if profiling is enabled. This parameter is ignored if a config file is specified in --config.
-->
已弃用: 如果启用了性能分析，则启用锁竞争分析。
如果 --config 指定了一个配置文件，那么这个参数将被忽略。
</td>
</tr>
<tr>
<td colspan="2">--disabled-metrics strings</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
This flag provides an escape hatch for misbehaving metrics. You must provide the fully qualified metric name in order to disable it. Disclaimer: disabling metrics is higher in precedence than showing hidden metrics.
-->
这个标志提供了一个规避不良指标的选项。你必须提供完整的指标名称才能禁用它。
免责声明：禁用指标的优先级比显示隐藏的指标更高。
</td>
</tr>
<tr>
<td colspan="2">--experimental-logging-sanitization</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[Experimental] When enabled prevents logging of fields tagged as sensitive (passwords, keys, tokens).<br/>Runtime log sanitization may introduce significant computation overhead and therefore should not be enabled in production.
-->
[试验性功能] 当启用此标志时，标记为敏感的字段（密码、密钥、令牌）等不会被日志
输出。<br/>
运行时的日志清理操作可能引入相当程度的计算开销，因此不应在生产环境中启用。
</td>
</tr>
<tr>
<td colspan="2">--feature-gates &lt;<!--comma-separated 'key=True|False' pairs-->逗号分隔的 'key=True|False' 对&gt;</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
A set of key=value pairs that describe feature gates for alpha/experimental features. Options are:<br/>
APIListChunking=true|false (BETA - default=true)<br/>
APIPriorityAndFairness=true|false (BETA - default=true)<br/>
APIResponseCompression=true|false (BETA - default=true)<br/>
APIServerIdentity=true|false (ALPHA - default=false)<br/>
AllAlpha=true|false (ALPHA - default=false)<br/>
AllBeta=true|false (BETA - default=false)<br/>
AnyVolumeDataSource=true|false (ALPHA - default=false)<br/>
AppArmor=true|false (BETA - default=true)<br/>
BalanceAttachedNodeVolumes=true|false (ALPHA - default=false)<br/>
BoundServiceAccountTokenVolume=true|false (BETA - default=true)<br/>
CPUManager=true|false (BETA - default=true)<br/>
CSIInlineVolume=true|false (BETA - default=true)<br/>
CSIMigration=true|false (BETA - default=true)<br/>
CSIMigrationAWS=true|false (BETA - default=false)<br/>
CSIMigrationAzureDisk=true|false (BETA - default=false)<br/>
CSIMigrationAzureFile=true|false (BETA - default=false)<br/>
CSIMigrationGCE=true|false (BETA - default=false)<br/>
CSIMigrationOpenStack=true|false (BETA - default=true)<br/>
CSIMigrationvSphere=true|false (BETA - default=false)<br/>
CSIMigrationvSphereComplete=true|false (BETA - default=false)<br/>
CSIServiceAccountToken=true|false (BETA - default=true)<br/>
CSIStorageCapacity=true|false (BETA - default=true)<br/>
CSIVolumeFSGroupPolicy=true|false (BETA - default=true)<br/>
CSIVolumeHealth=true|false (ALPHA - default=false)<br/>
ConfigurableFSGroupPolicy=true|false (BETA - default=true)<br/>
ControllerManagerLeaderMigration=true|false (ALPHA - default=false)<br/>
CronJobControllerV2=true|false (BETA - default=true)<br/>
CustomCPUCFSQuotaPeriod=true|false (ALPHA - default=false)<br/>
DaemonSetUpdateSurge=true|false (ALPHA - default=false)<br/>
DefaultPodTopologySpread=true|false (BETA - default=true)<br/>
DevicePlugins=true|false (BETA - default=true)<br/>
DisableAcceleratorUsageMetrics=true|false (BETA - default=true)<br/>
DownwardAPIHugePages=true|false (BETA - default=false)<br/>
DynamicKubeletConfig=true|false (BETA - default=true)<br/>
EfficientWatchResumption=true|false (BETA - default=true)<br/>
EndpointSliceProxying=true|false (BETA - default=true)<br/>
EndpointSliceTerminatingCondition=true|false (ALPHA - default=false)<br/>
EphemeralContainers=true|false (ALPHA - default=false)<br/>
ExpandCSIVolumes=true|false (BETA - default=true)<br/>
ExpandInUsePersistentVolumes=true|false (BETA - default=true)<br/>
ExpandPersistentVolumes=true|false (BETA - default=true)<br/>
ExperimentalHostUserNamespaceDefaulting=true|false (BETA - default=false)<br/>
GenericEphemeralVolume=true|false (BETA - default=true)<br/>
GracefulNodeShutdown=true|false (BETA - default=true)<br/>
HPAContainerMetrics=true|false (ALPHA - default=false)<br/>
HPAScaleToZero=true|false (ALPHA - default=false)<br/>
HugePageStorageMediumSize=true|false (BETA - default=true)<br/>
IPv6DualStack=true|false (BETA - default=true)<br/>
InTreePluginAWSUnregister=true|false (ALPHA - default=false)<br/>
InTreePluginAzureDiskUnregister=true|false (ALPHA - default=false)<br/>
InTreePluginAzureFileUnregister=true|false (ALPHA - default=false)<br/>
InTreePluginGCEUnregister=true|false (ALPHA - default=false)<br/>
InTreePluginOpenStackUnregister=true|false (ALPHA - default=false)<br/>
InTreePluginvSphereUnregister=true|false (ALPHA - default=false)<br/>
IndexedJob=true|false (ALPHA - default=false)<br/>
IngressClassNamespacedParams=true|false (ALPHA - default=false)<br/>
KubeletCredentialProviders=true|false (ALPHA - default=false)<br/>
KubeletPodResources=true|false (BETA - default=true)<br/>
KubeletPodResourcesGetAllocatable=true|false (ALPHA - default=false)<br/>
LocalStorageCapacityIsolation=true|false (BETA - default=true)<br/>
LocalStorageCapacityIsolationFSQuotaMonitoring=true|false (ALPHA - default=false)<br/>
LogarithmicScaleDown=true|false (ALPHA - default=false)<br/>
MemoryManager=true|false (ALPHA - default=false)<br/>
MixedProtocolLBService=true|false (ALPHA - default=false)<br/>
NamespaceDefaultLabelName=true|false (BETA - default=true)<br/>
NetworkPolicyEndPort=true|false (ALPHA - default=false)<br/>
NonPreemptingPriority=true|false (BETA - default=true)<br/>
PodAffinityNamespaceSelector=true|false (ALPHA - default=false)<br/>
PodDeletionCost=true|false (ALPHA - default=false)<br/>
PodOverhead=true|false (BETA - default=true)<br/>
PreferNominatedNode=true|false (ALPHA - default=false)<br/>
ProbeTerminationGracePeriod=true|false (ALPHA - default=false)<br/>
ProcMountType=true|false (ALPHA - default=false)<br/>
QOSReserved=true|false (ALPHA - default=false)<br/>
RemainingItemCount=true|false (BETA - default=true)<br/>
RemoveSelfLink=true|false (BETA - default=true)<br/>
RotateKubeletServerCertificate=true|false (BETA - default=true)<br/>
ServerSideApply=true|false (BETA - default=true)<br/>
ServiceInternalTrafficPolicy=true|false (ALPHA - default=false)<br/>
ServiceLBNodePortControl=true|false (ALPHA - default=false)<br/>
ServiceLoadBalancerClass=true|false (ALPHA - default=false)<br/>
ServiceTopology=true|false (ALPHA - default=false)<br/>
SetHostnameAsFQDN=true|false (BETA - default=true)<br/>
SizeMemoryBackedVolumes=true|false (ALPHA - default=false)<br/>
StorageVersionAPI=true|false (ALPHA - default=false)<br/>
StorageVersionHash=true|false (BETA - default=true)<br/>
SuspendJob=true|false (ALPHA - default=false)<br/>
TTLAfterFinished=true|false (BETA - default=true)<br/>
TopologyAwareHints=true|false (ALPHA - default=false)<br/>
TopologyManager=true|false (BETA - default=true)<br/>
ValidateProxyRedirects=true|false (BETA - default=true)<br/>
VolumeCapacityPriority=true|false (ALPHA - default=false)<br/>
WarningHeaders=true|false (BETA - default=true)<br/>
WinDSR=true|false (ALPHA - default=false)<br/>
WinOverlay=true|false (BETA - default=true)<br/>
WindowsEndpointSliceProxying=true|false (BETA - default=true)
-->
一组 key=value 对，描述了 alpha/experimental 特征开关。选项包括：<br/>
A set of key=value pairs that describe feature gates for alpha/experimental features. Options are:<br/>
APIListChunking=true|false (BETA - 默认值=true)<br/>
APIPriorityAndFairness=true|false (BETA - 默认值=true)<br/>
APIResponseCompression=true|false (BETA - 默认值=true)<br/>
APIServerIdentity=true|false (ALPHA - 默认值=false)<br/>
AllAlpha=true|false (ALPHA - 默认值=false)<br/>
AllBeta=true|false (BETA - 默认值=false)<br/>
AnyVolumeDataSource=true|false (ALPHA - 默认值=false)<br/>
AppArmor=true|false (BETA - 默认值=true)<br/>
BalanceAttachedNodeVolumes=true|false (ALPHA - 默认值=false)<br/>
BoundServiceAccountTokenVolume=true|false (BETA - 默认值=true)<br/>
CPUManager=true|false (BETA - 默认值=true)<br/>
CSIInlineVolume=true|false (BETA - 默认值=true)<br/>
CSIMigration=true|false (BETA - 默认值=true)<br/>
CSIMigrationAWS=true|false (BETA - 默认值=false)<br/>
CSIMigrationAzureDisk=true|false (BETA - 默认值=false)<br/>
CSIMigrationAzureFile=true|false (BETA - 默认值=false)<br/>
CSIMigrationGCE=true|false (BETA - 默认值=false)<br/>
CSIMigrationOpenStack=true|false (BETA - 默认值=true)<br/>
CSIMigrationvSphere=true|false (BETA - 默认值=false)<br/>
CSIMigrationvSphereComplete=true|false (BETA - 默认值=false)<br/>
CSIServiceAccountToken=true|false (BETA - 默认值=true)<br/>
CSIStorageCapacity=true|false (BETA - 默认值=true)<br/>
CSIVolumeFSGroupPolicy=true|false (BETA - 默认值=true)<br/>
CSIVolumeHealth=true|false (ALPHA - 默认值=false)<br/>
ConfigurableFSGroupPolicy=true|false (BETA - 默认值=true)<br/>
ControllerManagerLeaderMigration=true|false (ALPHA - 默认值=false)<br/>
CronJobControllerV2=true|false (BETA - 默认值=true)<br/>
CustomCPUCFSQuotaPeriod=true|false (ALPHA - 默认值=false)<br/>
DaemonSetUpdateSurge=true|false (ALPHA - 默认值=false)<br/>
DefaultPodTopologySpread=true|false (BETA - 默认值=true)<br/>
DevicePlugins=true|false (BETA - 默认值=true)<br/>
DisableAcceleratorUsageMetrics=true|false (BETA - 默认值=true)<br/>
DownwardAPIHugePages=true|false (BETA - 默认值=false)<br/>
DynamicKubeletConfig=true|false (BETA - 默认值=true)<br/>
EfficientWatchResumption=true|false (BETA - 默认值=true)<br/>
EndpointSliceProxying=true|false (BETA - 默认值=true)<br/>
EndpointSliceTerminatingCondition=true|false (ALPHA - 默认值=false)<br/>
EphemeralContainers=true|false (ALPHA - 默认值=false)<br/>
ExpandCSIVolumes=true|false (BETA - 默认值=true)<br/>
ExpandInUsePersistentVolumes=true|false (BETA - 默认值=true)<br/>
ExpandPersistentVolumes=true|false (BETA - 默认值=true)<br/>
ExperimentalHostUserNamespaceDefaulting=true|false (BETA - 默认值=false)<br/>
GenericEphemeralVolume=true|false (BETA - 默认值=true)<br/>
GracefulNodeShutdown=true|false (BETA - 默认值=true)<br/>
HPAContainerMetrics=true|false (ALPHA - 默认值=false)<br/>
HPAScaleToZero=true|false (ALPHA - 默认值=false)<br/>
HugePageStorageMediumSize=true|false (BETA - 默认值=true)<br/>
IPv6DualStack=true|false (BETA - 默认值=true)<br/>
InTreePluginAWSUnregister=true|false (ALPHA - 默认值=false)<br/>
InTreePluginAzureDiskUnregister=true|false (ALPHA - 默认值=false)<br/>
InTreePluginAzureFileUnregister=true|false (ALPHA - 默认值=false)<br/>
InTreePluginGCEUnregister=true|false (ALPHA - 默认值=false)<br/>
InTreePluginOpenStackUnregister=true|false (ALPHA - 默认值=false)<br/>
InTreePluginvSphereUnregister=true|false (ALPHA - 默认值=false)<br/>
IndexedJob=true|false (ALPHA - 默认值=false)<br/>
IngressClassNamespacedParams=true|false (ALPHA - 默认值=false)<br/>
KubeletCredentialProviders=true|false (ALPHA - 默认值=false)<br/>
KubeletPodResources=true|false (BETA - 默认值=true)<br/>
KubeletPodResourcesGetAllocatable=true|false (ALPHA - 默认值=false)<br/>
LocalStorageCapacityIsolation=true|false (BETA - 默认值=true)<br/>
LocalStorageCapacityIsolationFSQuotaMonitoring=true|false (ALPHA - 默认值=false)<br/>
LogarithmicScaleDown=true|false (ALPHA - 默认值=false)<br/>
MemoryManager=true|false (ALPHA - 默认值=false)<br/>
MixedProtocolLBService=true|false (ALPHA - 默认值=false)<br/>
NamespaceDefaultLabelName=true|false (BETA - 默认值=true)<br/>
NetworkPolicyEndPort=true|false (ALPHA - 默认值=false)<br/>
NonPreemptingPriority=true|false (BETA - 默认值=true)<br/>
PodAffinityNamespaceSelector=true|false (ALPHA - 默认值=false)<br/>
PodDeletionCost=true|false (ALPHA - 默认值=false)<br/>
PodOverhead=true|false (BETA - 默认值=true)<br/>
PreferNominatedNode=true|false (ALPHA - 默认值=false)<br/>
ProbeTerminationGracePeriod=true|false (ALPHA - 默认值=false)<br/>
ProcMountType=true|false (ALPHA - 默认值=false)<br/>
QOSReserved=true|false (ALPHA - 默认值=false)<br/>
RemainingItemCount=true|false (BETA - 默认值=true)<br/>
RemoveSelfLink=true|false (BETA - 默认值=true)<br/>
RotateKubeletServerCertificate=true|false (BETA - 默认值=true)<br/>
ServerSideApply=true|false (BETA - 默认值=true)<br/>
ServiceInternalTrafficPolicy=true|false (ALPHA - 默认值=false)<br/>
ServiceLBNodePortControl=true|false (ALPHA - 默认值=false)<br/>
ServiceLoadBalancerClass=true|false (ALPHA - 默认值=false)<br/>
ServiceTopology=true|false (ALPHA - 默认值=false)<br/>
SetHostnameAsFQDN=true|false (BETA - 默认值=true)<br/>
SizeMemoryBackedVolumes=true|false (ALPHA - 默认值=false)<br/>
StorageVersionAPI=true|false (ALPHA - 默认值=false)<br/>
StorageVersionHash=true|false (BETA - 默认值=true)<br/>
SuspendJob=true|false (ALPHA - 默认值=false)<br/>
TTLAfterFinished=true|false (BETA - 默认值=true)<br/>
TopologyAwareHints=true|false (ALPHA - 默认值=false)<br/>
TopologyManager=true|false (BETA - 默认值=true)<br/>
ValidateProxyRedirects=true|false (BETA - 默认值=true)<br/>
VolumeCapacityPriority=true|false (ALPHA - 默认值=false)<br/>
WarningHeaders=true|false (BETA - 默认值=true)<br/>
WinDSR=true|false (ALPHA - 默认值=false)<br/>
WinOverlay=true|false (BETA - 默认值=true)<br/>
WindowsEndpointSliceProxying=true|false (BETA - 默认值=true)
</td>
</tr>
<tr>
<td colspan="2">--hard-pod-affinity-symmetric-weight int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值：1</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
DEPRECATED: RequiredDuringScheduling affinity is not symmetric, but there is an implicit PreferredDuringScheduling affinity rule corresponding to every RequiredDuringScheduling affinity rule. --hard-pod-affinity-symmetric-weight represents the weight of implicit PreferredDuringScheduling affinity rule. Must be in the range 0-100.This parameter is ignored if a config file is specified in --config.
-->
已弃用: RequiredDuringScheduling 亲和性是不对称的，但是存在与每个
RequiredDuringScheduling 关联性规则相对应的隐式 PreferredDuringScheduling 关联性规则。
<code>--hard-pod-affinity-symmetric-weight</code> 代表隐式 PreferredDuringScheduling
关联性规则的权重。权重必须在 0-100 范围内。
如果 --config 指定了一个配置文件，那么这个参数将被忽略。
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for kube-scheduler
-->
kube-scheduler 帮助命令
</td>
</tr>
<tr>
<td colspan="2">--http2-max-streams-per-connection int</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The limit that the server gives to clients for the maximum number of streams in an HTTP/2 connection. Zero means to use golang's default.
-->
服务器为客户端提供的 HTTP/2 连接最大限制。零表示使用 Golang 的默认值。
</td>
</tr>
<tr>
<td colspan="2">--kube-api-burst int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值：100</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
DEPRECATED: burst to use while talking with kubernetes apiserver. This parameter is ignored if a config file is specified in --config.
-->
已弃用: 与 kubernetes API 通信时使用的突发请求个数限值。
如果 --config 指定了一个配置文件，那么这个参数将被忽略。
</td>
</tr>
<tr>
<td colspan="2">--kube-api-content-type string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值："application/vnd.kubernetes.protobuf"</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
DEPRECATED: content type of requests sent to apiserver. This parameter is ignored if a config file is specified in --config.
-->
已弃用: 发送到 API 服务器的请求的内容类型。
如果 --config 指定了一个配置文件，那么这个参数将被忽略。
</td>
</tr>
<tr>
<td colspan="2">--kube-api-qps float32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值：50</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
DEPRECATED: QPS to use while talking with kubernetes apiserver. This parameter is ignored if a config file is specified in --config.
-->
已弃用: 与 kubernetes apiserver 通信时要使用的 QPS
如果 --config 指定了一个配置文件，那么这个参数将被忽略。
</td>
</tr>
<tr>
<td colspan="2">--kubeconfig string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
DEPRECATED: path to kubeconfig file with authorization and master location information. This parameter is ignored if a config file is specified in --config.
-->
已弃用: 包含鉴权和主节点位置信息的 kubeconfig 文件的路径。
如果 --config 指定了一个配置文件，那么这个参数将被忽略。
</td>
</tr>
<tr>
<td colspan="2">--leader-elect&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值：true</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Start a leader election client and gain leadership before executing the main loop. Enable this when running replicated components for high availability.
-->
在执行主循环之前，开始领导者选举并选出领导者。
使用多副本来实现高可用性时，可启用此标志。
</td>
</tr>
<tr>
<td colspan="2">--leader-elect-lease-duration duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值：15s</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The duration that non-leader candidates will wait after observing a leadership renewal until attempting to acquire leadership of a led but unrenewed leader slot. This is effectively the maximum duration that a leader can be stopped before it is replaced by another candidate. This is only applicable if leader election is enabled.
-->
非领导者候选人在观察到领导者更新后将等待直到试图获得领导但未更新的领导者职位的等待时间。
这实际上是领导者在被另一位候选人替代之前可以停止的最大持续时间。
该情况仅在启用了领导者选举的情况下才适用。
</td>
</tr>
<tr>
<td colspan="2">--leader-elect-renew-deadline duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值：10s</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The interval between attempts by the acting master to renew a leadership slot before it stops leading. This must be less than or equal to the lease duration. This is only applicable if leader election is enabled.
-->
领导者尝试在停止领导之前更新领导职位的间隔时间。该时间必须小于或等于租赁期限。
仅在启用了领导者选举的情况下才适用。
</td>
</tr>
<tr>
<td colspan="2">--leader-elect-resource-lock string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值："leases"</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The type of resource object that is used for locking during leader election. Supported options are 'endpoints', 'configmaps', 'leases', 'endpointsleases' and 'configmapsleases'.
-->
在领导者选举期间用于锁定的资源对象的类型。支持的选项是 `endpoints`、
`configmaps`、`leases`、`endpointleases` 和 `configmapsleases`。
</td>
</tr>
<tr>
<td colspan="2">--leader-elect-resource-name string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值："kube-scheduler"</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The name of resource object that is used for locking during leader election.
-->
在领导者选举期间用于锁定的资源对象的名称。
</td>
</tr>
<tr>
<td colspan="2">--leader-elect-resource-namespace string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值："kube-system"</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The namespace of resource object that is used for locking during leader election.
-->
在领导者选举期间用于锁定的资源对象的命名空间。
</td>
</tr>
<tr>
<td colspan="2">--leader-elect-retry-period duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值：2s
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The duration the clients should wait between attempting acquisition and renewal of a leadership. This is only applicable if leader election is enabled.
-->
客户应在尝试获取和更新领导之间等待的时间。仅在启用了领导者选举的情况下才适用。
</td>
</tr>
<tr>
<td colspan="2">--lock-object-name string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值："kube-scheduler"</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
DEPRECATED: define the name of the lock object. Will be removed in favor of leader-elect-resource-name. This parameter is ignored if a config file is specified in --config.
-->
已弃用: 定义锁对象的名称。将被删除以便使用 <code>--leader-elect-resource-name</code>。
如果 --config 指定了一个配置文件，那么这个参数将被忽略。
</td>
</tr>
<tr>
<td colspan="2">--lock-object-namespace string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值："kube-system"</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
DEPRECATED: define the namespace of the lock object. Will be removed in favor of leader-elect-resource-namespace. This parameter is ignored if a config file is specified in --config.
-->
已弃用: 定义锁对象的命名空间。将被删除以便使用 <code>leader-elect-resource-namespace</code>。
如果 --config 指定了一个配置文件，那么这个参数将被忽略。
</td>
</tr>
<tr>
<td colspan="2">--log-backtrace-at &lt;a string in the form 'file:N'&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<!--Default:-->默认值: 0</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
when logging hits line file:N, emit a stack trace
-->
当记录命中行文件 <code>file</code> 的第 <code>N</code> 行时输出堆栈跟踪。
</td>
</tr>
<tr>
<td colspan="2">--log-dir string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
If non-empty, write log files in this directory
-->
如果为非空，则在此目录中写入日志文件。
</td>
</tr>
<tr>
<td colspan="2">--log-file string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
If non-empty, use this log file
-->
如果为非空，则使用此文件作为日志文件。
</td>
</tr>
<tr>
<td colspan="2">--log-file-max-size uint&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值：1800</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Defines the maximum size a log file can grow to. Unit is megabytes. If the value is 0, the maximum file size is unlimited.
-->
定义日志文件可以增长到的最大值。单位为兆字节。
如果值为 0，则最大文件大小为无限制。
</td>
</tr>
<tr>
<td colspan="2">--log-flush-frequency duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值：5s</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Maximum number of seconds between log flushes
-->
两次日志刷新之间的最大秒数。
</td>
</tr>
<tr>
<td colspan="2">--logging-format string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值：“text”</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Sets the log format. Permitted formats: &quot;json&quot;, &quot;text&quot;.<br/>
Non-default formats don't honor these flags: --add-dir-header, --alsologtostderr, --log-backtrace-at, 
--log-dir, --log-file, --log-file-max-size, 
--logtostderr, --one-output, --skip-headers, --skip-log-headers, 
--stderrthreshold, --vmodule, --log-flush-frequency.<br/>
Non-default choices are currently alpha and subject to change without warning.
-->
设置日志格式。可选格式：“json”，“text”。<br/>
采用非默认格式时，以下标识不会生效：
--add-dir-header, --alsologtostderr, --log-backtrace-at, 
--log-dir, --log-file, --log-file-max-size, 
--logtostderr, --one-output, --skip-headers, --skip-log-headers, 
--stderrthreshold, --vmodule, --log-flush-frequency.<br/>
非默认选项目前处于 Alpha 阶段，有可能会出现变更且无事先警告。
</td>
</tr>
<tr>
<td colspan="2">--logtostderr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值：true</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
log to standard error instead of files
-->
日志记录到标准错误输出而不是文件。
</td>
</tr>
<tr>
<td colspan="2">--master string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The address of the Kubernetes API server (overrides any value in kubeconfig)
-->
Kubernetes API 服务器的地址（覆盖 kubeconfig 中的任何值）。
</td>
</tr>
<tr>
<td colspan="2">--one-output</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
If true, only write logs to their native severity level (vs also writing to each lower severity level)
-->
若此标志为 true，则日志仅写入其自身的严重性级别，而不会写入所有较低严重性级别。
</td>
</tr>
<tr>
<td colspan="2">--permit-address-sharing</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
If true, SO_REUSEADDR will be used when binding the port. This allows binding to wildcard IPs like 0.0.0.0 and specific IPs in parallel, and it avoids waiting for the kernel to release sockets in TIME_WAIT state. [default=false]
-->
如果为 true，在绑定端口时将使用 SO_REUSEADDR。
这将允许同时绑定诸如 0.0.0.0 这类通配符 IP和特定 IP，
并且它避免等待内核释放处于 TIME_WAIT 状态的套接字。
默认值： false
</td>
</tr>
<tr>
<td colspan="2">--permit-port-sharing</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
If true, SO_REUSEPORT will be used when binding the port, which allows more than one instance to bind on the same address and port. [default=false]
-->
如果此标志为 true，在绑定端口时会使用 SO_REUSEPORT，从而允许不止一个
实例绑定到同一地址和端口。 
默认值：false
</td>
</tr>
<tr>
<td colspan="2">--policy-config-file string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
DEPRECATED: file with scheduler policy configuration. This file is used if policy ConfigMap is not provided or --use-legacy-policy-config=true. Note: The scheduler will fail if this is combined with Plugin configs
-->
已弃用：包含调度器策略配置的文件。
当策略 ConfigMap 为提供时，或者 <code>--use-legacy-policy-config=true</code> 时使用此文件。
注意：当此标志与插件配置一起使用时，调度器会失败。
</td>
</tr>
<tr>
<td colspan="2">--policy-configmap string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
DEPRECATED: name of the ConfigMap object that contains scheduler's policy configuration. It must exist in the system namespace before scheduler initialization if --use-legacy-policy-config=false. The config must be provided as the value of an element in 'Data' map with the key='policy.cfg'. Note: The scheduler will fail if this is combined with Plugin configs
-->
已弃用: 包含调度器策略配置的 ConfigMap 对象的名称。
如果 --use-legacy-policy-config=false，则它必须在调度器初始化之前存在于
系统命名空间中。配置数据必须对应 'data' 映射中键名为 'policy.cfg' 的元素的值。
注意：如果与插件配置一起使用，调度器会失败。
</td>
</tr>
<tr>
<td colspan="2">--policy-configmap-namespace string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值："kube-system"</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
DEPRECATED: the namespace where policy ConfigMap is located. The kube-system namespace will be used if this is not provided or is empty. Note: The scheduler will fail if this is combined with Plugin configs
-->
已弃用: 策略 ConfigMap 所在的名字空间。如果未提供或为空，则将使用 kube-system 名字空间。
注意：如果与插件配置一起使用，调度器会失败。
</td>
</tr>
<tr>
<td colspan="2">--port int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值：10251</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
DEPRECATED: the port on which to serve HTTP insecurely without authentication and authorization. If 0, don't serve plain HTTP at all. See --secure-port instead. This parameter is ignored if a config file is specified in --config.
-->
已弃用： 在没有身份验证和鉴权的情况下不安全地为 HTTP 服务的端口。
如果为 0，则根本不提供 HTTP。请参见 --secure-port。
如果 --config 指定了一个配置文件，这个参数将被忽略。
</td>
</tr>
<tr>
<td colspan="2">--profiling&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值： true</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
DEPRECATED: enable profiling via web interface host:port/debug/pprof/. 
This parameter is ignored if a config file is specified in --config.
-->
已弃用: 通过 Web 界面主机启用配置文件：<code>host:port/debug/pprof/</code>。
如果 --config 指定了一个配置文件，这个参数将被忽略。
</td>
</tr>
<tr>
<td colspan="2">--requestheader-allowed-names stringSlice</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
List of client certificate common names to allow to provide usernames in headers specified by --requestheader-username-headers. If empty, any client certificate validated by the authorities in --requestheader-client-ca-file is allowed.
-->
客户端证书通用名称列表，允许在 <code>--requestheader-username-headers</code>
指定的头部中提供用户名。如果为空，则允许任何由
<code>--requestheader-client-ca-file</code> 中证书机构验证的客户端证书。
</td>
</tr>
<tr>
<td colspan="2">--requestheader-client-ca-file string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Root certificate bundle to use to verify client certificates on incoming requests before trusting usernames in headers specified by --requestheader-username-headers. WARNING: generally do not depend on authorization being already done for incoming requests.
-->
在信任 <code>--requestheader-username-headers</code> 指定的头部中的用户名之前
用于验证传入请求上的客户端证书的根证书包。
警告：通常不应假定传入请求已经完成鉴权。
</td>
</tr>
<tr>
<td colspan="2">--requestheader-extra-headers-prefix strings&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<!--Default:-->默认值: "x-remote-extra-"</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
List of request header prefixes to inspect. X-Remote-Extra- is suggested.
-->
要检查请求头部前缀列表。建议使用 <code>X-Remote-Extra-</code>。
</td>
</tr>
<tr>
<td colspan="2">--requestheader-group-headers strings&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<!--Default:-->默认值: "x-remote-group"</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
List of request headers to inspect for groups. X-Remote-Group is suggested.
-->
用于检查组的请求头部列表。建议使用 <code>X-Remote-Group</code>。
</td>
</tr>
<tr>
<td colspan="2">--requestheader-username-headers strings&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<!--Default:-->默认值: "x-remote-user"</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
List of request headers to inspect for usernames. X-Remote-User is common.
-->
用于检查用户名的请求头部列表。<code>X-Remote-User</code> 很常用。
</td>
</tr>
<tr>
<td colspan="2">--scheduler-name string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->
默认值："default-scheduler"</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- 
DEPRECATED: name of the scheduler, used to select which pods will be processed by this scheduler, based on pod's &quot;spec.schedulerName&quot;. This parameter is ignored if a config file is specified in --config.
-->
已弃用: 调度器名称，用于根据 Pod 的 “spec.schedulerName” 选择此
调度器将处理的 Pod。
如果 --config 指定了一个配置文件，那么这个参数将被忽略
</td>
</tr>
<tr>
<td colspan="2">--secure-port int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值：10259</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The port on which to serve HTTPS with authentication and authorization. If 0, don't serve HTTPS at all.
-->
通过身份验证和授权为 HTTPS 服务的端口。如果为 0，则根本不提供 HTTPS。
</td>
</tr>
<tr>
<td colspan="2">--show-hidden-metrics-for-version string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The previous version for which you want to show hidden metrics. Only the previous minor version is meaningful, other values will not be allowed. The format is &lt;major&gt;.&lt;minor&gt;, e.g.: '1.16'. The purpose of this format is make sure you have the opportunity to notice if the next release hides additional metrics, rather than being surprised when they are permanently removed in the release after that.
-->
你希望显式隐藏指标的老版本号。只有较早的此版本号有意义，其它值都是不允许的。
格式为 &lt;主版本&gt;.&lt;此版本&gt;，例如：'1.16'。
此格式的目的是确保你有机会注意到是否下一个发行版本中隐藏了一些额外的指标，
而不是当某些指标在该版本之后被彻底移除时感到震惊。
</td>
</tr>
<tr>
<td colspan="2">--skip-headers</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
If true, avoid header prefixes in the log messages
-->
如果为 true，日志消息中不再写入头部前缀。
</td>
</tr>
<tr>
<td colspan="2">--skip-log-headers</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
If true, avoid headers when opening log files
-->
如果为 true，则在打开日志文件时忽略其头部。
</td>
</tr>
<tr>
<td colspan="2">--stderrthreshold int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值：2</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
logs at or above this threshold go to stderr
-->
达到或超过此阈值的日志会被写入到标准错误输出。
</td>
</tr>
<tr>
<td colspan="2">--tls-cert-file string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
File containing the default x509 Certificate for HTTPS. (CA cert, if any, concatenated after server cert). If HTTPS serving is enabled, and --tls-cert-file and --tls-private-key-file are not provided, a self-signed certificate and key are generated for the public address and saved to the directory specified by --cert-dir.
-->
包含默认的 HTTPS x509 证书的文件。（CA证书（如果有）在服务器证书之后并置）。
如果启用了 HTTPS 服务，并且未提供 <code>--tls-cert-file</code> 和
<code>--tls-private-key-file</code>，则会为公共地址生成一个自签名证书和密钥，
并将其保存到 <code>--cert-dir</code> 指定的目录中。
</td>
</tr>
<tr>
<td colspan="2">--tls-cipher-suites strings</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- 
Comma-separated list of cipher suites for the server. If omitted, the default Go cipher suites will be used.<br/>
Preferred values: 
TLS_AES_128_GCM_SHA256, TLS_AES_256_GCM_SHA384, TLS_CHACHA20_POLY1305_SHA256, TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA, TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256, TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA, TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384, TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305, TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256, TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA, TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA, TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256, TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA, TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384, TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305, TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256, TLS_RSA_WITH_3DES_EDE_CBC_SHA, TLS_RSA_WITH_AES_128_CBC_SHA, TLS_RSA_WITH_AES_128_GCM_SHA256, TLS_RSA_WITH_AES_256_CBC_SHA, TLS_RSA_WITH_AES_256_GCM_SHA384.<br/>
Insecure values: 
TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256, TLS_ECDHE_ECDSA_WITH_RC4_128_SHA, TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256, TLS_ECDHE_RSA_WITH_RC4_128_SHA, TLS_RSA_WITH_AES_128_CBC_SHA256, TLS_RSA_WITH_RC4_128_SHA.
-->
服务器的密码套件列表，以逗号分隔。如果省略，将使用默认的 Go 密码套件。
优先考虑的值：
TLS_AES_128_GCM_SHA256, TLS_AES_256_GCM_SHA384, TLS_CHACHA20_POLY1305_SHA256, TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA, TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256, TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA, TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384, TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305, TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256, TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA, TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA, TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256, TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA, TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384, TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305, TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256, TLS_RSA_WITH_3DES_EDE_CBC_SHA, TLS_RSA_WITH_AES_128_CBC_SHA, TLS_RSA_WITH_AES_128_GCM_SHA256, TLS_RSA_WITH_AES_256_CBC_SHA, TLS_RSA_WITH_AES_256_GCM_SHA384.<br/>
不安全的值：
TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256, TLS_ECDHE_ECDSA_WITH_RC4_128_SHA, TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256, TLS_ECDHE_RSA_WITH_RC4_128_SHA, TLS_RSA_WITH_AES_128_CBC_SHA256, TLS_RSA_WITH_RC4_128_SHA.
</td>
</tr>
<tr>
<td colspan="2">--tls-min-version string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Minimum TLS version supported. Possible values: VersionTLS10, VersionTLS11, VersionTLS12, VersionTLS13
-->
支持的最低 TLS 版本。可能的值：VersionTLS10, VersionTLS11, VersionTLS12, VersionTLS13
</td>
</tr>
<tr>
<td colspan="2">--tls-private-key-file string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
File containing the default x509 private key matching --tls-cert-file.
-->
包含与 --tls-cert-file 匹配的默认 x509 私钥的文件。
</td>
</tr>
<tr>
<td colspan="2">--tls-sni-cert-key string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
A pair of x509 certificate and private key file paths, optionally suffixed with a list of domain patterns which are fully qualified domain names, possibly with prefixed wildcard segments. The domain patterns also allow IP addresses, but IPs should only be used if the apiserver has visibility to the IP address requested by a client. If no domain patterns are provided, the names of the certificate are extracted. Non-wildcard matches trump over wildcard matches, explicit domain patterns trump over extracted names. For multiple key/certificate pairs, use the --tls-sni-cert-key multiple times. Examples: &quot;example.crt,example.key&quot; or &quot;foo.crt,foo.key:*.foo.com,foo.com&quot;.
-->
一对 x509 证书和私钥文件路径，也可以包含由全限定域名构成的域名模式列表作为后缀，
并可能带有前缀的通配符段。域名匹配还允许是 IP 地址，
但是只有当 apiserver 对客户端请求的 IP 地址可见时，才能使用 IP。
如果未提供域名匹配模式，则提取证书名称。
非通配符匹配优先于通配符匹配，显式域名匹配优先于提取而来的名称。
若有多个密钥/证书对，可多次使用 <code>--tls-sni-cert-key</code>。
例子: "example.crt,example.key" 或者 "foo.crt,foo.key:*.foo.com,foo.com"。
</td>
</tr>
<tr>
<td colspan="2">--use-legacy-policy-config</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
DEPRECATED: when set to true, scheduler will ignore policy ConfigMap and uses policy config file. Note: The scheduler will fail if this is combined with Plugin configs
-->
已弃用：设置为 true 时，调度程序将忽略策略 ConfigMap 并使用策略配置文件。
注意：当此标志与插件配置一起使用时，调度器会失败。
</td>
</tr>
<tr>
<td colspan="2">-v, --v int</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
number for the log level verbosity
-->
设置日志级别详细程度的数字
</td>
</tr>
<tr>
<td colspan="2">--version version[=true]</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Print version information and quit
-->
打印版本信息并退出。
</td>
</tr>
<tr>
<td colspan="2">--vmodule &lt;<!--comma-separated 'pattern=N' settings-->逗号分隔的 ‘模式=N’ 配置列表&gt;</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
comma-separated list of pattern=N settings for file-filtered logging
-->
以逗号分隔的 ‘模式=N’ 设置列表，用于文件过滤的日志记录。
</td>
</tr>
<tr>
<td colspan="2">--write-config-to string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
If set, write the configuration values to this file and exit.
-->
如果已设置，将配置值写入此文件并退出。
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-1715b765e2ff39feffd103d59ec0ef07">9.7 - Kubelet 认证/鉴权</h1>
    
	<!-- 
reviewers:
- liggitt
title: Kubelet authentication/authorization
-->
<!-- 
## Overview 
-->
<h2 id="概述">概述</h2>
<!--  
A kubelet's HTTPS endpoint exposes APIs which give access to data of varying sensitivity,
and allow you to perform operations with varying levels of power on the node and within containers.
-->
<p>kubelet 的 HTTPS 端点公开了 API，
这些 API 可以访问敏感度不同的数据，
并允许你在节点上和容器内以不同级别的权限执行操作。</p>
<!--  
This document describes how to authenticate and authorize access to the kubelet's HTTPS endpoint.
-->
<p>本文档介绍了如何对 kubelet 的 HTTPS 端点的访问进行认证和鉴权。</p>
<!-- 
## Kubelet authentication 
-->
<h2 id="kubelet-身份认证">Kubelet 身份认证</h2>
<!-- 
By default, requests to the kubelet's HTTPS endpoint that are not rejected by other configured
authentication methods are treated as anonymous requests, and given a username of `system:anonymous`
and a group of `system:unauthenticated`.
-->
<p>默认情况下，未被已配置的其他身份认证方法拒绝的对 kubelet 的 HTTPS 端点的请求会被视为匿名请求，
并被赋予 <code>system:anonymous</code> 用户名和 <code>system:unauthenticated</code> 组。</p>
<!--  
To disable anonymous access and send `401 Unauthorized` responses to unauthenticated requests:
-->
<p>要禁用匿名访问并向未经身份认证的请求发送 <code>401 Unauthorized</code> 响应，请执行以下操作：</p>
<!-- 
* start the kubelet with the `--anonymous-auth=false` flag 
-->
<ul>
<li>带 <code>--anonymous-auth=false</code> 标志启动 kubelet</li>
</ul>
<!-- 
To enable X509 client certificate authentication to the kubelet's HTTPS endpoint:
-->
<p>要对 kubelet 的 HTTPS 端点启用 X509 客户端证书认证：</p>
<!--  
* start the kubelet with the `--client-ca-file` flag, providing a CA bundle to verify client certificates with
* start the apiserver with `--kubelet-client-certificate` and `--kubelet-client-key` flags
* see the [apiserver authentication documentation](/docs/reference/access-authn-authz/authentication/#x509-client-certs) for more details
-->
<ul>
<li>带 <code>--client-ca-file</code> 标志启动 kubelet，提供一个 CA 证书包以供验证客户端证书</li>
<li>带 <code>--kubelet-client-certificate</code> 和 <code>--kubelet-client-key</code> 标志启动 apiserver</li>
<li>有关更多详细信息，请参见
<a href="/zh/docs/reference/access-authn-authz/authentication/#x509-client-certs">apiserver 身份验证文档</a></li>
</ul>
<!--  
To enable API bearer tokens (including service account tokens) to be used to authenticate to the kubelet's HTTPS endpoint:
-->
<p>要启用 API 持有者令牌（包括服务帐户令牌）以对 kubelet 的 HTTPS 端点进行身份验证，请执行以下操作：</p>
<!--  
* ensure the `authentication.k8s.io/v1beta1` API group is enabled in the API server
* start the kubelet with the `--authentication-token-webhook` and the `--kubeconfig` flags
* the kubelet calls the `TokenReview` API on the configured API server to determine user information from bearer tokens
-->
<ul>
<li>确保在 API 服务器中启用了 <code>authentication.k8s.io/v1beta1</code> API 组</li>
<li>带 <code>--authentication-token-webhook</code> 和 <code>--kubeconfig</code> 标志启动 kubelet</li>
<li>kubelet 调用已配置的 API 服务器上的 <code>TokenReview</code> API，以根据持有者令牌确定用户信息</li>
</ul>
<!-- 
## Kubelet authorization 
-->
<h2 id="kubelet-鉴权">Kubelet 鉴权</h2>
<!--  
Any request that is successfully authenticated (including an anonymous request) is then authorized. The default authorization mode is `AlwaysAllow`, which allows all requests.
-->
<p>任何成功通过身份验证的请求（包括匿名请求）之后都会被鉴权。
默认的鉴权模式为 <code>AlwaysAllow</code>，它允许所有请求。</p>
<!--  
There are many possible reasons to subdivide access to the kubelet API:
-->
<p>细分对 kubelet API 的访问权限可能有多种原因：</p>
<!--  
* anonymous auth is enabled, but anonymous users' ability to call the kubelet API should be limited
* bearer token auth is enabled, but arbitrary API users' (like service accounts) ability to call the kubelet API should be limited
* client certificate auth is enabled, but only some of the client certificates signed by the configured CA should be allowed to use the kubelet API
-->
<ul>
<li>启用了匿名身份验证，但是应限制匿名用户调用 kubelet API 的能力</li>
<li>启用了持有者令牌认证，但应限制任意 API 用户（如服务帐户）调用 kubelet API 的能力</li>
<li>启用了客户端证书身份验证，但仅应允许已配置的 CA 签名的某些客户端证书使用 kubelet API</li>
</ul>
<!--  
To subdivide access to the kubelet API, delegate authorization to the API server:
-->
<p>要细分对 kubelet API 的访问权限，请将鉴权委派给 API 服务器：</p>
<!--  
* ensure the `authorization.k8s.io/v1beta1` API group is enabled in the API server
* start the kubelet with the `--authorization-mode=Webhook` and the `--kubeconfig` flags
* the kubelet calls the `SubjectAccessReview` API on the configured API server to determine whether each request is authorized
-->
<ul>
<li>确保在 API 服务器中启用了 <code>authorization.k8s.io/v1beta1</code> API 组</li>
<li>带 <code>--authorization-mode=Webhook</code> 和 <code>--kubeconfig</code> 标志启动 kubelet</li>
<li>kubelet 调用已配置的 API 服务器上的 <code>SubjectAccessReview</code> API，
以确定每个请求是否得到鉴权</li>
</ul>
<!--  
The kubelet authorizes API requests using the same [request attributes](/docs/reference/access-authn-authz/authorization/#review-your-request-attributes) approach as the apiserver.
-->
<p>kubelet 使用与 apiserver 相同的
<a href="/zh/docs/reference/access-authn-authz/authorization/#review-your-request-attributes">请求属性</a>
方法对 API 请求执行鉴权。</p>
<!--  
The verb is determined from the incoming request's HTTP verb:
-->
<p>请求的动词根据传入请求的 HTTP 动词确定：</p>
<!-- 
HTTP verb | request verb
-->
<table>
<thead>
<tr>
<th>HTTP 动词</th>
<th>请求动词</th>
</tr>
</thead>
<tbody>
<tr>
<td>POST</td>
<td>create</td>
</tr>
<tr>
<td>GET, HEAD</td>
<td>get</td>
</tr>
<tr>
<td>PUT</td>
<td>update</td>
</tr>
<tr>
<td>PATCH</td>
<td>patch</td>
</tr>
<tr>
<td>DELETE</td>
<td>delete</td>
</tr>
</tbody>
</table>
<!--  
The resource and subresource is determined from the incoming request's path:
-->
<p>资源和子资源是根据传入请求的路径确定的：</p>
<!--
Kubelet API  | resource | subresource  
-->
<table>
<thead>
<tr>
<th>Kubelet API</th>
<th>资源</th>
<th>子资源</th>
</tr>
</thead>
<tbody>
<tr>
<td>/stats/*</td>
<td>nodes</td>
<td>stats</td>
</tr>
<tr>
<td>/metrics/*</td>
<td>nodes</td>
<td>metrics</td>
</tr>
<tr>
<td>/logs/*</td>
<td>nodes</td>
<td>log</td>
</tr>
<tr>
<td>/spec/*</td>
<td>nodes</td>
<td>spec</td>
</tr>
<tr>
<td><em>其它所有</em></td>
<td>nodes</td>
<td>proxy</td>
</tr>
</tbody>
</table>
<!--  
The namespace and API group attributes are always an empty string, and
the resource name is always the name of the kubelet's `Node` API object.
-->
<p>名字空间和 API 组属性始终是空字符串，
资源名称始终是 kubelet 的 <code>Node</code> API 对象的名称。</p>
<!--  
When running in this mode, ensure the user identified by the `--kubelet-client-certificate` and `--kubelet-client-key`
flags passed to the apiserver is authorized for the following attributes:
-->
<p>在此模式下运行时，请确保传递给 apiserver 的由 <code>--kubelet-client-certificate</code> 和
<code>--kubelet-client-key</code> 标志标识的用户具有以下属性的鉴权：</p>
<ul>
<li>verb=*, resource=nodes, subresource=proxy</li>
<li>verb=*, resource=nodes, subresource=stats</li>
<li>verb=*, resource=nodes, subresource=log</li>
<li>verb=*, resource=nodes, subresource=spec</li>
<li>verb=*, resource=nodes, subresource=metrics</li>
</ul>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-bdd3803a4bb6efcc44a7ab03590ce93c">9.8 - TLS 启动引导</h1>
    
	<!--
reviewers:
- mikedanese
- liggitt
- smarterclayton
- awly
title: TLS bootstrapping
content_type: concept
-->
<!-- overview -->
<!--
In a Kubernetes cluster, the components on the worker nodes - kubelet and kube-proxy - need to communicate with Kubernetes master components, specifically kube-apiserver.
In order to ensure that communication is kept private, not interfered with, and ensure that each component of the cluster is talking to another trusted component, we strongly
recommend using client TLS certificates on nodes.
-->
<p>在一个 Kubernetes 集群中，工作节点上的组件（kubelet 和 kube-proxy）需要与
Kubernetes 主控组件通信，尤其是 kube-apiserver。
为了确保通信本身是私密的、不被干扰，并且确保集群的每个组件都在与另一个
可信的组件通信，我们强烈建议使用节点上的客户端 TLS 证书。</p>
<!--
The normal process of bootstrapping these components, especially worker nodes that need certificates so they can communicate safely with kube-apiserver,
can be a challenging process as it is often outside of the scope of Kubernetes and requires significant additional work.
This in turn, can make it challenging to initialize or scale a cluster.
-->
<p>启动引导这些组件的正常过程，尤其是需要证书来与 kube-apiserver 安全通信的
工作节点，可能会是一个具有挑战性的过程，因为这一过程通常不受 Kubernetes 控制，
需要不少额外工作。
这也使得初始化或者扩缩一个集群的操作变得具有挑战性。</p>
<!--
In order to simplify the process, beginning in version 1.4, Kubernetes introduced a certificate request and signing API to simplify the process. The proposal can be
found [here](https://github.com/kubernetes/kubernetes/pull/20439).

This document describes the process of node initialization, how to set up TLS client certificate bootstrapping for
kubelets, and how it works.
-->
<p>为了简化这一过程，从 1.4 版本开始，Kubernetes 引入了一个证书请求和签名
API 以便简化此过程。该提案可在
<a href="https://github.com/kubernetes/kubernetes/pull/20439">这里</a>看到。</p>
<p>本文档描述节点初始化的过程，如何为 kubelet 配置 TLS 客户端证书启动引导，
以及其背后的工作原理。</p>
<!-- body -->
<!--
## Initialization Process

When a worker node starts up, the kubelet does the following:
-->
<h2 id="initialization-process">初始化过程  </h2>
<p>当工作节点启动时，kubelet 执行以下操作：</p>
<!--
1. Look for its `kubeconfig` file
2. Retrieve the URL of the API server and credentials, normally a TLS key and signed certificate from the `kubeconfig` file
3. Attempt to communicate with the API server using the credentials.
-->
<ol>
<li>寻找自己的 <code>kubeconfig</code> 文件</li>
<li>检索 API 服务器的 URL 和凭据，通常是来自 <code>kubeconfig</code> 文件中的
TLS 密钥和已签名证书</li>
<li>尝试使用这些凭据来与 API 服务器通信</li>
</ol>
<!--
Assuming that the kube-apiserver successfully validates the kubelet's credentials, it will treat the kubelet as a valid node, and begin to assign pods to it.

Note that the above process depends upon:

* Existence of a key and certificate on the local host in the `kubeconfig`
* The certificate having been signed by a Certificate Authority (CA) trusted by the kube-apiserver
-->
<p>假定 kube-apiserver 成功地认证了 kubelet 的凭据数据，它会将 kubelet 视为
一个合法的节点并开始将 Pods 分派给该节点。</p>
<p>注意，签名的过程依赖于：</p>
<ul>
<li><code>kubeconfig</code> 中包含密钥和本地主机的证书</li>
<li>证书被 kube-apiserver 所信任的一个证书机构（CA）所签名</li>
</ul>
<!--
All of the following are responsibilities of whoever sets up and manages the cluster:

1. Creating the CA key and certificate
2. Distributing the CA certificate to the master nodes, where kube-apiserver is running
3. Creating a key and certificate for each kubelet; strongly recommended to have a unique one, with a unique CN, for each kubelet
4. Signing the kubelet certificate using the CA key
5. Distributing the kubelet key and signed certificate to the specific node on which the kubelet is running

The TLS Bootstrapping described in this document is intended to simplify, and partially or even completely automate, steps 3 onwards, as these are the most common when initializing or scaling
a cluster.
-->
<p>负责部署和管理集群的人有以下责任：</p>
<ol>
<li>创建 CA 密钥和证书</li>
<li>将 CA 证书发布到 kube-apiserver 运行所在的主控节点上</li>
<li>为每个 kubelet 创建密钥和证书；强烈建议为每个 kubelet 使用独一无二的、
CN 取值与众不同的密钥和证书</li>
<li>使用 CA 密钥对 kubelet 证书签名</li>
<li>将 kubelet 密钥和签名的证书发布到 kubelet 运行所在的特定节点上</li>
</ol>
<p>本文中描述的 TLS 启动引导过程有意简化甚至完全自动化上述过程，尤其是
第三步之后的操作，因为这些步骤是初始化或者扩缩集群时最常见的操作。</p>
<!--
### Bootstrap Initialization

In the bootstrap initialization process, the following occurs:
-->
<h3 id="bootstrap-initialization">启动引导初始化  </h3>
<p>在启动引导初始化过程中，会发生以下事情：</p>
<!--
1. kubelet begins
2. kubelet sees that it does _not_ have a `kubeconfig` file
3. kubelet searches for and finds a `bootstrap-kubeconfig` file
4. kubelet reads its bootstrap file, retrieving the URL of the API server and a limited usage "token"
5. kubelet connects to the API server, authenticates using the token
6. kubelet now has limited credentials to create and retrieve a certificate signing request (CSR)
7. kubelet creates a CSR for itself with the signerName set to `kubernetes.io/kube-apiserver-client-kubelet`
8. CSR is approved in one of two ways:
  * If configured, kube-controller-manager automatically approves the CSR
  * If configured, an outside process, possibly a person, approves the CSR using the Kubernetes API or via `kubectl`
9. Certificate is created for the kubelet
-->
<ol>
<li>kubelet 启动</li>
<li>kubelet 看到自己 <em>没有</em> 对应的 <code>kubeconfig</code> 文件</li>
<li>kubelet 搜索并发现 <code>bootstrap-kubeconfig</code> 文件</li>
<li>kubelet 读取该启动引导文件，从中获得 API 服务器的 URL 和用途有限的
一个“令牌（Token）”</li>
<li>kubelet 建立与 API 服务器的连接，使用上述令牌执行身份认证</li>
<li>kubelet 现在拥有受限制的凭据来创建和取回证书签名请求（CSR）</li>
<li>kubelet 为自己创建一个 CSR，并将其 signerName 设置为 <code>kubernetes.io/kube-apiserver-client-kubelet</code></li>
<li>CSR 被以如下两种方式之一批复：</li>
</ol>
<ul>
<li>如果配置了，kube-controller-manager 会自动批复该 CSR</li>
<li>如果配置了，一个外部进程，或者是人，使用 Kubernetes API 或者使用 <code>kubectl</code>
来批复该 CSR</li>
</ul>
<ol start="9">
<li>kubelet 所需要的证书被创建</li>
</ol>
<!--
10. Certificate is issued to the kubelet
11. kubelet retrieves the certificate
12. kubelet creates a proper `kubeconfig` with the key and signed certificate
13. kubelet begins normal operation
14. Optional: if configured, kubelet automatically requests renewal of the certificate when it is close to expiry
15. The renewed certificate is approved and issued, either automatically or manually, depending on configuration.
-->
<ol start="10">
<li>证书被发放给 kubelet</li>
<li>kubelet 取回该证书</li>
<li>kubelet 创建一个合适的 <code>kubeconfig</code>，其中包含密钥和已签名的证书</li>
<li>kubelet 开始正常操作</li>
<li>可选地，如果配置了，kubelet 在证书接近于过期时自动请求更新证书</li>
<li>更新的证书被批复并发放；取决于配置，这一过程可能是自动的或者手动完成</li>
</ol>
<!--
The rest of this document describes the necessary steps to configure TLS Bootstrapping, and its limitations.
-->
<p>本文的其余部分描述配置 TLS 启动引导的必要步骤及其局限性。</p>
<!--
## Configuration

To configure for TLS bootstrapping and optional automatic approval, you must configure options on the following components:

* kube-apiserver
* kube-controller-manager
* kubelet
* in-cluster resources: `ClusterRoleBinding` and potentially `ClusterRole`

In addition, you need your Kubernetes Certificate Authority (CA).
-->
<h2 id="configuration">配置   </h2>
<p>要配置 TLS 启动引导及可选的自动批复，你必须配置以下组件的选项：</p>
<ul>
<li>kube-apiserver</li>
<li>kube-controller-manager</li>
<li>kubelet</li>
<li>集群内的资源：<code>ClusterRoleBinding</code> 以及可能需要的 <code>ClusterRole</code></li>
</ul>
<p>此外，你需要有 Kubernetes 证书机构（Certificate Authority，CA）。</p>
<!--
## Certificate Authority

As without bootstrapping, you will need a Certificate Authority (CA) key and certificate. As without bootstrapping, these will be used
to sign the kubelet certificate. As before, it is your responsibility to distribute them to master nodes.
-->
<h2 id="certificate-authority">证书机构  </h2>
<p>就像在没有启动引导的情况下，你会需要证书机构（CA）密钥和证书。
这些数据会被用来对 kubelet 证书进行签名。
如前所述，将证书机构密钥和证书发布到主控节点是你的责任。</p>
<!--
For the purposes of this document, we will assume these have been distributed to master nodes at `/var/lib/kubernetes/ca.pem` (certificate) and `/var/lib/kubernetes/ca-key.pem` (key).
We will refer to these as "Kubernetes CA certificate and key".

All Kubernetes components that use these certificates - kubelet, kube-apiserver, kube-controller-manager - assume the key and certificate to be PEM-encoded.
-->
<p>就本文而言，我们假定这些数据被发布到主控节点上的
<code>/var/lib/kubernetes/ca.pem</code>（证书）和
<code>/var/lib/kubernetes/ca-key.pem</code>（密钥）文件中。
我们将这两个文件称作“Kubernetes CA 证书和密钥”。
所有 Kubernetes 组件（kubelet、kube-apiserver、kube-controller-manager）都使用
这些凭据，并假定这里的密钥和证书都是 PEM 编码的。</p>
<!--
## kube-apiserver configuration

The kube-apiserver has several requirements to enable TLS bootstrapping:

* Recognizing CA that signs the client certificate
* Authenticating the bootstrapping kubelet to the `system:bootstrappers` group
* Authorize the bootstrapping kubelet to create a certificate signing request (CSR)
-->
<h2 id="kube-apiserver-configuration">kube-apiserver 配置  </h2>
<p>启用 TLS 启动引导对 kube-apiserver 有若干需求：</p>
<ul>
<li>能够识别对客户端证书进行签名的 CA</li>
<li>能够对启动引导的 kubelet 执行身份认证，并将其置入 <code>system:bootstrappers</code> 组</li>
<li>能够对启动引导的 kubelet 执行鉴权操作，允许其创建证书签名请求（CSR）</li>
</ul>
<!--
### Recognizing client certificates

This is normal for all client certificate authentication.
If not already set, add the `--client-ca-file=FILENAME` flag to the kube-apiserver command to enable
client certificate authentication, referencing a certificate authority bundle
containing the signing certificate, for example
`--client-ca-file=/var/lib/kubernetes/ca.pem`.
-->
<h3 id="recognizing-client-certificates">识别客户证书   </h3>
<p>对于所有客户端证书的认证操作而言，这是很常见的。
如果还没有设置，要为 kube-apiserver 命令添加 <code>--client-ca-file=FILENAME</code>
标志来启用客户端证书认证，在标志中引用一个包含用来签名的证书的证书机构包，
例如：<code>--client-ca-file=/var/lib/kubernetes/ca.pem</code>。</p>
<!--
### Initial bootstrap authentication

In order for the bootstrapping kubelet to connect to kube-apiserver and request a certificate, it must first authenticate to the server.
You can use any [authenticator](/docs/reference/access-authn-authz/authentication/) that can authenticate the kubelet.
-->
<h3 id="initial-bootstrap-authentication">初始启动引导认证    </h3>
<p>为了让启动引导的 kubelet 能够连接到 kube-apiserver 并请求证书，
它必须首先在服务器上认证自身身份。你可以使用任何一种能够对 kubelet 执行身份认证的
<a href="/zh/docs/reference/access-authn-authz/authentication/">身份认证组件</a>。</p>
<!--
While any authentication strategy can be used for the kubelet's initial
bootstrap credentials, the following two authenticators are recommended for ease
of provisioning.

1. [Bootstrap Tokens](#bootstrap-tokens)
2. [Token authentication file](#token-authentication-file)
-->
<p>尽管所有身份认证策略都可以用来对 kubelet 的初始启动凭据来执行认证，
出于容易准备的因素，建议使用如下两个身份认证组件：</p>
<ol>
<li><a href="#bootstrap-tokens">启动引导令牌（Bootstrap Token）</a></li>
<li><a href="#token-authentication-file">令牌认证文件</a></li>
</ol>
<!--
Bootstrap tokens are a simpler and more easily managed method to authenticate kubelets, and do not require any additional flags when starting kube-apiserver.
Using bootstrap tokens is currently __beta__ as of Kubernetes version 1.12.
-->
<p>启动引导令牌是一种对 kubelet 进行身份认证的方法，相对简单且容易管理，
且不需要在启动 kube-apiserver 时设置额外的标志。
启动引导令牌从 Kubernetes 1.12 开始是一种 <strong>Beta</strong> 功能特性。</p>
<!--
Whichever method you choose, the requirement is that the kubelet be able to authenticate as a user with the rights to:

1. create and retrieve CSRs
2. be automatically approved to request node client certificates, if automatic approval is enabled.
-->
<p>无论选择哪种方法，这里的需求是 kubelet 能够被身份认证为某个具有如下权限的用户：</p>
<ol>
<li>创建和读取 CSR</li>
<li>在启用了自动批复时，能够在请求节点客户端证书时得到自动批复</li>
</ol>
<!--
A kubelet authenticating using bootstrap tokens is authenticated as a user in the group `system:bootstrappers`, which is the standard method to use.
-->
<p>使用启动引导令牌执行身份认证的 kubelet 会被认证为 <code>system:bootstrappers</code>
组中的用户。这是使用启动引导令牌的一种标准方法。</p>
<!--
As this feature matures, you
should ensure tokens are bound to a Role Based Access Control (RBAC) policy
which limits requests (using the [bootstrap token](/docs/reference/access-authn-authz/bootstrap-tokens/)) strictly to client
requests related to certificate provisioning. With RBAC in place, scoping the
tokens to a group allows for great flexibility. For example, you could disable a
particular bootstrap group's access when you are done provisioning the nodes.
-->
<p>随着这个功能特性的逐渐成熟，你需要确保令牌绑定到某基于角色的的访问控制（RBAC）
策略上，从而严格限制请求（使用<a href="/zh/docs/reference/access-authn-authz/bootstrap-tokens/">启动引导令牌</a>）
仅限于客户端申请提供证书。当 RBAC 被配置启用时，可以将令牌限制到某个组，从而
提高灵活性。例如，你可以在准备节点期间禁止某特定启动引导组的访问。</p>
<!--
#### Bootstrap tokens

Bootstrap tokens are described in detail [here](/docs/reference/access-authn-authz/bootstrap-tokens/). These are tokens that are stored as secrets in the Kubernetes cluster,
and then issued to the individual kubelet. You can use a single token for an entire cluster, or issue one per worker node.
-->
<h4 id="bootstrap-tokens">启动引导令牌  </h4>
<p>启动引导令牌的细节在<a href="/zh/docs/reference/access-authn-authz/bootstrap-tokens/">这里</a>
详述。启动引导令牌在 Kubernetes 集群中存储为 Secret 对象，被发放给各个 kubelet。
你可以在整个集群中使用同一个令牌，也可以为每个节点发放单独的令牌。</p>
<!--
The process is two-fold:

1. Create a Kubernetes secret with the token ID, secret and scope(s).
2. Issue the token to the kubelet
-->
<p>这一过程有两个方面：</p>
<ol>
<li>基于令牌 ID、机密数据和范畴信息创建 Kubernetes Secret</li>
<li>将令牌发放给 kubelet</li>
</ol>
<!--
From the kubelet's perspective, one token is like another and has no special meaning.
From the kube-apiserver's perspective, however, the bootstrap token is special. Due to its `type`, `namespace` and `name`, kube-apiserver recognizes it as a special token,
and grants anyone authenticating with that token special bootstrap rights, notably treating them as a member of the `system:bootstrappers` group. This fulfills a basic requirement
for TLS bootstrapping.
-->
<p>从 kubelet 的角度，所有令牌看起来都很像，没有特别的含义。
从 kube-apiserver 服务器的角度，启动引导令牌是很特殊的。
根据其 <code>type</code>、<code>namespace</code> 和 <code>name</code>，kube-apiserver 能够将认作特殊的令牌，
并授予携带该令牌的任何人特殊的启动引导权限，换言之，将其视为
<code>system:bootstrappers</code> 组的成员。这就满足了 TLS 启动引导的基本需求。</p>
<!--
The details for creating the secret are available [here](/docs/reference/access-authn-authz/bootstrap-tokens/).

If you want to use bootstrap tokens, you must enable it on kube-apiserver with the flag:
-->
<p>关于创建 Secret 的进一步细节可访问<a href="/zh/docs/reference/access-authn-authz/bootstrap-tokens/">这里</a>。</p>
<p>如果你希望使用启动引导令牌，你必须在 kube-apiserver 上使用下面的标志启用之：</p>
<pre tabindex="0"><code class="language-console" data-lang="console">--enable-bootstrap-token-auth=true
</code></pre><!--
#### Token authentication file

kube-apiserver has an ability to accept tokens as authentication.
These tokens are arbitrary but should represent at least 128 bits of entropy derived
from a secure random number generator (such as `/dev/urandom` on most modern Linux
systems). There are multiple ways you can generate a token. For example:
-->
<h4 id="token-authentication-file">令牌认证文件   </h4>
<p>kube-apiserver 能够将令牌视作身份认证依据。
这些令牌可以是任意数据，但必须表示为基于某安全的随机数生成器而得到的
至少 128 位混沌数据。这里的随机数生成器可以是现代 Linux 系统上的
<code>/dev/urandom</code>。生成令牌的方式有很多种。例如：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">head -c <span style="color:#666">16</span> /dev/urandom | od -An -t x | tr -d <span style="color:#b44">&#39; &#39;</span>
</code></pre></div><!--
will generate tokens that look like `02b50b05283e98dd0fd71db496ef01e8`.

The token file should look like the following example, where the first three
values can be anything and the quoted group name should be as depicted:
-->
<p>上面的命令会生成类似于 <code>02b50b05283e98dd0fd71db496ef01e8</code> 这样的令牌。</p>
<p>令牌文件看起来是下面的例子这样，其中前面三个值可以是任何值，用引号括起来
的组名称则只能用例子中给的值。</p>
<pre tabindex="0"><code class="language-console" data-lang="console">02b50b05283e98dd0fd71db496ef01e8,kubelet-bootstrap,10001,&quot;system:bootstrappers&quot;
</code></pre><!--
Add the `--token-auth-file=FILENAME` flag to the kube-apiserver command (in your
systemd unit file perhaps) to enable the token file.  See docs
[here](/docs/reference/access-authn-authz/authentication/#static-token-file) for
further details.
-->
<p>向 kube-apiserver 添加 <code>--token-auth-file=FILENAME</code> 标志（或许这要对 systemd
的单元文件作修改）以启用令牌文件。参见
<a href="/zh/docs/reference/access-authn-authz/authentication/#static-token-file">这里</a>
的文档以了解进一步的细节。</p>
<!--
### Authorize kubelet to create CSR

Now that the bootstrapping node is _authenticated_ as part of the
`system:bootstrappers` group, it needs to be _authorized_ to create a
certificate signing request (CSR) as well as retrieve it when done.
Fortunately, Kubernetes ships with a `ClusterRole` with precisely these (and
only these) permissions, `system:node-bootstrapper`.

To do this, you only need to create a `ClusterRoleBinding` that binds the `system:bootstrappers` group to the cluster role `system:node-bootstrapper`.
-->
<h3 id="authorize-kubelet-to-create-csr">授权 kubelet 创建 CSR   </h3>
<p>现在启动引导节点被身份认证为 <code>system:bootstrapping</code> 组的成员，它需要被 <em>授权</em>
创建证书签名请求（CSR）并在证书被签名之后将其取回。
幸运的是，Kubernetes 提供了一个 <code>ClusterRole</code>，其中精确地封装了这些许可，
<code>system:node-bootstrapper</code>。</p>
<p>为了实现这一点，你只需要创建 <code>ClusterRoleBinding</code>，将 <code>system:bootstrappers</code>
组绑定到集群角色 <code>system:node-bootstrapper</code>。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#080;font-style:italic"># 允许启动引导节点创建 CSR</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>rbac.authorization.k8s.io/v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>ClusterRoleBinding<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>create-csrs-for-bootstrapping<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">subjects</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>Group<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>system:bootstrappers<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">apiGroup</span>:<span style="color:#bbb"> </span>rbac.authorization.k8s.io<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">roleRef</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>ClusterRole<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>system:node-bootstrapper<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">apiGroup</span>:<span style="color:#bbb"> </span>rbac.authorization.k8s.io<span style="color:#bbb">
</span></code></pre></div><!--
## kube-controller-manager configuration

While the apiserver receives the requests for certificates from the kubelet and authenticates those requests,
the controller-manager is responsible for issuing actual signed certificates.
-->
<h2 id="kube-controller-manager-configuration">kube-controller-manager 配置  </h2>
<p>API 服务器从 kubelet 收到证书请求并对这些请求执行身份认证，但真正负责发放
签名证书的是控制器管理器。</p>
<!--
The controller-manager performs this function via a certificate-issuing control loop.
This takes the form of a
[cfssl](https://blog.cloudflare.com/introducing-cfssl/) local signer using
assets on disk. Currently, all certificates issued have one year validity and a
default set of key usages.
-->
<p>控制器管理器通过一个证书发放的控制回路来执行此操作。该操作的执行方式是使用磁盘上
的文件用 <a href="https://blog.cloudflare.com/introducing-cfssl/">cfssl</a> 本地签名组件
来完成。目前，所发放的所有证书都有一年的有效期，并设定了默认的一组密钥用法。</p>
<!--
In order for the controller-manager to sign certificates, it needs the following:

* access to the "Kubernetes CA key and certificate" that you created and distributed
* enabling CSR signing
-->
<p>为了让控制器管理器对证书签名，它需要：</p>
<ul>
<li>能够访问你之前所创建并分发的“Kubernetes CA 密钥和证书”</li>
<li>启用 CSR 签名</li>
</ul>
<!--
### Access to key and certificate

As described earlier, you need to create a Kubernetes CA key and certificate, and distribute it to the master nodes.
These will be used by the controller-manager to sign the kubelet certificates.
-->
<h3 id="access-to-key-and-certificate">访问密钥和证书  </h3>
<p>如前所述，你需要创建一个 Kubernetes CA 密钥和证书，并将其发布到主控节点。
这些数据会被控制器管理器来对 kubelet 证书进行签名。</p>
<!--
Since these signed certificates will, in turn, be used by the kubelet to authenticate as a regular kubelet to kube-apiserver, it is important that the CA
provided to the controller-manager at this stage also be trusted by kube-apiserver for authentication. This is provided to kube-apiserver
with the flag `--client-ca-file=FILENAME` (for example, `--client-ca-file=/var/lib/kubernetes/ca.pem`), as described in the kube-apiserver configuration section.

To provide the Kubernetes CA key and certificate to kube-controller-manager, use the following flags:
-->
<p>由于这些被签名的证书反过来会被 kubelet 用来在 kube-apiserver 执行普通的
kubelet 身份认证，很重要的一点是为控制器管理器所提供的 CA 也被 kube-apiserver
信任用来执行身份认证。CA 密钥和证书是通过 kube-apiserver 的标志
<code>--client-ca-file=FILENAME</code>（例如，<code>--client-ca-file=/var/lib/kubernetes/ca.pem</code>)，
来设定的，正如 kube-apiserver 配置节所述。</p>
<p>要将 Kubernetes CA 密钥和证书提供给 kube-controller-manager，可使用以下标志：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">--cluster-signing-cert-file<span style="color:#666">=</span><span style="color:#b44">&#34;/etc/path/to/kubernetes/ca/ca.crt&#34;</span> --cluster-signing-key-file<span style="color:#666">=</span><span style="color:#b44">&#34;/etc/path/to/kubernetes/ca/ca.key&#34;</span>
</code></pre></div><!--
For example:
-->
<p>例如：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">--cluster-signing-cert-file<span style="color:#666">=</span><span style="color:#b44">&#34;/var/lib/kubernetes/ca.pem&#34;</span> --cluster-signing-key-file<span style="color:#666">=</span><span style="color:#b44">&#34;/var/lib/kubernetes/ca-key.pem&#34;</span>
</code></pre></div><!--
The validity duration of signed certificates can be configured with flag:
-->
<p>所签名的证书的合法期限可以通过下面的标志来配置：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">--cluster-signing-duration
</code></pre></div><!--
### Approval

In order to approve CSRs, you need to tell the controller-manager that it is acceptable to approve them. This is done by granting
RBAC permissions to the correct group.
-->
<h3 id="approval">批复   </h3>
<p>为了对 CSR 进行批复，你需要告诉控制器管理器批复这些 CSR 是可接受的。
这是通过将 RBAC 访问权限授予正确的组来实现的。</p>
<!--
There are two distinct sets of permissions:

* `nodeclient`: If a node is creating a new certificate for a node, then it does not have a certificate yet. It is authenticating using one of the tokens listed above, and thus is part of the group `system:bootstrappers`.
* `selfnodeclient`: If a node is renewing its certificate, then it already has a certificate (by definition), which it uses continuously to authenticate as part of the group `system:nodes`.
-->
<p>许可权限有两组：</p>
<ul>
<li><code>nodeclient</code>：如果节点在为节点创建新的证书，则该节点还没有证书。该节点
使用前文所列的令牌之一来执行身份认证，因此是组 <code>system:bootstrappers</code> 组
的成员。</li>
<li><code>selfnodeclient</code>：如果节点在对证书执行续期操作，则该节点已经拥有一个证书。
节点持续使用现有的证书将自己认证为 <code>system:nodes</code> 组的成员。</li>
</ul>
<!--
To enable the kubelet to request and receive a new certificate, create a `ClusterRoleBinding` that binds the group in which the bootstrapping node is a member `system:bootstrappers` to the `ClusterRole` that grants it permission, `system:certificates.k8s.io:certificatesigningrequests:nodeclient`:
-->
<p>要允许 kubelet 请求并接收新的证书，可以创建一个 <code>ClusterRoleBinding</code> 将启动
引导节点所处的组 <code>system:bootstrappers</code> 绑定到为其赋予访问权限的
<code>ClusterRole</code> <code>system:certificates.k8s.io:certificatesigningrequests:nodeclient</code>：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#080;font-style:italic"># 批复 &#34;system:bootstrappers&#34; 组的所有 CSR</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>rbac.authorization.k8s.io/v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>ClusterRoleBinding<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>auto-approve-csrs-for-group<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">subjects</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>Group<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>system:bootstrappers<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">apiGroup</span>:<span style="color:#bbb"> </span>rbac.authorization.k8s.io<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">roleRef</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>ClusterRole<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>system:certificates.k8s.io:certificatesigningrequests:nodeclient<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">apiGroup</span>:<span style="color:#bbb"> </span>rbac.authorization.k8s.io<span style="color:#bbb">
</span></code></pre></div><!--
To enable the kubelet to renew its own client certificate, create a `ClusterRoleBinding` that binds the group in which the fully functioning node is a member `system:nodes` to the `ClusterRole` that
grants it permission, `system:certificates.k8s.io:certificatesigningrequests:selfnodeclient`:
-->
<p>要允许 kubelet 对其客户端证书执行续期操作，可以创建一个 <code>ClusterRoleBinding</code>
将正常工作的节点所处的组 <code>system:nodes</code> 绑定到为其授予访问许可的 <code>ClusterRole</code>
<code>system:certificates.k8s.io:certificatesigningrequests:selfnodeclient</code>：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#080;font-style:italic"># 批复 &#34;system:nodes&#34; 组的 CSR 续约请求</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>rbac.authorization.k8s.io/v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>ClusterRoleBinding<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>auto-approve-renewals-for-nodes<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">subjects</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>Group<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>system:nodes<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">apiGroup</span>:<span style="color:#bbb"> </span>rbac.authorization.k8s.io<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">roleRef</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>ClusterRole<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>system:certificates.k8s.io:certificatesigningrequests:selfnodeclient<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">apiGroup</span>:<span style="color:#bbb"> </span>rbac.authorization.k8s.io<span style="color:#bbb">
</span></code></pre></div><!--
The `csrapproving` controller that ships as part of
[kube-controller-manager](/docs/admin/kube-controller-manager/) and is enabled
by default. The controller uses the [`SubjectAccessReview`
API](/docs/reference/access-authn-authz/authorization/#checking-api-access) to
determine if a given user is authorized to request a CSR, then approves based on
the authorization outcome. To prevent conflicts with other approvers, the
builtin approver doesn't explicitly deny CSRs. It only ignores unauthorized
requests. The controller also prunes expired certificates as part of garbage
collection.
-->
<p>作为 <a href="/zh/docs/reference/generated/kube-controller-manager/">kube-controller-manager</a>
的一部分的 <code>csrapproving</code> 控制器是自动被启用的。
该控制器使用 <a href="/zh/docs/reference/access-authn-authz/authorization/#checking-api-access"><code>SubjectAccessReview</code> API</a>
来确定是否某给定用户被授权请求 CSR，之后基于鉴权结果执行批复操作。
为了避免与其它批复组件发生冲突，内置的批复组件不会显式地拒绝任何 CSRs。
该组件仅是忽略未被授权的请求。
控制器也会作为垃圾收集的一部分清除已过期的证书。</p>
<!--
## kubelet configuration

Finally, with the master nodes properly set up and all of the necessary authentication and authorization in place, we can configure the kubelet.
-->
<h2 id="kubelet-configuration">kubelet 配置  </h2>
<p>最后，当主控节点被正确配置并且所有必要的身份认证和鉴权机制都就绪时，
我们可以配置 kubelet。</p>
<!--
The kubelet requires the following configuration to bootstrap:

* A path to store the key and certificate it generates (optional, can use default)
* A path to a `kubeconfig` file that does not yet exist; it will place the bootstrapped config file here
* A path to a bootstrap `kubeconfig` file to provide the URL for the server and bootstrap credentials, e.g. a bootstrap token
* Optional: instructions to rotate certificates
-->
<p>kubelet 需要以下配置来执行启动引导：</p>
<ul>
<li>一个用来存储所生成的密钥和证书的路径（可选，可以使用默认配置）</li>
<li>一个用来指向尚不存在的 <code>kubeconfig</code> 文件的路径；kubelet 会将启动引导
配置文件放到这个位置</li>
<li>一个指向启动引导 <code>kubeconfig</code> 文件的路径，用来提供 API 服务器的 URL
和启动引导凭据，例如，启动引导令牌</li>
<li>可选的：轮换证书的指令</li>
</ul>
<!--
The bootstrap `kubeconfig` should be in a path available to the kubelet, for example `/var/lib/kubelet/bootstrap-kubeconfig`.

Its format is identical to a normal `kubeconfig` file. A sample file might look as follows:
-->
<p>启动引导 <code>kubeconfig</code> 文件应该放在一个 kubelet 可访问的路径下，例如
<code>/var/lib/kubelet/bootstrap-kubeconfig</code>。</p>
<p>其格式与普通的 <code>kubeconfig</code> 文件完全相同。实例文件可能看起来像这样：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>Config<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">clusters</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">cluster</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">certificate-authority</span>:<span style="color:#bbb"> </span>/var/lib/kubernetes/ca.pem<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">server</span>:<span style="color:#bbb"> </span>https://my.server.example.com:6443<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>bootstrap<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">contexts</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">context</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">cluster</span>:<span style="color:#bbb"> </span>bootstrap<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">user</span>:<span style="color:#bbb"> </span>kubelet-bootstrap<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>bootstrap<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">current-context</span>:<span style="color:#bbb"> </span>bootstrap<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">preferences</span>:<span style="color:#bbb"> </span>{}<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">users</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>kubelet-bootstrap<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">user</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">token</span>:<span style="color:#bbb"> </span>07401b.f395accd246ae52d<span style="color:#bbb">
</span></code></pre></div><!--
The important elements to note are:

* `certificate-authority`: path to a CA file, used to validate the server certificate presented by kube-apiserver
* `server`: URL to kube-apiserver
* `token`: the token to use
-->
<p>需要额外注意的一些因素有：</p>
<ul>
<li><code>certificate-authority</code>：指向 CA 文件的路径，用来对 kube-apiserver 所出示
的服务器证书进行验证</li>
<li><code>server</code>： 用来访问 kube-apiserver 的 URL</li>
<li><code>token</code>：要使用的令牌</li>
</ul>
<!--
The format of the token does not matter, as long as it matches what kube-apiserver expects. In the above example, we used a bootstrap token.
As stated earlier, _any_ valid authentication method can be used, not only tokens.

Because the bootstrap `kubeconfig` _is_ a standard `kubeconfig`, you can use `kubectl` to generate it. To create the above example file:
-->
<p>令牌的格式并不重要，只要它与 kube-apiserver 的期望匹配即可。
在上面的例子中，我们使用的是启动引导令牌。
如前所述，任何合法的身份认证方法都可以使用，不限于令牌。</p>
<p>因为启动引导 <code>kubeconfig</code> 文件是一个标准的 <code>kubeconfig</code> 文件，你可以使用
<code>kubectl</code> 来生成该文件。要生成上面的示例文件：</p>
<pre tabindex="0"><code>kubectl config --kubeconfig=/var/lib/kubelet/bootstrap-kubeconfig set-cluster bootstrap --server='https://my.server.example.com:6443' --certificate-authority=/var/lib/kubernetes/ca.pem
kubectl config --kubeconfig=/var/lib/kubelet/bootstrap-kubeconfig set-credentials kubelet-bootstrap --token=07401b.f395accd246ae52d
kubectl config --kubeconfig=/var/lib/kubelet/bootstrap-kubeconfig set-context bootstrap --user=kubelet-bootstrap --cluster=bootstrap
kubectl config --kubeconfig=/var/lib/kubelet/bootstrap-kubeconfig use-context bootstrap
</code></pre><!--
To indicate to the kubelet to use the bootstrap `kubeconfig`, use the following kubelet flag:
-->
<p>要指示 kubelet 使用启动引导 <code>kubeconfig</code> 文件，可以使用下面的 kubelet 标志：</p>
<pre tabindex="0"><code>--bootstrap-kubeconfig=&quot;/var/lib/kubelet/bootstrap-kubeconfig&quot; --kubeconfig=&quot;/var/lib/kubelet/kubeconfig&quot;
</code></pre><!--
When starting the kubelet, if the file specified via `--kubeconfig` does not
exist, the bootstrap kubeconfig specified via `--bootstrap-kubeconfig` is used
to request a client certificate from the API server. On approval of the
certificate request and receipt back by the kubelet, a kubeconfig file
referencing the generated key and obtained certificate is written to the path
specified by `--kubeconfig`. The certificate and key file will be placed in the
directory specified by `--cert-dir`.
-->
<p>在启动 kubelet 时，如果 <code>--kubeconfig</code> 标志所指定的文件并不存在，会使用通过标志
<code>--bootstrap-kubeconfig</code> 所指定的启动引导 kubeconfig 配置来向 API 服务器请求
客户端证书。在证书请求被批复并被 kubelet 收回时，一个引用所生成的密钥和所获得
证书的 kubeconfig 文件会被写入到通过 <code>--kubeconfig</code> 所指定的文件路径下。
证书和密钥文件会被放到 <code>--cert-dir</code> 所指定的目录中。</p>
<!--
### Client and Serving Certificates

All of the above relate to kubelet _client_ certificates, specifically, the certificates a kubelet
uses to authenticate to kube-apiserver.
-->
<h3 id="client-and-serving-certificates">客户和服务证书  </h3>
<p>前文所述的内容都与 kubelet <em>客户端</em> 证书相关，尤其是 kubelet 用来向
kube-apiserver 认证自身身份的证书。</p>
<!--
A kubelet also can use _serving_ certificates. The kubelet itself exposes an https endpoint for certain features.
To secure these, the kubelet can do one of:

* use provided key and certificate, via the `--tls-private-key-file` and `--tls-cert-file` flags
* create self-signed key and certificate, if a key and certificate are not provided
* request serving certificates from the cluster server, via the CSR API
-->
<p>kubelet 也可以使用 <em>服务（Serving）</em> 证书。kubelet 自身向外提供一个
HTTPS 末端，包含若干功能特性。要保证这些末端的安全性，kubelet 可以执行以下操作
之一：</p>
<ul>
<li>使用通过 <code>--tls-private-key-file</code> 和 <code>--tls-cert-file</code> 所设置的密钥和证书</li>
<li>如果没有提供密钥和证书，则创建自签名的密钥和证书</li>
<li>通过 CSR API 从集群服务器请求服务证书</li>
</ul>
<!--
The client certificate provided by TLS bootstrapping is signed, by default, for `client auth` only, and thus cannot
be used as serving certificates, or `server auth`.

However, you _can_ enable its server certificate, at least partially, via certificate rotation.
-->
<p>TLS 启动引导所提供的客户端证书默认被签名为仅用于 <code>client auth</code>（客户端认证），
因此不能作为提供服务的证书，或者 <code>server auth</code>。</p>
<p>不过，你可以启用服务器证书，至少可以部分地通过证书轮换来实现这点。</p>
<!--
### Certificate Rotation

Kubernetes v1.8 and higher kubelet implements __beta__ features for enabling
rotation of its client and/or serving certificates.  These can be enabled through
the respective `RotateKubeletClientCertificate` and
`RotateKubeletServerCertificate` feature flags on the kubelet and are enabled by
default.
-->
<h3 id="certificate-rotation">证书轮换   </h3>
<p>Kubernetes v1.8 和更高版本的 kubelet 实现了对客户端证书与/或服务证书进行轮换
这一 Beta 特性。这一特性通过 kubelet 对应的 <code>RotateKubeletClientCertificate</code> 和
<code>RotateKubeletServerCertificate</code> 特性门控标志来控制，并且是默认启用的。</p>
<!--
`RotateKubeletClientCertificate` causes the kubelet to rotate its client
certificates by creating new CSRs as its existing credentials expire. To enable
this feature pass the following flag to the kubelet:
-->
<p><code>RotateKubeletClientCertificate</code> 会导致 kubelet 在其现有凭据即将过期时通过
创建新的 CSR 来轮换其客户端证书。要启用此功能特性，可将下面的标志传递给
kubelet：</p>
<pre tabindex="0"><code>--rotate-certificates
</code></pre><!--
`RotateKubeletServerCertificate` causes the kubelet **both** to request a serving
certificate after bootstrapping its client credentials **and** to rotate that
certificate. To enable this feature pass the following flag to the kubelet:
-->
<p><code>RotateKubeletServerCertificate</code> 会让 kubelet 在启动引导其客户端凭据之后请求
一个服务证书 <strong>且</strong> 对该服务证书执行轮换操作。要启用此功能特性，将下面的标志
传递给 kubelet：</p>
<pre tabindex="0"><code>--rotate-server-certificates
</code></pre><blockquote class="note callout">
  <div><strong>说明：</strong> <!--
The CSR approving controllers implemented in core Kubernetes do not
approve node _serving_ certificates for [security
reasons](https://github.com/kubernetes/community/pull/1982). To use
`RotateKubeletServerCertificate` operators need to run a custom approving
controller, or manually approve the serving certificate requests.
-->
<p>Kubernetes 核心中所实现的 CSR 批复控制器出于
<a href="https://github.com/kubernetes/community/pull/1982">安全原因</a>
并不会自动批复节点的 <em>服务</em> 证书。
要使用 <code>RotateKubeletServerCertificate</code> 功能特性，集群运维人员需要运行一个
定制的控制器或者手动批复服务证书的请求。</p>
<!--
A deployment-specific approval process for kubelet serving certificates should typically only approve CSRs which:

1. are requested by nodes (ensure the `spec.username` field is of the form 
   `system:node:<nodeName>` and `spec.groups` contains `system:nodes`) 
2. request usages for a serving certificate (ensure `spec.usages` contains `server auth`, 
   optionally contains `digital signature` and `key encipherment`, and contains no other usages)
3. only have IP and DNS subjectAltNames that belong to the requesting node, 
   and have no URI and Email subjectAltNames (parse the x509 Certificate Signing Request 
   in `spec.request` to verify `subjectAltNames`)
-->
<p>对 kubelet 服务证书的批复过程因集群部署而异，通常应该仅批复如下 CSR：</p>
<ol>
<li>由节点发出的请求（确保 <code>spec.username</code> 字段形式为 <code>system:node:&lt;nodeName&gt;</code>
且 <code>spec.groups</code> 包含 <code>system:nodes</code>）</li>
<li>请求中包含服务证书用法（确保 <code>spec.usages</code> 中包含 <code>server auth</code>，可选地也可
包含 <code>digital signature</code> 和 <code>key encipherment</code>，且不包含其它用法）</li>
<li>仅包含隶属于请求节点的 IP 和 DNS 的 <code>subjectAltNames</code>，没有 URI 和 Email
形式的 <code>subjectAltNames</code>（解析 <code>spec.request</code> 中的 x509 证书签名请求可以
检查 <code>subjectAltNames</code>）</li>
</ol>
</div>
</blockquote>
<!--
## Other authenticating components

All of TLS bootstrapping described in this document relates to the kubelet. However,
other components may need to communicate directly with kube-apiserver. Notable is kube-proxy, which
is part of the Kubernetes control plane and runs on every node, but may also include other components such as monitoring or networking.
-->
<h2 id="other-authenticating-components">其它身份认证组件  </h2>
<p>本文所描述的所有 TLS 启动引导内容都与 kubelet 相关。不过，其它组件也可能需要
直接与 kube-apiserver 直接通信。容易想到的是 kube-proxy，同样隶属于
Kubernetes 的控制面并且运行在所有节点之上，不过也可能包含一些其它负责
监控或者联网的组件。</p>
<!--
Like the kubelet, these other components also require a method of authenticating to kube-apiserver.
You have several options for generating these credentials:
-->
<p>与 kubelet 类似，这些其它组件也需要一种向 kube-apiserver 认证身份的方法。
你可以用几种方法来生成这类凭据：</p>
<!--
* The old way: Create and distribute certificates the same way you did for kubelet before TLS bootstrapping
* DaemonSet: Since the kubelet itself is loaded on each node, and is sufficient to start base services, you can run kube-proxy and other node-specific services not as a standalone process, but rather as a daemonset in the `kube-system` namespace. Since it will be in-cluster, you can give it a proper service account with appropriate permissions to perform its activities. This may be the simplest way to configure such services.
-->
<ul>
<li>较老的方式：和 kubelet 在 TLS 启动引导之前所做的一样，用类似的方式
创建和分发证书</li>
<li>DaemonSet：由于 kubelet 自身被加载到所有节点之上，并且有足够能力来启动基本服务，
你可以运行将 kube-proxy 和其它特定节点的服务作为 <code>kube-system</code> 名字空间中的
DaemonSet 来执行，而不是独立的进程。由于 DaemonSet 位于集群内部，你可以为其
指派一个合适的服务账户，使之具有适当的访问权限来完成其使命。这也许是配置此类
服务的最简单的方法。</li>
</ul>
<!--
## kubectl approval

CSRs can be approved outside of the approval flows builtin to the controller
manager.
-->
<h2 id="kubectl-approval">kubectl 批复   </h2>
<p>CSRs 可以在控制器管理其内置的批复工作流之外被批复。</p>
<!--
The signing controller does not immediately sign all certificate requests.
Instead, it waits until they have been flagged with an "Approved" status by an
appropriately-privileged user. This flow is intended to allow for automated
approval handled by an external approval controller or the approval controller
implemented in the core controller-manager. However cluster administrators can
also manually approve certificate requests using kubectl. An administrator can
list CSRs with `kubectl get csr` and describe one in detail with `kubectl
describe csr <name>`. An administrator can approve or deny a CSR with `kubectl
certificate approve <name>` and `kubectl certificate deny <name>`.
-->
<p>签名控制器并不会立即对所有证书请求执行签名操作。相反，它会等待这些请求被某
具有适当特权的用户标记为 “Approved（已批准）”状态。
这一流程有意允许由外部批复控制器来自动执行的批复，或者由控制器管理器内置的
批复控制器来自动批复。
不过，集群管理员也可以使用 <code>kubectl</code> 来手动批准证书请求。
管理员可以通过 <code>kubectl get csr</code> 来列举所有的 CSR，使用
<code>kubectl descsribe csr &lt;name&gt;</code> 来描述某个 CSR 的细节。
管理员可以使用 <code>kubectl certificate approve &lt;name</code> 来批准某 CSR，或者
<code>kubectl certificate deny &lt;name&gt;</code> 来拒绝某 CSR。</p>

</div>



    
	
  

    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-a6ae13190e147ef3922315c2091fc258">10 - 配置 API</h1>
    
	
</div>



    
      
  
  
  
  

  
  

  
    
    
	
    

<div class="td-content" style="">
    
	<h1 id="pg-2896357fe4f62fe85522254410e0be7d">10.1 - Client Authentication (v1beta1)</h1>
    
	<h2 id="resource-types">Resource Types</h2>
<ul>
<li><a href="#client-authentication-k8s-io-v1beta1-ExecCredential">ExecCredential</a></li>
</ul>
<h2 id="client-authentication-k8s-io-v1beta1-ExecCredential"><code>ExecCredential</code>    </h2>
<p>ExecCredential is used by exec-based plugins to communicate credentials to
HTTP transports.</p>
<table class="table">
<thead><tr><th width="30%">Field</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>apiVersion</code><br/>string</td><td><code>client.authentication.k8s.io/v1beta1</code></td></tr>
<tr><td><code>kind</code><br/>string</td><td><code>ExecCredential</code></td></tr>
<tr><td><code>spec</code> <B>[Required]</B><br/>
<a href="#client-authentication-k8s-io-v1beta1-ExecCredentialSpec"><code>ExecCredentialSpec</code></a>
</td>
<td>
   Spec holds information passed to the plugin by the transport.</td>
</tr>
<tr><td><code>status</code><br/>
<a href="#client-authentication-k8s-io-v1beta1-ExecCredentialStatus"><code>ExecCredentialStatus</code></a>
</td>
<td>
   Status is filled in by the plugin and holds the credentials that the transport
should use to contact the API.</td>
</tr>
</tbody>
</table>
<h2 id="client-authentication-k8s-io-v1beta1-Cluster"><code>Cluster</code>    </h2>
<p><strong>Appears in:</strong></p>
<ul>
<li><a href="#client-authentication-k8s-io-v1beta1-ExecCredentialSpec">ExecCredentialSpec</a></li>
</ul>
<p>Cluster contains information to allow an exec plugin to communicate
with the kubernetes cluster being authenticated to.</p>
<p>To ensure that this struct contains everything someone would need to communicate
with a kubernetes cluster (just like they would via a kubeconfig), the fields
should shadow &quot;k8s.io/client-go/tools/clientcmd/api/v1&quot;.Cluster, with the exception
of CertificateAuthority, since CA data will always be passed to the plugin as bytes.</p>
<table class="table">
<thead><tr><th width="30%">Field</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>server</code> <B>[Required]</B><br/>
<code>string</code>
</td>
<td>
   Server is the address of the kubernetes cluster (https://hostname:port).</td>
</tr>
<tr><td><code>tls-server-name</code><br/>
<code>string</code>
</td>
<td>
   TLSServerName is passed to the server for SNI and is used in the client to
check server certificates against. If ServerName is empty, the hostname
used to contact the server is used.</td>
</tr>
<tr><td><code>insecure-skip-tls-verify</code><br/>
<code>bool</code>
</td>
<td>
   InsecureSkipTLSVerify skips the validity check for the server's certificate.
This will make your HTTPS connections insecure.</td>
</tr>
<tr><td><code>certificate-authority-data</code><br/>
<code>[]byte</code>
</td>
<td>
   CAData contains PEM-encoded certificate authority certificates.
If empty, system roots should be used.</td>
</tr>
<tr><td><code>proxy-url</code><br/>
<code>string</code>
</td>
<td>
   ProxyURL is the URL to the proxy to be used for all requests to this
cluster.</td>
</tr>
<tr><td><code>config</code><br/>
<a href="https://godoc.org/k8s.io/apimachinery/pkg/runtime/#RawExtension"><code>k8s.io/apimachinery/pkg/runtime.RawExtension</code></a>
</td>
<td>
   Config holds additional config data that is specific to the exec
plugin with regards to the cluster being authenticated to.
<p>This data is sourced from the clientcmd Cluster object's
extensions[client.authentication.k8s.io/exec] field:</p>
<p>clusters:</p>
<ul>
<li>name: my-cluster
cluster:
...
extensions:
<ul>
<li>name: client.authentication.k8s.io/exec  # reserved extension name for per cluster exec config
extension:
audience: 06e3fbd18de8  # arbitrary config</li>
</ul>
</li>
</ul>
<p>In some environments, the user config may be exactly the same across many clusters
(i.e. call this exec plugin) minus some details that are specific to each cluster
such as the audience.  This field allows the per cluster config to be directly
specified with the cluster info.  Using this field to store secret data is not
recommended as one of the prime benefits of exec plugins is that no secrets need
to be stored directly in the kubeconfig.</td></p>
</tr>
</tbody>
</table>
<h2 id="client-authentication-k8s-io-v1beta1-ExecCredentialSpec"><code>ExecCredentialSpec</code>    </h2>
<p><strong>Appears in:</strong></p>
<ul>
<li><a href="#client-authentication-k8s-io-v1beta1-ExecCredential">ExecCredential</a></li>
</ul>
<p>ExecCredentialSpec holds request and runtime specific information provided by
the transport.</p>
<table class="table">
<thead><tr><th width="30%">Field</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>cluster</code><br/>
<a href="#client-authentication-k8s-io-v1beta1-Cluster"><code>Cluster</code></a>
</td>
<td>
   Cluster contains information to allow an exec plugin to communicate with the
kubernetes cluster being authenticated to. Note that Cluster is non-nil only
when provideClusterInfo is set to true in the exec provider config (i.e.,
ExecConfig.ProvideClusterInfo).</td>
</tr>
</tbody>
</table>
<h2 id="client-authentication-k8s-io-v1beta1-ExecCredentialStatus"><code>ExecCredentialStatus</code>    </h2>
<p><strong>Appears in:</strong></p>
<ul>
<li><a href="#client-authentication-k8s-io-v1beta1-ExecCredential">ExecCredential</a></li>
</ul>
<p>ExecCredentialStatus holds credentials for the transport to use.</p>
<p>Token and ClientKeyData are sensitive fields. This data should only be
transmitted in-memory between client and exec plugin process. Exec plugin
itself should at least be protected via file permissions.</p>
<table class="table">
<thead><tr><th width="30%">Field</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>expirationTimestamp</code><br/>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.20/#time-v1-meta"><code>meta/v1.Time</code></a>
</td>
<td>
   ExpirationTimestamp indicates a time when the provided credentials expire.</td>
</tr>
<tr><td><code>token</code> <B>[Required]</B><br/>
<code>string</code>
</td>
<td>
   Token is a bearer token used by the client for request authentication.</td>
</tr>
<tr><td><code>clientCertificateData</code> <B>[Required]</B><br/>
<code>string</code>
</td>
<td>
   PEM-encoded client TLS certificates (including intermediates, if any).</td>
</tr>
<tr><td><code>clientKeyData</code> <B>[Required]</B><br/>
<code>string</code>
</td>
<td>
   PEM-encoded private key for the above certificate.</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-8f61883225b6bed85530d1904e148392">10.2 - kube-apiserver Audit Configuration (v1)</h1>
    
	<h2 id="resource-types">Resource Types</h2>
<ul>
<li><a href="#audit-k8s-io-v1-Event">Event</a></li>
<li><a href="#audit-k8s-io-v1-EventList">EventList</a></li>
<li><a href="#audit-k8s-io-v1-Policy">Policy</a></li>
<li><a href="#audit-k8s-io-v1-PolicyList">PolicyList</a></li>
</ul>
<h2 id="audit-k8s-io-v1-Event"><code>Event</code>    </h2>
<p><strong>Appears in:</strong></p>
<ul>
<li><a href="#audit-k8s-io-v1-EventList">EventList</a></li>
</ul>
<p>Event captures all the information that can be included in an API audit log.</p>
<table class="table">
<thead><tr><th width="30%">Field</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>apiVersion</code><br/>string</td><td><code>audit.k8s.io/v1</code></td></tr>
<tr><td><code>kind</code><br/>string</td><td><code>Event</code></td></tr>
<tr><td><code>level</code> <B>[Required]</B><br/>
<a href="#audit-k8s-io-v1-Level"><code>Level</code></a>
</td>
<td>
   AuditLevel at which event was generated</td>
</tr>
<tr><td><code>auditID</code> <B>[Required]</B><br/>
<a href="https://godoc.org/k8s.io/apimachinery/pkg/types#UID"><code>k8s.io/apimachinery/pkg/types.UID</code></a>
</td>
<td>
   Unique audit ID, generated for each request.</td>
</tr>
<tr><td><code>stage</code> <B>[Required]</B><br/>
<a href="#audit-k8s-io-v1-Stage"><code>Stage</code></a>
</td>
<td>
   Stage of the request handling when this event instance was generated.</td>
</tr>
<tr><td><code>requestURI</code> <B>[Required]</B><br/>
<code>string</code>
</td>
<td>
   RequestURI is the request URI as sent by the client to a server.</td>
</tr>
<tr><td><code>verb</code> <B>[Required]</B><br/>
<code>string</code>
</td>
<td>
   Verb is the kubernetes verb associated with the request.
For non-resource requests, this is the lower-cased HTTP method.</td>
</tr>
<tr><td><code>user</code> <B>[Required]</B><br/>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.20/#userinfo-v1-authentication"><code>authentication/v1.UserInfo</code></a>
</td>
<td>
   Authenticated user information.</td>
</tr>
<tr><td><code>impersonatedUser</code><br/>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.20/#userinfo-v1-authentication"><code>authentication/v1.UserInfo</code></a>
</td>
<td>
   Impersonated user information.</td>
</tr>
<tr><td><code>sourceIPs</code><br/>
<code>[]string</code>
</td>
<td>
   Source IPs, from where the request originated and intermediate proxies.</td>
</tr>
<tr><td><code>userAgent</code><br/>
<code>string</code>
</td>
<td>
   UserAgent records the user agent string reported by the client.
Note that the UserAgent is provided by the client, and must not be trusted.</td>
</tr>
<tr><td><code>objectRef</code><br/>
<a href="#audit-k8s-io-v1-ObjectReference"><code>ObjectReference</code></a>
</td>
<td>
   Object reference this request is targeted at.
Does not apply for List-type requests, or non-resource requests.</td>
</tr>
<tr><td><code>responseStatus</code><br/>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.20/#status-v1-meta"><code>meta/v1.Status</code></a>
</td>
<td>
   The response status, populated even when the ResponseObject is not a Status type.
For successful responses, this will only include the Code and StatusSuccess.
For non-status type error responses, this will be auto-populated with the error Message.</td>
</tr>
<tr><td><code>requestObject</code><br/>
<a href="https://godoc.org/k8s.io/apimachinery/pkg/runtime#Unknown"><code>k8s.io/apimachinery/pkg/runtime.Unknown</code></a>
</td>
<td>
   API object from the request, in JSON format. The RequestObject is recorded as-is in the request
(possibly re-encoded as JSON), prior to version conversion, defaulting, admission or
merging. It is an external versioned object type, and may not be a valid object on its own.
Omitted for non-resource requests.  Only logged at Request Level and higher.</td>
</tr>
<tr><td><code>responseObject</code><br/>
<a href="https://godoc.org/k8s.io/apimachinery/pkg/runtime#Unknown"><code>k8s.io/apimachinery/pkg/runtime.Unknown</code></a>
</td>
<td>
   API object returned in the response, in JSON. The ResponseObject is recorded after conversion
to the external type, and serialized as JSON.  Omitted for non-resource requests.  Only logged
at Response Level.</td>
</tr>
<tr><td><code>requestReceivedTimestamp</code><br/>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.20/#microtime-v1-meta"><code>meta/v1.MicroTime</code></a>
</td>
<td>
   Time the request reached the apiserver.</td>
</tr>
<tr><td><code>stageTimestamp</code><br/>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.20/#microtime-v1-meta"><code>meta/v1.MicroTime</code></a>
</td>
<td>
   Time the request reached current audit stage.</td>
</tr>
<tr><td><code>annotations</code><br/>
<code>map[string]string</code>
</td>
<td>
   Annotations is an unstructured key value map stored with an audit event that may be set by
plugins invoked in the request serving chain, including authentication, authorization and
admission plugins. Note that these annotations are for the audit event, and do not correspond
to the metadata.annotations of the submitted object. Keys should uniquely identify the informing
component to avoid name collisions (e.g. podsecuritypolicy.admission.k8s.io/policy). Values
should be short. Annotations are included in the Metadata level.</td>
</tr>
</tbody>
</table>
<h2 id="audit-k8s-io-v1-EventList"><code>EventList</code>    </h2>
<p>EventList is a list of audit Events.</p>
<table class="table">
<thead><tr><th width="30%">Field</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>apiVersion</code><br/>string</td><td><code>audit.k8s.io/v1</code></td></tr>
<tr><td><code>kind</code><br/>string</td><td><code>EventList</code></td></tr>
<tr><td><code>metadata</code><br/>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.20/#listmeta-v1-meta"><code>meta/v1.ListMeta</code></a>
</td>
<td>
   <span class="text-muted">No description provided.</span>
   </td>
</tr>
<tr><td><code>items</code> <B>[Required]</B><br/>
<a href="#audit-k8s-io-v1-Event"><code>[]Event</code></a>
</td>
<td>
   <span class="text-muted">No description provided.</span>
   </td>
</tr>
</tbody>
</table>
<h2 id="audit-k8s-io-v1-Policy"><code>Policy</code>    </h2>
<p><strong>Appears in:</strong></p>
<ul>
<li><a href="#audit-k8s-io-v1-PolicyList">PolicyList</a></li>
</ul>
<p>Policy defines the configuration of audit logging, and the rules for how different request
categories are logged.</p>
<table class="table">
<thead><tr><th width="30%">Field</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>apiVersion</code><br/>string</td><td><code>audit.k8s.io/v1</code></td></tr>
<tr><td><code>kind</code><br/>string</td><td><code>Policy</code></td></tr>
<tr><td><code>metadata</code><br/>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.20/#objectmeta-v1-meta"><code>meta/v1.ObjectMeta</code></a>
</td>
<td>
   ObjectMeta is included for interoperability with API infrastructure.Refer to the Kubernetes API documentation for the fields of the <code>metadata</code> field.</td>
</tr>
<tr><td><code>rules</code> <B>[Required]</B><br/>
<a href="#audit-k8s-io-v1-PolicyRule"><code>[]PolicyRule</code></a>
</td>
<td>
   Rules specify the audit Level a request should be recorded at.
A request may match multiple rules, in which case the FIRST matching rule is used.
The default audit level is None, but can be overridden by a catch-all rule at the end of the list.
PolicyRules are strictly ordered.</td>
</tr>
<tr><td><code>omitStages</code><br/>
<a href="#audit-k8s-io-v1-Stage"><code>[]Stage</code></a>
</td>
<td>
   OmitStages is a list of stages for which no events are created. Note that this can also
be specified per rule in which case the union of both are omitted.</td>
</tr>
</tbody>
</table>
<h2 id="audit-k8s-io-v1-PolicyList"><code>PolicyList</code>    </h2>
<p>PolicyList is a list of audit Policies.</p>
<table class="table">
<thead><tr><th width="30%">Field</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>apiVersion</code><br/>string</td><td><code>audit.k8s.io/v1</code></td></tr>
<tr><td><code>kind</code><br/>string</td><td><code>PolicyList</code></td></tr>
<tr><td><code>metadata</code><br/>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.20/#listmeta-v1-meta"><code>meta/v1.ListMeta</code></a>
</td>
<td>
   <span class="text-muted">No description provided.</span>
   </td>
</tr>
<tr><td><code>items</code> <B>[Required]</B><br/>
<a href="#audit-k8s-io-v1-Policy"><code>[]Policy</code></a>
</td>
<td>
   <span class="text-muted">No description provided.</span>
   </td>
</tr>
</tbody>
</table>
<h2 id="audit-k8s-io-v1-GroupResources"><code>GroupResources</code>    </h2>
<p><strong>Appears in:</strong></p>
<ul>
<li><a href="#audit-k8s-io-v1-PolicyRule">PolicyRule</a></li>
</ul>
<p>GroupResources represents resource kinds in an API group.</p>
<table class="table">
<thead><tr><th width="30%">Field</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>group</code><br/>
<code>string</code>
</td>
<td>
   Group is the name of the API group that contains the resources.
The empty string represents the core API group.</td>
</tr>
<tr><td><code>resources</code><br/>
<code>[]string</code>
</td>
<td>
   Resources is a list of resources this rule applies to.
<p>For example:
'pods' matches pods.
'pods/log' matches the log subresource of pods.
'∗' matches all resources and their subresources.
'pods/∗' matches all subresources of pods.
'∗/scale' matches all scale subresources.</p>
<p>If wildcard is present, the validation rule will ensure resources do not
overlap with each other.</p>
<p>An empty list implies all resources and subresources in this API groups apply.</td></p>
</tr>
<tr><td><code>resourceNames</code><br/>
<code>[]string</code>
</td>
<td>
   ResourceNames is a list of resource instance names that the policy matches.
Using this field requires Resources to be specified.
An empty list implies that every instance of the resource is matched.</td>
</tr>
</tbody>
</table>
<h2 id="audit-k8s-io-v1-Level"><code>Level</code>    </h2>
<p>(Alias of <code>string</code>)</p>
<p><strong>Appears in:</strong></p>
<ul>
<li>
<p><a href="#audit-k8s-io-v1-Event">Event</a></p>
</li>
<li>
<p><a href="#audit-k8s-io-v1-PolicyRule">PolicyRule</a></p>
</li>
</ul>
<p>Level defines the amount of information logged during auditing</p>
<h2 id="audit-k8s-io-v1-ObjectReference"><code>ObjectReference</code>    </h2>
<p><strong>Appears in:</strong></p>
<ul>
<li><a href="#audit-k8s-io-v1-Event">Event</a></li>
</ul>
<p>ObjectReference contains enough information to let you inspect or modify the referred object.</p>
<table class="table">
<thead><tr><th width="30%">Field</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>resource</code><br/>
<code>string</code>
</td>
<td>
   <span class="text-muted">No description provided.</span>
   </td>
</tr>
<tr><td><code>namespace</code><br/>
<code>string</code>
</td>
<td>
   <span class="text-muted">No description provided.</span>
   </td>
</tr>
<tr><td><code>name</code><br/>
<code>string</code>
</td>
<td>
   <span class="text-muted">No description provided.</span>
   </td>
</tr>
<tr><td><code>uid</code><br/>
<a href="https://godoc.org/k8s.io/apimachinery/pkg/types#UID"><code>k8s.io/apimachinery/pkg/types.UID</code></a>
</td>
<td>
   <span class="text-muted">No description provided.</span>
   </td>
</tr>
<tr><td><code>apiGroup</code><br/>
<code>string</code>
</td>
<td>
   APIGroup is the name of the API group that contains the referred object.
The empty string represents the core API group.</td>
</tr>
<tr><td><code>apiVersion</code><br/>
<code>string</code>
</td>
<td>
   APIVersion is the version of the API group that contains the referred object.</td>
</tr>
<tr><td><code>resourceVersion</code><br/>
<code>string</code>
</td>
<td>
   <span class="text-muted">No description provided.</span>
   </td>
</tr>
<tr><td><code>subresource</code><br/>
<code>string</code>
</td>
<td>
   <span class="text-muted">No description provided.</span>
   </td>
</tr>
</tbody>
</table>
<h2 id="audit-k8s-io-v1-PolicyRule"><code>PolicyRule</code>    </h2>
<p><strong>Appears in:</strong></p>
<ul>
<li><a href="#audit-k8s-io-v1-Policy">Policy</a></li>
</ul>
<p>PolicyRule maps requests based off metadata to an audit Level.
Requests must match the rules of every field (an intersection of rules).</p>
<table class="table">
<thead><tr><th width="30%">Field</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>level</code> <B>[Required]</B><br/>
<a href="#audit-k8s-io-v1-Level"><code>Level</code></a>
</td>
<td>
   The Level that requests matching this rule are recorded at.</td>
</tr>
<tr><td><code>users</code><br/>
<code>[]string</code>
</td>
<td>
   The users (by authenticated user name) this rule applies to.
An empty list implies every user.</td>
</tr>
<tr><td><code>userGroups</code><br/>
<code>[]string</code>
</td>
<td>
   The user groups this rule applies to. A user is considered matching
if it is a member of any of the UserGroups.
An empty list implies every user group.</td>
</tr>
<tr><td><code>verbs</code><br/>
<code>[]string</code>
</td>
<td>
   The verbs that match this rule.
An empty list implies every verb.</td>
</tr>
<tr><td><code>resources</code><br/>
<a href="#audit-k8s-io-v1-GroupResources"><code>[]GroupResources</code></a>
</td>
<td>
   Resources that this rule matches. An empty list implies all kinds in all API groups.</td>
</tr>
<tr><td><code>namespaces</code><br/>
<code>[]string</code>
</td>
<td>
   Namespaces that this rule matches.
The empty string "" matches non-namespaced resources.
An empty list implies every namespace.</td>
</tr>
<tr><td><code>nonResourceURLs</code><br/>
<code>[]string</code>
</td>
<td>
   NonResourceURLs is a set of URL paths that should be audited.
&lowast;s are allowed, but only as the full, final step in the path.
Examples:
 "/metrics" - Log requests for apiserver metrics
 "/healthz&lowast;" - Log all health checks</td>
</tr>
<tr><td><code>omitStages</code><br/>
<a href="#audit-k8s-io-v1-Stage"><code>[]Stage</code></a>
</td>
<td>
   OmitStages is a list of stages for which no events are created. Note that this can also
be specified policy wide in which case the union of both are omitted.
An empty list means no restrictions will apply.</td>
</tr>
</tbody>
</table>
<h2 id="audit-k8s-io-v1-Stage"><code>Stage</code>    </h2>
<p>(Alias of <code>string</code>)</p>
<p><strong>Appears in:</strong></p>
<ul>
<li>
<p><a href="#audit-k8s-io-v1-Event">Event</a></p>
</li>
<li>
<p><a href="#audit-k8s-io-v1-Policy">Policy</a></p>
</li>
<li>
<p><a href="#audit-k8s-io-v1-PolicyRule">PolicyRule</a></p>
</li>
</ul>
<p>Stage defines the stages in request handling that audit events may be generated.</p>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-d8644f8d8b33ff33a31c8b55065eaf37">10.3 - kube-proxy Configuration (v1alpha1)</h1>
    
	<h2 id="resource-types">Resource Types</h2>
<ul>
<li><a href="#kubeproxy-config-k8s-io-v1alpha1-KubeProxyConfiguration">KubeProxyConfiguration</a></li>
</ul>
<h2 id="kubeproxy-config-k8s-io-v1alpha1-KubeProxyConfiguration"><code>KubeProxyConfiguration</code>    </h2>
<p>KubeProxyConfiguration contains everything necessary to configure the
Kubernetes proxy server.</p>
<table class="table">
<thead><tr><th width="30%">Field</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>apiVersion</code><br/>string</td><td><code>kubeproxy.config.k8s.io/v1alpha1</code></td></tr>
<tr><td><code>kind</code><br/>string</td><td><code>KubeProxyConfiguration</code></td></tr>
<tr><td><code>featureGates</code> <B>[Required]</B><br/>
<code>map[string]bool</code>
</td>
<td>
   featureGates is a map of feature names to bools that enable or disable alpha/experimental features.</td>
</tr>
<tr><td><code>bindAddress</code> <B>[Required]</B><br/>
<code>string</code>
</td>
<td>
   bindAddress is the IP address for the proxy server to serve on (set to 0.0.0.0
for all interfaces)</td>
</tr>
<tr><td><code>healthzBindAddress</code> <B>[Required]</B><br/>
<code>string</code>
</td>
<td>
   healthzBindAddress is the IP address and port for the health check server to serve on,
defaulting to 0.0.0.0:10256</td>
</tr>
<tr><td><code>metricsBindAddress</code> <B>[Required]</B><br/>
<code>string</code>
</td>
<td>
   metricsBindAddress is the IP address and port for the metrics server to serve on,
defaulting to 127.0.0.1:10249 (set to 0.0.0.0 for all interfaces)</td>
</tr>
<tr><td><code>bindAddressHardFail</code> <B>[Required]</B><br/>
<code>bool</code>
</td>
<td>
   bindAddressHardFail, if true, kube-proxy will treat failure to bind to a port as fatal and exit</td>
</tr>
<tr><td><code>enableProfiling</code> <B>[Required]</B><br/>
<code>bool</code>
</td>
<td>
   enableProfiling enables profiling via web interface on /debug/pprof handler.
Profiling handlers will be handled by metrics server.</td>
</tr>
<tr><td><code>clusterCIDR</code> <B>[Required]</B><br/>
<code>string</code>
</td>
<td>
   clusterCIDR is the CIDR range of the pods in the cluster. It is used to
bridge traffic coming from outside of the cluster. If not provided,
no off-cluster bridging will be performed.</td>
</tr>
<tr><td><code>hostnameOverride</code> <B>[Required]</B><br/>
<code>string</code>
</td>
<td>
   hostnameOverride, if non-empty, will be used as the identity instead of the actual hostname.</td>
</tr>
<tr><td><code>clientConnection</code> <B>[Required]</B><br/>
<a href="#ClientConnectionConfiguration"><code>ClientConnectionConfiguration</code></a>
</td>
<td>
   clientConnection specifies the kubeconfig file and client connection settings for the proxy
server to use when communicating with the apiserver.</td>
</tr>
<tr><td><code>iptables</code> <B>[Required]</B><br/>
<a href="#kubeproxy-config-k8s-io-v1alpha1-KubeProxyIPTablesConfiguration"><code>KubeProxyIPTablesConfiguration</code></a>
</td>
<td>
   iptables contains iptables-related configuration options.</td>
</tr>
<tr><td><code>ipvs</code> <B>[Required]</B><br/>
<a href="#kubeproxy-config-k8s-io-v1alpha1-KubeProxyIPVSConfiguration"><code>KubeProxyIPVSConfiguration</code></a>
</td>
<td>
   ipvs contains ipvs-related configuration options.</td>
</tr>
<tr><td><code>oomScoreAdj</code> <B>[Required]</B><br/>
<code>int32</code>
</td>
<td>
   oomScoreAdj is the oom-score-adj value for kube-proxy process. Values must be within
the range [-1000, 1000]</td>
</tr>
<tr><td><code>mode</code> <B>[Required]</B><br/>
<a href="#kubeproxy-config-k8s-io-v1alpha1-ProxyMode"><code>ProxyMode</code></a>
</td>
<td>
   mode specifies which proxy mode to use.</td>
</tr>
<tr><td><code>portRange</code> <B>[Required]</B><br/>
<code>string</code>
</td>
<td>
   portRange is the range of host ports (beginPort-endPort, inclusive) that may be consumed
in order to proxy service traffic. If unspecified (0-0) then ports will be randomly chosen.</td>
</tr>
<tr><td><code>udpIdleTimeout</code> <B>[Required]</B><br/>
<a href="https://godoc.org/k8s.io/apimachinery/pkg/apis/meta/v1#Duration"><code>meta/v1.Duration</code></a>
</td>
<td>
   udpIdleTimeout is how long an idle UDP connection will be kept open (e.g. '250ms', '2s').
Must be greater than 0. Only applicable for proxyMode=userspace.</td>
</tr>
<tr><td><code>conntrack</code> <B>[Required]</B><br/>
<a href="#kubeproxy-config-k8s-io-v1alpha1-KubeProxyConntrackConfiguration"><code>KubeProxyConntrackConfiguration</code></a>
</td>
<td>
   conntrack contains conntrack-related configuration options.</td>
</tr>
<tr><td><code>configSyncPeriod</code> <B>[Required]</B><br/>
<a href="https://godoc.org/k8s.io/apimachinery/pkg/apis/meta/v1#Duration"><code>meta/v1.Duration</code></a>
</td>
<td>
   configSyncPeriod is how often configuration from the apiserver is refreshed. Must be greater
than 0.</td>
</tr>
<tr><td><code>nodePortAddresses</code> <B>[Required]</B><br/>
<code>[]string</code>
</td>
<td>
   nodePortAddresses is the --nodeport-addresses value for kube-proxy process. Values must be valid
IP blocks. These values are as a parameter to select the interfaces where nodeport works.
In case someone would like to expose a service on localhost for local visit and some other interfaces for
particular purpose, a list of IP blocks would do that.
If set it to "127.0.0.0/8", kube-proxy will only select the loopback interface for NodePort.
If set it to a non-zero IP block, kube-proxy will filter that down to just the IPs that applied to the node.
An empty string slice is meant to select all network interfaces.</td>
</tr>
<tr><td><code>winkernel</code> <B>[Required]</B><br/>
<a href="#kubeproxy-config-k8s-io-v1alpha1-KubeProxyWinkernelConfiguration"><code>KubeProxyWinkernelConfiguration</code></a>
</td>
<td>
   winkernel contains winkernel-related configuration options.</td>
</tr>
<tr><td><code>showHiddenMetricsForVersion</code> <B>[Required]</B><br/>
<code>string</code>
</td>
<td>
   ShowHiddenMetricsForVersion is the version for which you want to show hidden metrics.</td>
</tr>
<tr><td><code>detectLocalMode</code> <B>[Required]</B><br/>
<a href="#kubeproxy-config-k8s-io-v1alpha1-LocalMode"><code>LocalMode</code></a>
</td>
<td>
   DetectLocalMode determines mode to use for detecting local traffic, defaults to LocalModeClusterCIDR</td>
</tr>
</tbody>
</table>
<h2 id="kubeproxy-config-k8s-io-v1alpha1-KubeProxyConntrackConfiguration"><code>KubeProxyConntrackConfiguration</code>    </h2>
<p><strong>Appears in:</strong></p>
<ul>
<li><a href="#kubeproxy-config-k8s-io-v1alpha1-KubeProxyConfiguration">KubeProxyConfiguration</a></li>
</ul>
<p>KubeProxyConntrackConfiguration contains conntrack settings for
the Kubernetes proxy server.</p>
<table class="table">
<thead><tr><th width="30%">Field</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>maxPerCore</code> <B>[Required]</B><br/>
<code>int32</code>
</td>
<td>
   maxPerCore is the maximum number of NAT connections to track
per CPU core (0 to leave the limit as-is and ignore min).</td>
</tr>
<tr><td><code>min</code> <B>[Required]</B><br/>
<code>int32</code>
</td>
<td>
   min is the minimum value of connect-tracking records to allocate,
regardless of conntrackMaxPerCore (set maxPerCore=0 to leave the limit as-is).</td>
</tr>
<tr><td><code>tcpEstablishedTimeout</code> <B>[Required]</B><br/>
<a href="https://godoc.org/k8s.io/apimachinery/pkg/apis/meta/v1#Duration"><code>meta/v1.Duration</code></a>
</td>
<td>
   tcpEstablishedTimeout is how long an idle TCP connection will be kept open
(e.g. '2s').  Must be greater than 0 to set.</td>
</tr>
<tr><td><code>tcpCloseWaitTimeout</code> <B>[Required]</B><br/>
<a href="https://godoc.org/k8s.io/apimachinery/pkg/apis/meta/v1#Duration"><code>meta/v1.Duration</code></a>
</td>
<td>
   tcpCloseWaitTimeout is how long an idle conntrack entry
in CLOSE_WAIT state will remain in the conntrack
table. (e.g. '60s'). Must be greater than 0 to set.</td>
</tr>
</tbody>
</table>
<h2 id="kubeproxy-config-k8s-io-v1alpha1-KubeProxyIPTablesConfiguration"><code>KubeProxyIPTablesConfiguration</code>    </h2>
<p><strong>Appears in:</strong></p>
<ul>
<li><a href="#kubeproxy-config-k8s-io-v1alpha1-KubeProxyConfiguration">KubeProxyConfiguration</a></li>
</ul>
<p>KubeProxyIPTablesConfiguration contains iptables-related configuration
details for the Kubernetes proxy server.</p>
<table class="table">
<thead><tr><th width="30%">Field</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>masqueradeBit</code> <B>[Required]</B><br/>
<code>int32</code>
</td>
<td>
   masqueradeBit is the bit of the iptables fwmark space to use for SNAT if using
the pure iptables proxy mode. Values must be within the range [0, 31].</td>
</tr>
<tr><td><code>masqueradeAll</code> <B>[Required]</B><br/>
<code>bool</code>
</td>
<td>
   masqueradeAll tells kube-proxy to SNAT everything if using the pure iptables proxy mode.</td>
</tr>
<tr><td><code>syncPeriod</code> <B>[Required]</B><br/>
<a href="https://godoc.org/k8s.io/apimachinery/pkg/apis/meta/v1#Duration"><code>meta/v1.Duration</code></a>
</td>
<td>
   syncPeriod is the period that iptables rules are refreshed (e.g. '5s', '1m',
'2h22m').  Must be greater than 0.</td>
</tr>
<tr><td><code>minSyncPeriod</code> <B>[Required]</B><br/>
<a href="https://godoc.org/k8s.io/apimachinery/pkg/apis/meta/v1#Duration"><code>meta/v1.Duration</code></a>
</td>
<td>
   minSyncPeriod is the minimum period that iptables rules are refreshed (e.g. '5s', '1m',
'2h22m').</td>
</tr>
</tbody>
</table>
<h2 id="kubeproxy-config-k8s-io-v1alpha1-KubeProxyIPVSConfiguration"><code>KubeProxyIPVSConfiguration</code>    </h2>
<p><strong>Appears in:</strong></p>
<ul>
<li><a href="#kubeproxy-config-k8s-io-v1alpha1-KubeProxyConfiguration">KubeProxyConfiguration</a></li>
</ul>
<p>KubeProxyIPVSConfiguration contains ipvs-related configuration
details for the Kubernetes proxy server.</p>
<table class="table">
<thead><tr><th width="30%">Field</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>syncPeriod</code> <B>[Required]</B><br/>
<a href="https://godoc.org/k8s.io/apimachinery/pkg/apis/meta/v1#Duration"><code>meta/v1.Duration</code></a>
</td>
<td>
   syncPeriod is the period that ipvs rules are refreshed (e.g. '5s', '1m',
'2h22m').  Must be greater than 0.</td>
</tr>
<tr><td><code>minSyncPeriod</code> <B>[Required]</B><br/>
<a href="https://godoc.org/k8s.io/apimachinery/pkg/apis/meta/v1#Duration"><code>meta/v1.Duration</code></a>
</td>
<td>
   minSyncPeriod is the minimum period that ipvs rules are refreshed (e.g. '5s', '1m',
'2h22m').</td>
</tr>
<tr><td><code>scheduler</code> <B>[Required]</B><br/>
<code>string</code>
</td>
<td>
   ipvs scheduler</td>
</tr>
<tr><td><code>excludeCIDRs</code> <B>[Required]</B><br/>
<code>[]string</code>
</td>
<td>
   excludeCIDRs is a list of CIDR's which the ipvs proxier should not touch
when cleaning up ipvs services.</td>
</tr>
<tr><td><code>strictARP</code> <B>[Required]</B><br/>
<code>bool</code>
</td>
<td>
   strict ARP configure arp_ignore and arp_announce to avoid answering ARP queries
from kube-ipvs0 interface</td>
</tr>
<tr><td><code>tcpTimeout</code> <B>[Required]</B><br/>
<a href="https://godoc.org/k8s.io/apimachinery/pkg/apis/meta/v1#Duration"><code>meta/v1.Duration</code></a>
</td>
<td>
   tcpTimeout is the timeout value used for idle IPVS TCP sessions.
The default value is 0, which preserves the current timeout value on the system.</td>
</tr>
<tr><td><code>tcpFinTimeout</code> <B>[Required]</B><br/>
<a href="https://godoc.org/k8s.io/apimachinery/pkg/apis/meta/v1#Duration"><code>meta/v1.Duration</code></a>
</td>
<td>
   tcpFinTimeout is the timeout value used for IPVS TCP sessions after receiving a FIN.
The default value is 0, which preserves the current timeout value on the system.</td>
</tr>
<tr><td><code>udpTimeout</code> <B>[Required]</B><br/>
<a href="https://godoc.org/k8s.io/apimachinery/pkg/apis/meta/v1#Duration"><code>meta/v1.Duration</code></a>
</td>
<td>
   udpTimeout is the timeout value used for IPVS UDP packets.
The default value is 0, which preserves the current timeout value on the system.</td>
</tr>
</tbody>
</table>
<h2 id="kubeproxy-config-k8s-io-v1alpha1-KubeProxyWinkernelConfiguration"><code>KubeProxyWinkernelConfiguration</code>    </h2>
<p><strong>Appears in:</strong></p>
<ul>
<li><a href="#kubeproxy-config-k8s-io-v1alpha1-KubeProxyConfiguration">KubeProxyConfiguration</a></li>
</ul>
<p>KubeProxyWinkernelConfiguration contains Windows/HNS settings for
the Kubernetes proxy server.</p>
<table class="table">
<thead><tr><th width="30%">Field</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>networkName</code> <B>[Required]</B><br/>
<code>string</code>
</td>
<td>
   networkName is the name of the network kube-proxy will use
to create endpoints and policies</td>
</tr>
<tr><td><code>sourceVip</code> <B>[Required]</B><br/>
<code>string</code>
</td>
<td>
   sourceVip is the IP address of the source VIP endoint used for
NAT when loadbalancing</td>
</tr>
<tr><td><code>enableDSR</code> <B>[Required]</B><br/>
<code>bool</code>
</td>
<td>
   enableDSR tells kube-proxy whether HNS policies should be created
with DSR</td>
</tr>
</tbody>
</table>
<h2 id="kubeproxy-config-k8s-io-v1alpha1-LocalMode"><code>LocalMode</code>    </h2>
<p>(Alias of <code>string</code>)</p>
<p><strong>Appears in:</strong></p>
<ul>
<li><a href="#kubeproxy-config-k8s-io-v1alpha1-KubeProxyConfiguration">KubeProxyConfiguration</a></li>
</ul>
<p>LocalMode represents modes to detect local traffic from the node</p>
<h2 id="kubeproxy-config-k8s-io-v1alpha1-ProxyMode"><code>ProxyMode</code>    </h2>
<p>(Alias of <code>string</code>)</p>
<p><strong>Appears in:</strong></p>
<ul>
<li><a href="#kubeproxy-config-k8s-io-v1alpha1-KubeProxyConfiguration">KubeProxyConfiguration</a></li>
</ul>
<p>ProxyMode represents modes used by the Kubernetes proxy server.</p>
<p>Currently, three modes of proxy are available in Linux platform: 'userspace' (older, going to be EOL), 'iptables'
(newer, faster), 'ipvs'(newest, better in performance and scalability).</p>
<p>Two modes of proxy are available in Windows platform: 'userspace'(older, stable) and 'kernelspace' (newer, faster).</p>
<p>In Linux platform, if proxy mode is blank, use the best-available proxy (currently iptables, but may change in the
future). If the iptables proxy is selected, regardless of how, but the system's kernel or iptables versions are
insufficient, this always falls back to the userspace proxy. IPVS mode will be enabled when proxy mode is set to 'ipvs',
and the fall back path is firstly iptables and then userspace.</p>
<p>In Windows platform, if proxy mode is blank, use the best-available proxy (currently userspace, but may change in the
future). If winkernel proxy is selected, regardless of how, but the Windows kernel can't support this mode of proxy,
this always falls back to the userspace proxy.</p>
<h2 id="ClientConnectionConfiguration"><code>ClientConnectionConfiguration</code>    </h2>
<p><strong>Appears in:</strong></p>
<ul>
<li><a href="#kubeproxy-config-k8s-io-v1alpha1-KubeProxyConfiguration">KubeProxyConfiguration</a></li>
</ul>
<p>ClientConnectionConfiguration contains details for constructing a client.</p>
<table class="table">
<thead><tr><th width="30%">Field</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>kubeconfig</code> <B>[Required]</B><br/>
<code>string</code>
</td>
<td>
   kubeconfig is the path to a KubeConfig file.</td>
</tr>
<tr><td><code>acceptContentTypes</code> <B>[Required]</B><br/>
<code>string</code>
</td>
<td>
   acceptContentTypes defines the Accept header sent by clients when connecting to a server, overriding the
default value of 'application/json'. This field will control all connections to the server used by a particular
client.</td>
</tr>
<tr><td><code>contentType</code> <B>[Required]</B><br/>
<code>string</code>
</td>
<td>
   contentType is the content type used when sending data to the server from this client.</td>
</tr>
<tr><td><code>qps</code> <B>[Required]</B><br/>
<code>float32</code>
</td>
<td>
   qps controls the number of queries per second allowed for this connection.</td>
</tr>
<tr><td><code>burst</code> <B>[Required]</B><br/>
<code>int32</code>
</td>
<td>
   burst allows extra queries to accumulate when a client is exceeding its rate.</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-d673af4d710babea20cd6b317502afb8">10.4 - kube-scheduler Configuration (v1beta1)</h1>
    
	<h2 id="resource-types">Resource Types</h2>
<ul>
<li><a href="#kubescheduler-config-k8s-io-v1-Policy">Policy</a></li>
<li><a href="#kubescheduler-config-k8s-io-v1beta1-DefaultPreemptionArgs">DefaultPreemptionArgs</a></li>
<li><a href="#kubescheduler-config-k8s-io-v1beta1-InterPodAffinityArgs">InterPodAffinityArgs</a></li>
<li><a href="#kubescheduler-config-k8s-io-v1beta1-KubeSchedulerConfiguration">KubeSchedulerConfiguration</a></li>
<li><a href="#kubescheduler-config-k8s-io-v1beta1-NodeAffinityArgs">NodeAffinityArgs</a></li>
<li><a href="#kubescheduler-config-k8s-io-v1beta1-NodeLabelArgs">NodeLabelArgs</a></li>
<li><a href="#kubescheduler-config-k8s-io-v1beta1-NodeResourcesFitArgs">NodeResourcesFitArgs</a></li>
<li><a href="#kubescheduler-config-k8s-io-v1beta1-NodeResourcesLeastAllocatedArgs">NodeResourcesLeastAllocatedArgs</a></li>
<li><a href="#kubescheduler-config-k8s-io-v1beta1-NodeResourcesMostAllocatedArgs">NodeResourcesMostAllocatedArgs</a></li>
<li><a href="#kubescheduler-config-k8s-io-v1beta1-PodTopologySpreadArgs">PodTopologySpreadArgs</a></li>
<li><a href="#kubescheduler-config-k8s-io-v1beta1-RequestedToCapacityRatioArgs">RequestedToCapacityRatioArgs</a></li>
<li><a href="#kubescheduler-config-k8s-io-v1beta1-ServiceAffinityArgs">ServiceAffinityArgs</a></li>
<li><a href="#kubescheduler-config-k8s-io-v1beta1-VolumeBindingArgs">VolumeBindingArgs</a></li>
</ul>
<h2 id="kubescheduler-config-k8s-io-v1-Policy"><code>Policy</code>    </h2>
<p>Policy describes a struct for a policy resource used in api.</p>
<table class="table">
<thead><tr><th width="30%">Field</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>apiVersion</code><br/>string</td><td><code>kubescheduler.config.k8s.io/v1</code></td></tr>
<tr><td><code>kind</code><br/>string</td><td><code>Policy</code></td></tr>
<tr><td><code>predicates</code> <B>[Required]</B><br/>
<a href="#kubescheduler-config-k8s-io-v1-PredicatePolicy"><code>[]PredicatePolicy</code></a>
</td>
<td>
   Holds the information to configure the fit predicate functions</td>
</tr>
<tr><td><code>priorities</code> <B>[Required]</B><br/>
<a href="#kubescheduler-config-k8s-io-v1-PriorityPolicy"><code>[]PriorityPolicy</code></a>
</td>
<td>
   Holds the information to configure the priority functions</td>
</tr>
<tr><td><code>extenders</code> <B>[Required]</B><br/>
<a href="#kubescheduler-config-k8s-io-v1-LegacyExtender"><code>[]LegacyExtender</code></a>
</td>
<td>
   Holds the information to communicate with the extender(s)</td>
</tr>
<tr><td><code>hardPodAffinitySymmetricWeight</code> <B>[Required]</B><br/>
<code>int32</code>
</td>
<td>
   RequiredDuringScheduling affinity is not symmetric, but there is an implicit PreferredDuringScheduling affinity rule
corresponding to every RequiredDuringScheduling affinity rule.
HardPodAffinitySymmetricWeight represents the weight of implicit PreferredDuringScheduling affinity rule, in the range 1-100.</td>
</tr>
<tr><td><code>alwaysCheckAllPredicates</code> <B>[Required]</B><br/>
<code>bool</code>
</td>
<td>
   When AlwaysCheckAllPredicates is set to true, scheduler checks all
the configured predicates even after one or more of them fails.
When the flag is set to false, scheduler skips checking the rest
of the predicates after it finds one predicate that failed.</td>
</tr>
</tbody>
</table>
<h2 id="kubescheduler-config-k8s-io-v1-ExtenderManagedResource"><code>ExtenderManagedResource</code>    </h2>
<p><strong>Appears in:</strong></p>
<ul>
<li>
<p><a href="#kubescheduler-config-k8s-io-v1beta1-Extender">Extender</a></p>
</li>
<li>
<p><a href="#kubescheduler-config-k8s-io-v1-LegacyExtender">LegacyExtender</a></p>
</li>
</ul>
<p>ExtenderManagedResource describes the arguments of extended resources
managed by an extender.</p>
<table class="table">
<thead><tr><th width="30%">Field</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>name</code> <B>[Required]</B><br/>
<code>string</code>
</td>
<td>
   Name is the extended resource name.</td>
</tr>
<tr><td><code>ignoredByScheduler</code> <B>[Required]</B><br/>
<code>bool</code>
</td>
<td>
   IgnoredByScheduler indicates whether kube-scheduler should ignore this
resource when applying predicates.</td>
</tr>
</tbody>
</table>
<h2 id="kubescheduler-config-k8s-io-v1-ExtenderTLSConfig"><code>ExtenderTLSConfig</code>    </h2>
<p><strong>Appears in:</strong></p>
<ul>
<li>
<p><a href="#kubescheduler-config-k8s-io-v1beta1-Extender">Extender</a></p>
</li>
<li>
<p><a href="#kubescheduler-config-k8s-io-v1-LegacyExtender">LegacyExtender</a></p>
</li>
</ul>
<p>ExtenderTLSConfig contains settings to enable TLS with extender</p>
<table class="table">
<thead><tr><th width="30%">Field</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>insecure</code> <B>[Required]</B><br/>
<code>bool</code>
</td>
<td>
   Server should be accessed without verifying the TLS certificate. For testing only.</td>
</tr>
<tr><td><code>serverName</code> <B>[Required]</B><br/>
<code>string</code>
</td>
<td>
   ServerName is passed to the server for SNI and is used in the client to check server
certificates against. If ServerName is empty, the hostname used to contact the
server is used.</td>
</tr>
<tr><td><code>certFile</code> <B>[Required]</B><br/>
<code>string</code>
</td>
<td>
   Server requires TLS client certificate authentication</td>
</tr>
<tr><td><code>keyFile</code> <B>[Required]</B><br/>
<code>string</code>
</td>
<td>
   Server requires TLS client certificate authentication</td>
</tr>
<tr><td><code>caFile</code> <B>[Required]</B><br/>
<code>string</code>
</td>
<td>
   Trusted root certificates for server</td>
</tr>
<tr><td><code>certData</code> <B>[Required]</B><br/>
<code>[]byte</code>
</td>
<td>
   CertData holds PEM-encoded bytes (typically read from a client certificate file).
CertData takes precedence over CertFile</td>
</tr>
<tr><td><code>keyData</code> <B>[Required]</B><br/>
<code>[]byte</code>
</td>
<td>
   KeyData holds PEM-encoded bytes (typically read from a client certificate key file).
KeyData takes precedence over KeyFile</td>
</tr>
<tr><td><code>caData</code> <B>[Required]</B><br/>
<code>[]byte</code>
</td>
<td>
   CAData holds PEM-encoded bytes (typically read from a root certificates bundle).
CAData takes precedence over CAFile</td>
</tr>
</tbody>
</table>
<h2 id="kubescheduler-config-k8s-io-v1-LabelPreference"><code>LabelPreference</code>    </h2>
<p><strong>Appears in:</strong></p>
<ul>
<li><a href="#kubescheduler-config-k8s-io-v1-PriorityArgument">PriorityArgument</a></li>
</ul>
<p>LabelPreference holds the parameters that are used to configure the corresponding priority function</p>
<table class="table">
<thead><tr><th width="30%">Field</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>label</code> <B>[Required]</B><br/>
<code>string</code>
</td>
<td>
   Used to identify node "groups"</td>
</tr>
<tr><td><code>presence</code> <B>[Required]</B><br/>
<code>bool</code>
</td>
<td>
   This is a boolean flag
If true, higher priority is given to nodes that have the label
If false, higher priority is given to nodes that do not have the label</td>
</tr>
</tbody>
</table>
<h2 id="kubescheduler-config-k8s-io-v1-LabelsPresence"><code>LabelsPresence</code>    </h2>
<p><strong>Appears in:</strong></p>
<ul>
<li><a href="#kubescheduler-config-k8s-io-v1-PredicateArgument">PredicateArgument</a></li>
</ul>
<p>LabelsPresence holds the parameters that are used to configure the corresponding predicate in scheduler policy configuration.</p>
<table class="table">
<thead><tr><th width="30%">Field</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>labels</code> <B>[Required]</B><br/>
<code>[]string</code>
</td>
<td>
   The list of labels that identify node "groups"
All of the labels should be either present (or absent) for the node to be considered a fit for hosting the pod</td>
</tr>
<tr><td><code>presence</code> <B>[Required]</B><br/>
<code>bool</code>
</td>
<td>
   The boolean flag that indicates whether the labels should be present or absent from the node</td>
</tr>
</tbody>
</table>
<h2 id="kubescheduler-config-k8s-io-v1-LegacyExtender"><code>LegacyExtender</code>    </h2>
<p><strong>Appears in:</strong></p>
<ul>
<li><a href="#kubescheduler-config-k8s-io-v1-Policy">Policy</a></li>
</ul>
<p>LegacyExtender holds the parameters used to communicate with the extender. If a verb is unspecified/empty,
it is assumed that the extender chose not to provide that extension.</p>
<table class="table">
<thead><tr><th width="30%">Field</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>urlPrefix</code> <B>[Required]</B><br/>
<code>string</code>
</td>
<td>
   URLPrefix at which the extender is available</td>
</tr>
<tr><td><code>filterVerb</code> <B>[Required]</B><br/>
<code>string</code>
</td>
<td>
   Verb for the filter call, empty if not supported. This verb is appended to the URLPrefix when issuing the filter call to extender.</td>
</tr>
<tr><td><code>preemptVerb</code> <B>[Required]</B><br/>
<code>string</code>
</td>
<td>
   Verb for the preempt call, empty if not supported. This verb is appended to the URLPrefix when issuing the preempt call to extender.</td>
</tr>
<tr><td><code>prioritizeVerb</code> <B>[Required]</B><br/>
<code>string</code>
</td>
<td>
   Verb for the prioritize call, empty if not supported. This verb is appended to the URLPrefix when issuing the prioritize call to extender.</td>
</tr>
<tr><td><code>weight</code> <B>[Required]</B><br/>
<code>int64</code>
</td>
<td>
   The numeric multiplier for the node scores that the prioritize call generates.
The weight should be a positive integer</td>
</tr>
<tr><td><code>bindVerb</code> <B>[Required]</B><br/>
<code>string</code>
</td>
<td>
   Verb for the bind call, empty if not supported. This verb is appended to the URLPrefix when issuing the bind call to extender.
If this method is implemented by the extender, it is the extender's responsibility to bind the pod to apiserver. Only one extender
can implement this function.</td>
</tr>
<tr><td><code>enableHttps</code> <B>[Required]</B><br/>
<code>bool</code>
</td>
<td>
   EnableHTTPS specifies whether https should be used to communicate with the extender</td>
</tr>
<tr><td><code>tlsConfig</code> <B>[Required]</B><br/>
<a href="#kubescheduler-config-k8s-io-v1-ExtenderTLSConfig"><code>ExtenderTLSConfig</code></a>
</td>
<td>
   TLSConfig specifies the transport layer security config</td>
</tr>
<tr><td><code>httpTimeout</code> <B>[Required]</B><br/>
<a href="https://godoc.org/time#Duration"><code>time.Duration</code></a>
</td>
<td>
   HTTPTimeout specifies the timeout duration for a call to the extender. Filter timeout fails the scheduling of the pod. Prioritize
timeout is ignored, k8s/other extenders priorities are used to select the node.</td>
</tr>
<tr><td><code>nodeCacheCapable</code> <B>[Required]</B><br/>
<code>bool</code>
</td>
<td>
   NodeCacheCapable specifies that the extender is capable of caching node information,
so the scheduler should only send minimal information about the eligible nodes
assuming that the extender already cached full details of all nodes in the cluster</td>
</tr>
<tr><td><code>managedResources</code><br/>
<a href="#kubescheduler-config-k8s-io-v1-ExtenderManagedResource"><code>[]ExtenderManagedResource</code></a>
</td>
<td>
   ManagedResources is a list of extended resources that are managed by
this extender.
- A pod will be sent to the extender on the Filter, Prioritize and Bind
  (if the extender is the binder) phases iff the pod requests at least
  one of the extended resources in this list. If empty or unspecified,
  all pods will be sent to this extender.
- If IgnoredByScheduler is set to true for a resource, kube-scheduler
  will skip checking the resource in predicates.</td>
</tr>
<tr><td><code>ignorable</code> <B>[Required]</B><br/>
<code>bool</code>
</td>
<td>
   Ignorable specifies if the extender is ignorable, i.e. scheduling should not
fail when the extender returns an error or is not reachable.</td>
</tr>
</tbody>
</table>
<h2 id="kubescheduler-config-k8s-io-v1-PredicateArgument"><code>PredicateArgument</code>    </h2>
<p><strong>Appears in:</strong></p>
<ul>
<li><a href="#kubescheduler-config-k8s-io-v1-PredicatePolicy">PredicatePolicy</a></li>
</ul>
<p>PredicateArgument represents the arguments to configure predicate functions in scheduler policy configuration.
Only one of its members may be specified</p>
<table class="table">
<thead><tr><th width="30%">Field</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>serviceAffinity</code> <B>[Required]</B><br/>
<a href="#kubescheduler-config-k8s-io-v1-ServiceAffinity"><code>ServiceAffinity</code></a>
</td>
<td>
   The predicate that provides affinity for pods belonging to a service
It uses a label to identify nodes that belong to the same "group"</td>
</tr>
<tr><td><code>labelsPresence</code> <B>[Required]</B><br/>
<a href="#kubescheduler-config-k8s-io-v1-LabelsPresence"><code>LabelsPresence</code></a>
</td>
<td>
   The predicate that checks whether a particular node has a certain label
defined or not, regardless of value</td>
</tr>
</tbody>
</table>
<h2 id="kubescheduler-config-k8s-io-v1-PredicatePolicy"><code>PredicatePolicy</code>    </h2>
<p><strong>Appears in:</strong></p>
<ul>
<li><a href="#kubescheduler-config-k8s-io-v1-Policy">Policy</a></li>
</ul>
<p>PredicatePolicy describes a struct of a predicate policy.</p>
<table class="table">
<thead><tr><th width="30%">Field</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>name</code> <B>[Required]</B><br/>
<code>string</code>
</td>
<td>
   Identifier of the predicate policy
For a custom predicate, the name can be user-defined
For the Kubernetes provided predicates, the name is the identifier of the pre-defined predicate</td>
</tr>
<tr><td><code>argument</code> <B>[Required]</B><br/>
<a href="#kubescheduler-config-k8s-io-v1-PredicateArgument"><code>PredicateArgument</code></a>
</td>
<td>
   Holds the parameters to configure the given predicate</td>
</tr>
</tbody>
</table>
<h2 id="kubescheduler-config-k8s-io-v1-PriorityArgument"><code>PriorityArgument</code>    </h2>
<p><strong>Appears in:</strong></p>
<ul>
<li><a href="#kubescheduler-config-k8s-io-v1-PriorityPolicy">PriorityPolicy</a></li>
</ul>
<p>PriorityArgument represents the arguments to configure priority functions in scheduler policy configuration.
Only one of its members may be specified</p>
<table class="table">
<thead><tr><th width="30%">Field</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>serviceAntiAffinity</code> <B>[Required]</B><br/>
<a href="#kubescheduler-config-k8s-io-v1-ServiceAntiAffinity"><code>ServiceAntiAffinity</code></a>
</td>
<td>
   The priority function that ensures a good spread (anti-affinity) for pods belonging to a service
It uses a label to identify nodes that belong to the same "group"</td>
</tr>
<tr><td><code>labelPreference</code> <B>[Required]</B><br/>
<a href="#kubescheduler-config-k8s-io-v1-LabelPreference"><code>LabelPreference</code></a>
</td>
<td>
   The priority function that checks whether a particular node has a certain label
defined or not, regardless of value</td>
</tr>
<tr><td><code>requestedToCapacityRatioArguments</code> <B>[Required]</B><br/>
<a href="#kubescheduler-config-k8s-io-v1-RequestedToCapacityRatioArguments"><code>RequestedToCapacityRatioArguments</code></a>
</td>
<td>
   The RequestedToCapacityRatio priority function is parametrized with function shape.</td>
</tr>
</tbody>
</table>
<h2 id="kubescheduler-config-k8s-io-v1-PriorityPolicy"><code>PriorityPolicy</code>    </h2>
<p><strong>Appears in:</strong></p>
<ul>
<li><a href="#kubescheduler-config-k8s-io-v1-Policy">Policy</a></li>
</ul>
<p>PriorityPolicy describes a struct of a priority policy.</p>
<table class="table">
<thead><tr><th width="30%">Field</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>name</code> <B>[Required]</B><br/>
<code>string</code>
</td>
<td>
   Identifier of the priority policy
For a custom priority, the name can be user-defined
For the Kubernetes provided priority functions, the name is the identifier of the pre-defined priority function</td>
</tr>
<tr><td><code>weight</code> <B>[Required]</B><br/>
<code>int64</code>
</td>
<td>
   The numeric multiplier for the node scores that the priority function generates
The weight should be non-zero and can be a positive or a negative integer</td>
</tr>
<tr><td><code>argument</code> <B>[Required]</B><br/>
<a href="#kubescheduler-config-k8s-io-v1-PriorityArgument"><code>PriorityArgument</code></a>
</td>
<td>
   Holds the parameters to configure the given priority function</td>
</tr>
</tbody>
</table>
<h2 id="kubescheduler-config-k8s-io-v1-RequestedToCapacityRatioArguments"><code>RequestedToCapacityRatioArguments</code>    </h2>
<p><strong>Appears in:</strong></p>
<ul>
<li><a href="#kubescheduler-config-k8s-io-v1-PriorityArgument">PriorityArgument</a></li>
</ul>
<p>RequestedToCapacityRatioArguments holds arguments specific to RequestedToCapacityRatio priority function.</p>
<table class="table">
<thead><tr><th width="30%">Field</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>shape</code> <B>[Required]</B><br/>
<a href="#kubescheduler-config-k8s-io-v1-UtilizationShapePoint"><code>[]UtilizationShapePoint</code></a>
</td>
<td>
   Array of point defining priority function shape.</td>
</tr>
<tr><td><code>resources</code> <B>[Required]</B><br/>
<a href="#kubescheduler-config-k8s-io-v1-ResourceSpec"><code>[]ResourceSpec</code></a>
</td>
<td>
   <span class="text-muted">No description provided.</span>
   </td>
</tr>
</tbody>
</table>
<h2 id="kubescheduler-config-k8s-io-v1-ResourceSpec"><code>ResourceSpec</code>    </h2>
<p><strong>Appears in:</strong></p>
<ul>
<li><a href="#kubescheduler-config-k8s-io-v1-RequestedToCapacityRatioArguments">RequestedToCapacityRatioArguments</a></li>
</ul>
<p>ResourceSpec represents single resource and weight for bin packing of priority RequestedToCapacityRatioArguments.</p>
<table class="table">
<thead><tr><th width="30%">Field</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>name</code> <B>[Required]</B><br/>
<code>string</code>
</td>
<td>
   Name of the resource to be managed by RequestedToCapacityRatio function.</td>
</tr>
<tr><td><code>weight</code> <B>[Required]</B><br/>
<code>int64</code>
</td>
<td>
   Weight of the resource.</td>
</tr>
</tbody>
</table>
<h2 id="kubescheduler-config-k8s-io-v1-ServiceAffinity"><code>ServiceAffinity</code>    </h2>
<p><strong>Appears in:</strong></p>
<ul>
<li><a href="#kubescheduler-config-k8s-io-v1-PredicateArgument">PredicateArgument</a></li>
</ul>
<p>ServiceAffinity holds the parameters that are used to configure the corresponding predicate in scheduler policy configuration.</p>
<table class="table">
<thead><tr><th width="30%">Field</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>labels</code> <B>[Required]</B><br/>
<code>[]string</code>
</td>
<td>
   The list of labels that identify node "groups"
All of the labels should match for the node to be considered a fit for hosting the pod</td>
</tr>
</tbody>
</table>
<h2 id="kubescheduler-config-k8s-io-v1-ServiceAntiAffinity"><code>ServiceAntiAffinity</code>    </h2>
<p><strong>Appears in:</strong></p>
<ul>
<li><a href="#kubescheduler-config-k8s-io-v1-PriorityArgument">PriorityArgument</a></li>
</ul>
<p>ServiceAntiAffinity holds the parameters that are used to configure the corresponding priority function</p>
<table class="table">
<thead><tr><th width="30%">Field</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>label</code> <B>[Required]</B><br/>
<code>string</code>
</td>
<td>
   Used to identify node "groups"</td>
</tr>
</tbody>
</table>
<h2 id="kubescheduler-config-k8s-io-v1-UtilizationShapePoint"><code>UtilizationShapePoint</code>    </h2>
<p><strong>Appears in:</strong></p>
<ul>
<li><a href="#kubescheduler-config-k8s-io-v1-RequestedToCapacityRatioArguments">RequestedToCapacityRatioArguments</a></li>
</ul>
<p>UtilizationShapePoint represents single point of priority function shape.</p>
<table class="table">
<thead><tr><th width="30%">Field</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>utilization</code> <B>[Required]</B><br/>
<code>int32</code>
</td>
<td>
   Utilization (x axis). Valid values are 0 to 100. Fully utilized node maps to 100.</td>
</tr>
<tr><td><code>score</code> <B>[Required]</B><br/>
<code>int32</code>
</td>
<td>
   Score assigned to given utilization (y axis). Valid values are 0 to 10.</td>
</tr>
</tbody>
</table>
<h2 id="ClientConnectionConfiguration"><code>ClientConnectionConfiguration</code>    </h2>
<p><strong>Appears in:</strong></p>
<ul>
<li><a href="#kubescheduler-config-k8s-io-v1beta1-KubeSchedulerConfiguration">KubeSchedulerConfiguration</a></li>
</ul>
<p>ClientConnectionConfiguration contains details for constructing a client.</p>
<table class="table">
<thead><tr><th width="30%">Field</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>kubeconfig</code> <B>[Required]</B><br/>
<code>string</code>
</td>
<td>
   kubeconfig is the path to a KubeConfig file.</td>
</tr>
<tr><td><code>acceptContentTypes</code> <B>[Required]</B><br/>
<code>string</code>
</td>
<td>
   acceptContentTypes defines the Accept header sent by clients when connecting to a server, overriding the
default value of 'application/json'. This field will control all connections to the server used by a particular
client.</td>
</tr>
<tr><td><code>contentType</code> <B>[Required]</B><br/>
<code>string</code>
</td>
<td>
   contentType is the content type used when sending data to the server from this client.</td>
</tr>
<tr><td><code>qps</code> <B>[Required]</B><br/>
<code>float32</code>
</td>
<td>
   qps controls the number of queries per second allowed for this connection.</td>
</tr>
<tr><td><code>burst</code> <B>[Required]</B><br/>
<code>int32</code>
</td>
<td>
   burst allows extra queries to accumulate when a client is exceeding its rate.</td>
</tr>
</tbody>
</table>
<h2 id="DebuggingConfiguration"><code>DebuggingConfiguration</code>    </h2>
<p><strong>Appears in:</strong></p>
<ul>
<li><a href="#kubescheduler-config-k8s-io-v1beta1-KubeSchedulerConfiguration">KubeSchedulerConfiguration</a></li>
</ul>
<p>DebuggingConfiguration holds configuration for Debugging related features.</p>
<table class="table">
<thead><tr><th width="30%">Field</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>enableProfiling</code> <B>[Required]</B><br/>
<code>bool</code>
</td>
<td>
   enableProfiling enables profiling via web interface host:port/debug/pprof/</td>
</tr>
<tr><td><code>enableContentionProfiling</code> <B>[Required]</B><br/>
<code>bool</code>
</td>
<td>
   enableContentionProfiling enables lock contention profiling, if
enableProfiling is true.</td>
</tr>
</tbody>
</table>
<h2 id="LeaderElectionConfiguration"><code>LeaderElectionConfiguration</code>    </h2>
<p><strong>Appears in:</strong></p>
<ul>
<li><a href="#kubescheduler-config-k8s-io-v1beta1-KubeSchedulerConfiguration">KubeSchedulerConfiguration</a></li>
</ul>
<p>LeaderElectionConfiguration defines the configuration of leader election
clients for components that can run with leader election enabled.</p>
<table class="table">
<thead><tr><th width="30%">Field</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>leaderElect</code> <B>[Required]</B><br/>
<code>bool</code>
</td>
<td>
   leaderElect enables a leader election client to gain leadership
before executing the main loop. Enable this when running replicated
components for high availability.</td>
</tr>
<tr><td><code>leaseDuration</code> <B>[Required]</B><br/>
<a href="https://godoc.org/k8s.io/apimachinery/pkg/apis/meta/v1#Duration"><code>meta/v1.Duration</code></a>
</td>
<td>
   leaseDuration is the duration that non-leader candidates will wait
after observing a leadership renewal until attempting to acquire
leadership of a led but unrenewed leader slot. This is effectively the
maximum duration that a leader can be stopped before it is replaced
by another candidate. This is only applicable if leader election is
enabled.</td>
</tr>
<tr><td><code>renewDeadline</code> <B>[Required]</B><br/>
<a href="https://godoc.org/k8s.io/apimachinery/pkg/apis/meta/v1#Duration"><code>meta/v1.Duration</code></a>
</td>
<td>
   renewDeadline is the interval between attempts by the acting master to
renew a leadership slot before it stops leading. This must be less
than or equal to the lease duration. This is only applicable if leader
election is enabled.</td>
</tr>
<tr><td><code>retryPeriod</code> <B>[Required]</B><br/>
<a href="https://godoc.org/k8s.io/apimachinery/pkg/apis/meta/v1#Duration"><code>meta/v1.Duration</code></a>
</td>
<td>
   retryPeriod is the duration the clients should wait between attempting
acquisition and renewal of a leadership. This is only applicable if
leader election is enabled.</td>
</tr>
<tr><td><code>resourceLock</code> <B>[Required]</B><br/>
<code>string</code>
</td>
<td>
   resourceLock indicates the resource object type that will be used to lock
during leader election cycles.</td>
</tr>
<tr><td><code>resourceName</code> <B>[Required]</B><br/>
<code>string</code>
</td>
<td>
   resourceName indicates the name of resource object that will be used to lock
during leader election cycles.</td>
</tr>
<tr><td><code>resourceNamespace</code> <B>[Required]</B><br/>
<code>string</code>
</td>
<td>
   resourceName indicates the namespace of resource object that will be used to lock
during leader election cycles.</td>
</tr>
</tbody>
</table>
<h2 id="LoggingConfiguration"><code>LoggingConfiguration</code>    </h2>
<p><strong>Appears in:</strong></p>
<ul>
<li><a href="#kubelet-config-k8s-io-v1beta1-KubeletConfiguration">KubeletConfiguration</a></li>
</ul>
<p>LoggingConfiguration contains logging options
Refer <a href="https://github.com/kubernetes/component-base/blob/master/logs/options.go">Logs Options</a> for more information.</p>
<table class="table">
<thead><tr><th width="30%">Field</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>format</code> <B>[Required]</B><br/>
<code>string</code>
</td>
<td>
   Format Flag specifies the structure of log messages.
default value of format is `text`</td>
</tr>
<tr><td><code>sanitization</code> <B>[Required]</B><br/>
<code>bool</code>
</td>
<td>
   [Experimental] When enabled prevents logging of fields tagged as sensitive (passwords, keys, tokens).
Runtime log sanitization may introduce significant computation overhead and therefore should not be enabled in production.`)</td>
</tr>
</tbody>
</table>
<h2 id="kubescheduler-config-k8s-io-v1beta1-DefaultPreemptionArgs"><code>DefaultPreemptionArgs</code>    </h2>
<p>DefaultPreemptionArgs holds arguments used to configure the
DefaultPreemption plugin.</p>
<table class="table">
<thead><tr><th width="30%">Field</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>apiVersion</code><br/>string</td><td><code>kubescheduler.config.k8s.io/v1beta1</code></td></tr>
<tr><td><code>kind</code><br/>string</td><td><code>DefaultPreemptionArgs</code></td></tr>
<tr><td><code>minCandidateNodesPercentage</code> <B>[Required]</B><br/>
<code>int32</code>
</td>
<td>
   MinCandidateNodesPercentage is the minimum number of candidates to
shortlist when dry running preemption as a percentage of number of nodes.
Must be in the range [0, 100]. Defaults to 10% of the cluster size if
unspecified.</td>
</tr>
<tr><td><code>minCandidateNodesAbsolute</code> <B>[Required]</B><br/>
<code>int32</code>
</td>
<td>
   MinCandidateNodesAbsolute is the absolute minimum number of candidates to
shortlist. The likely number of candidates enumerated for dry running
preemption is given by the formula:
numCandidates = max(numNodes &lowast; minCandidateNodesPercentage, minCandidateNodesAbsolute)
We say "likely" because there are other factors such as PDB violations
that play a role in the number of candidates shortlisted. Must be at least
0 nodes. Defaults to 100 nodes if unspecified.</td>
</tr>
</tbody>
</table>
<h2 id="kubescheduler-config-k8s-io-v1beta1-InterPodAffinityArgs"><code>InterPodAffinityArgs</code>    </h2>
<p>InterPodAffinityArgs holds arguments used to configure the InterPodAffinity plugin.</p>
<table class="table">
<thead><tr><th width="30%">Field</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>apiVersion</code><br/>string</td><td><code>kubescheduler.config.k8s.io/v1beta1</code></td></tr>
<tr><td><code>kind</code><br/>string</td><td><code>InterPodAffinityArgs</code></td></tr>
<tr><td><code>hardPodAffinityWeight</code> <B>[Required]</B><br/>
<code>int32</code>
</td>
<td>
   HardPodAffinityWeight is the scoring weight for existing pods with a
matching hard affinity to the incoming pod.</td>
</tr>
</tbody>
</table>
<h2 id="kubescheduler-config-k8s-io-v1beta1-KubeSchedulerConfiguration"><code>KubeSchedulerConfiguration</code>    </h2>
<p>KubeSchedulerConfiguration configures a scheduler</p>
<table class="table">
<thead><tr><th width="30%">Field</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>apiVersion</code><br/>string</td><td><code>kubescheduler.config.k8s.io/v1beta1</code></td></tr>
<tr><td><code>kind</code><br/>string</td><td><code>KubeSchedulerConfiguration</code></td></tr>
<tr><td><code>parallelism</code> <B>[Required]</B><br/>
<code>int32</code>
</td>
<td>
   Parallelism defines the amount of parallelism in algorithms for scheduling a Pods. Must be greater than 0. Defaults to 16</td>
</tr>
<tr><td><code>leaderElection</code> <B>[Required]</B><br/>
<a href="#LeaderElectionConfiguration"><code>LeaderElectionConfiguration</code></a>
</td>
<td>
   LeaderElection defines the configuration of leader election client.</td>
</tr>
<tr><td><code>clientConnection</code> <B>[Required]</B><br/>
<a href="#ClientConnectionConfiguration"><code>ClientConnectionConfiguration</code></a>
</td>
<td>
   ClientConnection specifies the kubeconfig file and client connection
settings for the proxy server to use when communicating with the apiserver.</td>
</tr>
<tr><td><code>healthzBindAddress</code> <B>[Required]</B><br/>
<code>string</code>
</td>
<td>
   HealthzBindAddress is the IP address and port for the health check server to serve on,
defaulting to 0.0.0.0:10251</td>
</tr>
<tr><td><code>metricsBindAddress</code> <B>[Required]</B><br/>
<code>string</code>
</td>
<td>
   MetricsBindAddress is the IP address and port for the metrics server to
serve on, defaulting to 0.0.0.0:10251.</td>
</tr>
<tr><td><code>DebuggingConfiguration</code> <B>[Required]</B><br/>
<a href="#DebuggingConfiguration"><code>DebuggingConfiguration</code></a>
</td>
<td>(Members of <code>DebuggingConfiguration</code> are embedded into this type.)
   DebuggingConfiguration holds configuration for Debugging related features
TODO: We might wanna make this a substruct like Debugging componentbaseconfigv1alpha1.DebuggingConfiguration</td>
</tr>
<tr><td><code>percentageOfNodesToScore</code> <B>[Required]</B><br/>
<code>int32</code>
</td>
<td>
   PercentageOfNodesToScore is the percentage of all nodes that once found feasible
for running a pod, the scheduler stops its search for more feasible nodes in
the cluster. This helps improve scheduler's performance. Scheduler always tries to find
at least "minFeasibleNodesToFind" feasible nodes no matter what the value of this flag is.
Example: if the cluster size is 500 nodes and the value of this flag is 30,
then scheduler stops finding further feasible nodes once it finds 150 feasible ones.
When the value is 0, default percentage (5%--50% based on the size of the cluster) of the
nodes will be scored.</td>
</tr>
<tr><td><code>podInitialBackoffSeconds</code> <B>[Required]</B><br/>
<code>int64</code>
</td>
<td>
   PodInitialBackoffSeconds is the initial backoff for unschedulable pods.
If specified, it must be greater than 0. If this value is null, the default value (1s)
will be used.</td>
</tr>
<tr><td><code>podMaxBackoffSeconds</code> <B>[Required]</B><br/>
<code>int64</code>
</td>
<td>
   PodMaxBackoffSeconds is the max backoff for unschedulable pods.
If specified, it must be greater than podInitialBackoffSeconds. If this value is null,
the default value (10s) will be used.</td>
</tr>
<tr><td><code>profiles</code> <B>[Required]</B><br/>
<a href="#kubescheduler-config-k8s-io-v1beta1-KubeSchedulerProfile"><code>[]KubeSchedulerProfile</code></a>
</td>
<td>
   Profiles are scheduling profiles that kube-scheduler supports. Pods can
choose to be scheduled under a particular profile by setting its associated
scheduler name. Pods that don't specify any scheduler name are scheduled
with the "default-scheduler" profile, if present here.</td>
</tr>
<tr><td><code>extenders</code> <B>[Required]</B><br/>
<a href="#kubescheduler-config-k8s-io-v1beta1-Extender"><code>[]Extender</code></a>
</td>
<td>
   Extenders are the list of scheduler extenders, each holding the values of how to communicate
with the extender. These extenders are shared by all scheduler profiles.</td>
</tr>
</tbody>
</table>
<h2 id="kubescheduler-config-k8s-io-v1beta1-NodeAffinityArgs"><code>NodeAffinityArgs</code>    </h2>
<p>NodeAffinityArgs holds arguments to configure the NodeAffinity plugin.</p>
<table class="table">
<thead><tr><th width="30%">Field</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>apiVersion</code><br/>string</td><td><code>kubescheduler.config.k8s.io/v1beta1</code></td></tr>
<tr><td><code>kind</code><br/>string</td><td><code>NodeAffinityArgs</code></td></tr>
<tr><td><code>addedAffinity</code><br/>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.20/#nodeaffinity-v1-core"><code>core/v1.NodeAffinity</code></a>
</td>
<td>
   AddedAffinity is applied to all Pods additionally to the NodeAffinity
specified in the PodSpec. That is, Nodes need to satisfy AddedAffinity
AND .spec.NodeAffinity. AddedAffinity is empty by default (all Nodes
match).
When AddedAffinity is used, some Pods with affinity requirements that match
a specific Node (such as Daemonset Pods) might remain unschedulable.</td>
</tr>
</tbody>
</table>
<h2 id="kubescheduler-config-k8s-io-v1beta1-NodeLabelArgs"><code>NodeLabelArgs</code>    </h2>
<p>NodeLabelArgs holds arguments used to configure the NodeLabel plugin.</p>
<table class="table">
<thead><tr><th width="30%">Field</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>apiVersion</code><br/>string</td><td><code>kubescheduler.config.k8s.io/v1beta1</code></td></tr>
<tr><td><code>kind</code><br/>string</td><td><code>NodeLabelArgs</code></td></tr>
<tr><td><code>presentLabels</code> <B>[Required]</B><br/>
<code>[]string</code>
</td>
<td>
   PresentLabels should be present for the node to be considered a fit for hosting the pod</td>
</tr>
<tr><td><code>absentLabels</code> <B>[Required]</B><br/>
<code>[]string</code>
</td>
<td>
   AbsentLabels should be absent for the node to be considered a fit for hosting the pod</td>
</tr>
<tr><td><code>presentLabelsPreference</code> <B>[Required]</B><br/>
<code>[]string</code>
</td>
<td>
   Nodes that have labels in the list will get a higher score.</td>
</tr>
<tr><td><code>absentLabelsPreference</code> <B>[Required]</B><br/>
<code>[]string</code>
</td>
<td>
   Nodes that don't have labels in the list will get a higher score.</td>
</tr>
</tbody>
</table>
<h2 id="kubescheduler-config-k8s-io-v1beta1-NodeResourcesFitArgs"><code>NodeResourcesFitArgs</code>    </h2>
<p>NodeResourcesFitArgs holds arguments used to configure the NodeResourcesFit plugin.</p>
<table class="table">
<thead><tr><th width="30%">Field</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>apiVersion</code><br/>string</td><td><code>kubescheduler.config.k8s.io/v1beta1</code></td></tr>
<tr><td><code>kind</code><br/>string</td><td><code>NodeResourcesFitArgs</code></td></tr>
<tr><td><code>ignoredResources</code> <B>[Required]</B><br/>
<code>[]string</code>
</td>
<td>
   IgnoredResources is the list of resources that NodeResources fit filter
should ignore.</td>
</tr>
<tr><td><code>ignoredResourceGroups</code> <B>[Required]</B><br/>
<code>[]string</code>
</td>
<td>
   IgnoredResourceGroups defines the list of resource groups that NodeResources fit filter should ignore.
e.g. if group is ["example.com"], it will ignore all resource names that begin
with "example.com", such as "example.com/aaa" and "example.com/bbb".
A resource group name can't contain '/'.</td>
</tr>
</tbody>
</table>
<h2 id="kubescheduler-config-k8s-io-v1beta1-NodeResourcesLeastAllocatedArgs"><code>NodeResourcesLeastAllocatedArgs</code>    </h2>
<p>NodeResourcesLeastAllocatedArgs holds arguments used to configure NodeResourcesLeastAllocated plugin.</p>
<table class="table">
<thead><tr><th width="30%">Field</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>apiVersion</code><br/>string</td><td><code>kubescheduler.config.k8s.io/v1beta1</code></td></tr>
<tr><td><code>kind</code><br/>string</td><td><code>NodeResourcesLeastAllocatedArgs</code></td></tr>
<tr><td><code>resources</code> <B>[Required]</B><br/>
<a href="#kubescheduler-config-k8s-io-v1beta1-ResourceSpec"><code>[]ResourceSpec</code></a>
</td>
<td>
   Resources to be managed, if no resource is provided, default resource set with both
the weight of "cpu" and "memory" set to "1" will be applied.
Resource with "0" weight will not accountable for the final score.</td>
</tr>
</tbody>
</table>
<h2 id="kubescheduler-config-k8s-io-v1beta1-NodeResourcesMostAllocatedArgs"><code>NodeResourcesMostAllocatedArgs</code>    </h2>
<p>NodeResourcesMostAllocatedArgs holds arguments used to configure NodeResourcesMostAllocated plugin.</p>
<table class="table">
<thead><tr><th width="30%">Field</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>apiVersion</code><br/>string</td><td><code>kubescheduler.config.k8s.io/v1beta1</code></td></tr>
<tr><td><code>kind</code><br/>string</td><td><code>NodeResourcesMostAllocatedArgs</code></td></tr>
<tr><td><code>resources</code> <B>[Required]</B><br/>
<a href="#kubescheduler-config-k8s-io-v1beta1-ResourceSpec"><code>[]ResourceSpec</code></a>
</td>
<td>
   Resources to be managed, if no resource is provided, default resource set with both
the weight of "cpu" and "memory" set to "1" will be applied.
Resource with "0" weight will not accountable for the final score.</td>
</tr>
</tbody>
</table>
<h2 id="kubescheduler-config-k8s-io-v1beta1-PodTopologySpreadArgs"><code>PodTopologySpreadArgs</code>    </h2>
<p>PodTopologySpreadArgs holds arguments used to configure the PodTopologySpread plugin.</p>
<table class="table">
<thead><tr><th width="30%">Field</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>apiVersion</code><br/>string</td><td><code>kubescheduler.config.k8s.io/v1beta1</code></td></tr>
<tr><td><code>kind</code><br/>string</td><td><code>PodTopologySpreadArgs</code></td></tr>
<tr><td><code>defaultConstraints</code><br/>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.20/#topologyspreadconstraint-v1-core"><code>[]core/v1.TopologySpreadConstraint</code></a>
</td>
<td>
   DefaultConstraints defines topology spread constraints to be applied to
Pods that don't define any in `pod.spec.topologySpreadConstraints`.
`.defaultConstraints[&lowast;].labelSelectors` must be empty, as they are
deduced from the Pod's membership to Services, ReplicationControllers,
ReplicaSets or StatefulSets.
When not empty, .defaultingType must be "List".</td>
</tr>
<tr><td><code>defaultingType</code><br/>
<a href="#kubescheduler-config-k8s-io-v1beta1-PodTopologySpreadConstraintsDefaulting"><code>PodTopologySpreadConstraintsDefaulting</code></a>
</td>
<td>
   DefaultingType determines how .defaultConstraints are deduced. Can be one
of "System" or "List".
<ul>
<li>&quot;System&quot;: Use kubernetes defined constraints that spread Pods among
Nodes and Zones.</li>
<li>&quot;List&quot;: Use constraints defined in .defaultConstraints.</li>
</ul>
<p>Defaults to &quot;List&quot; if feature gate DefaultPodTopologySpread is disabled
and to &quot;System&quot; if enabled.</td></p>
</tr>
</tbody>
</table>
<h2 id="kubescheduler-config-k8s-io-v1beta1-RequestedToCapacityRatioArgs"><code>RequestedToCapacityRatioArgs</code>    </h2>
<p>RequestedToCapacityRatioArgs holds arguments used to configure RequestedToCapacityRatio plugin.</p>
<table class="table">
<thead><tr><th width="30%">Field</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>apiVersion</code><br/>string</td><td><code>kubescheduler.config.k8s.io/v1beta1</code></td></tr>
<tr><td><code>kind</code><br/>string</td><td><code>RequestedToCapacityRatioArgs</code></td></tr>
<tr><td><code>shape</code> <B>[Required]</B><br/>
<a href="#kubescheduler-config-k8s-io-v1beta1-UtilizationShapePoint"><code>[]UtilizationShapePoint</code></a>
</td>
<td>
   Points defining priority function shape</td>
</tr>
<tr><td><code>resources</code> <B>[Required]</B><br/>
<a href="#kubescheduler-config-k8s-io-v1beta1-ResourceSpec"><code>[]ResourceSpec</code></a>
</td>
<td>
   Resources to be managed</td>
</tr>
</tbody>
</table>
<h2 id="kubescheduler-config-k8s-io-v1beta1-ServiceAffinityArgs"><code>ServiceAffinityArgs</code>    </h2>
<p>ServiceAffinityArgs holds arguments used to configure the ServiceAffinity plugin.</p>
<table class="table">
<thead><tr><th width="30%">Field</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>apiVersion</code><br/>string</td><td><code>kubescheduler.config.k8s.io/v1beta1</code></td></tr>
<tr><td><code>kind</code><br/>string</td><td><code>ServiceAffinityArgs</code></td></tr>
<tr><td><code>affinityLabels</code> <B>[Required]</B><br/>
<code>[]string</code>
</td>
<td>
   AffinityLabels are homogeneous for pods that are scheduled to a node.
(i.e. it returns true IFF this pod can be added to this node such that all other pods in
the same service are running on nodes with the exact same values for Labels).</td>
</tr>
<tr><td><code>antiAffinityLabelsPreference</code> <B>[Required]</B><br/>
<code>[]string</code>
</td>
<td>
   AntiAffinityLabelsPreference are the labels to consider for service anti affinity scoring.</td>
</tr>
</tbody>
</table>
<h2 id="kubescheduler-config-k8s-io-v1beta1-VolumeBindingArgs"><code>VolumeBindingArgs</code>    </h2>
<p>VolumeBindingArgs holds arguments used to configure the VolumeBinding plugin.</p>
<table class="table">
<thead><tr><th width="30%">Field</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>apiVersion</code><br/>string</td><td><code>kubescheduler.config.k8s.io/v1beta1</code></td></tr>
<tr><td><code>kind</code><br/>string</td><td><code>VolumeBindingArgs</code></td></tr>
<tr><td><code>bindTimeoutSeconds</code> <B>[Required]</B><br/>
<code>int64</code>
</td>
<td>
   BindTimeoutSeconds is the timeout in seconds in volume binding operation.
Value must be non-negative integer. The value zero indicates no waiting.
If this value is nil, the default value (600) will be used.</td>
</tr>
</tbody>
</table>
<h2 id="kubescheduler-config-k8s-io-v1beta1-Extender"><code>Extender</code>    </h2>
<p><strong>Appears in:</strong></p>
<ul>
<li><a href="#kubescheduler-config-k8s-io-v1beta1-KubeSchedulerConfiguration">KubeSchedulerConfiguration</a></li>
</ul>
<p>Extender holds the parameters used to communicate with the extender. If a verb is unspecified/empty,
it is assumed that the extender chose not to provide that extension.</p>
<table class="table">
<thead><tr><th width="30%">Field</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>urlPrefix</code> <B>[Required]</B><br/>
<code>string</code>
</td>
<td>
   URLPrefix at which the extender is available</td>
</tr>
<tr><td><code>filterVerb</code> <B>[Required]</B><br/>
<code>string</code>
</td>
<td>
   Verb for the filter call, empty if not supported. This verb is appended to the URLPrefix when issuing the filter call to extender.</td>
</tr>
<tr><td><code>preemptVerb</code> <B>[Required]</B><br/>
<code>string</code>
</td>
<td>
   Verb for the preempt call, empty if not supported. This verb is appended to the URLPrefix when issuing the preempt call to extender.</td>
</tr>
<tr><td><code>prioritizeVerb</code> <B>[Required]</B><br/>
<code>string</code>
</td>
<td>
   Verb for the prioritize call, empty if not supported. This verb is appended to the URLPrefix when issuing the prioritize call to extender.</td>
</tr>
<tr><td><code>weight</code> <B>[Required]</B><br/>
<code>int64</code>
</td>
<td>
   The numeric multiplier for the node scores that the prioritize call generates.
The weight should be a positive integer</td>
</tr>
<tr><td><code>bindVerb</code> <B>[Required]</B><br/>
<code>string</code>
</td>
<td>
   Verb for the bind call, empty if not supported. This verb is appended to the URLPrefix when issuing the bind call to extender.
If this method is implemented by the extender, it is the extender's responsibility to bind the pod to apiserver. Only one extender
can implement this function.</td>
</tr>
<tr><td><code>enableHTTPS</code> <B>[Required]</B><br/>
<code>bool</code>
</td>
<td>
   EnableHTTPS specifies whether https should be used to communicate with the extender</td>
</tr>
<tr><td><code>tlsConfig</code> <B>[Required]</B><br/>
<a href="#kubescheduler-config-k8s-io-v1-ExtenderTLSConfig"><code>ExtenderTLSConfig</code></a>
</td>
<td>
   TLSConfig specifies the transport layer security config</td>
</tr>
<tr><td><code>httpTimeout</code> <B>[Required]</B><br/>
<a href="https://godoc.org/k8s.io/apimachinery/pkg/apis/meta/v1#Duration"><code>meta/v1.Duration</code></a>
</td>
<td>
   HTTPTimeout specifies the timeout duration for a call to the extender. Filter timeout fails the scheduling of the pod. Prioritize
timeout is ignored, k8s/other extenders priorities are used to select the node.</td>
</tr>
<tr><td><code>nodeCacheCapable</code> <B>[Required]</B><br/>
<code>bool</code>
</td>
<td>
   NodeCacheCapable specifies that the extender is capable of caching node information,
so the scheduler should only send minimal information about the eligible nodes
assuming that the extender already cached full details of all nodes in the cluster</td>
</tr>
<tr><td><code>managedResources</code><br/>
<a href="#kubescheduler-config-k8s-io-v1-ExtenderManagedResource"><code>[]ExtenderManagedResource</code></a>
</td>
<td>
   ManagedResources is a list of extended resources that are managed by
this extender.
- A pod will be sent to the extender on the Filter, Prioritize and Bind
  (if the extender is the binder) phases iff the pod requests at least
  one of the extended resources in this list. If empty or unspecified,
  all pods will be sent to this extender.
- If IgnoredByScheduler is set to true for a resource, kube-scheduler
  will skip checking the resource in predicates.</td>
</tr>
<tr><td><code>ignorable</code> <B>[Required]</B><br/>
<code>bool</code>
</td>
<td>
   Ignorable specifies if the extender is ignorable, i.e. scheduling should not
fail when the extender returns an error or is not reachable.</td>
</tr>
</tbody>
</table>
<h2 id="kubescheduler-config-k8s-io-v1beta1-KubeSchedulerProfile"><code>KubeSchedulerProfile</code>    </h2>
<p><strong>Appears in:</strong></p>
<ul>
<li><a href="#kubescheduler-config-k8s-io-v1beta1-KubeSchedulerConfiguration">KubeSchedulerConfiguration</a></li>
</ul>
<p>KubeSchedulerProfile is a scheduling profile.</p>
<table class="table">
<thead><tr><th width="30%">Field</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>schedulerName</code> <B>[Required]</B><br/>
<code>string</code>
</td>
<td>
   SchedulerName is the name of the scheduler associated to this profile.
If SchedulerName matches with the pod's "spec.schedulerName", then the pod
is scheduled with this profile.</td>
</tr>
<tr><td><code>plugins</code> <B>[Required]</B><br/>
<a href="#kubescheduler-config-k8s-io-v1beta1-Plugins"><code>Plugins</code></a>
</td>
<td>
   Plugins specify the set of plugins that should be enabled or disabled.
Enabled plugins are the ones that should be enabled in addition to the
default plugins. Disabled plugins are any of the default plugins that
should be disabled.
When no enabled or disabled plugin is specified for an extension point,
default plugins for that extension point will be used if there is any.
If a QueueSort plugin is specified, the same QueueSort Plugin and
PluginConfig must be specified for all profiles.</td>
</tr>
<tr><td><code>pluginConfig</code> <B>[Required]</B><br/>
<a href="#kubescheduler-config-k8s-io-v1beta1-PluginConfig"><code>[]PluginConfig</code></a>
</td>
<td>
   PluginConfig is an optional set of custom plugin arguments for each plugin.
Omitting config args for a plugin is equivalent to using the default config
for that plugin.</td>
</tr>
</tbody>
</table>
<h2 id="kubescheduler-config-k8s-io-v1beta1-Plugin"><code>Plugin</code>    </h2>
<p><strong>Appears in:</strong></p>
<ul>
<li><a href="#kubescheduler-config-k8s-io-v1beta1-PluginSet">PluginSet</a></li>
</ul>
<p>Plugin specifies a plugin name and its weight when applicable. Weight is used only for Score plugins.</p>
<table class="table">
<thead><tr><th width="30%">Field</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>name</code> <B>[Required]</B><br/>
<code>string</code>
</td>
<td>
   Name defines the name of plugin</td>
</tr>
<tr><td><code>weight</code> <B>[Required]</B><br/>
<code>int32</code>
</td>
<td>
   Weight defines the weight of plugin, only used for Score plugins.</td>
</tr>
</tbody>
</table>
<h2 id="kubescheduler-config-k8s-io-v1beta1-PluginConfig"><code>PluginConfig</code>    </h2>
<p><strong>Appears in:</strong></p>
<ul>
<li><a href="#kubescheduler-config-k8s-io-v1beta1-KubeSchedulerProfile">KubeSchedulerProfile</a></li>
</ul>
<p>PluginConfig specifies arguments that should be passed to a plugin at the time of initialization.
A plugin that is invoked at multiple extension points is initialized once. Args can have arbitrary structure.
It is up to the plugin to process these Args.</p>
<table class="table">
<thead><tr><th width="30%">Field</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>name</code> <B>[Required]</B><br/>
<code>string</code>
</td>
<td>
   Name defines the name of plugin being configured</td>
</tr>
<tr><td><code>args</code> <B>[Required]</B><br/>
<a href="https://godoc.org/k8s.io/apimachinery/pkg/runtime/#RawExtension"><code>k8s.io/apimachinery/pkg/runtime.RawExtension</code></a>
</td>
<td>
   Args defines the arguments passed to the plugins at the time of initialization. Args can have arbitrary structure.</td>
</tr>
</tbody>
</table>
<h2 id="kubescheduler-config-k8s-io-v1beta1-PluginSet"><code>PluginSet</code>    </h2>
<p><strong>Appears in:</strong></p>
<ul>
<li><a href="#kubescheduler-config-k8s-io-v1beta1-Plugins">Plugins</a></li>
</ul>
<p>PluginSet specifies enabled and disabled plugins for an extension point.
If an array is empty, missing, or nil, default plugins at that extension point will be used.</p>
<table class="table">
<thead><tr><th width="30%">Field</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>enabled</code> <B>[Required]</B><br/>
<a href="#kubescheduler-config-k8s-io-v1beta1-Plugin"><code>[]Plugin</code></a>
</td>
<td>
   Enabled specifies plugins that should be enabled in addition to default plugins.
These are called after default plugins and in the same order specified here.</td>
</tr>
<tr><td><code>disabled</code> <B>[Required]</B><br/>
<a href="#kubescheduler-config-k8s-io-v1beta1-Plugin"><code>[]Plugin</code></a>
</td>
<td>
   Disabled specifies default plugins that should be disabled.
When all default plugins need to be disabled, an array containing only one "&lowast;" should be provided.</td>
</tr>
</tbody>
</table>
<h2 id="kubescheduler-config-k8s-io-v1beta1-Plugins"><code>Plugins</code>    </h2>
<p><strong>Appears in:</strong></p>
<ul>
<li><a href="#kubescheduler-config-k8s-io-v1beta1-KubeSchedulerProfile">KubeSchedulerProfile</a></li>
</ul>
<p>Plugins include multiple extension points. When specified, the list of plugins for
a particular extension point are the only ones enabled. If an extension point is
omitted from the config, then the default set of plugins is used for that extension point.
Enabled plugins are called in the order specified here, after default plugins. If they need to
be invoked before default plugins, default plugins must be disabled and re-enabled here in desired order.</p>
<table class="table">
<thead><tr><th width="30%">Field</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>queueSort</code> <B>[Required]</B><br/>
<a href="#kubescheduler-config-k8s-io-v1beta1-PluginSet"><code>PluginSet</code></a>
</td>
<td>
   QueueSort is a list of plugins that should be invoked when sorting pods in the scheduling queue.</td>
</tr>
<tr><td><code>preFilter</code> <B>[Required]</B><br/>
<a href="#kubescheduler-config-k8s-io-v1beta1-PluginSet"><code>PluginSet</code></a>
</td>
<td>
   PreFilter is a list of plugins that should be invoked at "PreFilter" extension point of the scheduling framework.</td>
</tr>
<tr><td><code>filter</code> <B>[Required]</B><br/>
<a href="#kubescheduler-config-k8s-io-v1beta1-PluginSet"><code>PluginSet</code></a>
</td>
<td>
   Filter is a list of plugins that should be invoked when filtering out nodes that cannot run the Pod.</td>
</tr>
<tr><td><code>postFilter</code> <B>[Required]</B><br/>
<a href="#kubescheduler-config-k8s-io-v1beta1-PluginSet"><code>PluginSet</code></a>
</td>
<td>
   PostFilter is a list of plugins that are invoked after filtering phase, no matter whether filtering succeeds or not.</td>
</tr>
<tr><td><code>preScore</code> <B>[Required]</B><br/>
<a href="#kubescheduler-config-k8s-io-v1beta1-PluginSet"><code>PluginSet</code></a>
</td>
<td>
   PreScore is a list of plugins that are invoked before scoring.</td>
</tr>
<tr><td><code>score</code> <B>[Required]</B><br/>
<a href="#kubescheduler-config-k8s-io-v1beta1-PluginSet"><code>PluginSet</code></a>
</td>
<td>
   Score is a list of plugins that should be invoked when ranking nodes that have passed the filtering phase.</td>
</tr>
<tr><td><code>reserve</code> <B>[Required]</B><br/>
<a href="#kubescheduler-config-k8s-io-v1beta1-PluginSet"><code>PluginSet</code></a>
</td>
<td>
   Reserve is a list of plugins invoked when reserving/unreserving resources
after a node is assigned to run the pod.</td>
</tr>
<tr><td><code>permit</code> <B>[Required]</B><br/>
<a href="#kubescheduler-config-k8s-io-v1beta1-PluginSet"><code>PluginSet</code></a>
</td>
<td>
   Permit is a list of plugins that control binding of a Pod. These plugins can prevent or delay binding of a Pod.</td>
</tr>
<tr><td><code>preBind</code> <B>[Required]</B><br/>
<a href="#kubescheduler-config-k8s-io-v1beta1-PluginSet"><code>PluginSet</code></a>
</td>
<td>
   PreBind is a list of plugins that should be invoked before a pod is bound.</td>
</tr>
<tr><td><code>bind</code> <B>[Required]</B><br/>
<a href="#kubescheduler-config-k8s-io-v1beta1-PluginSet"><code>PluginSet</code></a>
</td>
<td>
   Bind is a list of plugins that should be invoked at "Bind" extension point of the scheduling framework.
The scheduler call these plugins in order. Scheduler skips the rest of these plugins as soon as one returns success.</td>
</tr>
<tr><td><code>postBind</code> <B>[Required]</B><br/>
<a href="#kubescheduler-config-k8s-io-v1beta1-PluginSet"><code>PluginSet</code></a>
</td>
<td>
   PostBind is a list of plugins that should be invoked after a pod is successfully bound.</td>
</tr>
</tbody>
</table>
<h2 id="kubescheduler-config-k8s-io-v1beta1-PodTopologySpreadConstraintsDefaulting"><code>PodTopologySpreadConstraintsDefaulting</code>    </h2>
<p>(Alias of <code>string</code>)</p>
<p><strong>Appears in:</strong></p>
<ul>
<li><a href="#kubescheduler-config-k8s-io-v1beta1-PodTopologySpreadArgs">PodTopologySpreadArgs</a></li>
</ul>
<p>PodTopologySpreadConstraintsDefaulting defines how to set default constraints
for the PodTopologySpread plugin.</p>
<h2 id="kubescheduler-config-k8s-io-v1beta1-ResourceSpec"><code>ResourceSpec</code>    </h2>
<p><strong>Appears in:</strong></p>
<ul>
<li>
<p><a href="#kubescheduler-config-k8s-io-v1beta1-NodeResourcesLeastAllocatedArgs">NodeResourcesLeastAllocatedArgs</a></p>
</li>
<li>
<p><a href="#kubescheduler-config-k8s-io-v1beta1-NodeResourcesMostAllocatedArgs">NodeResourcesMostAllocatedArgs</a></p>
</li>
<li>
<p><a href="#kubescheduler-config-k8s-io-v1beta1-RequestedToCapacityRatioArgs">RequestedToCapacityRatioArgs</a></p>
</li>
</ul>
<p>ResourceSpec represents single resource and weight for bin packing of priority RequestedToCapacityRatioArguments.</p>
<table class="table">
<thead><tr><th width="30%">Field</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>name</code> <B>[Required]</B><br/>
<code>string</code>
</td>
<td>
   Name of the resource to be managed by RequestedToCapacityRatio function.</td>
</tr>
<tr><td><code>weight</code> <B>[Required]</B><br/>
<code>int64</code>
</td>
<td>
   Weight of the resource.</td>
</tr>
</tbody>
</table>
<h2 id="kubescheduler-config-k8s-io-v1beta1-UtilizationShapePoint"><code>UtilizationShapePoint</code>    </h2>
<p><strong>Appears in:</strong></p>
<ul>
<li><a href="#kubescheduler-config-k8s-io-v1beta1-RequestedToCapacityRatioArgs">RequestedToCapacityRatioArgs</a></li>
</ul>
<p>UtilizationShapePoint represents single point of priority function shape.</p>
<table class="table">
<thead><tr><th width="30%">Field</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>utilization</code> <B>[Required]</B><br/>
<code>int32</code>
</td>
<td>
   Utilization (x axis). Valid values are 0 to 100. Fully utilized node maps to 100.</td>
</tr>
<tr><td><code>score</code> <B>[Required]</B><br/>
<code>int32</code>
</td>
<td>
   Score assigned to given utilization (y axis). Valid values are 0 to 10.</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-699f28965d0a72527ebd04826dda8901">10.5 - kube-scheduler Policy Configuration (v1)</h1>
    
	<h2 id="resource-types">Resource Types</h2>
<ul>
<li><a href="#kubescheduler-config-k8s-io-v1-Policy">Policy</a></li>
</ul>
<h2 id="kubescheduler-config-k8s-io-v1-Policy"><code>Policy</code>    </h2>
<p>Policy describes a struct for a policy resource used in api.</p>
<table class="table">
<thead><tr><th width="30%">Field</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>apiVersion</code><br/>string</td><td><code>kubescheduler.config.k8s.io/v1</code></td></tr>
<tr><td><code>kind</code><br/>string</td><td><code>Policy</code></td></tr>
<tr><td><code>predicates</code> <B>[Required]</B><br/>
<a href="#kubescheduler-config-k8s-io-v1-PredicatePolicy"><code>[]PredicatePolicy</code></a>
</td>
<td>
   Holds the information to configure the fit predicate functions</td>
</tr>
<tr><td><code>priorities</code> <B>[Required]</B><br/>
<a href="#kubescheduler-config-k8s-io-v1-PriorityPolicy"><code>[]PriorityPolicy</code></a>
</td>
<td>
   Holds the information to configure the priority functions</td>
</tr>
<tr><td><code>extenders</code> <B>[Required]</B><br/>
<a href="#kubescheduler-config-k8s-io-v1-LegacyExtender"><code>[]LegacyExtender</code></a>
</td>
<td>
   Holds the information to communicate with the extender(s)</td>
</tr>
<tr><td><code>hardPodAffinitySymmetricWeight</code> <B>[Required]</B><br/>
<code>int32</code>
</td>
<td>
   RequiredDuringScheduling affinity is not symmetric, but there is an implicit PreferredDuringScheduling affinity rule
corresponding to every RequiredDuringScheduling affinity rule.
HardPodAffinitySymmetricWeight represents the weight of implicit PreferredDuringScheduling affinity rule, in the range 1-100.</td>
</tr>
<tr><td><code>alwaysCheckAllPredicates</code> <B>[Required]</B><br/>
<code>bool</code>
</td>
<td>
   When AlwaysCheckAllPredicates is set to true, scheduler checks all
the configured predicates even after one or more of them fails.
When the flag is set to false, scheduler skips checking the rest
of the predicates after it finds one predicate that failed.</td>
</tr>
</tbody>
</table>
<h2 id="kubescheduler-config-k8s-io-v1-ExtenderManagedResource"><code>ExtenderManagedResource</code>    </h2>
<p><strong>Appears in:</strong></p>
<ul>
<li>
<p><a href="#kubescheduler-config-k8s-io-v1beta1-Extender">Extender</a></p>
</li>
<li>
<p><a href="#kubescheduler-config-k8s-io-v1-LegacyExtender">LegacyExtender</a></p>
</li>
</ul>
<p>ExtenderManagedResource describes the arguments of extended resources
managed by an extender.</p>
<table class="table">
<thead><tr><th width="30%">Field</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>name</code> <B>[Required]</B><br/>
<code>string</code>
</td>
<td>
   Name is the extended resource name.</td>
</tr>
<tr><td><code>ignoredByScheduler</code> <B>[Required]</B><br/>
<code>bool</code>
</td>
<td>
   IgnoredByScheduler indicates whether kube-scheduler should ignore this
resource when applying predicates.</td>
</tr>
</tbody>
</table>
<h2 id="kubescheduler-config-k8s-io-v1-ExtenderTLSConfig"><code>ExtenderTLSConfig</code>    </h2>
<p><strong>Appears in:</strong></p>
<ul>
<li>
<p><a href="#kubescheduler-config-k8s-io-v1beta1-Extender">Extender</a></p>
</li>
<li>
<p><a href="#kubescheduler-config-k8s-io-v1-LegacyExtender">LegacyExtender</a></p>
</li>
</ul>
<p>ExtenderTLSConfig contains settings to enable TLS with extender</p>
<table class="table">
<thead><tr><th width="30%">Field</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>insecure</code> <B>[Required]</B><br/>
<code>bool</code>
</td>
<td>
   Server should be accessed without verifying the TLS certificate. For testing only.</td>
</tr>
<tr><td><code>serverName</code> <B>[Required]</B><br/>
<code>string</code>
</td>
<td>
   ServerName is passed to the server for SNI and is used in the client to check server
certificates against. If ServerName is empty, the hostname used to contact the
server is used.</td>
</tr>
<tr><td><code>certFile</code> <B>[Required]</B><br/>
<code>string</code>
</td>
<td>
   Server requires TLS client certificate authentication</td>
</tr>
<tr><td><code>keyFile</code> <B>[Required]</B><br/>
<code>string</code>
</td>
<td>
   Server requires TLS client certificate authentication</td>
</tr>
<tr><td><code>caFile</code> <B>[Required]</B><br/>
<code>string</code>
</td>
<td>
   Trusted root certificates for server</td>
</tr>
<tr><td><code>certData</code> <B>[Required]</B><br/>
<code>[]byte</code>
</td>
<td>
   CertData holds PEM-encoded bytes (typically read from a client certificate file).
CertData takes precedence over CertFile</td>
</tr>
<tr><td><code>keyData</code> <B>[Required]</B><br/>
<code>[]byte</code>
</td>
<td>
   KeyData holds PEM-encoded bytes (typically read from a client certificate key file).
KeyData takes precedence over KeyFile</td>
</tr>
<tr><td><code>caData</code> <B>[Required]</B><br/>
<code>[]byte</code>
</td>
<td>
   CAData holds PEM-encoded bytes (typically read from a root certificates bundle).
CAData takes precedence over CAFile</td>
</tr>
</tbody>
</table>
<h2 id="kubescheduler-config-k8s-io-v1-LabelPreference"><code>LabelPreference</code>    </h2>
<p><strong>Appears in:</strong></p>
<ul>
<li><a href="#kubescheduler-config-k8s-io-v1-PriorityArgument">PriorityArgument</a></li>
</ul>
<p>LabelPreference holds the parameters that are used to configure the corresponding priority function</p>
<table class="table">
<thead><tr><th width="30%">Field</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>label</code> <B>[Required]</B><br/>
<code>string</code>
</td>
<td>
   Used to identify node "groups"</td>
</tr>
<tr><td><code>presence</code> <B>[Required]</B><br/>
<code>bool</code>
</td>
<td>
   This is a boolean flag
If true, higher priority is given to nodes that have the label
If false, higher priority is given to nodes that do not have the label</td>
</tr>
</tbody>
</table>
<h2 id="kubescheduler-config-k8s-io-v1-LabelsPresence"><code>LabelsPresence</code>    </h2>
<p><strong>Appears in:</strong></p>
<ul>
<li><a href="#kubescheduler-config-k8s-io-v1-PredicateArgument">PredicateArgument</a></li>
</ul>
<p>LabelsPresence holds the parameters that are used to configure the corresponding predicate in scheduler policy configuration.</p>
<table class="table">
<thead><tr><th width="30%">Field</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>labels</code> <B>[Required]</B><br/>
<code>[]string</code>
</td>
<td>
   The list of labels that identify node "groups"
All of the labels should be either present (or absent) for the node to be considered a fit for hosting the pod</td>
</tr>
<tr><td><code>presence</code> <B>[Required]</B><br/>
<code>bool</code>
</td>
<td>
   The boolean flag that indicates whether the labels should be present or absent from the node</td>
</tr>
</tbody>
</table>
<h2 id="kubescheduler-config-k8s-io-v1-LegacyExtender"><code>LegacyExtender</code>    </h2>
<p><strong>Appears in:</strong></p>
<ul>
<li><a href="#kubescheduler-config-k8s-io-v1-Policy">Policy</a></li>
</ul>
<p>LegacyExtender holds the parameters used to communicate with the extender. If a verb is unspecified/empty,
it is assumed that the extender chose not to provide that extension.</p>
<table class="table">
<thead><tr><th width="30%">Field</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>urlPrefix</code> <B>[Required]</B><br/>
<code>string</code>
</td>
<td>
   URLPrefix at which the extender is available</td>
</tr>
<tr><td><code>filterVerb</code> <B>[Required]</B><br/>
<code>string</code>
</td>
<td>
   Verb for the filter call, empty if not supported. This verb is appended to the URLPrefix when issuing the filter call to extender.</td>
</tr>
<tr><td><code>preemptVerb</code> <B>[Required]</B><br/>
<code>string</code>
</td>
<td>
   Verb for the preempt call, empty if not supported. This verb is appended to the URLPrefix when issuing the preempt call to extender.</td>
</tr>
<tr><td><code>prioritizeVerb</code> <B>[Required]</B><br/>
<code>string</code>
</td>
<td>
   Verb for the prioritize call, empty if not supported. This verb is appended to the URLPrefix when issuing the prioritize call to extender.</td>
</tr>
<tr><td><code>weight</code> <B>[Required]</B><br/>
<code>int64</code>
</td>
<td>
   The numeric multiplier for the node scores that the prioritize call generates.
The weight should be a positive integer</td>
</tr>
<tr><td><code>bindVerb</code> <B>[Required]</B><br/>
<code>string</code>
</td>
<td>
   Verb for the bind call, empty if not supported. This verb is appended to the URLPrefix when issuing the bind call to extender.
If this method is implemented by the extender, it is the extender's responsibility to bind the pod to apiserver. Only one extender
can implement this function.</td>
</tr>
<tr><td><code>enableHttps</code> <B>[Required]</B><br/>
<code>bool</code>
</td>
<td>
   EnableHTTPS specifies whether https should be used to communicate with the extender</td>
</tr>
<tr><td><code>tlsConfig</code> <B>[Required]</B><br/>
<a href="#kubescheduler-config-k8s-io-v1-ExtenderTLSConfig"><code>ExtenderTLSConfig</code></a>
</td>
<td>
   TLSConfig specifies the transport layer security config</td>
</tr>
<tr><td><code>httpTimeout</code> <B>[Required]</B><br/>
<a href="https://godoc.org/time#Duration"><code>time.Duration</code></a>
</td>
<td>
   HTTPTimeout specifies the timeout duration for a call to the extender. Filter timeout fails the scheduling of the pod. Prioritize
timeout is ignored, k8s/other extenders priorities are used to select the node.</td>
</tr>
<tr><td><code>nodeCacheCapable</code> <B>[Required]</B><br/>
<code>bool</code>
</td>
<td>
   NodeCacheCapable specifies that the extender is capable of caching node information,
so the scheduler should only send minimal information about the eligible nodes
assuming that the extender already cached full details of all nodes in the cluster</td>
</tr>
<tr><td><code>managedResources</code><br/>
<a href="#kubescheduler-config-k8s-io-v1-ExtenderManagedResource"><code>[]ExtenderManagedResource</code></a>
</td>
<td>
   ManagedResources is a list of extended resources that are managed by
this extender.
- A pod will be sent to the extender on the Filter, Prioritize and Bind
  (if the extender is the binder) phases iff the pod requests at least
  one of the extended resources in this list. If empty or unspecified,
  all pods will be sent to this extender.
- If IgnoredByScheduler is set to true for a resource, kube-scheduler
  will skip checking the resource in predicates.</td>
</tr>
<tr><td><code>ignorable</code> <B>[Required]</B><br/>
<code>bool</code>
</td>
<td>
   Ignorable specifies if the extender is ignorable, i.e. scheduling should not
fail when the extender returns an error or is not reachable.</td>
</tr>
</tbody>
</table>
<h2 id="kubescheduler-config-k8s-io-v1-PredicateArgument"><code>PredicateArgument</code>    </h2>
<p><strong>Appears in:</strong></p>
<ul>
<li><a href="#kubescheduler-config-k8s-io-v1-PredicatePolicy">PredicatePolicy</a></li>
</ul>
<p>PredicateArgument represents the arguments to configure predicate functions in scheduler policy configuration.
Only one of its members may be specified</p>
<table class="table">
<thead><tr><th width="30%">Field</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>serviceAffinity</code> <B>[Required]</B><br/>
<a href="#kubescheduler-config-k8s-io-v1-ServiceAffinity"><code>ServiceAffinity</code></a>
</td>
<td>
   The predicate that provides affinity for pods belonging to a service
It uses a label to identify nodes that belong to the same "group"</td>
</tr>
<tr><td><code>labelsPresence</code> <B>[Required]</B><br/>
<a href="#kubescheduler-config-k8s-io-v1-LabelsPresence"><code>LabelsPresence</code></a>
</td>
<td>
   The predicate that checks whether a particular node has a certain label
defined or not, regardless of value</td>
</tr>
</tbody>
</table>
<h2 id="kubescheduler-config-k8s-io-v1-PredicatePolicy"><code>PredicatePolicy</code>    </h2>
<p><strong>Appears in:</strong></p>
<ul>
<li><a href="#kubescheduler-config-k8s-io-v1-Policy">Policy</a></li>
</ul>
<p>PredicatePolicy describes a struct of a predicate policy.</p>
<table class="table">
<thead><tr><th width="30%">Field</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>name</code> <B>[Required]</B><br/>
<code>string</code>
</td>
<td>
   Identifier of the predicate policy
For a custom predicate, the name can be user-defined
For the Kubernetes provided predicates, the name is the identifier of the pre-defined predicate</td>
</tr>
<tr><td><code>argument</code> <B>[Required]</B><br/>
<a href="#kubescheduler-config-k8s-io-v1-PredicateArgument"><code>PredicateArgument</code></a>
</td>
<td>
   Holds the parameters to configure the given predicate</td>
</tr>
</tbody>
</table>
<h2 id="kubescheduler-config-k8s-io-v1-PriorityArgument"><code>PriorityArgument</code>    </h2>
<p><strong>Appears in:</strong></p>
<ul>
<li><a href="#kubescheduler-config-k8s-io-v1-PriorityPolicy">PriorityPolicy</a></li>
</ul>
<p>PriorityArgument represents the arguments to configure priority functions in scheduler policy configuration.
Only one of its members may be specified</p>
<table class="table">
<thead><tr><th width="30%">Field</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>serviceAntiAffinity</code> <B>[Required]</B><br/>
<a href="#kubescheduler-config-k8s-io-v1-ServiceAntiAffinity"><code>ServiceAntiAffinity</code></a>
</td>
<td>
   The priority function that ensures a good spread (anti-affinity) for pods belonging to a service
It uses a label to identify nodes that belong to the same "group"</td>
</tr>
<tr><td><code>labelPreference</code> <B>[Required]</B><br/>
<a href="#kubescheduler-config-k8s-io-v1-LabelPreference"><code>LabelPreference</code></a>
</td>
<td>
   The priority function that checks whether a particular node has a certain label
defined or not, regardless of value</td>
</tr>
<tr><td><code>requestedToCapacityRatioArguments</code> <B>[Required]</B><br/>
<a href="#kubescheduler-config-k8s-io-v1-RequestedToCapacityRatioArguments"><code>RequestedToCapacityRatioArguments</code></a>
</td>
<td>
   The RequestedToCapacityRatio priority function is parametrized with function shape.</td>
</tr>
</tbody>
</table>
<h2 id="kubescheduler-config-k8s-io-v1-PriorityPolicy"><code>PriorityPolicy</code>    </h2>
<p><strong>Appears in:</strong></p>
<ul>
<li><a href="#kubescheduler-config-k8s-io-v1-Policy">Policy</a></li>
</ul>
<p>PriorityPolicy describes a struct of a priority policy.</p>
<table class="table">
<thead><tr><th width="30%">Field</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>name</code> <B>[Required]</B><br/>
<code>string</code>
</td>
<td>
   Identifier of the priority policy
For a custom priority, the name can be user-defined
For the Kubernetes provided priority functions, the name is the identifier of the pre-defined priority function</td>
</tr>
<tr><td><code>weight</code> <B>[Required]</B><br/>
<code>int64</code>
</td>
<td>
   The numeric multiplier for the node scores that the priority function generates
The weight should be non-zero and can be a positive or a negative integer</td>
</tr>
<tr><td><code>argument</code> <B>[Required]</B><br/>
<a href="#kubescheduler-config-k8s-io-v1-PriorityArgument"><code>PriorityArgument</code></a>
</td>
<td>
   Holds the parameters to configure the given priority function</td>
</tr>
</tbody>
</table>
<h2 id="kubescheduler-config-k8s-io-v1-RequestedToCapacityRatioArguments"><code>RequestedToCapacityRatioArguments</code>    </h2>
<p><strong>Appears in:</strong></p>
<ul>
<li><a href="#kubescheduler-config-k8s-io-v1-PriorityArgument">PriorityArgument</a></li>
</ul>
<p>RequestedToCapacityRatioArguments holds arguments specific to RequestedToCapacityRatio priority function.</p>
<table class="table">
<thead><tr><th width="30%">Field</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>shape</code> <B>[Required]</B><br/>
<a href="#kubescheduler-config-k8s-io-v1-UtilizationShapePoint"><code>[]UtilizationShapePoint</code></a>
</td>
<td>
   Array of point defining priority function shape.</td>
</tr>
<tr><td><code>resources</code> <B>[Required]</B><br/>
<a href="#kubescheduler-config-k8s-io-v1-ResourceSpec"><code>[]ResourceSpec</code></a>
</td>
<td>
   <span class="text-muted">No description provided.</span>
   </td>
</tr>
</tbody>
</table>
<h2 id="kubescheduler-config-k8s-io-v1-ResourceSpec"><code>ResourceSpec</code>    </h2>
<p><strong>Appears in:</strong></p>
<ul>
<li><a href="#kubescheduler-config-k8s-io-v1-RequestedToCapacityRatioArguments">RequestedToCapacityRatioArguments</a></li>
</ul>
<p>ResourceSpec represents single resource and weight for bin packing of priority RequestedToCapacityRatioArguments.</p>
<table class="table">
<thead><tr><th width="30%">Field</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>name</code> <B>[Required]</B><br/>
<code>string</code>
</td>
<td>
   Name of the resource to be managed by RequestedToCapacityRatio function.</td>
</tr>
<tr><td><code>weight</code> <B>[Required]</B><br/>
<code>int64</code>
</td>
<td>
   Weight of the resource.</td>
</tr>
</tbody>
</table>
<h2 id="kubescheduler-config-k8s-io-v1-ServiceAffinity"><code>ServiceAffinity</code>    </h2>
<p><strong>Appears in:</strong></p>
<ul>
<li><a href="#kubescheduler-config-k8s-io-v1-PredicateArgument">PredicateArgument</a></li>
</ul>
<p>ServiceAffinity holds the parameters that are used to configure the corresponding predicate in scheduler policy configuration.</p>
<table class="table">
<thead><tr><th width="30%">Field</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>labels</code> <B>[Required]</B><br/>
<code>[]string</code>
</td>
<td>
   The list of labels that identify node "groups"
All of the labels should match for the node to be considered a fit for hosting the pod</td>
</tr>
</tbody>
</table>
<h2 id="kubescheduler-config-k8s-io-v1-ServiceAntiAffinity"><code>ServiceAntiAffinity</code>    </h2>
<p><strong>Appears in:</strong></p>
<ul>
<li><a href="#kubescheduler-config-k8s-io-v1-PriorityArgument">PriorityArgument</a></li>
</ul>
<p>ServiceAntiAffinity holds the parameters that are used to configure the corresponding priority function</p>
<table class="table">
<thead><tr><th width="30%">Field</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>label</code> <B>[Required]</B><br/>
<code>string</code>
</td>
<td>
   Used to identify node "groups"</td>
</tr>
</tbody>
</table>
<h2 id="kubescheduler-config-k8s-io-v1-UtilizationShapePoint"><code>UtilizationShapePoint</code>    </h2>
<p><strong>Appears in:</strong></p>
<ul>
<li><a href="#kubescheduler-config-k8s-io-v1-RequestedToCapacityRatioArguments">RequestedToCapacityRatioArguments</a></li>
</ul>
<p>UtilizationShapePoint represents single point of priority function shape.</p>
<table class="table">
<thead><tr><th width="30%">Field</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>utilization</code> <B>[Required]</B><br/>
<code>int32</code>
</td>
<td>
   Utilization (x axis). Valid values are 0 to 100. Fully utilized node maps to 100.</td>
</tr>
<tr><td><code>score</code> <B>[Required]</B><br/>
<code>int32</code>
</td>
<td>
   Score assigned to given utilization (y axis). Valid values are 0 to 10.</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-aaa2b8b78fe84a05914c155652d10956">10.6 - Kubelet Configuration (v1beta1)</h1>
    
	<h2 id="resource-types">Resource Types</h2>
<ul>
<li><a href="#kubelet-config-k8s-io-v1beta1-KubeletConfiguration">KubeletConfiguration</a></li>
<li><a href="#kubelet-config-k8s-io-v1beta1-SerializedNodeConfigSource">SerializedNodeConfigSource</a></li>
</ul>
<h2 id="kubelet-config-k8s-io-v1beta1-KubeletConfiguration"><code>KubeletConfiguration</code>    </h2>
<p>KubeletConfiguration contains the configuration for the Kubelet</p>
<table class="table">
<thead><tr><th width="30%">Field</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>apiVersion</code><br/>string</td><td><code>kubelet.config.k8s.io/v1beta1</code></td></tr>
<tr><td><code>kind</code><br/>string</td><td><code>KubeletConfiguration</code></td></tr>
<tr><td><code>enableServer</code> <B>[Required]</B><br/>
<code>bool</code>
</td>
<td>
   enableServer enables Kubelet's secured server.
Note: Kubelet's insecure port is controlled by the readOnlyPort option.
Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
it may disrupt components that interact with the Kubelet server.
Default: true</td>
</tr>
<tr><td><code>staticPodPath</code><br/>
<code>string</code>
</td>
<td>
   staticPodPath is the path to the directory containing local (static) pods to
run, or the path to a single static pod file.
Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
the set of static pods specified at the new path may be different than the
ones the Kubelet initially started with, and this may disrupt your node.
Default: ""</td>
</tr>
<tr><td><code>syncFrequency</code><br/>
<a href="https://godoc.org/k8s.io/apimachinery/pkg/apis/meta/v1#Duration"><code>meta/v1.Duration</code></a>
</td>
<td>
   syncFrequency is the max period between synchronizing running
containers and config.
Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
shortening this duration may have a negative performance impact, especially
as the number of Pods on the node increases. Alternatively, increasing this
duration will result in longer refresh times for ConfigMaps and Secrets.
Default: "1m"</td>
</tr>
<tr><td><code>fileCheckFrequency</code><br/>
<a href="https://godoc.org/k8s.io/apimachinery/pkg/apis/meta/v1#Duration"><code>meta/v1.Duration</code></a>
</td>
<td>
   fileCheckFrequency is the duration between checking config files for
new data
Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
shortening the duration will cause the Kubelet to reload local Static Pod
configurations more frequently, which may have a negative performance impact.
Default: "20s"</td>
</tr>
<tr><td><code>httpCheckFrequency</code><br/>
<a href="https://godoc.org/k8s.io/apimachinery/pkg/apis/meta/v1#Duration"><code>meta/v1.Duration</code></a>
</td>
<td>
   httpCheckFrequency is the duration between checking http for new data
Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
shortening the duration will cause the Kubelet to poll staticPodURL more
frequently, which may have a negative performance impact.
Default: "20s"</td>
</tr>
<tr><td><code>staticPodURL</code><br/>
<code>string</code>
</td>
<td>
   staticPodURL is the URL for accessing static pods to run
Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
the set of static pods specified at the new URL may be different than the
ones the Kubelet initially started with, and this may disrupt your node.
Default: ""</td>
</tr>
<tr><td><code>staticPodURLHeader</code><br/>
<code>map[string][]string</code>
</td>
<td>
   staticPodURLHeader is a map of slices with HTTP headers to use when accessing the podURL
Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
it may disrupt the ability to read the latest set of static pods from StaticPodURL.
Default: nil</td>
</tr>
<tr><td><code>address</code><br/>
<code>string</code>
</td>
<td>
   address is the IP address for the Kubelet to serve on (set to 0.0.0.0
for all interfaces).
Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
it may disrupt components that interact with the Kubelet server.
Default: "0.0.0.0"</td>
</tr>
<tr><td><code>port</code><br/>
<code>int32</code>
</td>
<td>
   port is the port for the Kubelet to serve on.
Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
it may disrupt components that interact with the Kubelet server.
Default: 10250</td>
</tr>
<tr><td><code>readOnlyPort</code><br/>
<code>int32</code>
</td>
<td>
   readOnlyPort is the read-only port for the Kubelet to serve on with
no authentication/authorization.
Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
it may disrupt components that interact with the Kubelet server.
Default: 0 (disabled)</td>
</tr>
<tr><td><code>tlsCertFile</code><br/>
<code>string</code>
</td>
<td>
   tlsCertFile is the file containing x509 Certificate for HTTPS. (CA cert,
if any, concatenated after server cert). If tlsCertFile and
tlsPrivateKeyFile are not provided, a self-signed certificate
and key are generated for the public address and saved to the directory
passed to the Kubelet's --cert-dir flag.
Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
it may disrupt components that interact with the Kubelet server.
Default: ""</td>
</tr>
<tr><td><code>tlsPrivateKeyFile</code><br/>
<code>string</code>
</td>
<td>
   tlsPrivateKeyFile is the file containing x509 private key matching tlsCertFile
Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
it may disrupt components that interact with the Kubelet server.
Default: ""</td>
</tr>
<tr><td><code>tlsCipherSuites</code><br/>
<code>[]string</code>
</td>
<td>
   TLSCipherSuites is the list of allowed cipher suites for the server.
Values are from tls package constants (https://golang.org/pkg/crypto/tls/#pkg-constants).
Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
it may disrupt components that interact with the Kubelet server.
Default: nil</td>
</tr>
<tr><td><code>tlsMinVersion</code><br/>
<code>string</code>
</td>
<td>
   TLSMinVersion is the minimum TLS version supported.
Values are from tls package constants (https://golang.org/pkg/crypto/tls/#pkg-constants).
Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
it may disrupt components that interact with the Kubelet server.
Default: ""</td>
</tr>
<tr><td><code>rotateCertificates</code><br/>
<code>bool</code>
</td>
<td>
   rotateCertificates enables client certificate rotation. The Kubelet will request a
new certificate from the certificates.k8s.io API. This requires an approver to approve the
certificate signing requests.
Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
disabling it may disrupt the Kubelet's ability to authenticate with the API server
after the current certificate expires.
Default: false</td>
</tr>
<tr><td><code>serverTLSBootstrap</code><br/>
<code>bool</code>
</td>
<td>
   serverTLSBootstrap enables server certificate bootstrap. Instead of self
signing a serving certificate, the Kubelet will request a certificate from
the certificates.k8s.io API. This requires an approver to approve the
certificate signing requests. The RotateKubeletServerCertificate feature
must be enabled.
Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
disabling it will stop the renewal of Kubelet server certificates, which can
disrupt components that interact with the Kubelet server in the long term,
due to certificate expiration.
Default: false</td>
</tr>
<tr><td><code>authentication</code><br/>
<a href="#kubelet-config-k8s-io-v1beta1-KubeletAuthentication"><code>KubeletAuthentication</code></a>
</td>
<td>
   authentication specifies how requests to the Kubelet's server are authenticated
Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
it may disrupt components that interact with the Kubelet server.
Defaults:
  anonymous:
    enabled: false
  webhook:
    enabled: true
    cacheTTL: "2m"</td>
</tr>
<tr><td><code>authorization</code><br/>
<a href="#kubelet-config-k8s-io-v1beta1-KubeletAuthorization"><code>KubeletAuthorization</code></a>
</td>
<td>
   authorization specifies how requests to the Kubelet's server are authorized
Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
it may disrupt components that interact with the Kubelet server.
Defaults:
  mode: Webhook
  webhook:
    cacheAuthorizedTTL: "5m"
    cacheUnauthorizedTTL: "30s"</td>
</tr>
<tr><td><code>registryPullQPS</code><br/>
<code>int32</code>
</td>
<td>
   registryPullQPS is the limit of registry pulls per second.
Set to 0 for no limit.
Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
it may impact scalability by changing the amount of traffic produced
by image pulls.
Default: 5</td>
</tr>
<tr><td><code>registryBurst</code><br/>
<code>int32</code>
</td>
<td>
   registryBurst is the maximum size of bursty pulls, temporarily allows
pulls to burst to this number, while still not exceeding registryPullQPS.
Only used if registryPullQPS > 0.
Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
it may impact scalability by changing the amount of traffic produced
by image pulls.
Default: 10</td>
</tr>
<tr><td><code>eventRecordQPS</code><br/>
<code>int32</code>
</td>
<td>
   eventRecordQPS is the maximum event creations per second. If 0, there
is no limit enforced.
Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
it may impact scalability by changing the amount of traffic produced by
event creations.
Default: 5</td>
</tr>
<tr><td><code>eventBurst</code><br/>
<code>int32</code>
</td>
<td>
   eventBurst is the maximum size of a burst of event creations, temporarily
allows event creations to burst to this number, while still not exceeding
eventRecordQPS. Only used if eventRecordQPS > 0.
Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
it may impact scalability by changing the amount of traffic produced by
event creations.
Default: 10</td>
</tr>
<tr><td><code>enableDebuggingHandlers</code><br/>
<code>bool</code>
</td>
<td>
   enableDebuggingHandlers enables server endpoints for log access
and local running of containers and commands, including the exec,
attach, logs, and portforward features.
Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
disabling it may disrupt components that interact with the Kubelet server.
Default: true</td>
</tr>
<tr><td><code>enableContentionProfiling</code><br/>
<code>bool</code>
</td>
<td>
   enableContentionProfiling enables lock contention profiling, if enableDebuggingHandlers is true.
Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
enabling it may carry a performance impact.
Default: false</td>
</tr>
<tr><td><code>healthzPort</code><br/>
<code>int32</code>
</td>
<td>
   healthzPort is the port of the localhost healthz endpoint (set to 0 to disable)
Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
it may disrupt components that monitor Kubelet health.
Default: 10248</td>
</tr>
<tr><td><code>healthzBindAddress</code><br/>
<code>string</code>
</td>
<td>
   healthzBindAddress is the IP address for the healthz server to serve on
Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
it may disrupt components that monitor Kubelet health.
Default: "127.0.0.1"</td>
</tr>
<tr><td><code>oomScoreAdj</code><br/>
<code>int32</code>
</td>
<td>
   oomScoreAdj is The oom-score-adj value for kubelet process. Values
must be within the range [-1000, 1000].
Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
it may impact the stability of nodes under memory pressure.
Default: -999</td>
</tr>
<tr><td><code>clusterDomain</code><br/>
<code>string</code>
</td>
<td>
   clusterDomain is the DNS domain for this cluster. If set, kubelet will
configure all containers to search this domain in addition to the
host's search domains.
Dynamic Kubelet Config (beta): Dynamically updating this field is not recommended,
as it should be kept in sync with the rest of the cluster.
Default: ""</td>
</tr>
<tr><td><code>clusterDNS</code><br/>
<code>[]string</code>
</td>
<td>
   clusterDNS is a list of IP addresses for the cluster DNS server. If set,
kubelet will configure all containers to use this for DNS resolution
instead of the host's DNS servers.
Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
changes will only take effect on Pods created after the update. Draining
the node is recommended before changing this field.
Default: nil</td>
</tr>
<tr><td><code>streamingConnectionIdleTimeout</code><br/>
<a href="https://godoc.org/k8s.io/apimachinery/pkg/apis/meta/v1#Duration"><code>meta/v1.Duration</code></a>
</td>
<td>
   streamingConnectionIdleTimeout is the maximum time a streaming connection
can be idle before the connection is automatically closed.
Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
it may impact components that rely on infrequent updates over streaming
connections to the Kubelet server.
Default: "4h"</td>
</tr>
<tr><td><code>nodeStatusUpdateFrequency</code><br/>
<a href="https://godoc.org/k8s.io/apimachinery/pkg/apis/meta/v1#Duration"><code>meta/v1.Duration</code></a>
</td>
<td>
   nodeStatusUpdateFrequency is the frequency that kubelet computes node
status. If node lease feature is not enabled, it is also the frequency that
kubelet posts node status to master.
Note: When node lease feature is not enabled, be cautious when changing the
constant, it must work with nodeMonitorGracePeriod in nodecontroller.
Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
it may impact node scalability, and also that the node controller's
nodeMonitorGracePeriod must be set to N&lowast;NodeStatusUpdateFrequency,
where N is the number of retries before the node controller marks
the node unhealthy.
Default: "10s"</td>
</tr>
<tr><td><code>nodeStatusReportFrequency</code><br/>
<a href="https://godoc.org/k8s.io/apimachinery/pkg/apis/meta/v1#Duration"><code>meta/v1.Duration</code></a>
</td>
<td>
   nodeStatusReportFrequency is the frequency that kubelet posts node
status to master if node status does not change. Kubelet will ignore this
frequency and post node status immediately if any change is detected. It is
only used when node lease feature is enabled. nodeStatusReportFrequency's
default value is 1m. But if nodeStatusUpdateFrequency is set explicitly,
nodeStatusReportFrequency's default value will be set to
nodeStatusUpdateFrequency for backward compatibility.
Default: "1m"</td>
</tr>
<tr><td><code>nodeLeaseDurationSeconds</code><br/>
<code>int32</code>
</td>
<td>
   nodeLeaseDurationSeconds is the duration the Kubelet will set on its corresponding Lease,
when the NodeLease feature is enabled. This feature provides an indicator of node
health by having the Kubelet create and periodically renew a lease, named after the node,
in the kube-node-lease namespace. If the lease expires, the node can be considered unhealthy.
The lease is currently renewed every 10s, per KEP-0009. In the future, the lease renewal interval
may be set based on the lease duration.
Requires the NodeLease feature gate to be enabled.
Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
decreasing the duration may reduce tolerance for issues that temporarily prevent
the Kubelet from renewing the lease (e.g. a short-lived network issue).
Default: 40</td>
</tr>
<tr><td><code>imageMinimumGCAge</code><br/>
<a href="https://godoc.org/k8s.io/apimachinery/pkg/apis/meta/v1#Duration"><code>meta/v1.Duration</code></a>
</td>
<td>
   imageMinimumGCAge is the minimum age for an unused image before it is
garbage collected.
Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
it may trigger or delay garbage collection, and may change the image overhead
on the node.
Default: "2m"</td>
</tr>
<tr><td><code>imageGCHighThresholdPercent</code><br/>
<code>int32</code>
</td>
<td>
   imageGCHighThresholdPercent is the percent of disk usage after which
image garbage collection is always run. The percent is calculated as
this field value out of 100.
Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
it may trigger or delay garbage collection, and may change the image overhead
on the node.
Default: 85</td>
</tr>
<tr><td><code>imageGCLowThresholdPercent</code><br/>
<code>int32</code>
</td>
<td>
   imageGCLowThresholdPercent is the percent of disk usage before which
image garbage collection is never run. Lowest disk usage to garbage
collect to. The percent is calculated as this field value out of 100.
Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
it may trigger or delay garbage collection, and may change the image overhead
on the node.
Default: 80</td>
</tr>
<tr><td><code>volumeStatsAggPeriod</code><br/>
<a href="https://godoc.org/k8s.io/apimachinery/pkg/apis/meta/v1#Duration"><code>meta/v1.Duration</code></a>
</td>
<td>
   How frequently to calculate and cache volume disk usage for all pods
Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
shortening the period may carry a performance impact.
Default: "1m"</td>
</tr>
<tr><td><code>kubeletCgroups</code><br/>
<code>string</code>
</td>
<td>
   kubeletCgroups is the absolute name of cgroups to isolate the kubelet in
Dynamic Kubelet Config (beta): This field should not be updated without a full node
reboot. It is safest to keep this value the same as the local config.
Default: ""</td>
</tr>
<tr><td><code>systemCgroups</code><br/>
<code>string</code>
</td>
<td>
   systemCgroups is absolute name of cgroups in which to place
all non-kernel processes that are not already in a container. Empty
for no container. Rolling back the flag requires a reboot.
Dynamic Kubelet Config (beta): This field should not be updated without a full node
reboot. It is safest to keep this value the same as the local config.
Default: ""</td>
</tr>
<tr><td><code>cgroupRoot</code><br/>
<code>string</code>
</td>
<td>
   cgroupRoot is the root cgroup to use for pods. This is handled by the
container runtime on a best effort basis.
Dynamic Kubelet Config (beta): This field should not be updated without a full node
reboot. It is safest to keep this value the same as the local config.
Default: ""</td>
</tr>
<tr><td><code>cgroupsPerQOS</code><br/>
<code>bool</code>
</td>
<td>
   Enable QoS based Cgroup hierarchy: top level cgroups for QoS Classes
And all Burstable and BestEffort pods are brought up under their
specific top level QoS cgroup.
Dynamic Kubelet Config (beta): This field should not be updated without a full node
reboot. It is safest to keep this value the same as the local config.
Default: true</td>
</tr>
<tr><td><code>cgroupDriver</code><br/>
<code>string</code>
</td>
<td>
   driver that the kubelet uses to manipulate cgroups on the host (cgroupfs or systemd)
Dynamic Kubelet Config (beta): This field should not be updated without a full node
reboot. It is safest to keep this value the same as the local config.
Default: "cgroupfs"</td>
</tr>
<tr><td><code>cpuManagerPolicy</code><br/>
<code>string</code>
</td>
<td>
   CPUManagerPolicy is the name of the policy to use.
Requires the CPUManager feature gate to be enabled.
Dynamic Kubelet Config (beta): This field should not be updated without a full node
reboot. It is safest to keep this value the same as the local config.
Default: "none"</td>
</tr>
<tr><td><code>cpuManagerReconcilePeriod</code><br/>
<a href="https://godoc.org/k8s.io/apimachinery/pkg/apis/meta/v1#Duration"><code>meta/v1.Duration</code></a>
</td>
<td>
   CPU Manager reconciliation period.
Requires the CPUManager feature gate to be enabled.
Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
shortening the period may carry a performance impact.
Default: "10s"</td>
</tr>
<tr><td><code>topologyManagerPolicy</code><br/>
<code>string</code>
</td>
<td>
   TopologyManagerPolicy is the name of the policy to use.
Policies other than "none" require the TopologyManager feature gate to be enabled.
Dynamic Kubelet Config (beta): This field should not be updated without a full node
reboot. It is safest to keep this value the same as the local config.
Default: "none"</td>
</tr>
<tr><td><code>topologyManagerScope</code><br/>
<code>string</code>
</td>
<td>
   TopologyManagerScope represents the scope of topology hint generation
that topology manager requests and hint providers generate.
"pod" scope requires the TopologyManager feature gate to be enabled.
Default: "container"</td>
</tr>
<tr><td><code>qosReserved</code><br/>
<code>map[string]string</code>
</td>
<td>
   qosReserved is a set of resource name to percentage pairs that specify
the minimum percentage of a resource reserved for exclusive use by the
guaranteed QoS tier.
Currently supported resources: "memory"
Requires the QOSReserved feature gate to be enabled.
Dynamic Kubelet Config (beta): This field should not be updated without a full node
reboot. It is safest to keep this value the same as the local config.
Default: nil</td>
</tr>
<tr><td><code>runtimeRequestTimeout</code><br/>
<a href="https://godoc.org/k8s.io/apimachinery/pkg/apis/meta/v1#Duration"><code>meta/v1.Duration</code></a>
</td>
<td>
   runtimeRequestTimeout is the timeout for all runtime requests except long running
requests - pull, logs, exec and attach.
Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
it may disrupt components that interact with the Kubelet server.
Default: "2m"</td>
</tr>
<tr><td><code>hairpinMode</code><br/>
<code>string</code>
</td>
<td>
   hairpinMode specifies how the Kubelet should configure the container
bridge for hairpin packets.
Setting this flag allows endpoints in a Service to loadbalance back to
themselves if they should try to access their own Service. Values:
  "promiscuous-bridge": make the container bridge promiscuous.
  "hairpin-veth":       set the hairpin flag on container veth interfaces.
  "none":               do nothing.
Generally, one must set --hairpin-mode=hairpin-veth to achieve hairpin NAT,
because promiscuous-bridge assumes the existence of a container bridge named cbr0.
Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
it may require a node reboot, depending on the network plugin.
Default: "promiscuous-bridge"</td>
</tr>
<tr><td><code>maxPods</code><br/>
<code>int32</code>
</td>
<td>
   maxPods is the number of pods that can run on this Kubelet.
Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
changes may cause Pods to fail admission on Kubelet restart, and may change
the value reported in Node.Status.Capacity[v1.ResourcePods], thus affecting
future scheduling decisions. Increasing this value may also decrease performance,
as more Pods can be packed into a single node.
Default: 110</td>
</tr>
<tr><td><code>podCIDR</code><br/>
<code>string</code>
</td>
<td>
   The CIDR to use for pod IP addresses, only used in standalone mode.
In cluster mode, this is obtained from the master.
Dynamic Kubelet Config (beta): This field should always be set to the empty default.
It should only set for standalone Kubelets, which cannot use Dynamic Kubelet Config.
Default: ""</td>
</tr>
<tr><td><code>podPidsLimit</code><br/>
<code>int64</code>
</td>
<td>
   PodPidsLimit is the maximum number of pids in any pod.
Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
lowering it may prevent container processes from forking after the change.
Default: -1</td>
</tr>
<tr><td><code>resolvConf</code><br/>
<code>string</code>
</td>
<td>
   ResolverConfig is the resolver configuration file used as the basis
for the container DNS resolution configuration.
Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
changes will only take effect on Pods created after the update. Draining
the node is recommended before changing this field.
Default: "/etc/resolv.conf"</td>
</tr>
<tr><td><code>runOnce</code><br/>
<code>bool</code>
</td>
<td>
   RunOnce causes the Kubelet to check the API server once for pods,
run those in addition to the pods specified by static pod files, and exit.
Default: false</td>
</tr>
<tr><td><code>cpuCFSQuota</code><br/>
<code>bool</code>
</td>
<td>
   cpuCFSQuota enables CPU CFS quota enforcement for containers that
specify CPU limits.
Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
disabling it may reduce node stability.
Default: true</td>
</tr>
<tr><td><code>cpuCFSQuotaPeriod</code><br/>
<a href="https://godoc.org/k8s.io/apimachinery/pkg/apis/meta/v1#Duration"><code>meta/v1.Duration</code></a>
</td>
<td>
   CPUCFSQuotaPeriod is the CPU CFS quota period value, cpu.cfs_period_us.
Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
limits set for containers will result in different cpu.cfs_quota settings. This
will trigger container restarts on the node being reconfigured.
Default: "100ms"</td>
</tr>
<tr><td><code>nodeStatusMaxImages</code><br/>
<code>int32</code>
</td>
<td>
   nodeStatusMaxImages caps the number of images reported in Node.Status.Images.
Note: If -1 is specified, no cap will be applied. If 0 is specified, no image is returned.
Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
different values can be reported on node status.
Default: 50</td>
</tr>
<tr><td><code>maxOpenFiles</code><br/>
<code>int64</code>
</td>
<td>
   maxOpenFiles is Number of files that can be opened by Kubelet process.
Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
it may impact the ability of the Kubelet to interact with the node's filesystem.
Default: 1000000</td>
</tr>
<tr><td><code>contentType</code><br/>
<code>string</code>
</td>
<td>
   contentType is contentType of requests sent to apiserver.
Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
it may impact the ability for the Kubelet to communicate with the API server.
If the Kubelet loses contact with the API server due to a change to this field,
the change cannot be reverted via dynamic Kubelet config.
Default: "application/vnd.kubernetes.protobuf"</td>
</tr>
<tr><td><code>kubeAPIQPS</code><br/>
<code>int32</code>
</td>
<td>
   kubeAPIQPS is the QPS to use while talking with kubernetes apiserver
Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
it may impact scalability by changing the amount of traffic the Kubelet
sends to the API server.
Default: 5</td>
</tr>
<tr><td><code>kubeAPIBurst</code><br/>
<code>int32</code>
</td>
<td>
   kubeAPIBurst is the burst to allow while talking with kubernetes apiserver
Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
it may impact scalability by changing the amount of traffic the Kubelet
sends to the API server.
Default: 10</td>
</tr>
<tr><td><code>serializeImagePulls</code><br/>
<code>bool</code>
</td>
<td>
   serializeImagePulls when enabled, tells the Kubelet to pull images one
at a time. We recommend &lowast;not&lowast; changing the default value on nodes that
run docker daemon with version  < 1.9 or an Aufs storage backend.
Issue #10959 has more details.
Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
it may impact the performance of image pulls.
Default: true</td>
</tr>
<tr><td><code>evictionHard</code><br/>
<code>map[string]string</code>
</td>
<td>
   Map of signal names to quantities that defines hard eviction thresholds. For example: {"memory.available": "300Mi"}.
To explicitly disable, pass a 0% or 100% threshold on an arbitrary resource.
Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
it may trigger or delay Pod evictions.
Default:
  memory.available:  "100Mi"
  nodefs.available:  "10%"
  nodefs.inodesFree: "5%"
  imagefs.available: "15%"</td>
</tr>
<tr><td><code>evictionSoft</code><br/>
<code>map[string]string</code>
</td>
<td>
   Map of signal names to quantities that defines soft eviction thresholds.
For example: {"memory.available": "300Mi"}.
Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
it may trigger or delay Pod evictions, and may change the allocatable reported
by the node.
Default: nil</td>
</tr>
<tr><td><code>evictionSoftGracePeriod</code><br/>
<code>map[string]string</code>
</td>
<td>
   Map of signal names to quantities that defines grace periods for each soft eviction signal.
For example: {"memory.available": "30s"}.
Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
it may trigger or delay Pod evictions.
Default: nil</td>
</tr>
<tr><td><code>evictionPressureTransitionPeriod</code><br/>
<a href="https://godoc.org/k8s.io/apimachinery/pkg/apis/meta/v1#Duration"><code>meta/v1.Duration</code></a>
</td>
<td>
   Duration for which the kubelet has to wait before transitioning out of an eviction pressure condition.
Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
lowering it may decrease the stability of the node when the node is overcommitted.
Default: "5m"</td>
</tr>
<tr><td><code>evictionMaxPodGracePeriod</code><br/>
<code>int32</code>
</td>
<td>
   Maximum allowed grace period (in seconds) to use when terminating pods in
response to a soft eviction threshold being met. This value effectively caps
the Pod's TerminationGracePeriodSeconds value during soft evictions.
Note: Due to issue #64530, the behavior has a bug where this value currently just
overrides the grace period during soft eviction, which can increase the grace
period from what is set on the Pod. This bug will be fixed in a future release.
Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
lowering it decreases the amount of time Pods will have to gracefully clean
up before being killed during a soft eviction.
Default: 0</td>
</tr>
<tr><td><code>evictionMinimumReclaim</code><br/>
<code>map[string]string</code>
</td>
<td>
   Map of signal names to quantities that defines minimum reclaims, which describe the minimum
amount of a given resource the kubelet will reclaim when performing a pod eviction while
that resource is under pressure. For example: {"imagefs.available": "2Gi"}
Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
it may change how well eviction can manage resource pressure.
Default: nil</td>
</tr>
<tr><td><code>podsPerCore</code><br/>
<code>int32</code>
</td>
<td>
   podsPerCore is the maximum number of pods per core. Cannot exceed MaxPods.
If 0, this field is ignored.
Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
changes may cause Pods to fail admission on Kubelet restart, and may change
the value reported in Node.Status.Capacity[v1.ResourcePods], thus affecting
future scheduling decisions. Increasing this value may also decrease performance,
as more Pods can be packed into a single node.
Default: 0</td>
</tr>
<tr><td><code>enableControllerAttachDetach</code><br/>
<code>bool</code>
</td>
<td>
   enableControllerAttachDetach enables the Attach/Detach controller to
manage attachment/detachment of volumes scheduled to this node, and
disables kubelet from executing any attach/detach operations
Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
changing which component is responsible for volume management on a live node
may result in volumes refusing to detach if the node is not drained prior to
the update, and if Pods are scheduled to the node before the
volumes.kubernetes.io/controller-managed-attach-detach annotation is updated by the
Kubelet. In general, it is safest to leave this value set the same as local config.
Default: true</td>
</tr>
<tr><td><code>protectKernelDefaults</code><br/>
<code>bool</code>
</td>
<td>
   protectKernelDefaults, if true, causes the Kubelet to error if kernel
flags are not as it expects. Otherwise the Kubelet will attempt to modify
kernel flags to match its expectation.
Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
enabling it may cause the Kubelet to crash-loop if the Kernel is not configured as
Kubelet expects.
Default: false</td>
</tr>
<tr><td><code>makeIPTablesUtilChains</code><br/>
<code>bool</code>
</td>
<td>
   If true, Kubelet ensures a set of iptables rules are present on host.
These rules will serve as utility rules for various components, e.g. KubeProxy.
The rules will be created based on IPTablesMasqueradeBit and IPTablesDropBit.
Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
disabling it will prevent the Kubelet from healing locally misconfigured iptables rules.
Default: true</td>
</tr>
<tr><td><code>iptablesMasqueradeBit</code><br/>
<code>int32</code>
</td>
<td>
   iptablesMasqueradeBit is the bit of the iptables fwmark space to mark for SNAT
Values must be within the range [0, 31]. Must be different from other mark bits.
Warning: Please match the value of the corresponding parameter in kube-proxy.
TODO: clean up IPTablesMasqueradeBit in kube-proxy
Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
it needs to be coordinated with other components, like kube-proxy, and the update
will only be effective if MakeIPTablesUtilChains is enabled.
Default: 14</td>
</tr>
<tr><td><code>iptablesDropBit</code><br/>
<code>int32</code>
</td>
<td>
   iptablesDropBit is the bit of the iptables fwmark space to mark for dropping packets.
Values must be within the range [0, 31]. Must be different from other mark bits.
Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
it needs to be coordinated with other components, like kube-proxy, and the update
will only be effective if MakeIPTablesUtilChains is enabled.
Default: 15</td>
</tr>
<tr><td><code>featureGates</code><br/>
<code>map[string]bool</code>
</td>
<td>
   featureGates is a map of feature names to bools that enable or disable alpha/experimental
features. This field modifies piecemeal the built-in default values from
"k8s.io/kubernetes/pkg/features/kube_features.go".
Dynamic Kubelet Config (beta): If dynamically updating this field, consider the
documentation for the features you are enabling or disabling. While we
encourage feature developers to make it possible to dynamically enable
and disable features, some changes may require node reboots, and some
features may require careful coordination to retroactively disable.
Default: nil</td>
</tr>
<tr><td><code>failSwapOn</code><br/>
<code>bool</code>
</td>
<td>
   failSwapOn tells the Kubelet to fail to start if swap is enabled on the node.
Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
setting it to true will cause the Kubelet to crash-loop if swap is enabled.
Default: true</td>
</tr>
<tr><td><code>containerLogMaxSize</code><br/>
<code>string</code>
</td>
<td>
   A quantity defines the maximum size of the container log file before it is rotated.
For example: "5Mi" or "256Ki".
Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
it may trigger log rotation.
Default: "10Mi"</td>
</tr>
<tr><td><code>containerLogMaxFiles</code><br/>
<code>int32</code>
</td>
<td>
   Maximum number of container log files that can be present for a container.
Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
lowering it may cause log files to be deleted.
Default: 5</td>
</tr>
<tr><td><code>configMapAndSecretChangeDetectionStrategy</code><br/>
<a href="#kubelet-config-k8s-io-v1beta1-ResourceChangeDetectionStrategy"><code>ResourceChangeDetectionStrategy</code></a>
</td>
<td>
   ConfigMapAndSecretChangeDetectionStrategy is a mode in which
config map and secret managers are running.
Default: "Watch"</td>
</tr>
<tr><td><code>systemReserved</code><br/>
<code>map[string]string</code>
</td>
<td>
   systemReserved is a set of ResourceName=ResourceQuantity (e.g. cpu=200m,memory=150G)
pairs that describe resources reserved for non-kubernetes components.
Currently only cpu and memory are supported.
See http://kubernetes.io/docs/user-guide/compute-resources for more detail.
Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
it may not be possible to increase the reserved resources, because this
requires resizing cgroups. Always look for a NodeAllocatableEnforced event
after updating this field to ensure that the update was successful.
Default: nil</td>
</tr>
<tr><td><code>kubeReserved</code><br/>
<code>map[string]string</code>
</td>
<td>
   A set of ResourceName=ResourceQuantity (e.g. cpu=200m,memory=150G) pairs
that describe resources reserved for kubernetes system components.
Currently cpu, memory and local storage for root file system are supported.
See http://kubernetes.io/docs/user-guide/compute-resources for more detail.
Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
it may not be possible to increase the reserved resources, because this
requires resizing cgroups. Always look for a NodeAllocatableEnforced event
after updating this field to ensure that the update was successful.
Default: nil</td>
</tr>
<tr><td><code>reservedSystemCPUs</code> <B>[Required]</B><br/>
<code>string</code>
</td>
<td>
   This ReservedSystemCPUs option specifies the cpu list reserved for the host level system threads and kubernetes related threads.
This provide a "static" CPU list rather than the "dynamic" list by system-reserved and kube-reserved.
This option overwrites CPUs provided by system-reserved and kube-reserved.</td>
</tr>
<tr><td><code>showHiddenMetricsForVersion</code><br/>
<code>string</code>
</td>
<td>
   The previous version for which you want to show hidden metrics.
Only the previous minor version is meaningful, other values will not be allowed.
The format is <major>.<minor>, e.g.: '1.16'.
The purpose of this format is make sure you have the opportunity to notice if the next release hides additional metrics,
rather than being surprised when they are permanently removed in the release after that.
Default: ""</td>
</tr>
<tr><td><code>systemReservedCgroup</code><br/>
<code>string</code>
</td>
<td>
   This flag helps kubelet identify absolute name of top level cgroup used to enforce `SystemReserved` compute resource reservation for OS system daemons.
Refer to [Node Allocatable](https://git.k8s.io/community/contributors/design-proposals/node/node-allocatable.md) doc for more information.
Dynamic Kubelet Config (beta): This field should not be updated without a full node
reboot. It is safest to keep this value the same as the local config.
Default: ""</td>
</tr>
<tr><td><code>kubeReservedCgroup</code><br/>
<code>string</code>
</td>
<td>
   This flag helps kubelet identify absolute name of top level cgroup used to enforce `KubeReserved` compute resource reservation for Kubernetes node system daemons.
Refer to [Node Allocatable](https://git.k8s.io/community/contributors/design-proposals/node/node-allocatable.md) doc for more information.
Dynamic Kubelet Config (beta): This field should not be updated without a full node
reboot. It is safest to keep this value the same as the local config.
Default: ""</td>
</tr>
<tr><td><code>enforceNodeAllocatable</code><br/>
<code>[]string</code>
</td>
<td>
   This flag specifies the various Node Allocatable enforcements that Kubelet needs to perform.
This flag accepts a list of options. Acceptable options are `none`, `pods`, `system-reserved` & `kube-reserved`.
If `none` is specified, no other options may be specified.
Refer to [Node Allocatable](https://git.k8s.io/community/contributors/design-proposals/node/node-allocatable.md) doc for more information.
Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
removing enforcements may reduce the stability of the node. Alternatively, adding
enforcements may reduce the stability of components which were using more than
the reserved amount of resources; for example, enforcing kube-reserved may cause
Kubelets to OOM if it uses more than the reserved resources, and enforcing system-reserved
may cause system daemons to OOM if they use more than the reserved resources.
Default: ["pods"]</td>
</tr>
<tr><td><code>allowedUnsafeSysctls</code><br/>
<code>[]string</code>
</td>
<td>
   A comma separated whitelist of unsafe sysctls or sysctl patterns (ending in &lowast;).
Unsafe sysctl groups are kernel.shm&lowast;, kernel.msg&lowast;, kernel.sem, fs.mqueue.&lowast;, and net.&lowast;.
These sysctls are namespaced but not allowed by default.  For example: "kernel.msg&lowast;,net.ipv4.route.min_pmtu"
Default: []</td>
</tr>
<tr><td><code>volumePluginDir</code><br/>
<code>string</code>
</td>
<td>
   volumePluginDir is the full path of the directory in which to search
for additional third party volume plugins.
Dynamic Kubelet Config (beta): If dynamically updating this field, consider that changing
the volumePluginDir may disrupt workloads relying on third party volume plugins.
Default: "/usr/libexec/kubernetes/kubelet-plugins/volume/exec/"</td>
</tr>
<tr><td><code>providerID</code><br/>
<code>string</code>
</td>
<td>
   providerID, if set, sets the unique id of the instance that an external provider (i.e. cloudprovider)
can use to identify a specific node.
Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
it may impact the ability of the Kubelet to interact with cloud providers.
Default: ""</td>
</tr>
<tr><td><code>kernelMemcgNotification</code><br/>
<code>bool</code>
</td>
<td>
   kernelMemcgNotification, if set, the kubelet will integrate with the kernel memcg notification
to determine if memory eviction thresholds are crossed rather than polling.
Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
it may impact the way Kubelet interacts with the kernel.
Default: false</td>
</tr>
<tr><td><code>logging</code> <B>[Required]</B><br/>
<a href="#LoggingConfiguration"><code>LoggingConfiguration</code></a>
</td>
<td>
   Logging specifies the options of logging.
Refer [Logs Options](https://github.com/kubernetes/component-base/blob/master/logs/options.go) for more information.
Defaults:
  Format: text</td>
</tr>
<tr><td><code>enableSystemLogHandler</code><br/>
<code>bool</code>
</td>
<td>
   enableSystemLogHandler enables system logs via web interface host:port/logs/
Default: true</td>
</tr>
<tr><td><code>shutdownGracePeriod</code><br/>
<a href="https://godoc.org/k8s.io/apimachinery/pkg/apis/meta/v1#Duration"><code>meta/v1.Duration</code></a>
</td>
<td>
   ShutdownGracePeriod specifies the total duration that the node should delay the shutdown and total grace period for pod termination during a node shutdown.
Default: "30s"</td>
</tr>
<tr><td><code>shutdownGracePeriodCriticalPods</code><br/>
<a href="https://godoc.org/k8s.io/apimachinery/pkg/apis/meta/v1#Duration"><code>meta/v1.Duration</code></a>
</td>
<td>
   ShutdownGracePeriodCriticalPods specifies the duration used to terminate critical pods during a node shutdown. This should be less than ShutdownGracePeriod.
For example, if ShutdownGracePeriod=30s, and ShutdownGracePeriodCriticalPods=10s, during a node shutdown the first 20 seconds would be reserved for gracefully terminating normal pods, and the last 10 seconds would be reserved for terminating critical pods.
Default: "10s"</td>
</tr>
</tbody>
</table>
<h2 id="kubelet-config-k8s-io-v1beta1-SerializedNodeConfigSource"><code>SerializedNodeConfigSource</code>    </h2>
<p>SerializedNodeConfigSource allows us to serialize v1.NodeConfigSource.
This type is used internally by the Kubelet for tracking checkpointed dynamic configs.
It exists in the kubeletconfig API group because it is classified as a versioned input to the Kubelet.</p>
<table class="table">
<thead><tr><th width="30%">Field</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>apiVersion</code><br/>string</td><td><code>kubelet.config.k8s.io/v1beta1</code></td></tr>
<tr><td><code>kind</code><br/>string</td><td><code>SerializedNodeConfigSource</code></td></tr>
<tr><td><code>source</code><br/>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.20/#nodeconfigsource-v1-core"><code>core/v1.NodeConfigSource</code></a>
</td>
<td>
   Source is the source that we are serializing</td>
</tr>
</tbody>
</table>
<h2 id="kubelet-config-k8s-io-v1beta1-HairpinMode"><code>HairpinMode</code>    </h2>
<p>(Alias of <code>string</code>)</p>
<p>HairpinMode denotes how the kubelet should configure networking to handle
hairpin packets.</p>
<h2 id="kubelet-config-k8s-io-v1beta1-KubeletAnonymousAuthentication"><code>KubeletAnonymousAuthentication</code>    </h2>
<p><strong>Appears in:</strong></p>
<ul>
<li><a href="#kubelet-config-k8s-io-v1beta1-KubeletAuthentication">KubeletAuthentication</a></li>
</ul>
<table class="table">
<thead><tr><th width="30%">Field</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>enabled</code><br/>
<code>bool</code>
</td>
<td>
   enabled allows anonymous requests to the kubelet server.
Requests that are not rejected by another authentication method are treated as anonymous requests.
Anonymous requests have a username of system:anonymous, and a group name of system:unauthenticated.</td>
</tr>
</tbody>
</table>
<h2 id="kubelet-config-k8s-io-v1beta1-KubeletAuthentication"><code>KubeletAuthentication</code>    </h2>
<p><strong>Appears in:</strong></p>
<ul>
<li><a href="#kubelet-config-k8s-io-v1beta1-KubeletConfiguration">KubeletConfiguration</a></li>
</ul>
<table class="table">
<thead><tr><th width="30%">Field</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>x509</code><br/>
<a href="#kubelet-config-k8s-io-v1beta1-KubeletX509Authentication"><code>KubeletX509Authentication</code></a>
</td>
<td>
   x509 contains settings related to x509 client certificate authentication</td>
</tr>
<tr><td><code>webhook</code><br/>
<a href="#kubelet-config-k8s-io-v1beta1-KubeletWebhookAuthentication"><code>KubeletWebhookAuthentication</code></a>
</td>
<td>
   webhook contains settings related to webhook bearer token authentication</td>
</tr>
<tr><td><code>anonymous</code><br/>
<a href="#kubelet-config-k8s-io-v1beta1-KubeletAnonymousAuthentication"><code>KubeletAnonymousAuthentication</code></a>
</td>
<td>
   anonymous contains settings related to anonymous authentication</td>
</tr>
</tbody>
</table>
<h2 id="kubelet-config-k8s-io-v1beta1-KubeletAuthorization"><code>KubeletAuthorization</code>    </h2>
<p><strong>Appears in:</strong></p>
<ul>
<li><a href="#kubelet-config-k8s-io-v1beta1-KubeletConfiguration">KubeletConfiguration</a></li>
</ul>
<table class="table">
<thead><tr><th width="30%">Field</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>mode</code><br/>
<a href="#kubelet-config-k8s-io-v1beta1-KubeletAuthorizationMode"><code>KubeletAuthorizationMode</code></a>
</td>
<td>
   mode is the authorization mode to apply to requests to the kubelet server.
Valid values are AlwaysAllow and Webhook.
Webhook mode uses the SubjectAccessReview API to determine authorization.</td>
</tr>
<tr><td><code>webhook</code><br/>
<a href="#kubelet-config-k8s-io-v1beta1-KubeletWebhookAuthorization"><code>KubeletWebhookAuthorization</code></a>
</td>
<td>
   webhook contains settings related to Webhook authorization.</td>
</tr>
</tbody>
</table>
<h2 id="kubelet-config-k8s-io-v1beta1-KubeletAuthorizationMode"><code>KubeletAuthorizationMode</code>    </h2>
<p>(Alias of <code>string</code>)</p>
<p><strong>Appears in:</strong></p>
<ul>
<li><a href="#kubelet-config-k8s-io-v1beta1-KubeletAuthorization">KubeletAuthorization</a></li>
</ul>
<h2 id="kubelet-config-k8s-io-v1beta1-KubeletWebhookAuthentication"><code>KubeletWebhookAuthentication</code>    </h2>
<p><strong>Appears in:</strong></p>
<ul>
<li><a href="#kubelet-config-k8s-io-v1beta1-KubeletAuthentication">KubeletAuthentication</a></li>
</ul>
<table class="table">
<thead><tr><th width="30%">Field</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>enabled</code><br/>
<code>bool</code>
</td>
<td>
   enabled allows bearer token authentication backed by the tokenreviews.authentication.k8s.io API</td>
</tr>
<tr><td><code>cacheTTL</code><br/>
<a href="https://godoc.org/k8s.io/apimachinery/pkg/apis/meta/v1#Duration"><code>meta/v1.Duration</code></a>
</td>
<td>
   cacheTTL enables caching of authentication results</td>
</tr>
</tbody>
</table>
<h2 id="kubelet-config-k8s-io-v1beta1-KubeletWebhookAuthorization"><code>KubeletWebhookAuthorization</code>    </h2>
<p><strong>Appears in:</strong></p>
<ul>
<li><a href="#kubelet-config-k8s-io-v1beta1-KubeletAuthorization">KubeletAuthorization</a></li>
</ul>
<table class="table">
<thead><tr><th width="30%">Field</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>cacheAuthorizedTTL</code><br/>
<a href="https://godoc.org/k8s.io/apimachinery/pkg/apis/meta/v1#Duration"><code>meta/v1.Duration</code></a>
</td>
<td>
   cacheAuthorizedTTL is the duration to cache 'authorized' responses from the webhook authorizer.</td>
</tr>
<tr><td><code>cacheUnauthorizedTTL</code><br/>
<a href="https://godoc.org/k8s.io/apimachinery/pkg/apis/meta/v1#Duration"><code>meta/v1.Duration</code></a>
</td>
<td>
   cacheUnauthorizedTTL is the duration to cache 'unauthorized' responses from the webhook authorizer.</td>
</tr>
</tbody>
</table>
<h2 id="kubelet-config-k8s-io-v1beta1-KubeletX509Authentication"><code>KubeletX509Authentication</code>    </h2>
<p><strong>Appears in:</strong></p>
<ul>
<li><a href="#kubelet-config-k8s-io-v1beta1-KubeletAuthentication">KubeletAuthentication</a></li>
</ul>
<table class="table">
<thead><tr><th width="30%">Field</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>clientCAFile</code><br/>
<code>string</code>
</td>
<td>
   clientCAFile is the path to a PEM-encoded certificate bundle. If set, any request presenting a client certificate
signed by one of the authorities in the bundle is authenticated with a username corresponding to the CommonName,
and groups corresponding to the Organization in the client certificate.</td>
</tr>
</tbody>
</table>
<h2 id="kubelet-config-k8s-io-v1beta1-ResourceChangeDetectionStrategy"><code>ResourceChangeDetectionStrategy</code>    </h2>
<p>(Alias of <code>string</code>)</p>
<p><strong>Appears in:</strong></p>
<ul>
<li><a href="#kubelet-config-k8s-io-v1beta1-KubeletConfiguration">KubeletConfiguration</a></li>
</ul>
<p>ResourceChangeDetectionStrategy denotes a mode in which internal
managers (secret, configmap) are discovering object changes.</p>
<h2 id="LoggingConfiguration"><code>LoggingConfiguration</code>    </h2>
<p><strong>Appears in:</strong></p>
<ul>
<li><a href="#kubelet-config-k8s-io-v1beta1-KubeletConfiguration">KubeletConfiguration</a></li>
</ul>
<p>LoggingConfiguration contains logging options
Refer <a href="https://github.com/kubernetes/component-base/blob/master/logs/options.go">Logs Options</a> for more information.</p>
<table class="table">
<thead><tr><th width="30%">Field</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>format</code> <B>[Required]</B><br/>
<code>string</code>
</td>
<td>
   Format Flag specifies the structure of log messages.
default value of format is `text`</td>
</tr>
<tr><td><code>sanitization</code> <B>[Required]</B><br/>
<code>bool</code>
</td>
<td>
   [Experimental] When enabled prevents logging of fields tagged as sensitive (passwords, keys, tokens).
Runtime log sanitization may introduce significant computation overhead and therefore should not be enabled in production.`)</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-74f43b2a33c21414f1ed8c359b37d326">10.7 - WebhookAdmission Configuration (v1)</h1>
    
	<p>Package v1 is the v1 version of the API.</p>
<h2 id="resource-types">Resource Types</h2>
<ul>
<li><a href="#apiserver-config-k8s-io-v1-WebhookAdmission">WebhookAdmission</a></li>
</ul>
<h2 id="apiserver-config-k8s-io-v1-WebhookAdmission"><code>WebhookAdmission</code>    </h2>
<p>WebhookAdmission provides configuration for the webhook admission controller.</p>
<table class="table">
<thead><tr><th width="30%">Field</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>apiVersion</code><br/>string</td><td><code>apiserver.config.k8s.io/v1</code></td></tr>
<tr><td><code>kind</code><br/>string</td><td><code>WebhookAdmission</code></td></tr>
<tr><td><code>kubeConfigFile</code> <B>[Required]</B><br/>
<code>string</code>
</td>
<td>
   KubeConfigFile is the path to the kubeconfig file.</td>
</tr>
</tbody>
</table>

</div>



    
	
  

    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-f8b023454daa9497b7eea35b7d35c075">11 - 调度</h1>
    
	
</div>



    
      
  
  
  
  

  
  

  
    
    
	
    

<div class="td-content" style="">
    
	<h1 id="pg-5a0a68fb6a7ffefb6d5f861100fa0ae3">11.1 - 调度策略</h1>
    
	<!--  
title: Scheduling Policies
content_type: concept
weight: 10
-->
<!-- overview -->
<!--  
A scheduling Policy can be used to specify the *predicates* and *priorities*
that the <a class='glossary-tooltip' title='控制平面组件，负责监视新创建的、未指定运行节点的 Pod，选择节点让 Pod 在上面运行。' data-toggle='tooltip' data-placement='top' href='/docs/reference/generated/kube-scheduler/' target='_blank' aria-label='kube-scheduler'>kube-scheduler</a>
runs to [filter and score nodes](/docs/concepts/scheduling-eviction/kube-scheduler/#kube-scheduler-implementation),
respectively.
-->
<p><a class='glossary-tooltip' title='控制平面组件，负责监视新创建的、未指定运行节点的 Pod，选择节点让 Pod 在上面运行。' data-toggle='tooltip' data-placement='top' href='/docs/reference/generated/kube-scheduler/' target='_blank' aria-label='kube-scheduler'>kube-scheduler</a>
根据调度策略指定的<em>断言（predicates）<em>和</em>优先级（priorities）</em>
分别对节点进行<a href="/zh/docs/concepts/scheduling-eviction/kube-scheduler/#kube-scheduler-implementation">过滤和打分</a>。</p>
<!--  
You can set a scheduling policy by running
`kube-scheduler --policy-config-file <filename>` or
`kube-scheduler --policy-configmap <ConfigMap>`
and using the [Policy type](/zh/docs/reference/config-api/kube-scheduler-policy-config.v1/).
-->
<p>你可以通过执行 <code>kube-scheduler --policy-config-file &lt;filename&gt;</code> 或
<code>kube-scheduler --policy-configmap &lt;ConfigMap&gt;</code>
设置并使用<a href="/zh/docs/reference/config-api/kube-scheduler-policy-config.v1/">调度策略</a>。</p>
<!-- body -->
<!-- ## Predicates -->
<h2 id="predicates">断言   </h2>
<!-- The following *predicates* implement filtering: -->
<p>以下<em>断言</em>实现了过滤接口：</p>
<!-- 
- `PodFitsHostPorts`: Checks if a Node has free ports (the network protocol kind)
  for the Pod ports the Pod is requesting. 
-->
<ul>
<li><code>PodFitsHostPorts</code>：检查 Pod 请求的端口（网络协议类型）在节点上是否可用。</li>
</ul>
<!-- - `PodFitsHost`: Checks if a Pod specifies a specific Node by its hostname. -->
<ul>
<li><code>PodFitsHost</code>：检查 Pod 是否通过主机名指定了 Node。</li>
</ul>
<!-- 
- `PodFitsResources`: Checks if the Node has free resources (eg, CPU and Memory)
  to meet the requirement of the Pod.
-->
<ul>
<li><code>PodFitsResources</code>：检查节点的空闲资源（例如，CPU和内存）是否满足 Pod 的要求。</li>
</ul>
<!--  
- `MatchNodeSelector`: Checks if a Pod's Node <a class='glossary-tooltip' title='选择算符允许用户通过标签对一组资源对象进行筛选过滤。' data-toggle='tooltip' data-placement='top' href='/zh/docs/concepts/overview/working-with-objects/labels/' target='_blank' aria-label='选择算符（Selector）'>选择算符（Selector）</a>
   matches the Node's <a class='glossary-tooltip' title='用来为对象设置可标识的属性标记；这些标记对用户而言是有意义且重要的。' data-toggle='tooltip' data-placement='top' href='/zh/docs/concepts/overview/working-with-objects/labels/' target='_blank' aria-label='label(s)'>label(s)</a>.
-->
<ul>
<li><code>MatchNodeSelector</code>：检查 Pod 的节点<a class='glossary-tooltip' title='选择算符允许用户通过标签对一组资源对象进行筛选过滤。' data-toggle='tooltip' data-placement='top' href='/zh/docs/concepts/overview/working-with-objects/labels/' target='_blank' aria-label='选择算符'>选择算符</a>
和节点的 <a class='glossary-tooltip' title='用来为对象设置可标识的属性标记；这些标记对用户而言是有意义且重要的。' data-toggle='tooltip' data-placement='top' href='/zh/docs/concepts/overview/working-with-objects/labels/' target='_blank' aria-label='标签'>标签</a> 是否匹配。</li>
</ul>
<!--  
- `NoVolumeZoneConflict`: Evaluate if the <a class='glossary-tooltip' title='包含可被 Pod 中容器访问的数据的目录。' data-toggle='tooltip' data-placement='top' href='/zh/docs/concepts/storage/volumes/' target='_blank' aria-label='Volumes'>Volumes</a>
  that a Pod requests are available on the Node, given the failure zone restrictions for
  that storage.
-->
<ul>
<li><code>NoVolumeZoneConflict</code>：给定该存储的故障区域限制，
评估 Pod 请求的<a class='glossary-tooltip' title='包含可被 Pod 中容器访问的数据的目录。' data-toggle='tooltip' data-placement='top' href='/zh/docs/concepts/storage/volumes/' target='_blank' aria-label='卷'>卷</a>在节点上是否可用。</li>
</ul>
<!--  
- `NoDiskConflict`: Evaluates if a Pod can fit on a Node due to the volumes it requests,
   and those that are already mounted.
-->
<ul>
<li><code>NoDiskConflict</code>：根据 Pod 请求的卷是否在节点上已经挂载，评估 Pod 和节点是否匹配。</li>
</ul>
<!--  
- `MaxCSIVolumeCount`: Decides how many <a class='glossary-tooltip' title='容器存储接口 （CSI）定义了存储系统暴露给容器的标准接口。' data-toggle='tooltip' data-placement='top' href='/zh/docs/concepts/storage/volumes/#csi' target='_blank' aria-label='CSI'>CSI</a>
  volumes should be attached, and whether that's over a configured limit.
-->
<ul>
<li><code>MaxCSIVolumeCount</code>：决定附加 <a class='glossary-tooltip' title='容器存储接口 （CSI）定义了存储系统暴露给容器的标准接口。' data-toggle='tooltip' data-placement='top' href='/zh/docs/concepts/storage/volumes/#csi' target='_blank' aria-label='CSI'>CSI</a> 卷的数量，判断是否超过配置的限制。</li>
</ul>
<!--  
- `CheckNodeMemoryPressure`: If a Node is reporting memory pressure, and there's no
  configured exception, the Pod won't be scheduled there.
-->
<ul>
<li><code>CheckNodeMemoryPressure</code>：如果节点正上报内存压力，并且没有异常配置，则不会把 Pod 调度到此节点上。</li>
</ul>
<!--  
- `CheckNodePIDPressure`: If a Node is reporting that process IDs are scarce, and
  there's no configured exception, the Pod won't be scheduled there.
-->
<ul>
<li><code>CheckNodePIDPressure</code>：如果节点正上报进程 ID 稀缺，并且没有异常配置，则不会把 Pod 调度到此节点上。</li>
</ul>
<!--  
- `CheckNodeDiskPressure`: If a Node is reporting storage pressure (a filesystem that
   is full or nearly full), and there's no configured exception, the Pod won't be
   scheduled there.
-->
<ul>
<li><code>CheckNodeDiskPressure</code>：如果节点正上报存储压力（文件系统已满或几乎已满），并且没有异常配置，则不会把 Pod 调度到此节点上。</li>
</ul>
<!--  
- `CheckNodeCondition`: Nodes can report that they have a completely full filesystem,
  that networking isn't available or that kubelet is otherwise not ready to run Pods.
  If such a condition is set for a Node, and there's no configured exception, the Pod
  won't be scheduled there.
-->
<ul>
<li><code>CheckNodeCondition</code>：节点可用上报自己的文件系统已满，网络不可用或者 kubelet 尚未准备好运行 Pod。
如果节点上设置了这样的状况，并且没有异常配置，则不会把 Pod 调度到此节点上。</li>
</ul>
<!--  
- `PodToleratesNodeTaints`: checks if a Pod's <a class='glossary-tooltip' title='一个核心对象，由三个必需的属性组成：key、value 和 effect。 容忍度允许将 Pod 调度到具有对应污点的节点或节点组上。' data-toggle='tooltip' data-placement='top' href='/zh/docs/concepts/scheduling-eviction/taint-and-toleration/' target='_blank' aria-label='tolerations'>tolerations</a>
  can tolerate the Node's <a class='glossary-tooltip' title='污点是一种一个核心对象，包含三个必需的属性：key、value 和 effect。 污点会阻止在节点或节点组上调度 Pod。' data-toggle='tooltip' data-placement='top' href='/zh/docs/concepts/scheduling-eviction/taint-and-toleration/' target='_blank' aria-label='taints'>taints</a>.
-->
<ul>
<li><code>PodToleratesNodeTaints</code>：检查 Pod 的<a class='glossary-tooltip' title='一个核心对象，由三个必需的属性组成：key、value 和 effect。 容忍度允许将 Pod 调度到具有对应污点的节点或节点组上。' data-toggle='tooltip' data-placement='top' href='/zh/docs/concepts/scheduling-eviction/taint-and-toleration/' target='_blank' aria-label='容忍'>容忍</a>
是否能容忍节点的<a class='glossary-tooltip' title='污点是一种一个核心对象，包含三个必需的属性：key、value 和 effect。 污点会阻止在节点或节点组上调度 Pod。' data-toggle='tooltip' data-placement='top' href='/zh/docs/concepts/scheduling-eviction/taint-and-toleration/' target='_blank' aria-label='污点'>污点</a>。</li>
</ul>
<!-- 
- `CheckVolumeBinding`: Evaluates if a Pod can fit due to the volumes it requests.
  This applies for both bound and unbound
  <a class='glossary-tooltip' title='声明在持久卷中定义的存储资源，以便可以将其挂载为容器中的卷。' data-toggle='tooltip' data-placement='top' href='/zh/docs/concepts/storage/persistent-volumes/' target='_blank' aria-label='PVCs'>PVCs</a>. 
-->
<ul>
<li><code>CheckVolumeBinding</code>：基于 Pod 的卷请求，评估 Pod 是否适合节点，这里的卷包括绑定的和未绑定的
<a class='glossary-tooltip' title='声明在持久卷中定义的存储资源，以便可以将其挂载为容器中的卷。' data-toggle='tooltip' data-placement='top' href='/zh/docs/concepts/storage/persistent-volumes/' target='_blank' aria-label='PVCs'>PVCs</a> 都适用。</li>
</ul>
<!-- ## Priorities -->
<h2 id="priorities">优先级   </h2>
<!-- The following *priorities* implement scoring: -->
<p>以下<em>优先级</em>实现了打分接口：</p>
<!--  
- `SelectorSpreadPriority`: Spreads Pods across hosts, considering Pods that
   belong to the same <a class='glossary-tooltip' title='将运行在一组 Pods 上的应用程序公开为网络服务的抽象方法。' data-toggle='tooltip' data-placement='top' href='/zh/docs/concepts/services-networking/service/' target='_blank' aria-label='Service'>Service</a>,
   <a class='glossary-tooltip' title='StatefulSet 用来管理某 Pod 集合的部署和扩缩，并为这些 Pod 提供持久存储和持久标识符。' data-toggle='tooltip' data-placement='top' href='/zh/docs/concepts/workloads/controllers/statefulset/' target='_blank' aria-label='StatefulSet'>StatefulSet</a> or
   <a class='glossary-tooltip' title='ReplicaSet 是下一代副本控制器。' data-toggle='tooltip' data-placement='top' href='/zh/docs/concepts/workloads/controllers/replicaset/' target='_blank' aria-label='ReplicaSet'>ReplicaSet</a>.
-->
<ul>
<li><code>SelectorSpreadPriority</code>：属于同一 <a class='glossary-tooltip' title='将运行在一组 Pods 上的应用程序公开为网络服务的抽象方法。' data-toggle='tooltip' data-placement='top' href='/zh/docs/concepts/services-networking/service/' target='_blank' aria-label='Service'>Service</a>、
<a class='glossary-tooltip' title='StatefulSet 用来管理某 Pod 集合的部署和扩缩，并为这些 Pod 提供持久存储和持久标识符。' data-toggle='tooltip' data-placement='top' href='/zh/docs/concepts/workloads/controllers/statefulset/' target='_blank' aria-label='StatefulSet'>StatefulSet</a> 或
<a class='glossary-tooltip' title='ReplicaSet 是下一代副本控制器。' data-toggle='tooltip' data-placement='top' href='/zh/docs/concepts/workloads/controllers/replicaset/' target='_blank' aria-label='ReplicaSet'>ReplicaSet</a> 的 Pod，跨主机部署。</li>
</ul>
<!--  
- `InterPodAffinityPriority`: Implements preferred
  [inter pod affininity and antiaffinity](/docs/concepts/scheduling-eviction/assign-pod-node/#inter-pod-affinity-and-anti-affinity).
-->
<ul>
<li><code>InterPodAffinityPriority</code>：实现了 <a href="/zh/docs/concepts/scheduling-eviction/assign-pod-node/#inter-pod-affinity-and-anti-affinity">Pod 间亲和性与反亲和性</a>的优先级。</li>
</ul>
<!--
- `LeastRequestedPriority`: Favors nodes with fewer requested resources. In other
  words, the more Pods that are placed on a Node, and the more resources those
  Pods use, the lower the ranking this policy will give.  
-->
<ul>
<li><code>LeastRequestedPriority</code>：偏向最少请求资源的节点。
换句话说，节点上的 Pod 越多，使用的资源就越多，此策略给出的排名就越低。</li>
</ul>
<!--  
- `MostRequestedPriority`: Favors nodes with most requested resources. This policy
  will fit the scheduled Pods onto the smallest number of Nodes needed to run your
  overall set of workloads.
-->
<ul>
<li><code>MostRequestedPriority</code>：支持最多请求资源的节点。
该策略将 Pod 调度到整体工作负载所需的最少的一组节点上。</li>
</ul>
<!-- - `RequestedToCapacityRatioPriority`: Creates a requestedToCapacity based ResourceAllocationPriority using default resource scoring function shape. -->
<ul>
<li><code>RequestedToCapacityRatioPriority</code>：使用默认的打分方法模型，创建基于 ResourceAllocationPriority 的 requestedToCapacity。</li>
</ul>
<!-- - `BalancedResourceAllocation`: Favors nodes with balanced resource usage. -->
<ul>
<li><code>BalancedResourceAllocation</code>：偏向平衡资源使用的节点。</li>
</ul>
<!-- 
- `NodePreferAvoidPodsPriority`: Prioritizes nodes according to the node annotation
  `scheduler.alpha.kubernetes.io/preferAvoidPods`. You can use this to hint that
  two different Pods shouldn't run on the same Node. 
  -->
<ul>
<li><code>NodePreferAvoidPodsPriority</code>：根据节点的注解 <code>scheduler.alpha.kubernetes.io/preferAvoidPods</code> 对节点进行优先级排序。
你可以使用它来暗示两个不同的 Pod 不应在同一节点上运行。</li>
</ul>
<!--  
- `NodeAffinityPriority`: Prioritizes nodes according to node affinity scheduling
   preferences indicated in PreferredDuringSchedulingIgnoredDuringExecution.
   You can read more about this in [Assigning Pods to Nodes](/docs/concepts/scheduling-eviction/assign-pod-node/).
-->
<ul>
<li><code>NodeAffinityPriority</code>：根据节点亲和中 PreferredDuringSchedulingIgnoredDuringExecution 字段对节点进行优先级排序。
你可以在<a href="/zh/docs/concepts/scheduling-eviction/assign-pod-node/">将 Pod 分配给节点</a>中了解更多。</li>
</ul>
<!--  
- `TaintTolerationPriority`: Prepares the priority list for all the nodes, based on
  the number of intolerable taints on the node. This policy adjusts a node's rank
  taking that list into account.
-->
<ul>
<li><code>TaintTolerationPriority</code>：根据节点上无法忍受的污点数量，给所有节点进行优先级排序。
此策略会根据排序结果调整节点的等级。</li>
</ul>
<!-- 
- `ImageLocalityPriority`: Favors nodes that already have the
  <a class='glossary-tooltip' title='镜像是保存的容器实例，它打包了应用运行所需的一组软件。' data-toggle='tooltip' data-placement='top' href='/zh/docs/reference/glossary/?all=true#term-image' target='_blank' aria-label='container images'>container images</a> for that
  Pod cached locally.
-->
<ul>
<li><code>ImageLocalityPriority</code>：偏向已在本地缓存 Pod 所需容器镜像的节点。</li>
</ul>
<!-- 
- `ServiceSpreadingPriority`: For a given Service, this policy aims to make sure that
  the Pods for the Service run on different nodes. It favours scheduling onto nodes
  that don't have Pods for the service already assigned there. The overall outcome is
  that the Service becomes more resilient to a single Node failure.
-->
<ul>
<li><code>ServiceSpreadingPriority</code>：对于给定的 Service，此策略旨在确保该 Service 关联的 Pod 在不同的节点上运行。
它偏向把 Pod 调度到没有该服务的节点。
整体来看，Service 对于单个节点故障变得更具弹性。</li>
</ul>
<!-- - `EqualPriority`: Gives an equal weight of one to all nodes. -->
<ul>
<li><code>EqualPriority</code>：给予所有节点相等的权重。</li>
</ul>
<!-- 
- `EvenPodsSpreadPriority`: Implements preferred
  [pod topology spread constraints](/docs/concepts/workloads/pods/pod-topology-spread-constraints/). 
-->
<ul>
<li><code>EvenPodsSpreadPriority</code>：实现了 <a href="/zh/docs/concepts/workloads/pods/pod-topology-spread-constraints/">Pod 拓扑扩展约束</a>的优先级排序。</li>
</ul>
<h2 id="接下来">接下来</h2>
<!--  
* Learn about [scheduling](/docs/concepts/scheduling-eviction/kube-scheduler/)
* Learn about [kube-scheduler Configuration](/docs/reference/scheduling/config/)
* Read the [kube-scheduler configuration reference (v1beta1)](/docs/reference/config-api/kube-scheduler-config.v1beta1)
* Read the [kube-scheduler Policy reference (v1)](/docs/reference/config-api/kube-scheduler-policy-config.v1/)
-->
<ul>
<li>了解<a href="/zh/docs/concepts/scheduling-eviction/kube-scheduler/">调度</a></li>
<li>了解 <a href="/zh/docs/reference/scheduling/config/">kube-scheduler 配置</a></li>
<li>阅读 <a href="/zh/docs/reference/config-api/kube-scheduler-config.v1beta1">kube-scheduler 配置参考 (v1beta1)</a></li>
<li>阅读 <a href="/zh/docs/reference/config-api/kube-scheduler-policy-config.v1/">kube-scheduler 策略参考 (v1)</a></li>
</ul>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-ef4fb938b6b63c95f5f26f9b1cec3054">11.2 - 调度器配置</h1>
    
	<!--
title: Scheduler Configuration
content_type: concept
weight: 20
-->





<div style="margin-top: 10px; margin-bottom: 10px;">
<b>FEATURE STATE:</b> <code>Kubernetes v1.19 [beta]</code>
</div>

<!--
You can customize the behavior of the `kube-scheduler` by writing a configuration
file and passing its path as a command line argument.
-->
<p>你可以通过编写配置文件，并将其路径传给 <code>kube-scheduler</code> 的命令行参数，定制 <code>kube-scheduler</code> 的行为。</p>
<!-- overview -->
<!-- body -->
<!--
A scheduling Profile allows you to configure the different stages of scheduling
in the <a class='glossary-tooltip' title='控制平面组件，负责监视新创建的、未指定运行节点的 Pod，选择节点让 Pod 在上面运行。' data-toggle='tooltip' data-placement='top' href='/docs/reference/generated/kube-scheduler/' target='_blank' aria-label='kube-scheduler'>kube-scheduler</a>.
Each stage is exposed in a extension point. Plugins provide scheduling behaviors
by implementing one or more of these extension points.
-->
<p>调度模板（Profile）允许你配置 <a class='glossary-tooltip' title='控制平面组件，负责监视新创建的、未指定运行节点的 Pod，选择节点让 Pod 在上面运行。' data-toggle='tooltip' data-placement='top' href='/docs/reference/generated/kube-scheduler/' target='_blank' aria-label='kube-scheduler'>kube-scheduler</a>
中的不同调度阶段。每个阶段都暴露于某个扩展点中。插件通过实现一个或多个扩展点来提供调度行为。</p>
<!--
You can specify scheduling profiles by running `kube-scheduler --config <filename>`,
using the 
[KubeSchedulerConfiguration (v1beta1)](/docs/reference/config-api/kube-scheduler-config.v1beta1/)
struct.
-->
<p>你可以通过运行 <code>kube-scheduler --config &lt;filename&gt;</code> 来设置调度模板，
使用 <a href="/docs/reference/config-api/kube-scheduler-config.v1beta1/">KubeSchedulerConfiguration (v1beta1)</a> 结构体。</p>
<!-- A minimal configuration looks as follows: -->
<p>最简单的配置如下：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>kubescheduler.config.k8s.io/v1beta1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>KubeSchedulerConfiguration<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">clientConnection</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">kubeconfig</span>:<span style="color:#bbb"> </span>/etc/srv/kubernetes/kube-scheduler/kubeconfig<span style="color:#bbb">
</span></code></pre></div><!-- ## Profiles -->
<h2 id="profiles">配置文件   </h2>
<!--  
A scheduling Profile allows you to configure the different stages of scheduling
in the <a class='glossary-tooltip' title='控制平面组件，负责监视新创建的、未指定运行节点的 Pod，选择节点让 Pod 在上面运行。' data-toggle='tooltip' data-placement='top' href='/docs/reference/generated/kube-scheduler/' target='_blank' aria-label='kube-scheduler'>kube-scheduler</a>.
Each stage is exposed in an [extension point](#extension-points).
[Plugins](#scheduling-plugins) provide scheduling behaviors by implementing one
or more of these extension points.
-->
<p>通过调度配置文件，你可以配置 <a class='glossary-tooltip' title='控制平面组件，负责监视新创建的、未指定运行节点的 Pod，选择节点让 Pod 在上面运行。' data-toggle='tooltip' data-placement='top' href='/docs/reference/generated/kube-scheduler/' target='_blank' aria-label='kube-scheduler'>kube-scheduler</a> 在不同阶段的调度行为。
每个阶段都在一个<a href="#extension-points">扩展点</a>中公开。
<a href="#scheduling-plugins">调度插件</a>通过实现一个或多个扩展点，来提供调度行为。</p>
<!--  
You can configure a single instance of `kube-scheduler` to run
[multiple profiles](#multiple-profiles).
-->
<p>你可以配置同一 <code>kube-scheduler</code> 实例使用<a href="#multiple-profiles">多个配置文件</a>。</p>
<!-- ### Extension points -->
<h3 id="extensions-points">扩展点   </h3>
<!--  
Scheduling happens in a series of stages that are exposed through the following
extension points:
-->
<p>调度行为发生在一系列阶段中，这些阶段是通过以下扩展点公开的：</p>
<!--  
1. `QueueSort`: These plugins provide an ordering function that is used to
   sort pending Pods in the scheduling queue. Exactly one queue sort plugin
   may be enabled at a time.
-->
<ol>
<li><code>QueueSort</code>：这些插件对调度队列中的悬决的 Pod 排序。
一次只能启用一个队列排序插件。</li>
</ol>
<!--
2. `PreFilter`: These plugins are used to pre-process or check information
   about a Pod or the cluster before filtering. They can mark a pod as
   unschedulable.
 -->
<ol start="2">
<li><code>PreFilter</code>：这些插件用于在过滤之前预处理或检查 Pod 或集群的信息。
它们可以将 Pod 标记为不可调度。</li>
</ol>
<!--
3. `Filter`: These plugins are the equivalent of Predicates in a scheduling
   Policy and are used to filter out nodes that can not run the Pod. Filters
   are called in the configured order. A pod is marked as unschedulable if no
   nodes pass all the filters.
-->
<ol start="3">
<li><code>Filter</code>：这些插件相当于调度策略中的断言（Predicates），用于过滤不能运行 Pod 的节点。
过滤器的调用顺序是可配置的。
如果没有一个节点通过所有过滤器的筛选，Pod 将会被标记为不可调度。</li>
</ol>
<!--
4. `PreScore`: This is an informational extension point that can be used
   for doing pre-scoring work.
-->
<ol start="4">
<li><code>PreScore</code>：这是一个信息扩展点，可用于预打分工作。</li>
</ol>
<!--  
5. `Score`: These plugins provide a score to each node that has passed the
   filtering phase. The scheduler will then select the node with the highest
   weighted scores sum.
-->
<ol start="5">
<li><code>Score</code>：这些插件给通过筛选阶段的节点打分。调度器会选择得分最高的节点。</li>
</ol>
<!--  
6. `Reserve`: This is an informational extension point that notifies plugins
   when resources have been reserved for a given Pod. Plugins also implement an
   `Unreserve` call that gets called in the case of failure during or after
   `Reserve`.
-->
<ol start="6">
<li><code>Reserve</code>：这是一个信息扩展点，当资源已经预留给 Pod 时，会通知插件。
这些插件还实现了 <code>Unreserve</code> 接口，在 <code>Reserve</code> 期间或之后出现故障时调用。</li>
</ol>
<!-- 7. `Permit`: These plugins can prevent or delay the binding of a Pod. -->
<ol start="7">
<li><code>Permit</code>：这些插件可以阻止或延迟 Pod 绑定。</li>
</ol>
<!-- 8. `PreBind`: These plugins perform any work required before a Pod is bound.-->
<ol start="8">
<li><code>PreBind</code>：这些插件在 Pod 绑定节点之前执行。</li>
</ol>
<!--  
9. `Bind`: The plugins bind a Pod to a Node. Bind plugins are called in order
   and once one has done the binding, the remaining plugins are skipped. At
   least one bind plugin is required.
-->
<ol start="9">
<li><code>Bind</code>：这个插件将 Pod 与节点绑定。绑定插件是按顺序调用的，只要有一个插件完成了绑定，其余插件都会跳过。绑定插件至少需要一个。</li>
</ol>
<!--
10. `PostBind`: This is an informational extension point that is called after
   a Pod has been bound.
-->
<ol start="10">
<li><code>PostBind</code>：这是一个信息扩展点，在 Pod 绑定了节点之后调用。</li>
</ol>
<!--
For each extension point, you could disable specific [default plugins](#scheduling-plugins)
or enable your own. For example:
-->
<p>对每个扩展点，你可以禁用<a href="#scheduling-plugins">默认插件</a>或者是启用自己的插件，例如：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>kubescheduler.config.k8s.io/v1beta1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>KubeSchedulerConfiguration<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">profiles</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- <span style="color:#008000;font-weight:bold">plugins</span>:<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">score</span>:<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#008000;font-weight:bold">disabled</span>:<span style="color:#bbb">
</span><span style="color:#bbb">        </span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>NodeResourcesLeastAllocated<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#008000;font-weight:bold">enabled</span>:<span style="color:#bbb">
</span><span style="color:#bbb">        </span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>MyCustomPluginA<span style="color:#bbb">
</span><span style="color:#bbb">          </span><span style="color:#008000;font-weight:bold">weight</span>:<span style="color:#bbb"> </span><span style="color:#666">2</span><span style="color:#bbb">
</span><span style="color:#bbb">        </span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>MyCustomPluginB<span style="color:#bbb">
</span><span style="color:#bbb">          </span><span style="color:#008000;font-weight:bold">weight</span>:<span style="color:#bbb"> </span><span style="color:#666">1</span><span style="color:#bbb">
</span></code></pre></div><!--
You can use `*` as name in the disabled array to disable all default plugins
for that extension point. This can also be used to rearrange plugins order, if
desired.
-->
<p>你可以在 <code>disabled</code> 数组中使用 <code>*</code> 禁用该扩展点的所有默认插件。
如果需要，这个字段也可以用来对插件重新顺序。</p>
<!-- ### Scheduling plugins -->
<h3 id="scheduling-plugin">调度插件   </h3>
<!--
1. `UnReserve`: This is an informational extension point that is called if
   a Pod is rejected after being reserved and put on hold by a `Permit` plugin.
-->
<ol>
<li><code>UnReserve</code>：这是一个信息扩展点，如果一个 Pod 在预留后被拒绝，并且被 <code>Permit</code> 插件搁置，它就会被调用。</li>
</ol>
<!-- ## Scheduling plugins -->
<h2 id="scheduling-plugins">调度插件  </h2>
<!--  
The following plugins, enabled by default, implement one or more of these
extension points:
-->
<p>下面默认启用的插件实现了一个或多个扩展点：</p>
<!--  
- `SelectorSpread`: Favors spreading across nodes for Pods that belong to
  <a class='glossary-tooltip' title='将运行在一组 Pods 上的应用程序公开为网络服务的抽象方法。' data-toggle='tooltip' data-placement='top' href='/zh/docs/concepts/services-networking/service/' target='_blank' aria-label='Services'>Services</a>,
  <a class='glossary-tooltip' title='ReplicaSet 是下一代副本控制器。' data-toggle='tooltip' data-placement='top' href='/zh/docs/concepts/workloads/controllers/replicaset/' target='_blank' aria-label='ReplicaSets'>ReplicaSets</a> and
  <a class='glossary-tooltip' title='StatefulSet 用来管理某 Pod 集合的部署和扩缩，并为这些 Pod 提供持久存储和持久标识符。' data-toggle='tooltip' data-placement='top' href='/zh/docs/concepts/workloads/controllers/statefulset/' target='_blank' aria-label='StatefulSets'>StatefulSets</a>.
  Extension points: `PreScore`, `Score`.
-->
<ul>
<li>
<p><code>SelectorSpread</code>：对于属于 <a class='glossary-tooltip' title='将运行在一组 Pods 上的应用程序公开为网络服务的抽象方法。' data-toggle='tooltip' data-placement='top' href='/zh/docs/concepts/services-networking/service/' target='_blank' aria-label='Services'>Services</a>、
<a class='glossary-tooltip' title='ReplicaSet 是下一代副本控制器。' data-toggle='tooltip' data-placement='top' href='/zh/docs/concepts/workloads/controllers/replicaset/' target='_blank' aria-label='ReplicaSets'>ReplicaSets</a> 和
<a class='glossary-tooltip' title='StatefulSet 用来管理某 Pod 集合的部署和扩缩，并为这些 Pod 提供持久存储和持久标识符。' data-toggle='tooltip' data-placement='top' href='/zh/docs/concepts/workloads/controllers/statefulset/' target='_blank' aria-label='StatefulSets'>StatefulSets</a> 的 Pod，偏好跨多个节点部署。</p>
<p>实现的扩展点：<code>PreScore</code>，<code>Score</code>。</p>
</li>
</ul>
<!--  
- `ImageLocality`: Favors nodes that already have the container images that the
  Pod runs.
  Extension points: `Score`.
-->
<ul>
<li>
<p><code>ImageLocality</code>：选择已经存在 Pod 运行所需容器镜像的节点。</p>
<p>实现的扩展点：<code>Score</code>。</p>
</li>
</ul>
<!--  
- `TaintToleration`: Implements
  [taints and tolerations](/docs/concepts/scheduling-eviction/taint-and-toleration/).
  Implements extension points: `Filter`, `Prescore`, `Score`.
-->
<ul>
<li>
<p><code>TaintToleration</code>：实现了<a href="/zh/docs/concepts/scheduling-eviction/taint-and-toleration/">污点和容忍</a>。</p>
<p>实现的扩展点：<code>Filter</code>，<code>Prescore</code>，<code>Score</code>。</p>
</li>
</ul>
<!--  
- `NodeName`: Checks if a Pod spec node name matches the current node.
  Extension points: `Filter`.
-->
<ul>
<li>
<p><code>NodeName</code>：检查 Pod 指定的节点名称与当前节点是否匹配。</p>
<p>实现的扩展点：<code>Filter</code>。</p>
</li>
</ul>
<!--  
- `NodePorts`: Checks if a node has free ports for the requested Pod ports.
  Extension points: `PreFilter`, `Filter`.
-->
<ul>
<li>
<p><code>NodePorts</code>：检查 Pod 请求的端口在节点上是否可用。</p>
<p>实现的扩展点：<code>PreFilter</code>，<code>Filter</code>。</p>
</li>
</ul>
<!--  
- `NodePreferAvoidPods`: Scores nodes according to the node
  <a class='glossary-tooltip' title='注解是以键值对的形式给资源对象附加随机的无法标识的元数据。' data-toggle='tooltip' data-placement='top' href='/zh/docs/concepts/overview/working-with-objects/annotations/' target='_blank' aria-label=' '> </a>
  `scheduler.alpha.kubernetes.io/preferAvoidPods`.
  Extension points: `Score`.
-->
<ul>
<li>
<p><code>NodePreferAvoidPods</code>：基于节点的 <a class='glossary-tooltip' title='注解是以键值对的形式给资源对象附加随机的无法标识的元数据。' data-toggle='tooltip' data-placement='top' href='/zh/docs/concepts/overview/working-with-objects/annotations/' target='_blank' aria-label='注解'>注解</a>
<code>scheduler.alpha.kubernetes.io/preferAvoidPods</code> 打分。</p>
<p>实现的扩展点：<code>Score</code>。</p>
</li>
</ul>
<!--  
- `NodeAffinity`: Implements
  [node selectors](/docs/concepts/scheduling-eviction/assign-pod-node/#nodeselector)
  and [node affinity](/docs/concepts/scheduling-eviction/assign-pod-node/#node-affinity).
  Extension points: `Filter`, `Score`.
-->
<ul>
<li>
<p><code>NodeAffinity</code>：实现了<a href="/zh/docs/concepts/scheduling-eviction/assign-pod-node/#nodeselector">节点选择器</a>
和<a href="/zh/docs/concepts/scheduling-eviction/assign-pod-node/#node-affinity">节点亲和性</a>。</p>
<p>实现的扩展点：<code>Filter</code>，<code>Score</code>.</p>
</li>
</ul>
<!--  
- `PodTopologySpread`: Implements
  [Pod topology spread](/docs/concepts/workloads/pods/pod-topology-spread-constraints/).
  Extension points: `PreFilter`, `Filter`, `PreScore`, `Score`.
-->
<ul>
<li>
<p><code>PodTopologySpread</code>：实现了 <a href="/zh/docs/concepts/workloads/pods/pod-topology-spread-constraints/">Pod 拓扑分布</a>。</p>
<p>实现的扩展点：<code>PreFilter</code>，<code>Filter</code>，<code>PreScore</code>，<code>Score</code>。</p>
</li>
</ul>
<!--  
- `NodeUnschedulable`: Filters out nodes that have `.spec.unschedulable` set to
  true.
  Extension points: `Filter`.
-->
<ul>
<li>
<p><code>NodeUnschedulable</code>：过滤 <code>.spec.unschedulable</code> 值为 true 的节点。</p>
<p>实现的扩展点：<code>Filter</code>。</p>
</li>
</ul>
<!--  
- `NodeResourcesFit`: Checks if the node has all the resources that the Pod is
  requesting.
  Extension points: `PreFilter`, `Filter`.
-->
<ul>
<li>
<p><code>NodeResourcesFit</code>：检查节点是否拥有 Pod 请求的所有资源。</p>
<p>实现的扩展点：<code>PreFilter</code>，<code>Filter</code>。</p>
</li>
</ul>
<!--  
- `NodeResourcesBalancedAllocation`: Favors nodes that would obtain a more
  balanced resource usage if the Pod is scheduled there.
  Extension points: `Score`.
-->
<ul>
<li>
<p><code>NodeResourcesBalancedAllocation</code>：调度 Pod 时，选择资源使用更为均衡的节点。</p>
<p>实现的扩展点：<code>Score</code>。</p>
</li>
</ul>
<!--  
- `NodeResourcesLeastAllocated`: Favors nodes that have a low allocation of
  resources.
  Extension points: `Score`.
-->
<ul>
<li>
<p><code>NodeResourcesLeastAllocated</code>：选择资源分配较少的节点。</p>
<p>实现的扩展点：<code>Score</code>。</p>
</li>
</ul>
<!--  
- `VolumeBinding`: Checks if the node has or if it can bind the requested
  <a class='glossary-tooltip' title='包含可被 Pod 中容器访问的数据的目录。' data-toggle='tooltip' data-placement='top' href='/zh/docs/concepts/storage/volumes/' target='_blank' aria-label='volumes'>volumes</a>.
  Extension points: `PreFilter`, `Filter`, `Reserve`, `PreBind`, `Score`.
  <blockquote class="note callout">
  <div><strong>说明：</strong> <code>Score</code> extension point is enabled when <code>VolumeCapacityPriority</code> feature is
enabled. It prioritizes the smallest PVs that can fit the requested volume
size.</div>
</blockquote>
-->
<ul>
<li><code>VolumeBinding</code>：检查节点是否有请求的卷，或是否可以绑定请求的卷。
实现的扩展点: <code>PreFilter</code>、<code>Filter</code>、<code>Reserve</code>、<code>PreBind</code> 和 <code>Score</code>。
<blockquote class="note callout">
  <div><strong>说明：</strong> 当 <code>VolumeCapacityPriority</code> 特性被启用时，<code>Score</code> 扩展点也被启用。
它优先考虑可以满足所需卷大小的最小 PV。</div>
</blockquote></li>
</ul>
<!--
- `VolumeRestrictions`: Checks that volumes mounted in the node satisfy
  restrictions that are specific to the volume provider.
  Extension points: `Filter`.
-->
<ul>
<li>
<p><code>VolumeRestrictions</code>：检查挂载到节点上的卷是否满足卷提供程序的限制。</p>
<p>实现的扩展点：<code>Filter</code>。</p>
</li>
</ul>
<!--  
- `VolumeZone`: Checks that volumes requested satisfy any zone requirements they
  might have.
  Extension points: `Filter`.
-->
<ul>
<li>
<p><code>VolumeZone</code>：检查请求的卷是否在任何区域都满足。</p>
<p>实现的扩展点：<code>Filter</code>。</p>
</li>
</ul>
<!--
- `NodeVolumeLimits`: Checks that CSI volume limits can be satisfied for the
  node.
  Extension points: `Filter`.
-->
<ul>
<li>
<p><code>NodeVolumeLimits</code>：检查该节点是否满足 CSI 卷限制。</p>
<p>实现的扩展点：<code>Filter</code>。</p>
</li>
</ul>
<!--  
- `EBSLimits`: Checks that AWS EBS volume limits can be satisfied for the node.
  Extension points: `Filter`.
-->
<ul>
<li>
<p><code>EBSLimits</code>：检查节点是否满足 AWS EBS 卷限制。</p>
<p>实现的扩展点：<code>Filter</code>。</p>
</li>
</ul>
<!--  
- `GCEPDLimits`: Checks that GCP-PD volume limits can be satisfied for the node.
  Extension points: `Filter`.
-->
<ul>
<li>
<p><code>GCEPDLimits</code>：检查该节点是否满足 GCP-PD 卷限制。</p>
<p>实现的扩展点：<code>Filter</code>。</p>
</li>
</ul>
<!--  
- `AzureDiskLimits`: Checks that Azure disk volume limits can be satisfied for
  the node.
  Extension points: `Filter`.
-->
<ul>
<li>
<p><code>AzureDiskLimits</code>：检查该节点是否满足 Azure 卷限制。</p>
<p>实现的扩展点：<code>Filter</code>。</p>
</li>
</ul>
<!--  
- `InterPodAffinity`: Implements
  [inter-Pod affinity and anti-affinity](/docs/concepts/scheduling-eviction/assign-pod-node/#inter-pod-affinity-and-anti-affinity).
  Extension points: `PreFilter`, `Filter`, `PreScore`, `Score`.
-->
<ul>
<li>
<p><code>InterPodAffinity</code>：实现 <a href="/zh/docs/concepts/scheduling-eviction/assign-pod-node/#inter-pod-affinity-and-anti-affinity">Pod 间亲和性与反亲和性</a>。</p>
<p>实现的扩展点：<code>PreFilter</code>，<code>Filter</code>，<code>PreScore</code>，<code>Score</code>。</p>
</li>
</ul>
<!--  
- `PrioritySort`: Provides the default priority based sorting.
  Extension points: `QueueSort`.
-->
<ul>
<li>
<p><code>PrioritySort</code>：提供默认的基于优先级的排序。</p>
<p>实现的扩展点：<code>QueueSort</code>。</p>
</li>
</ul>
<!--  
- `DefaultBinder`: Provides the default binding mechanism.
  Extension points: `Bind`.
-->
<ul>
<li>
<p><code>DefaultBinder</code>：提供默认的绑定机制。</p>
<p>实现的扩展点：<code>Bind</code>。</p>
</li>
</ul>
<!--  
- `DefaultPreemption`: Provides the default preemption mechanism.
  Extension points: `PostFilter`.
-->
<ul>
<li>
<p><code>DefaultPreemption</code>：提供默认的抢占机制。</p>
<p>实现的扩展点：<code>PostFilter</code>。</p>
</li>
</ul>
<!--  
You can also enable the following plugins, through the component config APIs,
that are not enabled by default:
-->
<p>你也可以通过组件配置 API 启用以下插件（默认不启用）:</p>
<!--  
- `NodeResourcesMostAllocated`: Favors nodes that have a high allocation of
  resources.
  Extension points: `Score`.
-->
<ul>
<li>
<p><code>NodeResourcesMostAllocated</code>：选择已分配资源多的节点。</p>
<p>实现的扩展点：<code>Score</code>。</p>
</li>
</ul>
<!--  
- `RequestedToCapacityRatio`: Favor nodes according to a configured function of
  the allocated resources.
  Extension points: `Score`.
-->
<ul>
<li>
<p><code>RequestedToCapacityRatio</code>：根据已分配资源的某函数设置选择节点。</p>
<p>实现的扩展点：<code>Score</code>。</p>
</li>
</ul>
<!--  
- `CinderVolume`: Checks that OpenStack Cinder volume limits can be satisfied
  for the node.
  Extension points: `Filter`.
-->
<ul>
<li>
<p><code>CinderVolume</code>：检查该节点是否满足 OpenStack Cinder 卷限制。</p>
<p>实现的扩展点：<code>Filter</code>。</p>
</li>
</ul>
<!--  
- `NodeLabel`: Filters and / or scores a node according to configured
  <a class='glossary-tooltip' title='用来为对象设置可标识的属性标记；这些标记对用户而言是有意义且重要的。' data-toggle='tooltip' data-placement='top' href='/zh/docs/concepts/overview/working-with-objects/labels/' target='_blank' aria-label='label(s)'>label(s)</a>.
  Extension points: `Filter`, `Score`.
-->
<ul>
<li>
<p><code>NodeLabel</code>：根据配置的 <a class='glossary-tooltip' title='用来为对象设置可标识的属性标记；这些标记对用户而言是有意义且重要的。' data-toggle='tooltip' data-placement='top' href='/zh/docs/concepts/overview/working-with-objects/labels/' target='_blank' aria-label='标签'>标签</a>
过滤节点和/或给节点打分。</p>
<p>实现的扩展点：<code>Filter</code>，<code>Score</code>。</p>
</li>
</ul>
<!--  
- `ServiceAffinity`: Checks that Pods that belong to a
  <a class='glossary-tooltip' title='将运行在一组 Pods 上的应用程序公开为网络服务的抽象方法。' data-toggle='tooltip' data-placement='top' href='/zh/docs/concepts/services-networking/service/' target='_blank' aria-label='服务（Service）'>服务（Service）</a> fit in a set of nodes defined by
  configured labels. This plugin also favors spreading the Pods belonging to a
  Service across nodes.
  Extension points: `PreFilter`, `Filter`, `Score`.
-->
<ul>
<li>
<p><code>ServiceAffinity</code>：检查属于某个 <a class='glossary-tooltip' title='将运行在一组 Pods 上的应用程序公开为网络服务的抽象方法。' data-toggle='tooltip' data-placement='top' href='/zh/docs/concepts/services-networking/service/' target='_blank' aria-label='服务（Service）'>服务（Service）</a> 的 Pod
与配置的标签所定义的节点集是否适配。
这个插件还支持将属于某个 Service 的 Pod 分散到各个节点。</p>
<p>实现的扩展点：<code>PreFilter</code>，<code>Filter</code>，<code>Score</code>。</p>
</li>
</ul>
<!-- ### Multiple profiles -->
<h3 id="multiple-profiles">多配置文件   </h3>
<!--  
You can configure `kube-scheduler` to run more than one profile.
Each profile has an associated scheduler name and can have a different set of
plugins configured in its [extension points](#extension-points).
-->
<p>你可以配置 <code>kube-scheduler</code> 运行多个配置文件。
每个配置文件都有一个关联的调度器名称，并且可以在其扩展点中配置一组不同的插件。</p>
<!--  
With the following sample configuration, the scheduler will run with two
profiles: one with the default plugins and one with all scoring plugins
disabled.
-->
<p>使用下面的配置样例，调度器将运行两个配置文件：一个使用默认插件，另一个禁用所有打分插件。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>kubescheduler.config.k8s.io/v1beta1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>KubeSchedulerConfiguration<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">profiles</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- <span style="color:#008000;font-weight:bold">schedulerName</span>:<span style="color:#bbb"> </span>default-scheduler<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- <span style="color:#008000;font-weight:bold">schedulerName</span>:<span style="color:#bbb"> </span><span style="color:#a2f;font-weight:bold">no</span>-scoring-scheduler<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">plugins</span>:<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">preScore</span>:<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#008000;font-weight:bold">disabled</span>:<span style="color:#bbb">
</span><span style="color:#bbb">        </span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#39;*&#39;</span><span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">score</span>:<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#008000;font-weight:bold">disabled</span>:<span style="color:#bbb">
</span><span style="color:#bbb">        </span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#39;*&#39;</span><span style="color:#bbb">
</span></code></pre></div><!--  
Pods that want to be scheduled according to a specific profile can include
the corresponding scheduler name in its `.spec.schedulerName`.
-->
<p>对于那些希望根据特定配置文件来进行调度的 Pod，可以在 <code>.spec.schedulerName</code> 字段指定相应的调度器名称。</p>
<!--  
By default, one profile with the scheduler name `default-scheduler` is created.
This profile includes the default plugins described above. When declaring more
than one profile, a unique scheduler name for each of them is required.
-->
<p>默认情况下，将创建一个调度器名为 <code>default-scheduler</code> 的配置文件。
这个配置文件包括上面描述的所有默认插件。
声明多个配置文件时，每个配置文件中调度器名称必须唯一。</p>
<!--  
If a Pod doesn't specify a scheduler name, kube-apiserver will set it to
`default-scheduler`. Therefore, a profile with this scheduler name should exist
to get those pods scheduled.
-->
<p>如果 Pod 未指定调度器名称，kube-apiserver 将会把调度器名设置为 <code>default-scheduler</code>。
因此，应该存在一个调度器名为 <code>default-scheduler</code> 的配置文件来调度这些 Pod。</p>
<blockquote class="note callout">
  <div><strong>说明：</strong> <!--  
Pod's scheduling events have `.spec.schedulerName` as the ReportingController.
Events for leader election use the scheduler name of the first profile in the
list.
-->
<p>Pod 的调度事件把 <code>.spec.schedulerName</code> 字段值作为 ReportingController。
领导者选举事件使用列表中第一个配置文件的调度器名称。</div>
</blockquote>
<blockquote class="note callout">
  <div><strong>说明：</strong> <!--  
All profiles must use the same plugin in the QueueSort extension point and have
the same configuration parameters (if applicable). This is because the scheduler
only has one pending pods queue.
-->
<p>所有配置文件必须在 QueueSort 扩展点使用相同的插件，并具有相同的配置参数（如果适用）。
这是因为调度器只有一个保存 pending 状态 Pod 的队列。</div>
</blockquote>
<h2 id="接下来">接下来</h2>
<!--  
* Read the [kube-scheduler reference](https://kubernetes.io/docs/reference/command-line-tools-reference/kube-scheduler/)
* Learn about [scheduling](/docs/concepts/scheduling-eviction/kube-scheduler/)
* Read the [kube-scheduler configuration (v1beta1)](/docs/reference/config-api/kube-scheduler-config.v1beta1/) reference
-->
<ul>
<li>阅读 <a href="/zh/docs/reference/command-line-tools-reference/kube-scheduler/">kube-scheduler 参考</a></li>
<li>了解<a href="/zh/docs/concepts/scheduling-eviction/kube-scheduler/">调度</a></li>
<li>阅读 <a href="/zh/docs/reference/config-api/kube-scheduler-config.v1beta1/">kube-scheduler 配置 (v1beta1)</a> 参考</li>
</ul>

</div>



    
	
  

    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-c808ce38575e73f72835d7ed02b03780">12 - 其他工具</h1>
    
	<!-- 
title: Other Tools
reviewers:
- janetkuo
content_type: concept
weight: 80
no_list: true
-->
<!-- overview -->
<!-- 
Kubernetes contains several built-in tools to help you work with the Kubernetes system.
-->
<p>Kubernetes 包含多个内置工具来帮助你使用 Kubernetes 系统。</p>
<!-- body -->
<!--  
## Minikube

[`minikube`](https://minikube.sigs.k8s.io/docs/) is a tool that
runs a single-node Kubernetes cluster locally on your workstation for
development and testing purposes.
-->
<h2 id="minikube">Minikube</h2>
<p><a href="https://minikube.sigs.k8s.io/docs/"><code>minikube</code></a>
是一种在你的工作站上本地运行单节点 Kubernetes 集群的工具，用于开发和测试。</p>
<!-- 
## Dashboard

[`Dashboard`](/docs/tasks/access-application-cluster/web-ui-dashboard/), the web-based user interface of Kubernetes, allows you to deploy containerized applications
to a Kubernetes cluster, troubleshoot them, and manage the cluster and its resources itself.
-->
<h2 id="仪表盘">仪表盘</h2>
<p><a href="/zh/docs/tasks/access-application-cluster/web-ui-dashboard/"><code>Dashboard</code></a>，
基于 Web 的 Kubernetes 用户界面，
允许你将容器化的应用程序部署到 Kubernetes 集群，
对它们进行故障排查，并管理集群及其资源本身。</p>
<!-- 
## Helm

[`Kubernetes Helm`](https://github.com/kubernetes/helm) is a tool for managing packages of pre-configured
Kubernetes resources, aka Kubernetes charts.
-->
<h2 id="helm">Helm</h2>
<p><a href="https://github.com/kubernetes/helm"><code>Kubernetes Helm</code></a>
是一个用于管理预配置 Kubernetes 资源包的工具，也就是 Kubernetes 图表。</p>
<!-- 
Use Helm to:

* Find and use popular software packaged as Kubernetes charts
* Share your own applications as Kubernetes charts
* Create reproducible builds of your Kubernetes applications
* Intelligently manage your Kubernetes manifest files
* Manage releases of Helm packages
-->
<p>使用 Helm 来：</p>
<ul>
<li>查找和使用打包为 Kubernetes 图表的流行软件</li>
<li>将你自己的应用程序共享为 Kubernetes 图表</li>
<li>为你的 Kubernetes 应用程序创建可重现的构建</li>
<li>智能管理你的 Kubernetes 清单文件</li>
<li>管理 Helm 包的发布</li>
</ul>
<!-- 
## Kompose

[`Kompose`](https://github.com/kubernetes/kompose) is a tool to help Docker Compose users move to Kubernetes.
-->
<h2 id="kompose">Kompose</h2>
<p><a href="https://github.com/kubernetes/kompose"><code>Kompose</code></a>
是一个帮助 Docker Compose 用户迁移到 Kubernetes 的工具。</p>
<!-- 
Use Kompose to:

* Translate a Docker Compose file into Kubernetes objects
* Go from local Docker development to managing your application via Kubernetes
* Convert v1 or v2 Docker Compose `yaml` files or [Distributed Application Bundles](https://docs.docker.com/compose/bundles/)
-->
<p>使用 Kompose：</p>
<ul>
<li>将 Docker Compose 文件翻译成 Kubernetes 对象</li>
<li>从本地 Docker 开发转到通过 Kubernetes 管理你的应用程序</li>
<li>转换 Docker Compose v1 或 v2 版本的 <code>yaml</code> 文件或<a href="https://docs.docker.com/compose/bundles/">分布式应用程序包</a></li>
</ul>

</div>



    
      
  
  
  
  

  
  

  

    
	
  



          </main>
        </div>
      </div>
      
<footer class="d-print-none">
  <div class="footer__links">
    <nav>
      
      
      
      <a class="text-white" href="/zh/docs/home/">主页</a>
      
      <a class="text-white" href="/zh/blog/">博客</a>
      
      <a class="text-white" href="/zh/training/">培训</a>
      
      <a class="text-white" href="/zh/partners/">合作伙伴</a>
      
      <a class="text-white" href="/zh/community/">社区</a>
      
      <a class="text-white" href="/zh/case-studies/">案例分析</a>
      
    </nav>
  </div>
  <div class="container-fluid">
    <div class="row">
      <div class="col-6 col-sm-2 text-xs-center order-sm-2">
        
        
        
<ul class="list-inline mb-0">
  
  <li class="list-inline-item mx-2 h3" data-toggle="tooltip" data-placement="top" title="User mailing list" aria-label="User mailing list">
    <a class="text-white" target="_blank" href="https://discuss.kubernetes.io">
      <i class="fa fa-envelope"></i>
    </a>
  </li>
  
  <li class="list-inline-item mx-2 h3" data-toggle="tooltip" data-placement="top" title="Twitter" aria-label="Twitter">
    <a class="text-white" target="_blank" href="https://twitter.com/kubernetesio">
      <i class="fab fa-twitter"></i>
    </a>
  </li>
  
  <li class="list-inline-item mx-2 h3" data-toggle="tooltip" data-placement="top" title="Calendar" aria-label="Calendar">
    <a class="text-white" target="_blank" href="https://calendar.google.com/calendar/embed?src=calendar%40kubernetes.io">
      <i class="fas fa-calendar-alt"></i>
    </a>
  </li>
  
  <li class="list-inline-item mx-2 h3" data-toggle="tooltip" data-placement="top" title="Youtube" aria-label="Youtube">
    <a class="text-white" target="_blank" href="https://youtube.com/kubernetescommunity">
      <i class="fab fa-youtube"></i>
    </a>
  </li>
  
</ul>

        
        
      </div>
      <div class="col-6 col-sm-2 text-right text-xs-center order-sm-3">
        
        
        
<ul class="list-inline mb-0">
  
  <li class="list-inline-item mx-2 h3" data-toggle="tooltip" data-placement="top" title="GitHub" aria-label="GitHub">
    <a class="text-white" target="_blank" href="https://github.com/kubernetes/kubernetes">
      <i class="fab fa-github"></i>
    </a>
  </li>
  
  <li class="list-inline-item mx-2 h3" data-toggle="tooltip" data-placement="top" title="Slack" aria-label="Slack">
    <a class="text-white" target="_blank" href="https://slack.k8s.io">
      <i class="fab fa-slack"></i>
    </a>
  </li>
  
  <li class="list-inline-item mx-2 h3" data-toggle="tooltip" data-placement="top" title="Contribute" aria-label="Contribute">
    <a class="text-white" target="_blank" href="https://git.k8s.io/community/contributors/guide">
      <i class="fas fa-edit"></i>
    </a>
  </li>
  
  <li class="list-inline-item mx-2 h3" data-toggle="tooltip" data-placement="top" title="Stack Overflow" aria-label="Stack Overflow">
    <a class="text-white" target="_blank" href="https://stackoverflow.com/questions/tagged/kubernetes">
      <i class="fab fa-stack-overflow"></i>
    </a>
  </li>
  
</ul>

        
        
      </div>
      <div class="col-12 col-sm-8 text-center order-sm-2">
        <small class="text-white">&copy; 2021 The Kubernetes 作者 | 文档发布基于 <a href="https://git.k8s.io/website/LICENSE" class="light-text">CC BY 4.0</a> 授权许可</small>
        <br/>
        <small class="text-white">Copyright &copy; 2021 Linux 基金会&reg;。保留所有权利。Linux 基金会已注册并使用商标。如需了解 Linux 基金会的商标列表，请访问<a href="https://www.linuxfoundation.org/trademark-usage" class="light-text">商标使用页面</a></small>
        <br/>
        <small class="text-white">ICP license: 京ICP备17074266号-3</small>
        
        
          
        
      </div>
    </div>
  </div>
</footer>


    </div>
    
<script src="/js/popper-1.14.3.min.js" integrity="sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49" crossorigin="anonymous"></script>
<script src="/js/bootstrap-4.3.1.min.js" integrity="sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM" crossorigin="anonymous"></script>











<script src="/js/main.min.40616251a9b6e4b689e7769be0340661efa4d7ebb73f957404e963e135b4ed52.js" integrity="sha256-QGFiUam25LaJ53ab4DQGYe&#43;k1&#43;u3P5V0BOlj4TW07VI=" crossorigin="anonymous"></script>






  </body>
</html>
